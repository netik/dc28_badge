
build/badge.elf:     file format elf32-littlearm


Disassembly of section .vectors:

00200000 <_vectors>:
  200000:	20000400 	.word	0x20000400
  200004:	00200321 	.word	0x00200321
  200008:	00200323 	.word	0x00200323
  20000c:	0020036f 	.word	0x0020036f
  200010:	0020038d 	.word	0x0020038d
  200014:	00200379 	.word	0x00200379
  200018:	00200383 	.word	0x00200383
  20001c:	00200323 	.word	0x00200323
  200020:	00200323 	.word	0x00200323
  200024:	00200323 	.word	0x00200323
  200028:	00200323 	.word	0x00200323
  20002c:	00205011 	.word	0x00205011
  200030:	00200323 	.word	0x00200323
  200034:	00200323 	.word	0x00200323
  200038:	00200323 	.word	0x00200323
  20003c:	00200323 	.word	0x00200323
  200040:	00200323 	.word	0x00200323
  200044:	00200323 	.word	0x00200323
  200048:	00200323 	.word	0x00200323
  20004c:	00200323 	.word	0x00200323
  200050:	00200323 	.word	0x00200323
  200054:	00200323 	.word	0x00200323
  200058:	00200323 	.word	0x00200323
  20005c:	00200323 	.word	0x00200323
  200060:	00200323 	.word	0x00200323
  200064:	00200323 	.word	0x00200323
  200068:	00200323 	.word	0x00200323
  20006c:	00208045 	.word	0x00208045
  200070:	00208009 	.word	0x00208009
  200074:	00207fcd 	.word	0x00207fcd
  200078:	00207f91 	.word	0x00207f91
  20007c:	00207f59 	.word	0x00207f59
  200080:	00207f1d 	.word	0x00207f1d
  200084:	00207ee1 	.word	0x00207ee1
  200088:	00200323 	.word	0x00200323
  20008c:	00200323 	.word	0x00200323
  200090:	00200323 	.word	0x00200323
  200094:	00200323 	.word	0x00200323
  200098:	00200323 	.word	0x00200323
  20009c:	00200323 	.word	0x00200323
  2000a0:	00200323 	.word	0x00200323
  2000a4:	00200323 	.word	0x00200323
  2000a8:	00200323 	.word	0x00200323
  2000ac:	00200323 	.word	0x00200323
  2000b0:	00207251 	.word	0x00207251
  2000b4:	00200323 	.word	0x00200323
  2000b8:	00200323 	.word	0x00200323
  2000bc:	00207c95 	.word	0x00207c95
  2000c0:	00207c5d 	.word	0x00207c5d
  2000c4:	00200323 	.word	0x00200323
  2000c8:	00200323 	.word	0x00200323
  2000cc:	00200323 	.word	0x00200323
  2000d0:	00200323 	.word	0x00200323
  2000d4:	002070a1 	.word	0x002070a1
  2000d8:	00200323 	.word	0x00200323
  2000dc:	00200323 	.word	0x00200323
  2000e0:	00200323 	.word	0x00200323
  2000e4:	00200323 	.word	0x00200323
  2000e8:	00200323 	.word	0x00200323
  2000ec:	00200323 	.word	0x00200323
  2000f0:	00200323 	.word	0x00200323
  2000f4:	00200323 	.word	0x00200323
  2000f8:	00200323 	.word	0x00200323
  2000fc:	00207ea5 	.word	0x00207ea5
  200100:	00207085 	.word	0x00207085
  200104:	002075f9 	.word	0x002075f9
  200108:	0020720d 	.word	0x0020720d
  20010c:	00200323 	.word	0x00200323
  200110:	00200323 	.word	0x00200323
  200114:	00200323 	.word	0x00200323
  200118:	00200323 	.word	0x00200323
  20011c:	00200323 	.word	0x00200323
  200120:	00207e6d 	.word	0x00207e6d
  200124:	00207e31 	.word	0x00207e31
  200128:	00207df5 	.word	0x00207df5
  20012c:	00207db9 	.word	0x00207db9
  200130:	00207d81 	.word	0x00207d81
  200134:	00200323 	.word	0x00200323
  200138:	00200323 	.word	0x00200323
  20013c:	00200323 	.word	0x00200323
  200140:	00200323 	.word	0x00200323
  200144:	00200323 	.word	0x00200323
  200148:	00200323 	.word	0x00200323
  20014c:	00207869 	.word	0x00207869
  200150:	00207d45 	.word	0x00207d45
  200154:	00207d09 	.word	0x00207d09
  200158:	00207ccd 	.word	0x00207ccd
  20015c:	00200323 	.word	0x00200323
  200160:	00207c25 	.word	0x00207c25
  200164:	00207bed 	.word	0x00207bed
  200168:	00200323 	.word	0x00200323
  20016c:	00200323 	.word	0x00200323
  200170:	00200323 	.word	0x00200323
  200174:	00200323 	.word	0x00200323
  200178:	00200323 	.word	0x00200323
  20017c:	00200323 	.word	0x00200323
  200180:	00200323 	.word	0x00200323
  200184:	00204995 	.word	0x00204995
  200188:	00200323 	.word	0x00200323
  20018c:	00200323 	.word	0x00200323
  200190:	00200323 	.word	0x00200323
  200194:	00200323 	.word	0x00200323
  200198:	00200323 	.word	0x00200323
  20019c:	00200323 	.word	0x00200323
  2001a0:	00200323 	.word	0x00200323
  2001a4:	00200323 	.word	0x00200323
  2001a8:	00200323 	.word	0x00200323
  2001ac:	00200323 	.word	0x00200323
  2001b0:	00200323 	.word	0x00200323
  2001b4:	00200323 	.word	0x00200323
  2001b8:	00200323 	.word	0x00200323
  2001bc:	00200323 	.word	0x00200323
  2001c0:	00200323 	.word	0x00200323
  2001c4:	00200323 	.word	0x00200323
  2001c8:	00200323 	.word	0x00200323
  2001cc:	00200323 	.word	0x00200323
  2001d0:	00200323 	.word	0x00200323
  2001d4:	00200323 	.word	0x00200323
  2001d8:	00200323 	.word	0x00200323
  2001dc:	00200323 	.word	0x00200323
  2001e0:	00200323 	.word	0x00200323
  2001e4:	00200323 	.word	0x00200323
  2001e8:	00200323 	.word	0x00200323
  2001ec:	00200323 	.word	0x00200323
  2001f0:	00200323 	.word	0x00200323
  2001f4:	00200323 	.word	0x00200323
  2001f8:	00200323 	.word	0x00200323
  2001fc:	00200323 	.word	0x00200323

Disassembly of section .text:

00200200 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
  200200:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
  200202:	4839      	ldr	r0, [pc, #228]	; (2002e8 <endfiniloop+0x6>)
                msr     MSP, r0
  200204:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
  200208:	4838      	ldr	r0, [pc, #224]	; (2002ec <endfiniloop+0xa>)
                msr     PSP, r0
  20020a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
  20020e:	4838      	ldr	r0, [pc, #224]	; (2002f0 <endfiniloop+0xe>)
                movw    r1, #SCB_VTOR & 0xFFFF
  200210:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
  200214:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
  200218:	6008      	str	r0, [r1, #0]
#endif

#if CRT0_INIT_FPU == TRUE
                /* FPU FPCCR initialization.*/
                movw    r0, #CRT0_FPCCR_INIT & 0xFFFF
  20021a:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_FPCCR_INIT >> 16
  20021e:	f2cc 0000 	movt	r0, #49152	; 0xc000
                movw    r1, #SCB_FPCCR & 0xFFFF
  200222:	f64e 7134 	movw	r1, #61236	; 0xef34
                movt    r1, #SCB_FPCCR >> 16
  200226:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
  20022a:	6008      	str	r0, [r1, #0]
                dsb
  20022c:	f3bf 8f4f 	dsb	sy
                isb
  200230:	f3bf 8f6f 	isb	sy

                /* CPACR initialization.*/
                movw    r0, #CRT0_CPACR_INIT & 0xFFFF
  200234:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_CPACR_INIT >> 16
  200238:	f2c0 00f0 	movt	r0, #240	; 0xf0
                movw    r1, #SCB_CPACR & 0xFFFF
  20023c:	f64e 5188 	movw	r1, #60808	; 0xed88
                movt    r1, #SCB_CPACR >> 16
  200240:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
  200244:	6008      	str	r0, [r1, #0]
                dsb
  200246:	f3bf 8f4f 	dsb	sy
                isb
  20024a:	f3bf 8f6f 	isb	sy

                /* FPU FPSCR initially cleared.*/
                mov     r0, #0
  20024e:	f04f 0000 	mov.w	r0, #0
                vmsr    FPSCR, r0
  200252:	eee1 0a10 	vmsr	fpscr, r0

                /* FPU FPDSCR initially cleared.*/
                movw    r1, #SCB_FPDSCR & 0xFFFF
  200256:	f64e 713c 	movw	r1, #61244	; 0xef3c
                movt    r1, #SCB_FPDSCR >> 16
  20025a:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
  20025e:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA
  200260:	2006      	movs	r0, #6
#else
                movs    r0, #CRT0_CONTROL_INIT
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
  200262:	f380 8814 	msr	CONTROL, r0
                isb
  200266:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
  20026a:	f008 fd1d 	bl	208ca8 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
  20026e:	f006 fe29 	bl	206ec4 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
  200272:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
  200276:	491f      	ldr	r1, [pc, #124]	; (2002f4 <endfiniloop+0x12>)
                ldr     r2, =__main_stack_end__
  200278:	4a1b      	ldr	r2, [pc, #108]	; (2002e8 <endfiniloop+0x6>)

0020027a <msloop>:
msloop:
                cmp     r1, r2
  20027a:	4291      	cmp	r1, r2
                itt     lo
  20027c:	bf3c      	itt	cc
                strlo   r0, [r1], #4
  20027e:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
  200282:	e7fa      	bcc.n	20027a <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
  200284:	491c      	ldr	r1, [pc, #112]	; (2002f8 <endfiniloop+0x16>)
                ldr     r2, =__process_stack_end__
  200286:	4a19      	ldr	r2, [pc, #100]	; (2002ec <endfiniloop+0xa>)

00200288 <psloop>:
psloop:
                cmp     r1, r2
  200288:	4291      	cmp	r1, r2
                itt     lo
  20028a:	bf3c      	itt	cc
                strlo   r0, [r1], #4
  20028c:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
  200290:	e7fa      	bcc.n	200288 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
  200292:	491a      	ldr	r1, [pc, #104]	; (2002fc <endfiniloop+0x1a>)
                ldr     r2, =_data_start
  200294:	4a1a      	ldr	r2, [pc, #104]	; (200300 <endfiniloop+0x1e>)
                ldr     r3, =_data_end
  200296:	4b1b      	ldr	r3, [pc, #108]	; (200304 <endfiniloop+0x22>)

00200298 <dloop>:
dloop:
                cmp     r2, r3
  200298:	429a      	cmp	r2, r3
                ittt    lo
  20029a:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
  20029c:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
  2002a0:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
  2002a4:	e7f8      	bcc.n	200298 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
  2002a6:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
  2002a8:	4917      	ldr	r1, [pc, #92]	; (200308 <endfiniloop+0x26>)
                ldr     r2, =_bss_end
  2002aa:	4a18      	ldr	r2, [pc, #96]	; (20030c <endfiniloop+0x2a>)

002002ac <bloop>:
bloop:
                cmp     r1, r2
  2002ac:	4291      	cmp	r1, r2
                itt     lo
  2002ae:	bf3c      	itt	cc
                strlo   r0, [r1], #4
  2002b0:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
  2002b4:	e7fa      	bcc.n	2002ac <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
  2002b6:	f008 fccf 	bl	208c58 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
  2002ba:	f008 fcf4 	bl	208ca6 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
  2002be:	4c14      	ldr	r4, [pc, #80]	; (200310 <endfiniloop+0x2e>)
                ldr     r5, =__init_array_end
  2002c0:	4d14      	ldr	r5, [pc, #80]	; (200314 <endfiniloop+0x32>)

002002c2 <initloop>:
initloop:
                cmp     r4, r5
  2002c2:	42ac      	cmp	r4, r5
                bge     endinitloop
  2002c4:	da03      	bge.n	2002ce <endinitloop>
                ldr     r1, [r4], #4
  2002c6:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
  2002ca:	4788      	blx	r1
                b       initloop
  2002cc:	e7f9      	b.n	2002c2 <initloop>

002002ce <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
  2002ce:	f005 f8d5 	bl	20547c <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
  2002d2:	4c11      	ldr	r4, [pc, #68]	; (200318 <endfiniloop+0x36>)
                ldr     r5, =__fini_array_end
  2002d4:	4d11      	ldr	r5, [pc, #68]	; (20031c <endfiniloop+0x3a>)

002002d6 <finiloop>:
finiloop:
                cmp     r4, r5
  2002d6:	42ac      	cmp	r4, r5
                bge     endfiniloop
  2002d8:	da03      	bge.n	2002e2 <endfiniloop>
                ldr     r1, [r4], #4
  2002da:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
  2002de:	4788      	blx	r1
                b       finiloop
  2002e0:	e7f9      	b.n	2002d6 <finiloop>

002002e2 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
  2002e2:	f008 bcdf 	b.w	208ca4 <__default_exit>
  2002e6:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
  2002e8:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
  2002ec:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
  2002f0:	00200000 	.word	0x00200000
                ldr     r1, =__main_stack_base__
  2002f4:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
  2002f8:	20000400 	.word	0x20000400
                ldr     r1, =_textdata_start
  2002fc:	0800eed8 	.word	0x0800eed8
                ldr     r2, =_data_start
  200300:	20010000 	.word	0x20010000
                ldr     r3, =_data_end
  200304:	20010234 	.word	0x20010234
                ldr     r1, =_bss_start
  200308:	20000800 	.word	0x20000800
                ldr     r2, =_bss_end
  20030c:	200040a4 	.word	0x200040a4
                ldr     r4, =__init_array_start
  200310:	00200200 	.word	0x00200200
                ldr     r5, =__init_array_end
  200314:	00200200 	.word	0x00200200
                ldr     r4, =__fini_array_start
  200318:	00200200 	.word	0x00200200
                ldr     r5, =__fini_array_end
  20031c:	00200200 	.word	0x00200200

00200320 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
  200320:	e76e      	b.n	200200 <_crt0_entry>

00200322 <DebugMon_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
  200322:	f000 f800 	bl	200326 <_unhandled_exception>

00200326 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
  200326:	e7fe      	b.n	200326 <_unhandled_exception>

00200328 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
  200328:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
  20032c:	ed2d 8a10 	vpush	{s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
  200330:	f8c1 d00c 	str.w	sp, [r1, #12]
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
                mov     sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
  200334:	f8d0 d00c 	ldr.w	sp, [r0, #12]
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
  200338:	ecbd 8a10 	vpop	{s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
  20033c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00200340 <_port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_ENABLE_STACK_CHECK && PORT_ENABLE_GUARD_PAGES
                bl      _port_set_region
  200340:	f004 fe5a 	bl	204ff8 <_port_set_region>
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
  200344:	2300      	movs	r3, #0
                msr     BASEPRI, r3
  200346:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
  20034a:	4628      	mov	r0, r5
                blx     r4
  20034c:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
  20034e:	2000      	movs	r0, #0
                bl      chThdExit
  200350:	f005 fe14 	bl	205f7c <chThdExit>

00200354 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
  200354:	f005 fe1a 	bl	205f8c <chSchDoReschedule>

00200358 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
  200358:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
  20035a:	e7fe      	b.n	20035a <_port_exit_from_isr+0x2>

0020035c <CommonFault_Handler>:
	/*
	 * Test the link register to see if we got here
	 * from thread mode or handler mode. If thread mode,
	 * then switch to using the PSP as the current stack.
	 */
	tst	r1, #4
  20035c:	f011 0f04 	tst.w	r1, #4
	ite	eq
  200360:	bf0c      	ite	eq
	mrseq	r2, msp
  200362:	f3ef 8208 	mrseq	r2, MSP
	mrsne	r2, psp
  200366:	f3ef 8209 	mrsne	r2, PSP
	bl	trapHandle
  20036a:	f003 fd51 	bl	203e10 <trapHandle>

0020036e <HardFault_Handler>:

HardFault_Handler:
	mov	r0, #0
  20036e:	f04f 0000 	mov.w	r0, #0
	mov	r1, lr
  200372:	4671      	mov	r1, lr
	bl	CommonFault_Handler
  200374:	f7ff fff2 	bl	20035c <CommonFault_Handler>

00200378 <BusFault_Handler>:

BusFault_Handler:
	mov	r0, #1
  200378:	f04f 0001 	mov.w	r0, #1
	mov	r1, lr
  20037c:	4671      	mov	r1, lr
	bl	CommonFault_Handler
  20037e:	f7ff ffed 	bl	20035c <CommonFault_Handler>

00200382 <UsageFault_Handler>:

UsageFault_Handler:
	mov	r0, #2
  200382:	f04f 0002 	mov.w	r0, #2
	mov	r1, lr
  200386:	4671      	mov	r1, lr
	bl	CommonFault_Handler
  200388:	f7ff ffe8 	bl	20035c <CommonFault_Handler>

0020038c <MemManage_Handler>:

MemManage_Handler:
	mov	r0, #3
  20038c:	f04f 0003 	mov.w	r0, #3
	mov	r1, lr
  200390:	4671      	mov	r1, lr
	bl	CommonFault_Handler
  200392:	f7ff ffe3 	bl	20035c <CommonFault_Handler>

00200396 <strlen>:
	.eabi_attribute Tag_ARM_ISA_use, 0
	.thumb
	.syntax unified

def_fn	strlen p2align=1
	mov     r3, r0
  200396:	4603      	mov	r3, r0
1:	ldrb.w  r2, [r3], #1
  200398:	f813 2b01 	ldrb.w	r2, [r3], #1
	cmp     r2, #0
  20039c:	2a00      	cmp	r2, #0
	bne	1b
  20039e:	d1fb      	bne.n	200398 <strlen+0x2>
	subs    r0, r3, r0
  2003a0:	1a18      	subs	r0, r3, r0
	subs    r0, #1
  2003a2:	3801      	subs	r0, #1
	bx      lr
  2003a4:	4770      	bx	lr
	...

002003b0 <memchr>:
memchr:
	@ r0 = start of memory to scan
	@ r1 = character to look for
	@ r2 = length
	@ returns r0 = pointer to character or NULL if not found
	and	r1,r1,#0xff	@ Don't trust the caller to pass a char
  2003b0:	f001 01ff 	and.w	r1, r1, #255	; 0xff

	cmp	r2,#16		@ If short don't bother with anything clever
  2003b4:	2a10      	cmp	r2, #16
	blt	20f 
  2003b6:	db2b      	blt.n	200410 <memchr+0x60>

	tst	r0, #7		@ If it's already aligned skip the next bit
  2003b8:	f010 0f07 	tst.w	r0, #7
	beq	10f
  2003bc:	d008      	beq.n	2003d0 <memchr+0x20>

	@ Work up to an aligned point
5:
	ldrb	r3, [r0],#1
  2003be:	f810 3b01 	ldrb.w	r3, [r0], #1
	subs	r2, r2, #1
  2003c2:	3a01      	subs	r2, #1
	cmp	r3, r1
  2003c4:	428b      	cmp	r3, r1
	beq	50f		@ If it matches exit found
  2003c6:	d02d      	beq.n	200424 <memchr+0x74>
	tst	r0, #7
  2003c8:	f010 0f07 	tst.w	r0, #7
	cbz	r2, 40f		@ If we run off the end, exit not found
  2003cc:	b342      	cbz	r2, 200420 <memchr+0x70>
	bne	5b		@ If not aligned yet then do next byte
  2003ce:	d1f6      	bne.n	2003be <memchr+0xe>
	
10:
	@ We are aligned, we know we have at least 8 bytes to work with
	push	{r4,r5,r6,r7}
  2003d0:	b4f0      	push	{r4, r5, r6, r7}
	orr	r1, r1, r1, lsl #8	@ expand the match word across all bytes
  2003d2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
	orr	r1, r1, r1, lsl #16
  2003d6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
	bic	r4, r2, #7	@ Number of double words to work with * 8
  2003da:	f022 0407 	bic.w	r4, r2, #7
	mvns	r7, #0		@ all F's
  2003de:	f07f 0700 	mvns.w	r7, #0
	movs	r3, #0
  2003e2:	2300      	movs	r3, #0
	
15:
	ldrd    r5,r6,[r0],#8
  2003e4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
	subs	r4, r4, #8
  2003e8:	3c08      	subs	r4, #8
	eor	r5,r5, r1	@ r5,r6 have 00's where bytes match the target
  2003ea:	ea85 0501 	eor.w	r5, r5, r1
	eor	r6,r6, r1
  2003ee:	ea86 0601 	eor.w	r6, r6, r1
	uadd8	r5, r5, r7	@ Par add 0xff - sets GE bits for bytes!=0
  2003f2:	fa85 f547 	uadd8	r5, r5, r7
	sel	r5, r3, r7	@ bytes are 00 for none-00 bytes,
  2003f6:	faa3 f587 	sel	r5, r3, r7
				@ or ff for 00 bytes - NOTE INVERSION
	uadd8	r6, r6, r7	@ Par add 0xff - sets GE bits for bytes!=0
  2003fa:	fa86 f647 	uadd8	r6, r6, r7
	sel	r6, r5, r7	@ chained....bytes are 00 for none-00 bytes
  2003fe:	faa5 f687 	sel	r6, r5, r7
				@ or ff for 00 bytes - NOTE INVERSION
	cbnz	r6, 60f
  200402:	b98e      	cbnz	r6, 200428 <memchr+0x78>
	bne	15b		@ (Flags from the subs above)
  200404:	d1ee      	bne.n	2003e4 <memchr+0x34>

	pop	{r4,r5,r6,r7}
  200406:	bcf0      	pop	{r4, r5, r6, r7}
	and	r1,r1,#0xff	@ r1 back to a single character
  200408:	f001 01ff 	and.w	r1, r1, #255	; 0xff
	and	r2,r2,#7	@ Leave the count remaining as the number
  20040c:	f002 0207 	and.w	r2, r2, #7
				@ after the double words have been done
 
20:
	cbz	r2, 40f		@ 0 length or hit the end already then not found
  200410:	b132      	cbz	r2, 200420 <memchr+0x70>

21:  @ Post aligned section, or just a short call
	ldrb	r3,[r0],#1
  200412:	f810 3b01 	ldrb.w	r3, [r0], #1
	subs	r2,r2,#1
  200416:	3a01      	subs	r2, #1
	eor	r3,r3,r1	@ r3 = 0 if match - doesn't break flags from sub
  200418:	ea83 0301 	eor.w	r3, r3, r1
	cbz	r3, 50f
  20041c:	b113      	cbz	r3, 200424 <memchr+0x74>
	bne	21b		@ on r2 flags
  20041e:	d1f8      	bne.n	200412 <memchr+0x62>

40:
	movs	r0,#0		@ not found
  200420:	2000      	movs	r0, #0
	bx	lr
  200422:	4770      	bx	lr

50:
	subs	r0,r0,#1	@ found
  200424:	3801      	subs	r0, #1
	bx	lr
  200426:	4770      	bx	lr

60:  @ We're here because the fast path found a hit 
     @ now we have to track down exactly which word it was
	@ r0 points to the start of the double word after the one tested
	@ r5 has the 00/ff pattern for the first word, r6 has the chained value
	cmp	r5, #0
  200428:	2d00      	cmp	r5, #0
	itte	eq
  20042a:	bf06      	itte	eq
	moveq	r5, r6		@ the end is in the 2nd word
  20042c:	4635      	moveq	r5, r6
	subeq	r0,r0,#3	@ Points to 2nd byte of 2nd word
  20042e:	3803      	subeq	r0, #3
	subne	r0,r0,#7	@ or 2nd byte of 1st word
  200430:	3807      	subne	r0, #7

	@ r0 currently points to the 2nd byte of the word containing the hit
	tst	r5, # CHARTSTMASK(0)	@ 1st character
  200432:	f015 0f01 	tst.w	r5, #1
	bne	61f
  200436:	d107      	bne.n	200448 <memchr+0x98>
	adds	r0,r0,#1
  200438:	3001      	adds	r0, #1
	tst	r5, # CHARTSTMASK(1)	@ 2nd character
  20043a:	f415 7f80 	tst.w	r5, #256	; 0x100
	ittt	eq
  20043e:	bf02      	ittt	eq
	addeq	r0,r0,#1
  200440:	3001      	addeq	r0, #1
	tsteq	r5, # (3<<15)		@ 2nd & 3rd character
  200442:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
	@ If not the 3rd must be the last one
	addeq	r0,r0,#1
  200446:	3001      	addeq	r0, #1

61:
	pop	{r4,r5,r6,r7}
  200448:	bcf0      	pop	{r4, r5, r6, r7}
	subs	r0,r0,#1
  20044a:	3801      	subs	r0, #1
	bx	lr
  20044c:	4770      	bx	lr
  20044e:	bf00      	nop

00200450 <strcmp>:
	.syntax unified
def_fn strcmp
	.cfi_sections .debug_frame
	.cfi_startproc
1:
	ldrb	r2, [r0], #1
  200450:	f810 2b01 	ldrb.w	r2, [r0], #1
	ldrb	r3, [r1], #1
  200454:	f811 3b01 	ldrb.w	r3, [r1], #1
	cmp	r2, #1
  200458:	2a01      	cmp	r2, #1
	it	cs
  20045a:	bf28      	it	cs
	cmpcs	r2, r3
  20045c:	429a      	cmpcs	r2, r3
	beq	1b
  20045e:	d0f7      	beq.n	200450 <strcmp>
2:
	subs	r0, r2, r3
  200460:	1ad0      	subs	r0, r2, r3
	bx	lr
  200462:	4770      	bx	lr

00200464 <__aeabi_drsub>:
#ifdef L_arm_addsubdf3

ARM_FUNC_START aeabi_drsub
	CFI_START_FUNCTION

	eor	xh, xh, #0x80000000	@ flip sign bit of first arg
  200464:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
	b	1f	
  200468:	e002      	b.n	200470 <__adddf3>
  20046a:	bf00      	nop

0020046c <__aeabi_dsub>:

ARM_FUNC_START subdf3
ARM_FUNC_ALIAS aeabi_dsub subdf3

	eor	yh, yh, #0x80000000	@ flip sign bit of second arg
  20046c:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00200470 <__adddf3>:
#endif

ARM_FUNC_START adddf3
ARM_FUNC_ALIAS aeabi_dadd adddf3

1:  do_push {r4, r5, lr}        @ sp -= 12
  200470:	b530      	push	{r4, r5, lr}
	.cfi_rel_offset r4, 0       @ Registers are saved from sp to sp + 8
	.cfi_rel_offset r5, 4
	.cfi_rel_offset lr, 8

	@ Look for zeroes, equal values, INF, or NAN.
	shift1	lsl, r4, xh, #1
  200472:	ea4f 0441 	mov.w	r4, r1, lsl #1
	shift1	lsl, r5, yh, #1
  200476:	ea4f 0543 	mov.w	r5, r3, lsl #1
	teq	r4, r5
  20047a:	ea94 0f05 	teq	r4, r5
	do_it	eq
  20047e:	bf08      	it	eq
	teqeq	xl, yl
  200480:	ea90 0f02 	teqeq	r0, r2
	do_it	ne, ttt
  200484:	bf1f      	itttt	ne
	COND(orr,s,ne)	ip, r4, xl
  200486:	ea54 0c00 	orrsne.w	ip, r4, r0
	COND(orr,s,ne)	ip, r5, yl
  20048a:	ea55 0c02 	orrsne.w	ip, r5, r2
	COND(mvn,s,ne)	ip, r4, asr #21
  20048e:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
	COND(mvn,s,ne)	ip, r5, asr #21
  200492:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
	beq	LSYM(Lad_s)
  200496:	f000 80e2 	beq.w	20065e <__adddf3+0x1ee>

	@ Compute exponent difference.  Make largest exponent in r4,
	@ corresponding arg in xh-xl, and positive exponent difference in r5.
	shift1	lsr, r4, r4, #21
  20049a:	ea4f 5454 	mov.w	r4, r4, lsr #21
	rsbs	r5, r4, r5, lsr #21
  20049e:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
	do_it	lt
  2004a2:	bfb8      	it	lt
	rsblt	r5, r5, #0
  2004a4:	426d      	neglt	r5, r5
	ble	1f
  2004a6:	dd0c      	ble.n	2004c2 <__adddf3+0x52>
	add	r4, r4, r5
  2004a8:	442c      	add	r4, r5
	eor	yl, xl, yl
  2004aa:	ea80 0202 	eor.w	r2, r0, r2
	eor	yh, xh, yh
  2004ae:	ea81 0303 	eor.w	r3, r1, r3
	eor	xl, yl, xl
  2004b2:	ea82 0000 	eor.w	r0, r2, r0
	eor	xh, yh, xh
  2004b6:	ea83 0101 	eor.w	r1, r3, r1
	eor	yl, xl, yl
  2004ba:	ea80 0202 	eor.w	r2, r0, r2
	eor	yh, xh, yh
  2004be:	ea81 0303 	eor.w	r3, r1, r3
1:
	@ If exponent difference is too large, return largest argument
	@ already in xh-xl.  We need up to 54 bit to handle proper rounding
	@ of 0x1p54 - 1.1.
	cmp	r5, #54
  2004c2:	2d36      	cmp	r5, #54	; 0x36
	do_it	hi
  2004c4:	bf88      	it	hi
	RETLDM	"r4, r5" hi
  2004c6:	bd30      	pophi	{r4, r5, pc}

	@ Convert mantissa to signed integer.
	tst	xh, #0x80000000
  2004c8:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
	mov	xh, xh, lsl #12
  2004cc:	ea4f 3101 	mov.w	r1, r1, lsl #12
	mov	ip, #0x00100000
  2004d0:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
	orr	xh, ip, xh, lsr #12
  2004d4:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
	beq	1f
  2004d8:	d002      	beq.n	2004e0 <__adddf3+0x70>
#if defined(__thumb2__)
	negs	xl, xl
  2004da:	4240      	negs	r0, r0
	sbc	xh, xh, xh, lsl #1
  2004dc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
#else
	rsbs	xl, xl, #0
	rsc	xh, xh, #0
#endif
1:
	tst	yh, #0x80000000
  2004e0:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
	mov	yh, yh, lsl #12
  2004e4:	ea4f 3303 	mov.w	r3, r3, lsl #12
	orr	yh, ip, yh, lsr #12
  2004e8:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
	beq	1f
  2004ec:	d002      	beq.n	2004f4 <__adddf3+0x84>
#if defined(__thumb2__)
	negs	yl, yl
  2004ee:	4252      	negs	r2, r2
	sbc	yh, yh, yh, lsl #1
  2004f0:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
	rsc	yh, yh, #0
#endif
1:
	@ If exponent == difference, one or both args were denormalized.
	@ Since this is not common case, rescale them off line.
	teq	r4, r5
  2004f4:	ea94 0f05 	teq	r4, r5
	beq	LSYM(Lad_d)
  2004f8:	f000 80a7 	beq.w	20064a <__adddf3+0x1da>
@ point. Otherwise the CFI would change to a different state after the branch,
@ which would be disastrous for backtracing.
LSYM(Lad_x):

	@ Compensate for the exponent overlapping the mantissa MSB added later
	sub	r4, r4, #1
  2004fc:	f1a4 0401 	sub.w	r4, r4, #1

	@ Shift yh-yl right per r5, add to xh-xl, keep leftover bits into ip.
	rsbs	lr, r5, #32
  200500:	f1d5 0e20 	rsbs	lr, r5, #32
	blt	1f
  200504:	db0d      	blt.n	200522 <__adddf3+0xb2>
	shift1	lsl, ip, yl, lr
  200506:	fa02 fc0e 	lsl.w	ip, r2, lr
	shiftop adds xl xl yl lsr r5 yl
  20050a:	fa22 f205 	lsr.w	r2, r2, r5
  20050e:	1880      	adds	r0, r0, r2
	adc	xh, xh, #0
  200510:	f141 0100 	adc.w	r1, r1, #0
	shiftop adds xl xl yh lsl lr yl
  200514:	fa03 f20e 	lsl.w	r2, r3, lr
  200518:	1880      	adds	r0, r0, r2
	shiftop adcs xh xh yh asr r5 yh
  20051a:	fa43 f305 	asr.w	r3, r3, r5
  20051e:	4159      	adcs	r1, r3
	b	2f
  200520:	e00e      	b.n	200540 <__adddf3+0xd0>
1:	sub	r5, r5, #32
  200522:	f1a5 0520 	sub.w	r5, r5, #32
	add	lr, lr, #32
  200526:	f10e 0e20 	add.w	lr, lr, #32
	cmp	yl, #1
  20052a:	2a01      	cmp	r2, #1
	shift1	lsl,ip, yh, lr
  20052c:	fa03 fc0e 	lsl.w	ip, r3, lr
	do_it	cs
  200530:	bf28      	it	cs
	orrcs	ip, ip, #2		@ 2 not 1, to allow lsr #1 later
  200532:	f04c 0c02 	orrcs.w	ip, ip, #2
	shiftop adds xl xl yh asr r5 yh
  200536:	fa43 f305 	asr.w	r3, r3, r5
  20053a:	18c0      	adds	r0, r0, r3
	adcs	xh, xh, yh, asr #31
  20053c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
2:
	@ We now have a result in xh-xl-ip.
	@ Keep absolute value in xh-xl-ip, sign in r5 (the n bit was set above)
	and	r5, xh, #0x80000000
  200540:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
	bpl	LSYM(Lad_p)
  200544:	d507      	bpl.n	200556 <__adddf3+0xe6>
#if defined(__thumb2__)
	mov	lr, #0
  200546:	f04f 0e00 	mov.w	lr, #0
	negs	ip, ip
  20054a:	f1dc 0c00 	rsbs	ip, ip, #0
	sbcs	xl, lr, xl
  20054e:	eb7e 0000 	sbcs.w	r0, lr, r0
	sbc	xh, lr, xh
  200552:	eb6e 0101 	sbc.w	r1, lr, r1
	rsc	xh, xh, #0
#endif

	@ Determine how to normalize the result.
LSYM(Lad_p):
	cmp	xh, #0x00100000
  200556:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
	bcc	LSYM(Lad_a)
  20055a:	d31b      	bcc.n	200594 <__adddf3+0x124>
	cmp	xh, #0x00200000
  20055c:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
	bcc	LSYM(Lad_e)
  200560:	d30c      	bcc.n	20057c <__adddf3+0x10c>

	@ Result needs to be shifted right.
	movs	xh, xh, lsr #1
  200562:	0849      	lsrs	r1, r1, #1
	movs	xl, xl, rrx
  200564:	ea5f 0030 	movs.w	r0, r0, rrx
	mov	ip, ip, rrx
  200568:	ea4f 0c3c 	mov.w	ip, ip, rrx
	add	r4, r4, #1
  20056c:	f104 0401 	add.w	r4, r4, #1

	@ Make sure we did not bust our exponent.
	mov	r2, r4, lsl #21
  200570:	ea4f 5244 	mov.w	r2, r4, lsl #21
	cmn	r2, #(2 << 21)
  200574:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
	bcs	LSYM(Lad_o)
  200578:	f080 809a 	bcs.w	2006b0 <__adddf3+0x240>
	@ Our result is now properly aligned into xh-xl, remaining bits in ip.
	@ Round with MSB of ip. If halfway between two numbers, round towards
	@ LSB of xl = 0.
	@ Pack final result together.
LSYM(Lad_e):
	cmp	ip, #0x80000000
  20057c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
	do_it	eq
  200580:	bf08      	it	eq
	COND(mov,s,eq)	ip, xl, lsr #1
  200582:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
	adcs	xl, xl, #0
  200586:	f150 0000 	adcs.w	r0, r0, #0
	adc	xh, xh, r4, lsl #20
  20058a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
	orr	xh, xh, r5
  20058e:	ea41 0105 	orr.w	r1, r1, r5
	RETLDM	"r4, r5"
  200592:	bd30      	pop	{r4, r5, pc}

	@ Result must be shifted left and exponent adjusted.
LSYM(Lad_a):
	movs	ip, ip, lsl #1
  200594:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
	adcs	xl, xl, xl
  200598:	4140      	adcs	r0, r0
	adc	xh, xh, xh
  20059a:	eb41 0101 	adc.w	r1, r1, r1
	subs	r4, r4, #1
  20059e:	3c01      	subs	r4, #1
	do_it	hs
  2005a0:	bf28      	it	cs
	cmphs	xh, #0x00100000
  2005a2:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
	bhs	LSYM(Lad_e)
  2005a6:	d2e9      	bcs.n	20057c <__adddf3+0x10c>
	sublo	r3, r3, r2, lsr #1
	sub	r3, r3, r2, lsr #3

#else

	teq	xh, #0
  2005a8:	f091 0f00 	teq	r1, #0
	do_it	eq, t
  2005ac:	bf04      	itt	eq
	moveq	xh, xl
  2005ae:	4601      	moveq	r1, r0
	moveq	xl, #0
  2005b0:	2000      	moveq	r0, #0
	clz	r3, xh
  2005b2:	fab1 f381 	clz	r3, r1
	do_it	eq
  2005b6:	bf08      	it	eq
	addeq	r3, r3, #32
  2005b8:	3320      	addeq	r3, #32
	sub	r3, r3, #11
  2005ba:	f1a3 030b 	sub.w	r3, r3, #11

#endif

	@ determine how to shift the value.
	subs	r2, r3, #32
  2005be:	f1b3 0220 	subs.w	r2, r3, #32
	bge	2f
  2005c2:	da0c      	bge.n	2005de <__adddf3+0x16e>
	adds	r2, r2, #12
  2005c4:	320c      	adds	r2, #12
	ble	1f
  2005c6:	dd08      	ble.n	2005da <__adddf3+0x16a>

	@ shift value left 21 to 31 bits, or actually right 11 to 1 bits
	@ since a register switch happened above.
	add	ip, r2, #20
  2005c8:	f102 0c14 	add.w	ip, r2, #20
	rsb	r2, r2, #12
  2005cc:	f1c2 020c 	rsb	r2, r2, #12
	shift1	lsl, xl, xh, ip
  2005d0:	fa01 f00c 	lsl.w	r0, r1, ip
	shift1	lsr, xh, xh, r2
  2005d4:	fa21 f102 	lsr.w	r1, r1, r2
	b	3f
  2005d8:	e00c      	b.n	2005f4 <__adddf3+0x184>

	@ actually shift value left 1 to 20 bits, which might also represent
	@ 32 to 52 bits if counting the register switch that happened earlier.
1:	add	r2, r2, #20
  2005da:	f102 0214 	add.w	r2, r2, #20
2:	do_it	le
  2005de:	bfd8      	it	le
	rsble	ip, r2, #32
  2005e0:	f1c2 0c20 	rsble	ip, r2, #32
	shift1	lsl, xh, xh, r2
  2005e4:	fa01 f102 	lsl.w	r1, r1, r2
#if defined(__thumb2__)
	lsr	ip, xl, ip
  2005e8:	fa20 fc0c 	lsr.w	ip, r0, ip
	itt	le
  2005ec:	bfdc      	itt	le
	orrle	xh, xh, ip
  2005ee:	ea41 010c 	orrle.w	r1, r1, ip
	lslle	xl, xl, r2
  2005f2:	4090      	lslle	r0, r2
	orrle	xh, xh, xl, lsr ip
	movle	xl, xl, lsl r2
#endif

	@ adjust exponent accordingly.
3:	subs	r4, r4, r3
  2005f4:	1ae4      	subs	r4, r4, r3
	do_it	ge, tt
  2005f6:	bfa2      	ittt	ge
	addge	xh, xh, r4, lsl #20
  2005f8:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
	orrge	xh, xh, r5
  2005fc:	4329      	orrge	r1, r5
	RETLDM	"r4, r5" ge
  2005fe:	bd30      	popge	{r4, r5, pc}

	@ Exponent too small, denormalize result.
	@ Find out proper shift value.
	mvn	r4, r4
  200600:	ea6f 0404 	mvn.w	r4, r4
	subs	r4, r4, #31
  200604:	3c1f      	subs	r4, #31
	bge	2f
  200606:	da1c      	bge.n	200642 <__adddf3+0x1d2>
	adds	r4, r4, #12
  200608:	340c      	adds	r4, #12
	bgt	1f
  20060a:	dc0e      	bgt.n	20062a <__adddf3+0x1ba>

	@ shift result right of 1 to 20 bits, sign is in r5.
	add	r4, r4, #20
  20060c:	f104 0414 	add.w	r4, r4, #20
	rsb	r2, r4, #32
  200610:	f1c4 0220 	rsb	r2, r4, #32
	shift1	lsr, xl, xl, r4
  200614:	fa20 f004 	lsr.w	r0, r0, r4
	shiftop orr xl xl xh lsl r2 yh
  200618:	fa01 f302 	lsl.w	r3, r1, r2
  20061c:	ea40 0003 	orr.w	r0, r0, r3
	shiftop orr xh r5 xh lsr r4 yh
  200620:	fa21 f304 	lsr.w	r3, r1, r4
  200624:	ea45 0103 	orr.w	r1, r5, r3
	RETLDM	"r4, r5"
  200628:	bd30      	pop	{r4, r5, pc}

	@ shift result right of 21 to 31 bits, or left 11 to 1 bits after
	@ a register switch from xh to xl.
1:	rsb	r4, r4, #12
  20062a:	f1c4 040c 	rsb	r4, r4, #12
	rsb	r2, r4, #32
  20062e:	f1c4 0220 	rsb	r2, r4, #32
	shift1	lsr, xl, xl, r2
  200632:	fa20 f002 	lsr.w	r0, r0, r2
	shiftop orr xl xl xh lsl r4 yh
  200636:	fa01 f304 	lsl.w	r3, r1, r4
  20063a:	ea40 0003 	orr.w	r0, r0, r3
	mov	xh, r5
  20063e:	4629      	mov	r1, r5
	RETLDM	"r4, r5"
  200640:	bd30      	pop	{r4, r5, pc}

	@ Shift value right of 32 to 64 bits, or 0 to 32 bits after a switch
	@ from xh to xl.
2:	shift1	lsr, xl, xh, r4
  200642:	fa21 f004 	lsr.w	r0, r1, r4
	mov	xh, r5
  200646:	4629      	mov	r1, r5
	RETLDM	"r4, r5"
  200648:	bd30      	pop	{r4, r5, pc}

	@ Adjust exponents for denormalized arguments.
	@ Note that r4 must not remain equal to 0.
LSYM(Lad_d):
	teq	r4, #0
  20064a:	f094 0f00 	teq	r4, #0
	eor	yh, yh, #0x00100000
  20064e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
	do_it	eq, te
  200652:	bf06      	itte	eq
	eoreq	xh, xh, #0x00100000
  200654:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
	addeq	r4, r4, #1
  200658:	3401      	addeq	r4, #1
	subne	r5, r5, #1
  20065a:	3d01      	subne	r5, #1
	b	LSYM(Lad_x)
  20065c:	e74e      	b.n	2004fc <__adddf3+0x8c>


LSYM(Lad_s):
	mvns	ip, r4, asr #21
  20065e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
	do_it	ne
  200662:	bf18      	it	ne
	COND(mvn,s,ne)	ip, r5, asr #21
  200664:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
	beq	LSYM(Lad_i)
  200668:	d029      	beq.n	2006be <__adddf3+0x24e>

	teq	r4, r5
  20066a:	ea94 0f05 	teq	r4, r5
	do_it	eq
  20066e:	bf08      	it	eq
	teqeq	xl, yl
  200670:	ea90 0f02 	teqeq	r0, r2
	beq	1f
  200674:	d005      	beq.n	200682 <__adddf3+0x212>

	@ Result is x + 0.0 = x or 0.0 + y = y.
	orrs	ip, r4, xl
  200676:	ea54 0c00 	orrs.w	ip, r4, r0
	do_it	eq, t
  20067a:	bf04      	itt	eq
	moveq	xh, yh
  20067c:	4619      	moveq	r1, r3
	moveq	xl, yl
  20067e:	4610      	moveq	r0, r2
	RETLDM	"r4, r5"
  200680:	bd30      	pop	{r4, r5, pc}

1:	teq	xh, yh
  200682:	ea91 0f03 	teq	r1, r3

	@ Result is x - x = 0.
	do_it	ne, tt
  200686:	bf1e      	ittt	ne
	movne	xh, #0
  200688:	2100      	movne	r1, #0
	movne	xl, #0
  20068a:	2000      	movne	r0, #0
	RETLDM	"r4, r5" ne
  20068c:	bd30      	popne	{r4, r5, pc}

	@ Result is x + x = 2x.
	movs	ip, r4, lsr #21
  20068e:	ea5f 5c54 	movs.w	ip, r4, lsr #21
	bne	2f
  200692:	d105      	bne.n	2006a0 <__adddf3+0x230>
	movs	xl, xl, lsl #1
  200694:	0040      	lsls	r0, r0, #1
	adcs	xh, xh, xh
  200696:	4149      	adcs	r1, r1
	do_it	cs
  200698:	bf28      	it	cs
	orrcs	xh, xh, #0x80000000
  20069a:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
	RETLDM	"r4, r5"
  20069e:	bd30      	pop	{r4, r5, pc}
2:	adds	r4, r4, #(2 << 21)
  2006a0:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
	do_it	cc, t
  2006a4:	bf3c      	itt	cc
	addcc	xh, xh, #(1 << 20)
  2006a6:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
	RETLDM	"r4, r5" cc
  2006aa:	bd30      	popcc	{r4, r5, pc}
	and	r5, xh, #0x80000000
  2006ac:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000

	@ Overflow: return INF.
LSYM(Lad_o):
	orr	xh, r5, #0x7f000000
  2006b0:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
	orr	xh, xh, #0x00f00000
  2006b4:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
	mov	xl, #0
  2006b8:	f04f 0000 	mov.w	r0, #0
	RETLDM	"r4, r5"
  2006bc:	bd30      	pop	{r4, r5, pc}
	@   if yh-yl != INF/NAN: return xh-xl (which is INF/NAN)
	@   if either is NAN: return NAN
	@   if opposite sign: return NAN
	@   otherwise return xh-xl (which is INF or -INF)
LSYM(Lad_i):
	mvns	ip, r4, asr #21
  2006be:	ea7f 5c64 	mvns.w	ip, r4, asr #21
	do_it	ne, te
  2006c2:	bf1a      	itte	ne
	movne	xh, yh
  2006c4:	4619      	movne	r1, r3
	movne	xl, yl
  2006c6:	4610      	movne	r0, r2
	COND(mvn,s,eq)	ip, r5, asr #21
  2006c8:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
	do_it	ne, t
  2006cc:	bf1c      	itt	ne
	movne	yh, xh
  2006ce:	460b      	movne	r3, r1
	movne	yl, xl
  2006d0:	4602      	movne	r2, r0
	orrs	r4, xl, xh, lsl #12
  2006d2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
	do_it	eq, te
  2006d6:	bf06      	itte	eq
	COND(orr,s,eq)	r5, yl, yh, lsl #12
  2006d8:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
	teqeq	xh, yh
  2006dc:	ea91 0f03 	teqeq	r1, r3
	orrne	xh, xh, #0x00080000	@ quiet NAN
  2006e0:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
	RETLDM	"r4, r5"
  2006e4:	bd30      	pop	{r4, r5, pc}
  2006e6:	bf00      	nop

002006e8 <__aeabi_ui2d>:

ARM_FUNC_START floatunsidf
ARM_FUNC_ALIAS aeabi_ui2d floatunsidf
	CFI_START_FUNCTION

	teq	r0, #0
  2006e8:	f090 0f00 	teq	r0, #0
	do_it	eq, t
  2006ec:	bf04      	itt	eq
	moveq	r1, #0
  2006ee:	2100      	moveq	r1, #0
	RETc(eq)
  2006f0:	4770      	bxeq	lr

	do_push {r4, r5, lr}        @ sp -= 12
  2006f2:	b530      	push	{r4, r5, lr}
	.cfi_adjust_cfa_offset 12   @ CFA is now sp + previousOffset + 12
	.cfi_rel_offset r4, 0       @ Registers are saved from sp + 0 to sp + 8.
	.cfi_rel_offset r5, 4
	.cfi_rel_offset lr, 8

	mov	r4, #0x400		@ initial exponent
  2006f4:	f44f 6480 	mov.w	r4, #1024	; 0x400
	add	r4, r4, #(52-1 - 1)
  2006f8:	f104 0432 	add.w	r4, r4, #50	; 0x32
	mov	r5, #0			@ sign bit is 0
  2006fc:	f04f 0500 	mov.w	r5, #0
	.ifnc	xl, r0
	mov	xl, r0
	.endif
	mov	xh, #0
  200700:	f04f 0100 	mov.w	r1, #0
	b	LSYM(Lad_l)
  200704:	e750      	b.n	2005a8 <__adddf3+0x138>
  200706:	bf00      	nop

00200708 <__aeabi_i2d>:

ARM_FUNC_START floatsidf
ARM_FUNC_ALIAS aeabi_i2d floatsidf
	CFI_START_FUNCTION

	teq	r0, #0
  200708:	f090 0f00 	teq	r0, #0
	do_it	eq, t
  20070c:	bf04      	itt	eq
	moveq	r1, #0
  20070e:	2100      	moveq	r1, #0
	RETc(eq)
  200710:	4770      	bxeq	lr

	do_push {r4, r5, lr}        @ sp -= 12
  200712:	b530      	push	{r4, r5, lr}
	.cfi_adjust_cfa_offset 12   @ CFA is now sp + previousOffset + 12
	.cfi_rel_offset r4, 0       @ Registers are saved from sp + 0 to sp + 8.
	.cfi_rel_offset r5, 4
	.cfi_rel_offset lr, 8

	mov	r4, #0x400		@ initial exponent
  200714:	f44f 6480 	mov.w	r4, #1024	; 0x400
	add	r4, r4, #(52-1 - 1)
  200718:	f104 0432 	add.w	r4, r4, #50	; 0x32
	ands	r5, r0, #0x80000000	@ sign bit in r5
  20071c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
	do_it	mi
  200720:	bf48      	it	mi
	rsbmi	r0, r0, #0		@ absolute value
  200722:	4240      	negmi	r0, r0
	.ifnc	xl, r0
	mov	xl, r0
	.endif
	mov	xh, #0
  200724:	f04f 0100 	mov.w	r1, #0
	b	LSYM(Lad_l)
  200728:	e73e      	b.n	2005a8 <__adddf3+0x138>
  20072a:	bf00      	nop

0020072c <__aeabi_f2d>:

ARM_FUNC_START extendsfdf2
ARM_FUNC_ALIAS aeabi_f2d extendsfdf2
	CFI_START_FUNCTION

	movs	r2, r0, lsl #1		@ toss sign bit
  20072c:	0042      	lsls	r2, r0, #1
	mov	xh, r2, asr #3		@ stretch exponent
  20072e:	ea4f 01e2 	mov.w	r1, r2, asr #3
	mov	xh, xh, rrx		@ retrieve sign bit
  200732:	ea4f 0131 	mov.w	r1, r1, rrx
	mov	xl, r2, lsl #28		@ retrieve remaining bits
  200736:	ea4f 7002 	mov.w	r0, r2, lsl #28
	do_it	ne, ttt
  20073a:	bf1f      	itttt	ne
	COND(and,s,ne)	r3, r2, #0xff000000	@ isolate exponent
  20073c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
	teqne	r3, #0xff000000		@ if not 0, check if INF or NAN
  200740:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
	eorne	xh, xh, #0x38000000	@ fixup exponent otherwise.
  200744:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
	RETc(ne)			@ and return it.
  200748:	4770      	bxne	lr

	bics	r2, r2, #0xff000000	@ isolate mantissa
  20074a:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
	do_it	eq			@ if 0, that is ZERO or INF,
  20074e:	bf08      	it	eq
	RETc(eq)			@ we are done already.
  200750:	4770      	bxeq	lr

	teq	r3, #0xff000000		@ check for NAN
  200752:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
	do_it	eq, t
  200756:	bf04      	itt	eq
	orreq	xh, xh, #0x00080000	@ change to quiet NAN
  200758:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
	RETc(eq)			@ and return it.
  20075c:	4770      	bxeq	lr

	@ value was denormalized.  We can normalize it now.
	do_push	{r4, r5, lr}
  20075e:	b530      	push	{r4, r5, lr}
	.cfi_adjust_cfa_offset 12   @ CFA is now sp + previousOffset + 12
	.cfi_rel_offset r4, 0       @ Registers are saved from sp + 0 to sp + 8.
	.cfi_rel_offset r5, 4
	.cfi_rel_offset lr, 8

	mov	r4, #0x380		@ setup corresponding exponent
  200760:	f44f 7460 	mov.w	r4, #896	; 0x380
	and	r5, xh, #0x80000000	@ move sign bit in r5
  200764:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
	bic	xh, xh, #0x80000000
  200768:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
	b	LSYM(Lad_l)
  20076c:	e71c      	b.n	2005a8 <__adddf3+0x138>
  20076e:	bf00      	nop

00200770 <__aeabi_ul2d>:
ARM_FUNC_START floatundidf
ARM_FUNC_ALIAS aeabi_ul2d floatundidf
	CFI_START_FUNCTION
	.cfi_remember_state        @ Save the current CFA state.

	orrs	r2, r0, r1
  200770:	ea50 0201 	orrs.w	r2, r0, r1
	do_it	eq
  200774:	bf08      	it	eq
	RETc(eq)
  200776:	4770      	bxeq	lr

	do_push {r4, r5, lr}       @ sp -= 12
  200778:	b530      	push	{r4, r5, lr}
	.cfi_adjust_cfa_offset 12  @ CFA is now sp + previousOffset + 12
	.cfi_rel_offset r4, 0      @ Registers are saved from sp + 0 to sp + 8
	.cfi_rel_offset r5, 4
	.cfi_rel_offset lr, 8

	mov	r5, #0
  20077a:	f04f 0500 	mov.w	r5, #0
	b	2f
  20077e:	e00a      	b.n	200796 <__aeabi_l2d+0x16>

00200780 <__aeabi_l2d>:
	.cfi_restore_state
	@ Restore the CFI state we saved above. If we didn't do this then the
	@ following instructions would have the CFI state that was set by the
	@ offset adjustments made in floatundidf.

	orrs	r2, r0, r1
  200780:	ea50 0201 	orrs.w	r2, r0, r1
	do_it	eq
  200784:	bf08      	it	eq
	RETc(eq)
  200786:	4770      	bxeq	lr

	do_push {r4, r5, lr}       @ sp -= 12
  200788:	b530      	push	{r4, r5, lr}
	.cfi_adjust_cfa_offset 12  @ CFA is now sp + previousOffset + 12
	.cfi_rel_offset r4, 0      @ Registers are saved from sp to sp + 8
	.cfi_rel_offset r5, 4
	.cfi_rel_offset lr, 8

	ands	r5, ah, #0x80000000	@ sign bit in r5
  20078a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
	bpl	2f
  20078e:	d502      	bpl.n	200796 <__aeabi_l2d+0x16>
#if defined(__thumb2__)
	negs	al, al
  200790:	4240      	negs	r0, r0
	sbc	ah, ah, ah, lsl #1
  200792:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
#else
	rsbs	al, al, #0
	rsc	ah, ah, #0
#endif
2:
	mov	r4, #0x400		@ initial exponent
  200796:	f44f 6480 	mov.w	r4, #1024	; 0x400
	add	r4, r4, #(52-1 - 1)
  20079a:	f104 0432 	add.w	r4, r4, #50	; 0x32
	mov	ip, al
	mov	xh, ah
	mov	xl, ip
	.endif

	movs	ip, xh, lsr #22
  20079e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
	beq	LSYM(Lad_p)
  2007a2:	f43f aed8 	beq.w	200556 <__adddf3+0xe6>

	@ The value is too big.  Scale it down a bit...
	mov	r2, #3
  2007a6:	f04f 0203 	mov.w	r2, #3
	movs	ip, ip, lsr #3
  2007aa:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
	do_it	ne
  2007ae:	bf18      	it	ne
	addne	r2, r2, #3
  2007b0:	3203      	addne	r2, #3
	movs	ip, ip, lsr #3
  2007b2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
	do_it	ne
  2007b6:	bf18      	it	ne
	addne	r2, r2, #3
  2007b8:	3203      	addne	r2, #3
	add	r2, r2, ip, lsr #3
  2007ba:	eb02 02dc 	add.w	r2, r2, ip, lsr #3

	rsb	r3, r2, #32
  2007be:	f1c2 0320 	rsb	r3, r2, #32
	shift1	lsl, ip, xl, r3
  2007c2:	fa00 fc03 	lsl.w	ip, r0, r3
	shift1	lsr, xl, xl, r2
  2007c6:	fa20 f002 	lsr.w	r0, r0, r2
	shiftop orr xl xl xh lsl r3 lr
  2007ca:	fa01 fe03 	lsl.w	lr, r1, r3
  2007ce:	ea40 000e 	orr.w	r0, r0, lr
	shift1	lsr, xh, xh, r2
  2007d2:	fa21 f102 	lsr.w	r1, r1, r2
	add	r4, r4, r2
  2007d6:	4414      	add	r4, r2
	b	LSYM(Lad_p)
  2007d8:	e6bd      	b.n	200556 <__adddf3+0xe6>
  2007da:	bf00      	nop

002007dc <otg_txfifo_handler.constprop.0>:
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
  2007dc:	4a1c      	ldr	r2, [pc, #112]	; (200850 <otg_txfifo_handler.constprop.0+0x74>)
  2007de:	eb02 0380 	add.w	r3, r2, r0, lsl #2
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
  2007e2:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
  2007e4:	6ed4      	ldr	r4, [r2, #108]	; 0x6c
      return false;

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
  2007e6:	1c45      	adds	r5, r0, #1
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
  2007e8:	68df      	ldr	r7, [r3, #12]
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
  2007ea:	eb04 3505 	add.w	r5, r4, r5, lsl #12
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
  2007ee:	697b      	ldr	r3, [r7, #20]
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
  2007f0:	eb04 1c40 	add.w	ip, r4, r0, lsl #5
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
  2007f4:	e9d3 2100 	ldrd	r2, r1, [r3]
  2007f8:	4291      	cmp	r1, r2
  2007fa:	d30a      	bcc.n	200812 <otg_txfifo_handler.constprop.0+0x36>
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
  2007fc:	2301      	movs	r3, #1
  2007fe:	f8d4 2834 	ldr.w	r2, [r4, #2100]	; 0x834
  200802:	fa03 f000 	lsl.w	r0, r3, r0
  200806:	ea22 0000 	bic.w	r0, r2, r0
  20080a:	f8c4 0834 	str.w	r0, [r4, #2100]	; 0x834
      return true;
  20080e:	4618      	mov	r0, r3
    usbp->epc[ep]->in_state->txcnt += n;
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
  }
}
  200810:	bdf0      	pop	{r4, r5, r6, r7, pc}
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
  200812:	1a52      	subs	r2, r2, r1
    if (n > usbp->epc[ep]->in_maxsize)
  200814:	8a39      	ldrh	r1, [r7, #16]
  200816:	428a      	cmp	r2, r1
  200818:	bf28      	it	cs
  20081a:	460a      	movcs	r2, r1
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
  20081c:	f8dc 1918 	ldr.w	r1, [ip, #2328]	; 0x918
  200820:	b289      	uxth	r1, r1
  200822:	ebb2 0f81 	cmp.w	r2, r1, lsl #2
  200826:	d810      	bhi.n	20084a <otg_txfifo_handler.constprop.0+0x6e>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
  200828:	6899      	ldr	r1, [r3, #8]
  20082a:	f1a1 0e04 	sub.w	lr, r1, #4
    *fifop = *((uint32_t *)buf);
  20082e:	f85e 6f04 	ldr.w	r6, [lr, #4]!
  200832:	602e      	str	r6, [r5, #0]
    if (n <= 4) {
  200834:	eba1 060e 	sub.w	r6, r1, lr
  200838:	4416      	add	r6, r2
  20083a:	2e04      	cmp	r6, #4
  20083c:	d8f7      	bhi.n	20082e <otg_txfifo_handler.constprop.0+0x52>
    usbp->epc[ep]->in_state->txbuf += n;
  20083e:	4411      	add	r1, r2
  200840:	6099      	str	r1, [r3, #8]
    usbp->epc[ep]->in_state->txcnt += n;
  200842:	6859      	ldr	r1, [r3, #4]
  200844:	440a      	add	r2, r1
  200846:	605a      	str	r2, [r3, #4]
  200848:	e7d4      	b.n	2007f4 <otg_txfifo_handler.constprop.0+0x18>
      return false;
  20084a:	2000      	movs	r0, #0
  20084c:	e7e0      	b.n	200810 <otg_txfifo_handler.constprop.0+0x34>
  20084e:	bf00      	nop
  200850:	20000e14 	.word	0x20000e14

00200854 <long_to_string_with_divisor.constprop.0>:
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
  200854:	b5f0      	push	{r4, r5, r6, r7, lr}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
  200856:	f100 040b 	add.w	r4, r0, #11
  20085a:	4623      	mov	r3, r4
  do {
    i = (int)(l % radix);
  20085c:	460d      	mov	r5, r1
  20085e:	fbb1 f1f2 	udiv	r1, r1, r2
  200862:	fb02 5711 	mls	r7, r2, r1, r5
    i += '0';
  200866:	f107 0630 	add.w	r6, r7, #48	; 0x30
    if (i > '9')
  20086a:	2e39      	cmp	r6, #57	; 0x39
      i += 'A' - '0' - 10;
  20086c:	bfc8      	it	gt
  20086e:	f107 0637 	addgt.w	r6, r7, #55	; 0x37
    *--q = i;
    l /= radix;
  } while ((ll /= radix) != 0);
  200872:	4295      	cmp	r5, r2
    *--q = i;
  200874:	f803 6d01 	strb.w	r6, [r3, #-1]!
  } while ((ll /= radix) != 0);
  200878:	d2f0      	bcs.n	20085c <long_to_string_with_divisor.constprop.0+0x8>
  20087a:	1e42      	subs	r2, r0, #1

  i = (int)(p + MAX_FILLER - q);
  20087c:	1ae1      	subs	r1, r4, r3
  do
    *p++ = *q++;
  20087e:	f813 5b01 	ldrb.w	r5, [r3], #1
  while (--i);
  200882:	429c      	cmp	r4, r3
    *p++ = *q++;
  200884:	f802 5f01 	strb.w	r5, [r2, #1]!
  while (--i);
  200888:	d1f9      	bne.n	20087e <long_to_string_with_divisor.constprop.0+0x2a>

  return p;
}
  20088a:	4408      	add	r0, r1
  20088c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

00200890 <_putc>:
}

static void
_putc (char c)
{
	USART1->TDR = (uint32_t)c;
  200890:	4b03      	ldr	r3, [pc, #12]	; (2008a0 <_putc+0x10>)
  200892:	6298      	str	r0, [r3, #40]	; 0x28
	(void)USART1->TDR;
  200894:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	while ((USART1->ISR & USART_ISR_TXE) == 0)
  200896:	69da      	ldr	r2, [r3, #28]
  200898:	0612      	lsls	r2, r2, #24
  20089a:	d5fc      	bpl.n	200896 <_putc+0x6>
		;

	return;
}
  20089c:	4770      	bx	lr
  20089e:	bf00      	nop
  2008a0:	40011000 	.word	0x40011000

002008a4 <_puts>:
/*static*/ void
_puts (char * str)
{
	char * p;
	p = str;
	while (*p != '\0') {
  2008a4:	1e41      	subs	r1, r0, #1
{
  2008a6:	b508      	push	{r3, lr}
	while (*p != '\0') {
  2008a8:	f811 0f01 	ldrb.w	r0, [r1, #1]!
  2008ac:	b938      	cbnz	r0, 2008be <_puts+0x1a>
		_putc (*p);
		p++;
	}
	_putc ('\r');
  2008ae:	200d      	movs	r0, #13
  2008b0:	f7ff ffee 	bl	200890 <_putc>
	_putc ('\n');
  2008b4:	200a      	movs	r0, #10
	return;
}
  2008b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	_putc ('\n');
  2008ba:	f7ff bfe9 	b.w	200890 <_putc>
		_putc (*p);
  2008be:	f7ff ffe7 	bl	200890 <_putc>
		p++;
  2008c2:	e7f1      	b.n	2008a8 <_puts+0x4>

002008c4 <get_descriptor>:
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
  2008c4:	2902      	cmp	r1, #2
  2008c6:	d00c      	beq.n	2008e2 <get_descriptor+0x1e>
  2008c8:	2903      	cmp	r1, #3
  2008ca:	d004      	beq.n	2008d6 <get_descriptor+0x12>
  2008cc:	2901      	cmp	r1, #1
  case USB_DESCRIPTOR_DEVICE:
    return &vcom_device_descriptor;
  2008ce:	4807      	ldr	r0, [pc, #28]	; (2008ec <get_descriptor+0x28>)
  2008d0:	bf18      	it	ne
  2008d2:	2000      	movne	r0, #0
  2008d4:	4770      	bx	lr
  case USB_DESCRIPTOR_CONFIGURATION:
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
  2008d6:	2a03      	cmp	r2, #3
  2008d8:	d805      	bhi.n	2008e6 <get_descriptor+0x22>
      return &vcom_strings[dindex];
  2008da:	4805      	ldr	r0, [pc, #20]	; (2008f0 <get_descriptor+0x2c>)
  2008dc:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
  2008e0:	4770      	bx	lr
  switch (dtype) {
  2008e2:	4804      	ldr	r0, [pc, #16]	; (2008f4 <get_descriptor+0x30>)
  2008e4:	4770      	bx	lr
  }
  return NULL;
  2008e6:	2000      	movs	r0, #0
}
  2008e8:	4770      	bx	lr
  2008ea:	bf00      	nop
  2008ec:	0800e9c0 	.word	0x0800e9c0
  2008f0:	0800ea44 	.word	0x0800ea44
  2008f4:	0800e974 	.word	0x0800e974

002008f8 <gdisp_lld_blit_area>:
	#if GDISP_HARDWARE_BITFILLS
		// Uses p.x,p.y  p.cx,p.cy  p.x1,p.y1 (=srcx,srcy)  p.x2 (=srccx), p.ptr (=buffer)
		LLDSPEC void gdisp_lld_blit_area(GDisplay* g) {
			gU32	srcstart, dststart;

			srcstart = LTDC_PIXELBYTES * ((gU32)g->p.x2 * g->p.y1 * + g->p.x1) + (gU32)g->p.ptr;
  2008f8:	f8b0 2042 	ldrh.w	r2, [r0, #66]	; 0x42
  2008fc:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
			dststart = (gU32)PIXEL_ADDR(g, PIXIL_POS(g, g->p.x, g->p.y));
  200900:	6941      	ldr	r1, [r0, #20]
			srcstart = LTDC_PIXELBYTES * ((gU32)g->p.x2 * g->p.y1 * + g->p.x1) + (gU32)g->p.ptr;
  200902:	fb13 f302 	smulbb	r3, r3, r2
  200906:	f9b0 2040 	ldrsh.w	r2, [r0, #64]	; 0x40
  20090a:	4353      	muls	r3, r2
  20090c:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
  20090e:	eb02 0243 	add.w	r2, r2, r3, lsl #1
			dststart = (gU32)PIXEL_ADDR(g, PIXIL_POS(g, g->p.x, g->p.y));
  200912:	f9b0 3038 	ldrsh.w	r3, [r0, #56]	; 0x38
		LLDSPEC void gdisp_lld_blit_area(GDisplay* g) {
  200916:	b530      	push	{r4, r5, lr}
			dststart = (gU32)PIXEL_ADDR(g, PIXIL_POS(g, g->p.x, g->p.y));
  200918:	005b      	lsls	r3, r3, #1
  20091a:	8f44      	ldrh	r4, [r0, #58]	; 0x3a
  20091c:	890d      	ldrh	r5, [r1, #8]
  20091e:	fb14 3305 	smlabb	r3, r4, r5, r3
  200922:	680c      	ldr	r4, [r1, #0]
  200924:	441c      	add	r4, r3
				// This is slightly less than optimal as we flush the whole line in the source and destination image
				// instead of just the cx portion but this saves us having to iterate over each line.
				gU32	f, e;

				// Data memory barrier
				__ugfxDSB();
  200926:	f3bf 8f4f 	dsb	sy

				// Flush the source area
				e = srcstart + (g->p.cy > 1 ? ((gU32)g->p.x2*g->p.cy) : (gU32)g->p.cx)*LTDC_PIXELBYTES;
  20092a:	f9b0 103e 	ldrsh.w	r1, [r0, #62]	; 0x3e
				for(f=(srcstart & ~31); f < e; f += 32)
				    SCB->DCCIMVAC = f;
  20092e:	4d16      	ldr	r5, [pc, #88]	; (200988 <gdisp_lld_blit_area+0x90>)
				e = srcstart + (g->p.cy > 1 ? ((gU32)g->p.x2*g->p.cy) : (gU32)g->p.cx)*LTDC_PIXELBYTES;
  200930:	2901      	cmp	r1, #1
  200932:	bfca      	itet	gt
  200934:	f8b0 3044 	ldrhgt.w	r3, [r0, #68]	; 0x44
  200938:	f9b0 303c 	ldrshle.w	r3, [r0, #60]	; 0x3c
  20093c:	fb13 f301 	smulbbgt	r3, r3, r1
				for(f=(srcstart & ~31); f < e; f += 32)
  200940:	f022 011f 	bic.w	r1, r2, #31
				e = srcstart + (g->p.cy > 1 ? ((gU32)g->p.x2*g->p.cy) : (gU32)g->p.cx)*LTDC_PIXELBYTES;
  200944:	005b      	lsls	r3, r3, #1
  200946:	4413      	add	r3, r2
				for(f=(srcstart & ~31); f < e; f += 32)
  200948:	4299      	cmp	r1, r3
  20094a:	d319      	bcc.n	200980 <gdisp_lld_blit_area+0x88>
				    SCB->DCCIMVAC = f;
				    SCB->DCIMVAC = f;
				}
#endif
				// Data memory barrier
				__ugfxDSB();
  20094c:	f3bf 8f4f 	dsb	sy
			}
			#endif

			// Wait until DMA2D is ready
			while(DMA2D->CR & DMA2D_CR_START);
  200950:	4b0e      	ldr	r3, [pc, #56]	; (20098c <gdisp_lld_blit_area+0x94>)
  200952:	6819      	ldr	r1, [r3, #0]
  200954:	07c9      	lsls	r1, r1, #31
  200956:	d4fc      	bmi.n	200952 <gdisp_lld_blit_area+0x5a>

			// Source setup
			DMA2D->FGMAR = srcstart;
			DMA2D->FGOR = g->p.x2 - g->p.cx;
  200958:	f9b0 103c 	ldrsh.w	r1, [r0, #60]	; 0x3c
			DMA2D->FGMAR = srcstart;
  20095c:	60da      	str	r2, [r3, #12]
			DMA2D->FGOR = g->p.x2 - g->p.cx;
  20095e:	f9b0 2044 	ldrsh.w	r2, [r0, #68]	; 0x44
  200962:	1a52      	subs	r2, r2, r1
  200964:	611a      	str	r2, [r3, #16]

			// Output setup
			DMA2D->OMAR = dststart;
			DMA2D->OOR = g->g.Width - g->p.cx;
  200966:	f9b0 2008 	ldrsh.w	r2, [r0, #8]
			DMA2D->OMAR = dststart;
  20096a:	63dc      	str	r4, [r3, #60]	; 0x3c
			DMA2D->OOR = g->g.Width - g->p.cx;
  20096c:	1a52      	subs	r2, r2, r1
  20096e:	641a      	str	r2, [r3, #64]	; 0x40
			DMA2D->NLR = (g->p.cx << 16) | (g->p.cy);
  200970:	f9b0 203e 	ldrsh.w	r2, [r0, #62]	; 0x3e
  200974:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
  200978:	645a      	str	r2, [r3, #68]	; 0x44

			// Set MODE to M2M and Start the process
			DMA2D->CR = DMA2D_CR_MODE_M2M | DMA2D_CR_START;
  20097a:	2201      	movs	r2, #1
  20097c:	601a      	str	r2, [r3, #0]
		}
  20097e:	bd30      	pop	{r4, r5, pc}
				    SCB->DCCIMVAC = f;
  200980:	f8c5 1270 	str.w	r1, [r5, #624]	; 0x270
				for(f=(srcstart & ~31); f < e; f += 32)
  200984:	3120      	adds	r1, #32
  200986:	e7df      	b.n	200948 <gdisp_lld_blit_area+0x50>
  200988:	e000ed00 	.word	0xe000ed00
  20098c:	4002b000 	.word	0x4002b000

00200990 <gdisp_lld_fill_area>:
	{
  200990:	b570      	push	{r4, r5, r6, lr}
			pos = PIXIL_POS(g, g->p.x, g->p.y);
  200992:	6946      	ldr	r6, [r0, #20]
  200994:	f9b0 5038 	ldrsh.w	r5, [r0, #56]	; 0x38
  200998:	8933      	ldrh	r3, [r6, #8]
  20099a:	006d      	lsls	r5, r5, #1
  20099c:	8f44      	ldrh	r4, [r0, #58]	; 0x3a
			lineadd = g->g.Width - g->p.cx;
  20099e:	f9b0 1008 	ldrsh.w	r1, [r0, #8]
			pos = PIXIL_POS(g, g->p.x, g->p.y);
  2009a2:	fb14 5503 	smlabb	r5, r4, r3, r5
			shape = (g->p.cx << 16) | (g->p.cy);
  2009a6:	f9b0 203e 	ldrsh.w	r2, [r0, #62]	; 0x3e
			lineadd = g->g.Width - g->p.cx;
  2009aa:	f9b0 303c 	ldrsh.w	r3, [r0, #60]	; 0x3c
  2009ae:	1ac9      	subs	r1, r1, r3
			shape = (g->p.cx << 16) | (g->p.cy);
  2009b0:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
		while(DMA2D->CR & DMA2D_CR_START);
  2009b4:	4b07      	ldr	r3, [pc, #28]	; (2009d4 <gdisp_lld_fill_area+0x44>)
  2009b6:	681c      	ldr	r4, [r3, #0]
  2009b8:	07e4      	lsls	r4, r4, #31
  2009ba:	d4fc      	bmi.n	2009b6 <gdisp_lld_fill_area+0x26>
		DMA2D->OMAR = (gU32)PIXEL_ADDR(g, pos);
  2009bc:	6834      	ldr	r4, [r6, #0]
  2009be:	442c      	add	r4, r5
  2009c0:	63dc      	str	r4, [r3, #60]	; 0x3c
		DMA2D->OOR = lineadd;
  2009c2:	6419      	str	r1, [r3, #64]	; 0x40
		DMA2D->NLR = shape;
  2009c4:	645a      	str	r2, [r3, #68]	; 0x44
			DMA2D->OCOLR = (gU32)(gdispColor2Native(g->p.color));
  2009c6:	f8b0 2048 	ldrh.w	r2, [r0, #72]	; 0x48
  2009ca:	639a      	str	r2, [r3, #56]	; 0x38
		DMA2D->CR = DMA2D_CR_MODE_R2M | DMA2D_CR_START;
  2009cc:	4a02      	ldr	r2, [pc, #8]	; (2009d8 <gdisp_lld_fill_area+0x48>)
  2009ce:	601a      	str	r2, [r3, #0]
	}
  2009d0:	bd70      	pop	{r4, r5, r6, pc}
  2009d2:	bf00      	nop
  2009d4:	4002b000 	.word	0x4002b000
  2009d8:	00030001 	.word	0x00030001

002009dc <gdisp_lld_get_pixel_color>:
		pos = PIXIL_POS(g, g->p.x, g->p.y);
  2009dc:	f9b0 3038 	ldrsh.w	r3, [r0, #56]	; 0x38
  2009e0:	6941      	ldr	r1, [r0, #20]
  2009e2:	005a      	lsls	r2, r3, #1
  2009e4:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
  2009e6:	8908      	ldrh	r0, [r1, #8]
  2009e8:	fb13 2300 	smlabb	r3, r3, r0, r2
		while(DMA2D->CR & DMA2D_CR_START);
  2009ec:	4803      	ldr	r0, [pc, #12]	; (2009fc <gdisp_lld_get_pixel_color+0x20>)
  2009ee:	6802      	ldr	r2, [r0, #0]
  2009f0:	07d2      	lsls	r2, r2, #31
  2009f2:	d4fc      	bmi.n	2009ee <gdisp_lld_get_pixel_color+0x12>
		color = PIXEL_ADDR(g, pos)[0];
  2009f4:	680a      	ldr	r2, [r1, #0]
}
  2009f6:	5ad0      	ldrh	r0, [r2, r3]
  2009f8:	4770      	bx	lr
  2009fa:	bf00      	nop
  2009fc:	4002b000 	.word	0x4002b000

00200a00 <gdisp_lld_draw_pixel>:
		pos = PIXIL_POS(g, g->p.x, g->p.y);
  200a00:	f9b0 3038 	ldrsh.w	r3, [r0, #56]	; 0x38
  200a04:	6941      	ldr	r1, [r0, #20]
  200a06:	005a      	lsls	r2, r3, #1
  200a08:	8f43      	ldrh	r3, [r0, #58]	; 0x3a
LLDSPEC void gdisp_lld_draw_pixel(GDisplay* g) {
  200a0a:	b510      	push	{r4, lr}
		pos = PIXIL_POS(g, g->p.x, g->p.y);
  200a0c:	890c      	ldrh	r4, [r1, #8]
  200a0e:	fb13 2304 	smlabb	r3, r3, r4, r2
		while(DMA2D->CR & DMA2D_CR_START);
  200a12:	4c04      	ldr	r4, [pc, #16]	; (200a24 <gdisp_lld_draw_pixel+0x24>)
  200a14:	6822      	ldr	r2, [r4, #0]
  200a16:	07d2      	lsls	r2, r2, #31
  200a18:	d4fc      	bmi.n	200a14 <gdisp_lld_draw_pixel+0x14>
		PIXEL_ADDR(g, pos)[0] = gdispColor2Native(g->p.color);
  200a1a:	f8b0 0048 	ldrh.w	r0, [r0, #72]	; 0x48
  200a1e:	680a      	ldr	r2, [r1, #0]
  200a20:	52d0      	strh	r0, [r2, r3]
}
  200a22:	bd10      	pop	{r4, pc}
  200a24:	4002b000 	.word	0x4002b000

00200a28 <_ltdc_layer_init>:
	pLayReg->PFCR = (pLayReg->PFCR & ~LTDC_LxPFCR_PF) | ((gU32)pCfg->fmt & LTDC_LxPFCR_PF);
  200a28:	6903      	ldr	r3, [r0, #16]
  200a2a:	894a      	ldrh	r2, [r1, #10]
  200a2c:	f023 0307 	bic.w	r3, r3, #7
static void _ltdc_layer_init(LTDC_Layer_TypeDef* pLayReg, const ltdcLayerConfig* pCfg) {
  200a30:	b510      	push	{r4, lr}
	pLayReg->PFCR = (pLayReg->PFCR & ~LTDC_LxPFCR_PF) | ((gU32)pCfg->fmt & LTDC_LxPFCR_PF);
  200a32:	f002 0407 	and.w	r4, r2, #7
  200a36:	4323      	orrs	r3, r4
  200a38:	6103      	str	r3, [r0, #16]
	pLayReg->CFBAR = (gU32)pCfg->frame & LTDC_LxCFBAR_CFBADD;
  200a3a:	680b      	ldr	r3, [r1, #0]
  200a3c:	6283      	str	r3, [r0, #40]	; 0x28
	pLayReg->CFBLR = ((((gU32)pCfg->pitch << 16) & LTDC_LxCFBLR_CFBP) | (((gU32)fmt2Bpp[pCfg->fmt] * pCfg->width + 3) & LTDC_LxCFBLR_CFBLL));
  200a3e:	4b30      	ldr	r3, [pc, #192]	; (200b00 <_ltdc_layer_init+0xd8>)
  200a40:	5c9c      	ldrb	r4, [r3, r2]
  200a42:	2203      	movs	r2, #3
  200a44:	888b      	ldrh	r3, [r1, #4]
  200a46:	fb13 2304 	smlabb	r3, r3, r4, r2
  200a4a:	f9b1 4008 	ldrsh.w	r4, [r1, #8]
  200a4e:	4a2d      	ldr	r2, [pc, #180]	; (200b04 <_ltdc_layer_init+0xdc>)
  200a50:	f3c3 030c 	ubfx	r3, r3, #0, #13
  200a54:	ea02 4204 	and.w	r2, r2, r4, lsl #16
	for (start = 0; start < pCfg->palettelen; start++)
  200a58:	8c8c      	ldrh	r4, [r1, #36]	; 0x24
	pLayReg->CFBLR = ((((gU32)pCfg->pitch << 16) & LTDC_LxCFBLR_CFBP) | (((gU32)fmt2Bpp[pCfg->fmt] * pCfg->width + 3) & LTDC_LxCFBLR_CFBLL));
  200a5a:	4313      	orrs	r3, r2
	stop  = start + pCfg->cx - 1;
  200a5c:	f9b1 2010 	ldrsh.w	r2, [r1, #16]
	pLayReg->CFBLR = ((((gU32)pCfg->pitch << 16) & LTDC_LxCFBLR_CFBP) | (((gU32)fmt2Bpp[pCfg->fmt] * pCfg->width + 3) & LTDC_LxCFBLR_CFBLL));
  200a60:	62c3      	str	r3, [r0, #44]	; 0x2c
	stop  = start + pCfg->cx - 1;
  200a62:	3a01      	subs	r2, #1
	pLayReg->CFBLNR = (gU32)pCfg->height & LTDC_LxCFBLNR_CFBLNBR;
  200a64:	88cb      	ldrh	r3, [r1, #6]
  200a66:	f3c3 030a 	ubfx	r3, r3, #0, #11
  200a6a:	6303      	str	r3, [r0, #48]	; 0x30
	start = (gU32)pCfg->x + driverCfg.hsync + driverCfg.hbackporch;
  200a6c:	f9b1 300c 	ldrsh.w	r3, [r1, #12]
  200a70:	3336      	adds	r3, #54	; 0x36
	stop  = start + pCfg->cx - 1;
  200a72:	441a      	add	r2, r3
	pLayReg->WHPCR = ((start <<  0) & LTDC_LxWHPCR_WHSTPOS) | ((stop  << 16) & LTDC_LxWHPCR_WHSPPOS);
  200a74:	f3c3 030b 	ubfx	r3, r3, #0, #12
  200a78:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
	stop  = start + pCfg->cy - 1;
  200a7c:	f9b1 2012 	ldrsh.w	r2, [r1, #18]
	pLayReg->WHPCR = ((start <<  0) & LTDC_LxWHPCR_WHSTPOS) | ((stop  << 16) & LTDC_LxWHPCR_WHSPPOS);
  200a80:	6043      	str	r3, [r0, #4]
	stop  = start + pCfg->cy - 1;
  200a82:	3a01      	subs	r2, #1
	start = (gU32)pCfg->y + driverCfg.vsync + driverCfg.vbackporch;
  200a84:	f9b1 300e 	ldrsh.w	r3, [r1, #14]
  200a88:	330c      	adds	r3, #12
	stop  = start + pCfg->cy - 1;
  200a8a:	441a      	add	r2, r3
	pLayReg->WVPCR = ((start <<  0) & LTDC_LxWVPCR_WVSTPOS) | ((stop  << 16) & LTDC_LxWVPCR_WVSPPOS);
  200a8c:	f3c3 030b 	ubfx	r3, r3, #0, #12
  200a90:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  200a94:	6083      	str	r3, [r0, #8]
	pLayReg->DCCR = pCfg->defcolor;
  200a96:	694b      	ldr	r3, [r1, #20]
  200a98:	6183      	str	r3, [r0, #24]
	pLayReg->CKCR = (pLayReg->CKCR & ~0x00FFFFFF) | (pCfg->keycolor & 0x00FFFFFF);
  200a9a:	698b      	ldr	r3, [r1, #24]
  200a9c:	68c2      	ldr	r2, [r0, #12]
  200a9e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  200aa2:	f002 427f 	and.w	r2, r2, #4278190080	; 0xff000000
  200aa6:	4313      	orrs	r3, r2
  200aa8:	60c3      	str	r3, [r0, #12]
	pLayReg->CACR = (pLayReg->CACR & ~LTDC_LxCACR_CONSTA) | ((gU32)pCfg->alpha & LTDC_LxCACR_CONSTA);
  200aaa:	6943      	ldr	r3, [r0, #20]
  200aac:	f891 2026 	ldrb.w	r2, [r1, #38]	; 0x26
  200ab0:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  200ab4:	4313      	orrs	r3, r2
  200ab6:	6143      	str	r3, [r0, #20]
	pLayReg->BFCR = (pLayReg->BFCR & ~(LTDC_LxBFCR_BF1 | LTDC_LxBFCR_BF2)) | ((gU32)pCfg->blending & (LTDC_LxBFCR_BF1 | LTDC_LxBFCR_BF2));
  200ab8:	69cb      	ldr	r3, [r1, #28]
  200aba:	69c2      	ldr	r2, [r0, #28]
  200abc:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
  200ac0:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
  200ac4:	055b      	lsls	r3, r3, #21
  200ac6:	f022 0207 	bic.w	r2, r2, #7
  200aca:	0d5b      	lsrs	r3, r3, #21
  200acc:	4313      	orrs	r3, r2
  200ace:	61c3      	str	r3, [r0, #28]
	for (start = 0; start < pCfg->palettelen; start++)
  200ad0:	2300      	movs	r3, #0
  200ad2:	429c      	cmp	r4, r3
  200ad4:	d809      	bhi.n	200aea <_ltdc_layer_init+0xc2>
	pLayReg->CR = (pLayReg->CR & ~LTDC_LEF_MASK) | ((gU32)pCfg->layerflags & LTDC_LEF_MASK);
  200ad6:	6802      	ldr	r2, [r0, #0]
  200ad8:	f891 3027 	ldrb.w	r3, [r1, #39]	; 0x27
  200adc:	f022 0213 	bic.w	r2, r2, #19
  200ae0:	f003 0313 	and.w	r3, r3, #19
  200ae4:	4313      	orrs	r3, r2
  200ae6:	6003      	str	r3, [r0, #0]
}
  200ae8:	bd10      	pop	{r4, pc}
		pLayReg->CLUTWR = ((gU32)start << 24) | (pCfg->palette[start] & 0x00FFFFFF);
  200aea:	6a0a      	ldr	r2, [r1, #32]
  200aec:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
  200af0:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  200af4:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
	for (start = 0; start < pCfg->palettelen; start++)
  200af8:	3301      	adds	r3, #1
		pLayReg->CLUTWR = ((gU32)start << 24) | (pCfg->palette[start] & 0x00FFFFFF);
  200afa:	6402      	str	r2, [r0, #64]	; 0x40
  200afc:	e7e9      	b.n	200ad2 <_ltdc_layer_init+0xaa>
  200afe:	bf00      	nop
  200b00:	0800e754 	.word	0x0800e754
  200b04:	1fff0000 	.word	0x1fff0000

00200b08 <fatfsUnmount>:

static gBool fatfsUnmount(const char* drive)
{
	(void)drive;

	if (fatfs_mounted) {
  200b08:	4b04      	ldr	r3, [pc, #16]	; (200b1c <fatfsUnmount+0x14>)
  200b0a:	f993 0000 	ldrsb.w	r0, [r3]
  200b0e:	b118      	cbz	r0, 200b18 <fatfsUnmount+0x10>
		// FatFS does not provide an unmount routine.
		fatfs_mounted = gFalse;
  200b10:	2200      	movs	r2, #0
		return gTrue;
  200b12:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		fatfs_mounted = gFalse;
  200b16:	701a      	strb	r2, [r3, #0]
	}

	return gFalse;
}
  200b18:	4770      	bx	lr
  200b1a:	bf00      	nop
  200b1c:	20001bf8 	.word	0x20001bf8

00200b20 <fatfsEOF>:
	if ( f_eof( (FIL*)f->obj ) != 0)
  200b20:	6883      	ldr	r3, [r0, #8]
  200b22:	6958      	ldr	r0, [r3, #20]
  200b24:	68db      	ldr	r3, [r3, #12]
}
  200b26:	4298      	cmp	r0, r3
  200b28:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  200b2c:	bf18      	it	ne
  200b2e:	2000      	movne	r0, #0
  200b30:	4770      	bx	lr

00200b32 <fatfsGetSize>:
	return (gFileSize)f_size( (FIL*)f->obj );
  200b32:	6883      	ldr	r3, [r0, #8]
}
  200b34:	68d8      	ldr	r0, [r3, #12]
  200b36:	4770      	bx	lr

00200b38 <gfileSetPos>:
	if (!f || !(f->flags & GFILEFLG_OPEN))
		return 0;
	return f->pos;
}

gBool gfileSetPos(GFILE *f, gFileSize pos) {
  200b38:	b538      	push	{r3, r4, r5, lr}
  200b3a:	460d      	mov	r5, r1
	if (!f || !(f->flags & GFILEFLG_OPEN))
  200b3c:	4604      	mov	r4, r0
  200b3e:	b908      	cbnz	r0, 200b44 <gfileSetPos+0xc>
		return gFalse;
  200b40:	2000      	movs	r0, #0
	if (!f->vmt->setpos || !f->vmt->setpos(f, pos))
		return gFalse;
	f->pos = pos;
	return gTrue;
}
  200b42:	bd38      	pop	{r3, r4, r5, pc}
	if (!f || !(f->flags & GFILEFLG_OPEN))
  200b44:	8883      	ldrh	r3, [r0, #4]
  200b46:	07db      	lsls	r3, r3, #31
  200b48:	d5fa      	bpl.n	200b40 <gfileSetPos+0x8>
	if (!f->vmt->setpos || !f->vmt->setpos(f, pos))
  200b4a:	6803      	ldr	r3, [r0, #0]
  200b4c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  200b4e:	2b00      	cmp	r3, #0
  200b50:	d0f6      	beq.n	200b40 <gfileSetPos+0x8>
  200b52:	4798      	blx	r3
  200b54:	2800      	cmp	r0, #0
  200b56:	d0f3      	beq.n	200b40 <gfileSetPos+0x8>
	return gTrue;
  200b58:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	f->pos = pos;
  200b5c:	60e5      	str	r5, [r4, #12]
	return gTrue;
  200b5e:	e7f0      	b.n	200b42 <gfileSetPos+0xa>

00200b60 <gfileGetPos>:
	if (!f || !(f->flags & GFILEFLG_OPEN))
  200b60:	b130      	cbz	r0, 200b70 <gfileGetPos+0x10>
  200b62:	8883      	ldrh	r3, [r0, #4]
  200b64:	f013 0301 	ands.w	r3, r3, #1
  200b68:	d001      	beq.n	200b6e <gfileGetPos+0xe>
	return f->pos;
  200b6a:	68c0      	ldr	r0, [r0, #12]
  200b6c:	4770      	bx	lr
		return 0;
  200b6e:	4618      	mov	r0, r3
}
  200b70:	4770      	bx	lr

00200b72 <gfileRead>:
gMemSize gfileRead(GFILE *f, void *buf, gMemSize len) {
  200b72:	b510      	push	{r4, lr}
	if (!f || (f->flags & (GFILEFLG_OPEN|GFILEFLG_READ)) != (GFILEFLG_OPEN|GFILEFLG_READ))
  200b74:	4604      	mov	r4, r0
  200b76:	b168      	cbz	r0, 200b94 <gfileRead+0x22>
  200b78:	8883      	ldrh	r3, [r0, #4]
  200b7a:	f003 0303 	and.w	r3, r3, #3
  200b7e:	2b03      	cmp	r3, #3
  200b80:	d108      	bne.n	200b94 <gfileRead+0x22>
	if (!f->vmt->read)
  200b82:	6803      	ldr	r3, [r0, #0]
  200b84:	69db      	ldr	r3, [r3, #28]
  200b86:	b13b      	cbz	r3, 200b98 <gfileRead+0x26>
	if ((res = f->vmt->read(f, buf, len)) <= 0)
  200b88:	4798      	blx	r3
  200b8a:	b110      	cbz	r0, 200b92 <gfileRead+0x20>
	f->pos += res;
  200b8c:	68e3      	ldr	r3, [r4, #12]
  200b8e:	4403      	add	r3, r0
  200b90:	60e3      	str	r3, [r4, #12]
}
  200b92:	bd10      	pop	{r4, pc}
		return 0;
  200b94:	2000      	movs	r0, #0
  200b96:	e7fc      	b.n	200b92 <gfileRead+0x20>
  200b98:	4618      	mov	r0, r3
  200b9a:	e7fa      	b.n	200b92 <gfileRead+0x20>

00200b9c <gfileClose>:
void gfileClose(GFILE *f) {
  200b9c:	b510      	push	{r4, lr}
	if (!f || !(f->flags & GFILEFLG_OPEN))
  200b9e:	4604      	mov	r4, r0
  200ba0:	b140      	cbz	r0, 200bb4 <gfileClose+0x18>
  200ba2:	8883      	ldrh	r3, [r0, #4]
  200ba4:	07db      	lsls	r3, r3, #31
  200ba6:	d505      	bpl.n	200bb4 <gfileClose+0x18>
	if (f->vmt->close)
  200ba8:	6803      	ldr	r3, [r0, #0]
  200baa:	699b      	ldr	r3, [r3, #24]
  200bac:	b103      	cbz	r3, 200bb0 <gfileClose+0x14>
		f->vmt->close(f);
  200bae:	4798      	blx	r3
	f->flags = 0;
  200bb0:	2300      	movs	r3, #0
  200bb2:	80a3      	strh	r3, [r4, #4]
}
  200bb4:	bd10      	pop	{r4, pc}

00200bb6 <initFrameGif>:
/**
 * Read the info on a frame.
 *
 * Pre:		The file position is at the start of the frame.
 */
static gdispImageError initFrameGif(gdispImage *img) {
  200bb6:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	gdispImagePrivate_GIF *	priv;
	gifimgcache *			cache;
	gU8					blocktype;
	gU8					blocksz;

	priv = (gdispImagePrivate_GIF *)img->priv;
  200bb8:	6944      	ldr	r4, [r0, #20]
static gdispImageError initFrameGif(gdispImage *img) {
  200bba:	4605      	mov	r5, r0

	// Save the dispose info from the existing frame
	priv->dispose.flags = priv->frame.flags;
  200bbc:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
	priv->dispose.y = priv->frame.y;
	priv->dispose.width = priv->frame.width;
	priv->dispose.height = priv->frame.height;

	// Check for a cached version of this image
	for(cache=priv->cache; cache && cache->frame.posstart <= gfileGetPos(img->f); cache=cache->next) {
  200bbe:	6927      	ldr	r7, [r4, #16]
	priv->dispose.flags = priv->frame.flags;
  200bc0:	87a3      	strh	r3, [r4, #60]	; 0x3c
	priv->dispose.x = priv->frame.x;
  200bc2:	8ba3      	ldrh	r3, [r4, #28]
  200bc4:	68c1      	ldr	r1, [r0, #12]
  200bc6:	87e3      	strh	r3, [r4, #62]	; 0x3e
	priv->dispose.y = priv->frame.y;
  200bc8:	8be3      	ldrh	r3, [r4, #30]
  200bca:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
	priv->dispose.width = priv->frame.width;
  200bce:	8c23      	ldrh	r3, [r4, #32]
  200bd0:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42
	priv->dispose.height = priv->frame.height;
  200bd4:	8c63      	ldrh	r3, [r4, #34]	; 0x22
  200bd6:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
	for(cache=priv->cache; cache && cache->frame.posstart <= gfileGetPos(img->f); cache=cache->next) {
  200bda:	b12f      	cbz	r7, 200be8 <initFrameGif+0x32>
  200bdc:	693a      	ldr	r2, [r7, #16]
  200bde:	4608      	mov	r0, r1
  200be0:	f7ff ffbe 	bl	200b60 <gfileGetPos>
  200be4:	4282      	cmp	r2, r0
  200be6:	dd17      	ble.n	200c18 <initFrameGif+0x62>
			return GDISP_IMAGE_ERR_OK;
		}
	}

	// Get ready for a new image
	priv->curcache = 0;
  200be8:	2200      	movs	r2, #0
				return GDISP_IMAGE_ERR_BADDATA;

			switch(blocktype) {
			case 0xF9:			// EXTENSION - Graphics Control Block
				// Read the GCB
				if (gfileRead(img->f, priv->buf, 6) != 6)
  200bea:	f104 0646 	add.w	r6, r4, #70	; 0x46
	priv->frame.posstart = gfileGetPos(img->f);
  200bee:	4608      	mov	r0, r1
	priv->curcache = 0;
  200bf0:	6162      	str	r2, [r4, #20]
	priv->frame.posstart = gfileGetPos(img->f);
  200bf2:	f7ff ffb5 	bl	200b60 <gfileGetPos>
  200bf6:	62e0      	str	r0, [r4, #44]	; 0x2c
	priv->frame.flags = 0;
  200bf8:	f884 2026 	strb.w	r2, [r4, #38]	; 0x26
	priv->frame.delay = 0;
  200bfc:	84a2      	strh	r2, [r4, #36]	; 0x24
	priv->frame.palsize = 0;
  200bfe:	8522      	strh	r2, [r4, #40]	; 0x28
		if (gfileRead(img->f, &blocktype, 1) != 1)
  200c00:	2201      	movs	r2, #1
  200c02:	f10d 0107 	add.w	r1, sp, #7
  200c06:	68e8      	ldr	r0, [r5, #12]
  200c08:	f7ff ffb3 	bl	200b72 <gfileRead>
  200c0c:	2801      	cmp	r0, #1
  200c0e:	4602      	mov	r2, r0
  200c10:	d012      	beq.n	200c38 <initFrameGif+0x82>
			return GDISP_IMAGE_ERR_BADDATA;
  200c12:	f248 0002 	movw	r0, #32770	; 0x8002
  200c16:	e00b      	b.n	200c30 <initFrameGif+0x7a>
		if (cache->frame.posstart == gfileGetPos(img->f)) {
  200c18:	d10c      	bne.n	200c34 <initFrameGif+0x7e>
			priv->frame = cache->frame;
  200c1a:	463e      	mov	r6, r7
  200c1c:	f104 051c 	add.w	r5, r4, #28
  200c20:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
  200c22:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  200c24:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
  200c28:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
			return GDISP_IMAGE_ERR_OK;
  200c2c:	2000      	movs	r0, #0
			priv->curcache = cache;
  200c2e:	6167      	str	r7, [r4, #20]

		default:			// UNDEFINED_RECORD_TYPE;
			return GDISP_IMAGE_ERR_UNSUPPORTED;
		}
	}
}
  200c30:	b003      	add	sp, #12
  200c32:	bdf0      	pop	{r4, r5, r6, r7, pc}
	for(cache=priv->cache; cache && cache->frame.posstart <= gfileGetPos(img->f); cache=cache->next) {
  200c34:	6abf      	ldr	r7, [r7, #40]	; 0x28
  200c36:	e7d0      	b.n	200bda <initFrameGif+0x24>
		switch(blocktype) {
  200c38:	f89d 3007 	ldrb.w	r3, [sp, #7]
  200c3c:	2b2c      	cmp	r3, #44	; 0x2c
  200c3e:	d007      	beq.n	200c50 <initFrameGif+0x9a>
  200c40:	2b3b      	cmp	r3, #59	; 0x3b
  200c42:	f000 8107 	beq.w	200e54 <initFrameGif+0x29e>
  200c46:	2b21      	cmp	r3, #33	; 0x21
  200c48:	d03e      	beq.n	200cc8 <initFrameGif+0x112>
					return GDISP_IMAGE_ERR_UNSUPPORTED;
  200c4a:	f248 0003 	movw	r0, #32771	; 0x8003
  200c4e:	e7ef      	b.n	200c30 <initFrameGif+0x7a>
			if (gfileRead(img->f, priv->buf, 9) != 9)
  200c50:	2209      	movs	r2, #9
  200c52:	f104 0146 	add.w	r1, r4, #70	; 0x46
  200c56:	68e8      	ldr	r0, [r5, #12]
  200c58:	f7ff ff8b 	bl	200b72 <gfileRead>
  200c5c:	2809      	cmp	r0, #9
  200c5e:	d1d8      	bne.n	200c12 <initFrameGif+0x5c>
			priv->frame.x = gdispImageGetAlignedLE16(priv->buf, 0);
  200c60:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
			if (((gU8 *)priv->buf)[8] & 0x80)				// Local color table?
  200c64:	f894 204e 	ldrb.w	r2, [r4, #78]	; 0x4e
			priv->frame.x = gdispImageGetAlignedLE16(priv->buf, 0);
  200c68:	83a3      	strh	r3, [r4, #28]
			priv->frame.y = gdispImageGetAlignedLE16(priv->buf, 2);
  200c6a:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
  200c6e:	83e3      	strh	r3, [r4, #30]
			priv->frame.width = gdispImageGetAlignedLE16(priv->buf, 4);
  200c70:	f8b4 304a 	ldrh.w	r3, [r4, #74]	; 0x4a
  200c74:	8423      	strh	r3, [r4, #32]
			priv->frame.height = gdispImageGetAlignedLE16(priv->buf, 6);
  200c76:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
  200c7a:	8463      	strh	r3, [r4, #34]	; 0x22
			if (((gU8 *)priv->buf)[8] & 0x80)				// Local color table?
  200c7c:	f994 304e 	ldrsb.w	r3, [r4, #78]	; 0x4e
  200c80:	2b00      	cmp	r3, #0
				priv->frame.palsize = 2 << (((gU8 *)priv->buf)[8] & 0x07);
  200c82:	bfbf      	itttt	lt
  200c84:	2302      	movlt	r3, #2
  200c86:	f002 0107 	andlt.w	r1, r2, #7
  200c8a:	408b      	lsllt	r3, r1
  200c8c:	8523      	strhlt	r3, [r4, #40]	; 0x28
			if (((gU8 *)priv->buf)[8] & 0x40)				// Interlaced?
  200c8e:	0652      	lsls	r2, r2, #25
				priv->frame.flags |= GIFL_INTERLACE;
  200c90:	bf42      	ittt	mi
  200c92:	f894 3026 	ldrbmi.w	r3, [r4, #38]	; 0x26
  200c96:	f043 0308 	orrmi.w	r3, r3, #8
  200c9a:	f884 3026 	strbmi.w	r3, [r4, #38]	; 0x26
			priv->frame.pospal = gfileGetPos(img->f);
  200c9e:	68e8      	ldr	r0, [r5, #12]
  200ca0:	f7ff ff5e 	bl	200b60 <gfileGetPos>
			priv->frame.posimg = priv->frame.pospal+priv->frame.palsize*3;
  200ca4:	8d23      	ldrh	r3, [r4, #40]	; 0x28
			if (priv->frame.posstart != priv->frame0pos)
  200ca6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
			priv->frame.posimg = priv->frame.pospal+priv->frame.palsize*3;
  200ca8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
			priv->frame.pospal = gfileGetPos(img->f);
  200cac:	6320      	str	r0, [r4, #48]	; 0x30
			priv->frame.posimg = priv->frame.pospal+priv->frame.palsize*3;
  200cae:	4418      	add	r0, r3
			if (priv->frame.posstart != priv->frame0pos)
  200cb0:	68e3      	ldr	r3, [r4, #12]
			priv->frame.posimg = priv->frame.pospal+priv->frame.palsize*3;
  200cb2:	6360      	str	r0, [r4, #52]	; 0x34
			if (priv->frame.posstart != priv->frame0pos)
  200cb4:	429a      	cmp	r2, r3
			priv->frame.posend = 0;
  200cb6:	f04f 0000 	mov.w	r0, #0
  200cba:	63a0      	str	r0, [r4, #56]	; 0x38
			if (priv->frame.posstart != priv->frame0pos)
  200cbc:	d0b8      	beq.n	200c30 <initFrameGif+0x7a>
				img->flags |= GDISP_IMAGE_FLG_ANIMATED;
  200cbe:	886b      	ldrh	r3, [r5, #2]
  200cc0:	f043 0302 	orr.w	r3, r3, #2
  200cc4:	806b      	strh	r3, [r5, #2]
  200cc6:	e7b3      	b.n	200c30 <initFrameGif+0x7a>
			if (gfileRead(img->f, &blocktype, 1) != 1)
  200cc8:	f10d 0107 	add.w	r1, sp, #7
  200ccc:	68e8      	ldr	r0, [r5, #12]
  200cce:	f7ff ff50 	bl	200b72 <gfileRead>
  200cd2:	2801      	cmp	r0, #1
  200cd4:	d19d      	bne.n	200c12 <initFrameGif+0x5c>
			switch(blocktype) {
  200cd6:	f89d 3007 	ldrb.w	r3, [sp, #7]
  200cda:	2bf9      	cmp	r3, #249	; 0xf9
  200cdc:	d016      	beq.n	200d0c <initFrameGif+0x156>
  200cde:	2bff      	cmp	r3, #255	; 0xff
  200ce0:	d060      	beq.n	200da4 <initFrameGif+0x1ee>
				if (blocktype <= 0x7F)
  200ce2:	0619      	lsls	r1, r3, #24
  200ce4:	d5b1      	bpl.n	200c4a <initFrameGif+0x94>
					if (gfileRead(img->f, &blocksz, 1) != 1)
  200ce6:	2201      	movs	r2, #1
  200ce8:	f10d 0106 	add.w	r1, sp, #6
  200cec:	68e8      	ldr	r0, [r5, #12]
  200cee:	f7ff ff40 	bl	200b72 <gfileRead>
  200cf2:	2801      	cmp	r0, #1
  200cf4:	d18d      	bne.n	200c12 <initFrameGif+0x5c>
					if (!blocksz)
  200cf6:	f89d 1006 	ldrb.w	r1, [sp, #6]
  200cfa:	68ea      	ldr	r2, [r5, #12]
  200cfc:	2900      	cmp	r1, #0
  200cfe:	f43f af7f 	beq.w	200c00 <initFrameGif+0x4a>
					gfileSetPos(img->f, gfileGetPos(img->f) + blocksz);
  200d02:	4610      	mov	r0, r2
  200d04:	f7ff ff2c 	bl	200b60 <gfileGetPos>
  200d08:	4401      	add	r1, r0
  200d0a:	e09c      	b.n	200e46 <initFrameGif+0x290>
				if (gfileRead(img->f, priv->buf, 6) != 6)
  200d0c:	2206      	movs	r2, #6
  200d0e:	4631      	mov	r1, r6
  200d10:	68e8      	ldr	r0, [r5, #12]
  200d12:	f7ff ff2e 	bl	200b72 <gfileRead>
  200d16:	2806      	cmp	r0, #6
  200d18:	f47f af7b 	bne.w	200c12 <initFrameGif+0x5c>
				if (((gU8 *)priv->buf)[0] != 4 || ((gU8 *)priv->buf)[5] != 0)
  200d1c:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
  200d20:	2b04      	cmp	r3, #4
  200d22:	f47f af76 	bne.w	200c12 <initFrameGif+0x5c>
  200d26:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
  200d2a:	2b00      	cmp	r3, #0
  200d2c:	f47f af71 	bne.w	200c12 <initFrameGif+0x5c>
				switch(((gU8 *)priv->buf)[1] & 0x1C) {
  200d30:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
  200d34:	f003 021c 	and.w	r2, r3, #28
  200d38:	2a08      	cmp	r2, #8
  200d3a:	d02c      	beq.n	200d96 <initFrameGif+0x1e0>
  200d3c:	d821      	bhi.n	200d82 <initFrameGif+0x1cc>
  200d3e:	f013 0f18 	tst.w	r3, #24
  200d42:	d182      	bne.n	200c4a <initFrameGif+0x94>
				if (((gU8 *)priv->buf)[1] & 0x01) {
  200d44:	07db      	lsls	r3, r3, #31
  200d46:	d509      	bpl.n	200d5c <initFrameGif+0x1a6>
  200d48:	886b      	ldrh	r3, [r5, #2]
					priv->frame.flags |= GIFL_TRANSPARENT;
  200d4a:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
					img->flags |= GDISP_IMAGE_FLG_TRANSPARENT;		// We set this but never clear it
  200d4e:	f043 0301 	orr.w	r3, r3, #1
					priv->frame.flags |= GIFL_TRANSPARENT;
  200d52:	f042 0201 	orr.w	r2, r2, #1
  200d56:	f884 2026 	strb.w	r2, [r4, #38]	; 0x26
					img->flags |= GDISP_IMAGE_FLG_TRANSPARENT;		// We set this but never clear it
  200d5a:	806b      	strh	r3, [r5, #2]
				if (((gU8 *)priv->buf)[1] & 0x02)				// Wait for user input?
  200d5c:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
  200d60:	886b      	ldrh	r3, [r5, #2]
  200d62:	0797      	lsls	r7, r2, #30
					img->flags &= ~GDISP_IMAGE_FLG_MULTIPAGE;
  200d64:	bf56      	itet	pl
  200d66:	f023 0304 	bicpl.w	r3, r3, #4
					img->flags |= GDISP_IMAGE_FLG_MULTIPAGE;
  200d6a:	f043 0304 	orrmi.w	r3, r3, #4
					img->flags &= ~GDISP_IMAGE_FLG_MULTIPAGE;
  200d6e:	b29b      	uxthpl	r3, r3
  200d70:	806b      	strh	r3, [r5, #2]
				priv->frame.delay = gdispImageGetAlignedLE16(priv->buf, 2);
  200d72:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
  200d76:	84a3      	strh	r3, [r4, #36]	; 0x24
				priv->frame.paltrans = ((gU8 *)priv->buf)[4];
  200d78:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
  200d7c:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
				break;
  200d80:	e73e      	b.n	200c00 <initFrameGif+0x4a>
  200d82:	2a0c      	cmp	r2, #12
  200d84:	d002      	beq.n	200d8c <initFrameGif+0x1d6>
  200d86:	2a10      	cmp	r2, #16
  200d88:	f47f af5f 	bne.w	200c4a <initFrameGif+0x94>
				case 0x0C: case 0x10:	priv->frame.flags |= GIFL_DISPOSEREST;		break;		// Dispose = restore. Value 0x10 is a hack for bad encoders
  200d8c:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
  200d90:	f042 0204 	orr.w	r2, r2, #4
  200d94:	e003      	b.n	200d9e <initFrameGif+0x1e8>
				case 0x08:				priv->frame.flags |= GIFL_DISPOSECLEAR;		break;		// Dispose = clear
  200d96:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
  200d9a:	f042 0202 	orr.w	r2, r2, #2
				case 0x0C: case 0x10:	priv->frame.flags |= GIFL_DISPOSEREST;		break;		// Dispose = restore. Value 0x10 is a hack for bad encoders
  200d9e:	f884 2026 	strb.w	r2, [r4, #38]	; 0x26
  200da2:	e7cf      	b.n	200d44 <initFrameGif+0x18e>
				if (priv->flags & GIF_LOOP)
  200da4:	7823      	ldrb	r3, [r4, #0]
  200da6:	07d8      	lsls	r0, r3, #31
  200da8:	d49d      	bmi.n	200ce6 <initFrameGif+0x130>
				if (gfileRead(img->f, priv->buf, 16) != 16)
  200daa:	2210      	movs	r2, #16
  200dac:	4631      	mov	r1, r6
  200dae:	68e8      	ldr	r0, [r5, #12]
  200db0:	f7ff fedf 	bl	200b72 <gfileRead>
  200db4:	2810      	cmp	r0, #16
  200db6:	f47f af2c 	bne.w	200c12 <initFrameGif+0x5c>
				if (((gU8 *)priv->buf)[0] != 11 && ((gU8 *)priv->buf)[12] != 3)
  200dba:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
  200dbe:	2b0b      	cmp	r3, #11
  200dc0:	d004      	beq.n	200dcc <initFrameGif+0x216>
  200dc2:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
  200dc6:	2b03      	cmp	r3, #3
  200dc8:	f47f af23 	bne.w	200c12 <initFrameGif+0x5c>
				if (((gU8 *)priv->buf)[1] == 'N' && ((gU8 *)priv->buf)[2] == 'E' && ((gU8 *)priv->buf)[3] == 'T'
  200dcc:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
  200dd0:	2b4e      	cmp	r3, #78	; 0x4e
  200dd2:	d133      	bne.n	200e3c <initFrameGif+0x286>
  200dd4:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
  200dd8:	2b45      	cmp	r3, #69	; 0x45
  200dda:	d12f      	bne.n	200e3c <initFrameGif+0x286>
  200ddc:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
  200de0:	2b54      	cmp	r3, #84	; 0x54
  200de2:	d12b      	bne.n	200e3c <initFrameGif+0x286>
						&& ((gU8 *)priv->buf)[4] == 'S' && ((gU8 *)priv->buf)[5] == 'C' && ((gU8 *)priv->buf)[6] == 'A'
  200de4:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
  200de8:	2b53      	cmp	r3, #83	; 0x53
  200dea:	d127      	bne.n	200e3c <initFrameGif+0x286>
  200dec:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
  200df0:	2b43      	cmp	r3, #67	; 0x43
  200df2:	d123      	bne.n	200e3c <initFrameGif+0x286>
  200df4:	f894 304c 	ldrb.w	r3, [r4, #76]	; 0x4c
  200df8:	2b41      	cmp	r3, #65	; 0x41
  200dfa:	d11f      	bne.n	200e3c <initFrameGif+0x286>
						&& ((gU8 *)priv->buf)[7] == 'P' && ((gU8 *)priv->buf)[8] == 'E' && ((gU8 *)priv->buf)[9] == '2'
  200dfc:	f894 304d 	ldrb.w	r3, [r4, #77]	; 0x4d
  200e00:	2b50      	cmp	r3, #80	; 0x50
  200e02:	d11b      	bne.n	200e3c <initFrameGif+0x286>
  200e04:	f894 304e 	ldrb.w	r3, [r4, #78]	; 0x4e
  200e08:	2b45      	cmp	r3, #69	; 0x45
  200e0a:	d117      	bne.n	200e3c <initFrameGif+0x286>
  200e0c:	f894 304f 	ldrb.w	r3, [r4, #79]	; 0x4f
  200e10:	2b32      	cmp	r3, #50	; 0x32
  200e12:	d113      	bne.n	200e3c <initFrameGif+0x286>
						&& ((gU8 *)priv->buf)[10] == '.' && ((gU8 *)priv->buf)[11] == '0') {
  200e14:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
  200e18:	2b2e      	cmp	r3, #46	; 0x2e
  200e1a:	d10f      	bne.n	200e3c <initFrameGif+0x286>
  200e1c:	f894 3051 	ldrb.w	r3, [r4, #81]	; 0x51
  200e20:	2b30      	cmp	r3, #48	; 0x30
  200e22:	d10b      	bne.n	200e3c <initFrameGif+0x286>
					if (((gU8 *)priv->buf)[13] == 1) {
  200e24:	f894 3053 	ldrb.w	r3, [r4, #83]	; 0x53
  200e28:	2b01      	cmp	r3, #1
  200e2a:	d107      	bne.n	200e3c <initFrameGif+0x286>
						priv->loops = gdispImageGetAlignedLE16(priv->buf, 14);
  200e2c:	f8b4 2054 	ldrh.w	r2, [r4, #84]	; 0x54
						priv->flags |= GIF_LOOP;
  200e30:	7823      	ldrb	r3, [r4, #0]
						priv->loops = gdispImageGetAlignedLE16(priv->buf, 14);
  200e32:	8062      	strh	r2, [r4, #2]
						if (!priv->loops)
  200e34:	b15a      	cbz	r2, 200e4e <initFrameGif+0x298>
						priv->flags |= GIF_LOOP;
  200e36:	f043 0301 	orr.w	r3, r3, #1
							priv->flags |= GIF_LOOPFOREVER;
  200e3a:	7023      	strb	r3, [r4, #0]
				gfileSetPos(img->f, gfileGetPos(img->f) - 4);
  200e3c:	68ea      	ldr	r2, [r5, #12]
  200e3e:	4610      	mov	r0, r2
  200e40:	f7ff fe8e 	bl	200b60 <gfileGetPos>
  200e44:	1f01      	subs	r1, r0, #4
					gfileSetPos(img->f, gfileGetPos(img->f) + blocksz);
  200e46:	4610      	mov	r0, r2
  200e48:	f7ff fe76 	bl	200b38 <gfileSetPos>
  200e4c:	e74b      	b.n	200ce6 <initFrameGif+0x130>
							priv->flags |= GIF_LOOPFOREVER;
  200e4e:	f043 0303 	orr.w	r3, r3, #3
  200e52:	e7f2      	b.n	200e3a <initFrameGif+0x284>
			if (!(priv->flags & GIF_LOOP))
  200e54:	7823      	ldrb	r3, [r4, #0]
  200e56:	07da      	lsls	r2, r3, #31
  200e58:	d50c      	bpl.n	200e74 <initFrameGif+0x2be>
			if (!(priv->flags & GIF_LOOPFOREVER)) {
  200e5a:	079b      	lsls	r3, r3, #30
  200e5c:	d403      	bmi.n	200e66 <initFrameGif+0x2b0>
				if (!priv->loops)
  200e5e:	8863      	ldrh	r3, [r4, #2]
  200e60:	b143      	cbz	r3, 200e74 <initFrameGif+0x2be>
				priv->loops--;
  200e62:	3b01      	subs	r3, #1
  200e64:	8063      	strh	r3, [r4, #2]
			gfileSetPos(img->f, priv->frame0pos);
  200e66:	68e1      	ldr	r1, [r4, #12]
  200e68:	68e8      	ldr	r0, [r5, #12]
  200e6a:	f7ff fe65 	bl	200b38 <gfileSetPos>
			return GDISP_IMAGE_GIF_LOOP;
  200e6e:	f64f 70fe 	movw	r0, #65534	; 0xfffe
  200e72:	e6dd      	b.n	200c30 <initFrameGif+0x7a>
				return GDISP_IMAGE_GIF_EOF;
  200e74:	f64f 70ff 	movw	r0, #65535	; 0xffff
  200e78:	e6da      	b.n	200c30 <initFrameGif+0x7a>

00200e7a <gdispImageNext_GIF>:
baddatacleanup:
	stopDecodeGif(img);
	return GDISP_IMAGE_ERR_BADDATA;
}

gDelay gdispImageNext_GIF(gdispImage *img) {
  200e7a:	b573      	push	{r0, r1, r4, r5, r6, lr}
	gdispImagePrivate_GIF *	priv;
	gDelay				delay;
	gU8					blocksz;

	priv = (gdispImagePrivate_GIF *)img->priv;
  200e7c:	6945      	ldr	r5, [r0, #20]
gDelay gdispImageNext_GIF(gdispImage *img) {
  200e7e:	4604      	mov	r4, r0

	// Save the delay and convert to millisecs
	delay = (gDelay)priv->frame.delay * 10;

	// We need to get to the end of this frame
	if (!priv->frame.posend) {
  200e80:	6bab      	ldr	r3, [r5, #56]	; 0x38
	delay = (gDelay)priv->frame.delay * 10;
  200e82:	8cae      	ldrh	r6, [r5, #36]	; 0x24
	if (!priv->frame.posend) {
  200e84:	b9db      	cbnz	r3, 200ebe <gdispImageNext_GIF+0x44>
		// We don't know where the end of the frame is yet - find it!
		gfileSetPos(img->f, priv->frame.posimg+1);				// Skip the code size byte too
  200e86:	6b69      	ldr	r1, [r5, #52]	; 0x34
  200e88:	68c0      	ldr	r0, [r0, #12]
  200e8a:	3101      	adds	r1, #1
  200e8c:	f7ff fe54 	bl	200b38 <gfileSetPos>
		while(1) {
			if (gfileRead(img->f, &blocksz, 1) != 1)
  200e90:	2201      	movs	r2, #1
  200e92:	f10d 0107 	add.w	r1, sp, #7
  200e96:	68e0      	ldr	r0, [r4, #12]
  200e98:	f7ff fe6b 	bl	200b72 <gfileRead>
  200e9c:	2801      	cmp	r0, #1
  200e9e:	d003      	beq.n	200ea8 <gdispImageNext_GIF+0x2e>
	// Seek to the end of this frame
	gfileSetPos(img->f, priv->frame.posend);

	// Read the next frame descriptor
	for(blocksz=0; blocksz < 2; blocksz++) {		// 2 loops max to prevent cycling forever with a bad file
		switch(initFrameGif(img)) {
  200ea0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		default:
			return gDelayForever;
		}
	}
	return gDelayForever;
}
  200ea4:	b002      	add	sp, #8
  200ea6:	bd70      	pop	{r4, r5, r6, pc}
			if (!blocksz)
  200ea8:	68e2      	ldr	r2, [r4, #12]
  200eaa:	f89d 1007 	ldrb.w	r1, [sp, #7]
  200eae:	4610      	mov	r0, r2
  200eb0:	f7ff fe56 	bl	200b60 <gfileGetPos>
  200eb4:	b111      	cbz	r1, 200ebc <gdispImageNext_GIF+0x42>
			gfileSetPos(img->f, gfileGetPos(img->f) + blocksz);
  200eb6:	4401      	add	r1, r0
  200eb8:	4610      	mov	r0, r2
  200eba:	e7e7      	b.n	200e8c <gdispImageNext_GIF+0x12>
		priv->frame.posend = gfileGetPos(img->f);
  200ebc:	63a8      	str	r0, [r5, #56]	; 0x38
	gfileSetPos(img->f, priv->frame.posend);
  200ebe:	6ba9      	ldr	r1, [r5, #56]	; 0x38
		switch(initFrameGif(img)) {
  200ec0:	f64f 75fe 	movw	r5, #65534	; 0xfffe
	gfileSetPos(img->f, priv->frame.posend);
  200ec4:	68e0      	ldr	r0, [r4, #12]
  200ec6:	f7ff fe37 	bl	200b38 <gfileSetPos>
	for(blocksz=0; blocksz < 2; blocksz++) {		// 2 loops max to prevent cycling forever with a bad file
  200eca:	2300      	movs	r3, #0
  200ecc:	f88d 3007 	strb.w	r3, [sp, #7]
		switch(initFrameGif(img)) {
  200ed0:	4620      	mov	r0, r4
  200ed2:	f7ff fe70 	bl	200bb6 <initFrameGif>
  200ed6:	b150      	cbz	r0, 200eee <gdispImageNext_GIF+0x74>
  200ed8:	42a8      	cmp	r0, r5
  200eda:	d1e1      	bne.n	200ea0 <gdispImageNext_GIF+0x26>
	for(blocksz=0; blocksz < 2; blocksz++) {		// 2 loops max to prevent cycling forever with a bad file
  200edc:	f89d 3007 	ldrb.w	r3, [sp, #7]
  200ee0:	3301      	adds	r3, #1
  200ee2:	b2db      	uxtb	r3, r3
  200ee4:	2b01      	cmp	r3, #1
  200ee6:	f88d 3007 	strb.w	r3, [sp, #7]
  200eea:	d9f1      	bls.n	200ed0 <gdispImageNext_GIF+0x56>
  200eec:	e7d8      	b.n	200ea0 <gdispImageNext_GIF+0x26>
	delay = (gDelay)priv->frame.delay * 10;
  200eee:	200a      	movs	r0, #10
  200ef0:	4370      	muls	r0, r6
  200ef2:	e7d7      	b.n	200ea4 <gdispImageNext_GIF+0x2a>

00200ef4 <getBytesGif>:
	decode = priv->decode;
  200ef4:	6943      	ldr	r3, [r0, #20]
static gU16 getBytesGif(gdispImage *img) {
  200ef6:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	decode = priv->decode;
  200efa:	699c      	ldr	r4, [r3, #24]
static gU16 getBytesGif(gdispImage *img) {
  200efc:	4606      	mov	r6, r0
	if (decode->code_last == decode->code_eof)
  200efe:	8a22      	ldrh	r2, [r4, #16]
  200f00:	89a3      	ldrh	r3, [r4, #12]
  200f02:	429a      	cmp	r2, r3
  200f04:	d104      	bne.n	200f10 <getBytesGif+0x1c>
		return 0;
  200f06:	2500      	movs	r5, #0
}
  200f08:	4628      	mov	r0, r5
  200f0a:	b002      	add	sp, #8
  200f0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	cnt = 0;
  200f10:	2500      	movs	r5, #0
			decode->buf[cnt++] = decode->stack[--decode->stackcnt];
  200f12:	f243 083c 	movw	r8, #12348	; 0x303c
	    code = decode->shiftdata & GifBitMask[decode->bitspercode];
  200f16:	4f88      	ldr	r7, [pc, #544]	; (201138 <getBytesGif+0x244>)
		if (decode->stackcnt > 0) {
  200f18:	8923      	ldrh	r3, [r4, #8]
  200f1a:	2b00      	cmp	r3, #0
  200f1c:	d031      	beq.n	200f82 <getBytesGif+0x8e>
			decode->buf[cnt++] = decode->stack[--decode->stackcnt];
  200f1e:	3b01      	subs	r3, #1
  200f20:	1c6a      	adds	r2, r5, #1
  200f22:	4425      	add	r5, r4
  200f24:	b29b      	uxth	r3, r3
  200f26:	8123      	strh	r3, [r4, #8]
  200f28:	4423      	add	r3, r4
  200f2a:	f813 3008 	ldrb.w	r3, [r3, r8]
  200f2e:	772b      	strb	r3, [r5, #28]
  200f30:	b295      	uxth	r5, r2
	while(cnt < sizeof(decode->buf)) {
  200f32:	2d20      	cmp	r5, #32
  200f34:	d1f0      	bne.n	200f18 <getBytesGif+0x24>
  200f36:	e7e7      	b.n	200f08 <getBytesGif+0x14>
	    	if ((!decode->blocksz && (gfileRead(img->f, &decode->blocksz, 1) != 1 || !decode->blocksz))
  200f38:	7823      	ldrb	r3, [r4, #0]
  200f3a:	b153      	cbz	r3, 200f52 <getBytesGif+0x5e>
	    			|| gfileRead(img->f, &bdata, 1) != 1) {
  200f3c:	2201      	movs	r2, #1
  200f3e:	f10d 0107 	add.w	r1, sp, #7
  200f42:	68f0      	ldr	r0, [r6, #12]
  200f44:	f7ff fe15 	bl	200b72 <gfileRead>
  200f48:	2801      	cmp	r0, #1
  200f4a:	d00d      	beq.n	200f68 <getBytesGif+0x74>
			decode->code_last = decode->code_eof;
  200f4c:	89a3      	ldrh	r3, [r4, #12]
  200f4e:	8223      	strh	r3, [r4, #16]
			break;
  200f50:	e7da      	b.n	200f08 <getBytesGif+0x14>
	    	if ((!decode->blocksz && (gfileRead(img->f, &decode->blocksz, 1) != 1 || !decode->blocksz))
  200f52:	2201      	movs	r2, #1
  200f54:	4621      	mov	r1, r4
  200f56:	68f0      	ldr	r0, [r6, #12]
  200f58:	f7ff fe0b 	bl	200b72 <gfileRead>
  200f5c:	2801      	cmp	r0, #1
  200f5e:	d1f5      	bne.n	200f4c <getBytesGif+0x58>
  200f60:	7823      	ldrb	r3, [r4, #0]
  200f62:	2b00      	cmp	r3, #0
  200f64:	d1ea      	bne.n	200f3c <getBytesGif+0x48>
  200f66:	e7f1      	b.n	200f4c <getBytesGif+0x58>
   	    	decode->blocksz--;
  200f68:	7823      	ldrb	r3, [r4, #0]
  200f6a:	3b01      	subs	r3, #1
  200f6c:	7023      	strb	r3, [r4, #0]
	        decode->shiftdata |= ((unsigned long)bdata) << decode->shiftbits;
  200f6e:	7923      	ldrb	r3, [r4, #4]
  200f70:	f89d 2007 	ldrb.w	r2, [sp, #7]
  200f74:	fa02 f103 	lsl.w	r1, r2, r3
  200f78:	6962      	ldr	r2, [r4, #20]
	        decode->shiftbits += 8;
  200f7a:	3308      	adds	r3, #8
	        decode->shiftdata |= ((unsigned long)bdata) << decode->shiftbits;
  200f7c:	430a      	orrs	r2, r1
	        decode->shiftbits += 8;
  200f7e:	7123      	strb	r3, [r4, #4]
	        decode->shiftdata |= ((unsigned long)bdata) << decode->shiftbits;
  200f80:	6162      	str	r2, [r4, #20]
	    while (decode->shiftbits < decode->bitspercode) {
  200f82:	7921      	ldrb	r1, [r4, #4]
  200f84:	78e3      	ldrb	r3, [r4, #3]
  200f86:	4299      	cmp	r1, r3
  200f88:	d3d6      	bcc.n	200f38 <getBytesGif+0x44>
	    decode->shiftbits -= decode->bitspercode;
  200f8a:	1ac9      	subs	r1, r1, r3
	    code = decode->shiftdata & GifBitMask[decode->bitspercode];
  200f8c:	6960      	ldr	r0, [r4, #20]
  200f8e:	f837 2013 	ldrh.w	r2, [r7, r3, lsl #1]
	    decode->shiftbits -= decode->bitspercode;
  200f92:	7121      	strb	r1, [r4, #4]
	    if (decode->code_max < GIF_CODE_MAX + 2 && ++decode->code_max > decode->maxcodesz && decode->bitspercode < GIF_MAX_CODE_BITS) {
  200f94:	89e1      	ldrh	r1, [r4, #14]
	    code = decode->shiftdata & GifBitMask[decode->bitspercode];
  200f96:	4002      	ands	r2, r0
	    decode->shiftdata >>= decode->bitspercode;
  200f98:	40d8      	lsrs	r0, r3
	    if (decode->code_max < GIF_CODE_MAX + 2 && ++decode->code_max > decode->maxcodesz && decode->bitspercode < GIF_MAX_CODE_BITS) {
  200f9a:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
	    decode->shiftdata >>= decode->bitspercode;
  200f9e:	6160      	str	r0, [r4, #20]
	    if (decode->code_max < GIF_CODE_MAX + 2 && ++decode->code_max > decode->maxcodesz && decode->bitspercode < GIF_MAX_CODE_BITS) {
  200fa0:	d80b      	bhi.n	200fba <getBytesGif+0xc6>
  200fa2:	3101      	adds	r1, #1
  200fa4:	88e0      	ldrh	r0, [r4, #6]
  200fa6:	b289      	uxth	r1, r1
  200fa8:	4281      	cmp	r1, r0
  200faa:	81e1      	strh	r1, [r4, #14]
  200fac:	d905      	bls.n	200fba <getBytesGif+0xc6>
  200fae:	2b0b      	cmp	r3, #11
	        decode->maxcodesz <<= 1;
  200fb0:	bf9f      	itttt	ls
  200fb2:	0040      	lslls	r0, r0, #1
	        decode->bitspercode++;
  200fb4:	3301      	addls	r3, #1
	        decode->maxcodesz <<= 1;
  200fb6:	80e0      	strhls	r0, [r4, #6]
	        decode->bitspercode++;
  200fb8:	70e3      	strbls	r3, [r4, #3]
		if (code == decode->code_eof) {
  200fba:	89a3      	ldrh	r3, [r4, #12]
  200fbc:	4293      	cmp	r3, r2
  200fbe:	d113      	bne.n	200fe8 <getBytesGif+0xf4>
				gfileSetPos(img->f, gfileGetPos(img->f)+decode->blocksz);
  200fc0:	68f2      	ldr	r2, [r6, #12]
  200fc2:	4610      	mov	r0, r2
  200fc4:	f7ff fdcc 	bl	200b60 <gfileGetPos>
  200fc8:	7821      	ldrb	r1, [r4, #0]
  200fca:	4401      	add	r1, r0
  200fcc:	4610      	mov	r0, r2
  200fce:	f7ff fdb3 	bl	200b38 <gfileSetPos>
			} while (gfileRead(img->f, &decode->blocksz, 1) == 1 && decode->blocksz);
  200fd2:	2201      	movs	r2, #1
  200fd4:	4621      	mov	r1, r4
  200fd6:	68f0      	ldr	r0, [r6, #12]
  200fd8:	f7ff fdcb 	bl	200b72 <gfileRead>
  200fdc:	2801      	cmp	r0, #1
  200fde:	d1b5      	bne.n	200f4c <getBytesGif+0x58>
  200fe0:	7823      	ldrb	r3, [r4, #0]
  200fe2:	2b00      	cmp	r3, #0
  200fe4:	d1ec      	bne.n	200fc0 <getBytesGif+0xcc>
  200fe6:	e7b1      	b.n	200f4c <getBytesGif+0x58>
		if (code == decode->code_clear) {
  200fe8:	f8b4 e00a 	ldrh.w	lr, [r4, #10]
  200fec:	4596      	cmp	lr, r2
  200fee:	d116      	bne.n	20101e <getBytesGif+0x12a>
  200ff0:	f504 5000 	add.w	r0, r4, #8192	; 0x2000
  200ff4:	f104 023c 	add.w	r2, r4, #60	; 0x3c
				decode->prefix[prefix] = GIF_CODE_NONE;
  200ff8:	f241 0102 	movw	r1, #4098	; 0x1002
  200ffc:	303c      	adds	r0, #60	; 0x3c
  200ffe:	f822 1b02 	strh.w	r1, [r2], #2
			for(prefix = 0; prefix <= GIF_CODE_MAX; prefix++)
  201002:	4290      	cmp	r0, r2
  201004:	d1fb      	bne.n	200ffe <getBytesGif+0x10a>
			decode->code_max = decode->code_eof + 1;
  201006:	3301      	adds	r3, #1
			decode->maxcodesz = 1 << decode->bitspercode;
  201008:	2201      	movs	r2, #1
			decode->code_last = GIF_CODE_NONE;
  20100a:	8221      	strh	r1, [r4, #16]
			decode->code_max = decode->code_eof + 1;
  20100c:	81e3      	strh	r3, [r4, #14]
			decode->bitspercode = decode->bitsperpixel + 1;
  20100e:	78a3      	ldrb	r3, [r4, #2]
  201010:	3301      	adds	r3, #1
  201012:	b2db      	uxtb	r3, r3
  201014:	70e3      	strb	r3, [r4, #3]
			decode->maxcodesz = 1 << decode->bitspercode;
  201016:	fa02 f303 	lsl.w	r3, r2, r3
  20101a:	80e3      	strh	r3, [r4, #6]
			continue;
  20101c:	e789      	b.n	200f32 <getBytesGif+0x3e>
		if (code < decode->code_clear) {
  20101e:	d924      	bls.n	20106a <getBytesGif+0x176>
			decode->buf[cnt++] = code;
  201020:	1c6b      	adds	r3, r5, #1
  201022:	4425      	add	r5, r4
  201024:	772a      	strb	r2, [r5, #28]
  201026:	b29d      	uxth	r5, r3
		if (decode->code_last != GIF_CODE_NONE && decode->prefix[decode->code_max - 2] == GIF_CODE_NONE) {
  201028:	8a23      	ldrh	r3, [r4, #16]
  20102a:	f241 0e02 	movw	lr, #4098	; 0x1002
  20102e:	4573      	cmp	r3, lr
  201030:	d019      	beq.n	201066 <getBytesGif+0x172>
  201032:	89e1      	ldrh	r1, [r4, #14]
  201034:	1e88      	subs	r0, r1, #2
  201036:	eb04 0141 	add.w	r1, r4, r1, lsl #1
  20103a:	f8b1 c038 	ldrh.w	ip, [r1, #56]	; 0x38
  20103e:	45f4      	cmp	ip, lr
  201040:	d111      	bne.n	201066 <getBytesGif+0x172>
			decode->prefix[decode->code_max - 2] = decode->code_last;
  201042:	870b      	strh	r3, [r1, #56]	; 0x38
			decode->suffix[decode->code_max - 2] = getPrefixGif(decode, code == decode->code_max - 2 ? decode->code_last : code);
  201044:	4290      	cmp	r0, r2
  201046:	bf18      	it	ne
  201048:	4613      	movne	r3, r2
	for(i=0; code > decode->code_clear && i <= GIF_CODE_MAX; i++, code = decode->prefix[code]) {
  20104a:	f8b4 e00a 	ldrh.w	lr, [r4, #10]
  20104e:	f241 0101 	movw	r1, #4097	; 0x1001
  201052:	4573      	cmp	r3, lr
  201054:	d903      	bls.n	20105e <getBytesGif+0x16a>
  201056:	3901      	subs	r1, #1
  201058:	b289      	uxth	r1, r1
  20105a:	2900      	cmp	r1, #0
  20105c:	d159      	bne.n	201112 <getBytesGif+0x21e>
			decode->suffix[decode->code_max - 2] = getPrefixGif(decode, code == decode->code_max - 2 ? decode->code_last : code);
  20105e:	4420      	add	r0, r4
  201060:	f242 013c 	movw	r1, #8252	; 0x203c
  201064:	5443      	strb	r3, [r0, r1]
		decode->code_last = code;
  201066:	8222      	strh	r2, [r4, #16]
  201068:	e763      	b.n	200f32 <getBytesGif+0x3e>
			if (decode->prefix[code] != GIF_CODE_NONE)
  20106a:	eb04 0342 	add.w	r3, r4, r2, lsl #1
  20106e:	f8b3 a03c 	ldrh.w	sl, [r3, #60]	; 0x3c
  201072:	f241 0302 	movw	r3, #4098	; 0x1002
  201076:	459a      	cmp	sl, r3
  201078:	d149      	bne.n	20110e <getBytesGif+0x21a>
			else if (code == decode->code_max - 2 && decode->stackcnt < sizeof(decode->stack)) {
  20107a:	89e0      	ldrh	r0, [r4, #14]
  20107c:	3802      	subs	r0, #2
  20107e:	4282      	cmp	r2, r0
  201080:	f47f af41 	bne.w	200f06 <getBytesGif+0x12>
  201084:	f8b4 c008 	ldrh.w	ip, [r4, #8]
  201088:	f5bc 5f80 	cmp.w	ip, #4096	; 0x1000
  20108c:	f4bf af3b 	bcs.w	200f06 <getBytesGif+0x12>
				prefix = decode->code_last;
  201090:	8a23      	ldrh	r3, [r4, #16]
  201092:	f241 0901 	movw	r9, #4097	; 0x1001
  201096:	4619      	mov	r1, r3
	for(i=0; code > decode->code_clear && i <= GIF_CODE_MAX; i++, code = decode->prefix[code]) {
  201098:	458e      	cmp	lr, r1
  20109a:	d206      	bcs.n	2010aa <getBytesGif+0x1b6>
  20109c:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
  2010a0:	fa1f f989 	uxth.w	r9, r9
  2010a4:	f1b9 0f00 	cmp.w	r9, #0
  2010a8:	d128      	bne.n	2010fc <getBytesGif+0x208>
				decode->suffix[decode->code_max - 2] = decode->stack[decode->stackcnt++] = getPrefixGif(decode, decode->code_last);
  2010aa:	f10c 0901 	add.w	r9, ip, #1
  2010ae:	b2c9      	uxtb	r1, r1
  2010b0:	44a4      	add	ip, r4
  2010b2:	4420      	add	r0, r4
  2010b4:	f8a4 9008 	strh.w	r9, [r4, #8]
  2010b8:	f80c 1008 	strb.w	r1, [ip, r8]
  2010bc:	f242 0c3c 	movw	ip, #8252	; 0x203c
  2010c0:	f800 100c 	strb.w	r1, [r0, ip]
				decode->stack[decode->stackcnt++] = decode->suffix[prefix];
  2010c4:	f242 003c 	movw	r0, #8252	; 0x203c
			while (decode->stackcnt < sizeof(decode->stack) && prefix > decode->code_clear && prefix <= GIF_CODE_MAX) {
  2010c8:	8921      	ldrh	r1, [r4, #8]
  2010ca:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
  2010ce:	f4bf af1a 	bcs.w	200f06 <getBytesGif+0x12>
  2010d2:	459e      	cmp	lr, r3
  2010d4:	d226      	bcs.n	201124 <getBytesGif+0x230>
  2010d6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  2010da:	f4bf af14 	bcs.w	200f06 <getBytesGif+0x12>
				decode->stack[decode->stackcnt++] = decode->suffix[prefix];
  2010de:	f101 0c01 	add.w	ip, r1, #1
  2010e2:	4421      	add	r1, r4
  2010e4:	f8a4 c008 	strh.w	ip, [r4, #8]
  2010e8:	eb04 0c03 	add.w	ip, r4, r3
				prefix = decode->prefix[prefix];
  2010ec:	eb04 0343 	add.w	r3, r4, r3, lsl #1
				decode->stack[decode->stackcnt++] = decode->suffix[prefix];
  2010f0:	f81c c000 	ldrb.w	ip, [ip, r0]
  2010f4:	f801 c008 	strb.w	ip, [r1, r8]
				prefix = decode->prefix[prefix];
  2010f8:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  2010fa:	e7e5      	b.n	2010c8 <getBytesGif+0x1d4>
		if (code > GIF_CODE_MAX)
  2010fc:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
  201100:	d203      	bcs.n	20110a <getBytesGif+0x216>
	for(i=0; code > decode->code_clear && i <= GIF_CODE_MAX; i++, code = decode->prefix[code]) {
  201102:	eb04 0141 	add.w	r1, r4, r1, lsl #1
  201106:	8f89      	ldrh	r1, [r1, #60]	; 0x3c
  201108:	e7c6      	b.n	201098 <getBytesGif+0x1a4>
			return GIF_CODE_NONE;
  20110a:	4651      	mov	r1, sl
  20110c:	e7cd      	b.n	2010aa <getBytesGif+0x1b6>
			if (decode->prefix[code] != GIF_CODE_NONE)
  20110e:	4613      	mov	r3, r2
  201110:	e7d8      	b.n	2010c4 <getBytesGif+0x1d0>
		if (code > GIF_CODE_MAX)
  201112:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  201116:	d203      	bcs.n	201120 <getBytesGif+0x22c>
	for(i=0; code > decode->code_clear && i <= GIF_CODE_MAX; i++, code = decode->prefix[code]) {
  201118:	eb04 0343 	add.w	r3, r4, r3, lsl #1
  20111c:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
  20111e:	e798      	b.n	201052 <getBytesGif+0x15e>
			return GIF_CODE_NONE;
  201120:	4663      	mov	r3, ip
  201122:	e79c      	b.n	20105e <getBytesGif+0x16a>
			if (decode->stackcnt >= sizeof(decode->stack) || prefix > GIF_CODE_MAX)
  201124:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  201128:	f4bf aeed 	bcs.w	200f06 <getBytesGif+0x12>
			decode->stack[decode->stackcnt++] = prefix;
  20112c:	1c48      	adds	r0, r1, #1
  20112e:	4421      	add	r1, r4
  201130:	8120      	strh	r0, [r4, #8]
  201132:	f801 3008 	strb.w	r3, [r1, r8]
  201136:	e777      	b.n	201028 <getBytesGif+0x134>
  201138:	0800e408 	.word	0x0800e408

0020113c <gdispImageNext_NATIVE>:
gDelay gdispImageNext_NATIVE(gdispImage *img) {
	(void) img;

	/* No more frames/pages */
	return gDelayForever;
}
  20113c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  201140:	4770      	bx	lr
	...

00201144 <_gdispDeInitDriver>:
}

void _gdispDeInitDriver(GDriver *g) {
	#define		gd		((GDisplay *)g)

	if (GDISP == gd)
  201144:	4a06      	ldr	r2, [pc, #24]	; (201160 <_gdispDeInitDriver+0x1c>)
  201146:	6813      	ldr	r3, [r2, #0]
  201148:	4283      	cmp	r3, r0
  20114a:	d107      	bne.n	20115c <_gdispDeInitDriver+0x18>
	GDriver		*pd;
	unsigned	sinstance;

	// Loop to find the system instance
	sinstance = 0;
	for(pd = dhead; pd; pd = pd->driverchain) {
  20114c:	4b05      	ldr	r3, [pc, #20]	; (201164 <_gdispDeInitDriver+0x20>)
  20114e:	681b      	ldr	r3, [r3, #0]
  201150:	b11b      	cbz	r3, 20115a <_gdispDeInitDriver+0x16>
		if (pd->vmt->type == type) {
  201152:	6859      	ldr	r1, [r3, #4]
  201154:	8809      	ldrh	r1, [r1, #0]
  201156:	2967      	cmp	r1, #103	; 0x67
  201158:	d1f9      	bne.n	20114e <_gdispDeInitDriver+0xa>
		GDISP = (GDisplay *)gdriverGetInstance(GDRIVER_TYPE_DISPLAY, 0);
  20115a:	6013      	str	r3, [r2, #0]
		}
	#endif
	MUTEX_DEINIT(gd);

	#undef gd
}
  20115c:	4770      	bx	lr
  20115e:	bf00      	nop
  201160:	20000810 	.word	0x20000810
  201164:	200018a4 	.word	0x200018a4

00201168 <disk_initialize>:
    BYTE pdrv         /* Physical drive number (0..) */
)
{
  DSTATUS stat;

  switch (pdrv) {
  201168:	b928      	cbnz	r0, 201176 <disk_initialize+0xe>
    return stat;
#else
  case SDC:
    stat = 0;
    /* It is initialized externally, just reads the status.*/
    if (blkGetDriverState(&FATFS_HAL_DEVICE) != BLK_READY)
  20116a:	4b04      	ldr	r3, [pc, #16]	; (20117c <disk_initialize+0x14>)
  20116c:	7918      	ldrb	r0, [r3, #4]
    if (sdcIsWriteProtected(&FATFS_HAL_DEVICE))
      stat |=  STA_PROTECT;
    return stat;
#endif
  }
  return STA_NOINIT;
  20116e:	3805      	subs	r0, #5
  201170:	bf18      	it	ne
  201172:	2001      	movne	r0, #1
  201174:	4770      	bx	lr
  201176:	2001      	movs	r0, #1
}
  201178:	4770      	bx	lr
  20117a:	bf00      	nop
  20117c:	200008ec 	.word	0x200008ec

00201180 <ld_clust.isra.0>:
)
{
	DWORD cl;

	cl = ld_word(dir + DIR_FstClusLO);
	if (fs->fs_type == FS_FAT32) {
  201180:	2803      	cmp	r0, #3
	rv = rv << 8 | ptr[0];
  201182:	7eca      	ldrb	r2, [r1, #27]
  201184:	7e8b      	ldrb	r3, [r1, #26]
  201186:	bf08      	it	eq
  201188:	7d48      	ldrbeq	r0, [r1, #21]
	cl = ld_word(dir + DIR_FstClusLO);
  20118a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	rv = rv << 8 | ptr[0];
  20118e:	bf02      	ittt	eq
  201190:	7d0a      	ldrbeq	r2, [r1, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
  201192:	ea42 2200 	orreq.w	r2, r2, r0, lsl #8
  201196:	ea43 4302 	orreq.w	r3, r3, r2, lsl #16
	}

	return cl;
}
  20119a:	4618      	mov	r0, r3
  20119c:	4770      	bx	lr

0020119e <mem_cpy.part.0>:
static void mem_cpy (void* dst, const void* src, UINT cnt)
  20119e:	3801      	subs	r0, #1
  2011a0:	440a      	add	r2, r1
			*d++ = *s++;
  2011a2:	f811 3b01 	ldrb.w	r3, [r1], #1
		} while (--cnt);
  2011a6:	4291      	cmp	r1, r2
			*d++ = *s++;
  2011a8:	f800 3f01 	strb.w	r3, [r0, #1]!
		} while (--cnt);
  2011ac:	d1f9      	bne.n	2011a2 <mem_cpy.part.0+0x4>
}
  2011ae:	4770      	bx	lr

002011b0 <validate>:

static FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
	FFOBJID* obj,			/* Pointer to the FFOBJID, the 1st member in the FIL/DIR object, to check validity */
	FATFS** rfs				/* Pointer to pointer to the owner filesystem object to return */
)
{
  2011b0:	b508      	push	{r3, lr}
	FRESULT res = FR_INVALID_OBJECT;


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
  2011b2:	b180      	cbz	r0, 2011d6 <validate+0x26>
  2011b4:	6802      	ldr	r2, [r0, #0]
  2011b6:	b17a      	cbz	r2, 2011d8 <validate+0x28>
  2011b8:	7813      	ldrb	r3, [r2, #0]
  2011ba:	b14b      	cbz	r3, 2011d0 <validate+0x20>
  2011bc:	8880      	ldrh	r0, [r0, #4]
  2011be:	88d3      	ldrh	r3, [r2, #6]
  2011c0:	4298      	cmp	r0, r3
  2011c2:	d105      	bne.n	2011d0 <validate+0x20>
			}
		} else {
			res = FR_TIMEOUT;
		}
#else
		if (!(disk_status(obj->fs->pdrv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
  2011c4:	7850      	ldrb	r0, [r2, #1]
  2011c6:	f7ff ffcf 	bl	201168 <disk_initialize>
  2011ca:	f010 0001 	ands.w	r0, r0, #1
  2011ce:	d004      	beq.n	2011da <validate+0x2a>
	FRESULT res = FR_INVALID_OBJECT;
  2011d0:	2009      	movs	r0, #9
			res = FR_OK;
		}
#endif
	}
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
  2011d2:	2200      	movs	r2, #0
  2011d4:	e001      	b.n	2011da <validate+0x2a>
  2011d6:	4602      	mov	r2, r0
	FRESULT res = FR_INVALID_OBJECT;
  2011d8:	2009      	movs	r0, #9
	*rfs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
  2011da:	600a      	str	r2, [r1, #0]
	return res;
}
  2011dc:	bd08      	pop	{r3, pc}

002011de <get_ldnumber>:
	tt = tp = *path;
  2011de:	6802      	ldr	r2, [r0, #0]
	if (!tp) return vol;	/* Invalid path name? */
  2011e0:	b14a      	cbz	r2, 2011f6 <get_ldnumber+0x18>
  2011e2:	4613      	mov	r3, r2
	do tc = *tt++; while ((UINT)tc >= (FF_USE_LFN ? ' ' : '!') && tc != ':');	/* Find a colon in the path */
  2011e4:	f813 1b01 	ldrb.w	r1, [r3], #1
  2011e8:	2920      	cmp	r1, #32
  2011ea:	d90b      	bls.n	201204 <get_ldnumber+0x26>
  2011ec:	293a      	cmp	r1, #58	; 0x3a
  2011ee:	d1f9      	bne.n	2011e4 <get_ldnumber+0x6>
		if (IsDigit(*tp) && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
  2011f0:	1c91      	adds	r1, r2, #2
  2011f2:	428b      	cmp	r3, r1
  2011f4:	d002      	beq.n	2011fc <get_ldnumber+0x1e>
	if (!tp) return vol;	/* Invalid path name? */
  2011f6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  2011fa:	4770      	bx	lr
		if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
  2011fc:	7812      	ldrb	r2, [r2, #0]
  2011fe:	2a30      	cmp	r2, #48	; 0x30
  201200:	d1f9      	bne.n	2011f6 <get_ldnumber+0x18>
			*path = tt;		/* Snip the drive prefix off */
  201202:	6003      	str	r3, [r0, #0]
	return vol;		/* Return the default drive */
  201204:	2000      	movs	r0, #0
  201206:	4770      	bx	lr

00201208 <clmt_clust>:
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
  201208:	6802      	ldr	r2, [r0, #0]
  20120a:	0a49      	lsrs	r1, r1, #9
	tbl = fp->cltbl + 1;	/* Top of CLMT */
  20120c:	6a83      	ldr	r3, [r0, #40]	; 0x28
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
  20120e:	8952      	ldrh	r2, [r2, #10]
	tbl = fp->cltbl + 1;	/* Top of CLMT */
  201210:	3304      	adds	r3, #4
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
  201212:	fbb1 f1f2 	udiv	r1, r1, r2
		ncl = *tbl++;			/* Number of cluters in the fragment */
  201216:	6818      	ldr	r0, [r3, #0]
		if (ncl == 0) return 0;	/* End of table? (error) */
  201218:	b130      	cbz	r0, 201228 <clmt_clust+0x20>
		if (cl < ncl) break;	/* In this fragment? */
  20121a:	4281      	cmp	r1, r0
  20121c:	d302      	bcc.n	201224 <clmt_clust+0x1c>
		cl -= ncl; tbl++;		/* Next fragment */
  20121e:	1a09      	subs	r1, r1, r0
  201220:	3308      	adds	r3, #8
  201222:	e7f8      	b.n	201216 <clmt_clust+0xe>
	return cl + *tbl;	/* Return the cluster number */
  201224:	6858      	ldr	r0, [r3, #4]
  201226:	4408      	add	r0, r1
}
  201228:	4770      	bx	lr

0020122a <clst2sect>:
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
  20122a:	6943      	ldr	r3, [r0, #20]
	clst -= 2;		/* Cluster number is origin from 2 */
  20122c:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
  20122e:	3b02      	subs	r3, #2
  201230:	428b      	cmp	r3, r1
	return fs->database + (LBA_t)fs->csize * clst;	/* Start sector number of the cluster */
  201232:	bf83      	ittte	hi
  201234:	8943      	ldrhhi	r3, [r0, #10]
  201236:	6a80      	ldrhi	r0, [r0, #40]	; 0x28
  201238:	fb01 0003 	mlahi	r0, r1, r3, r0
	if (clst >= fs->n_fatent - 2) return 0;		/* Is it invalid cluster number? */
  20123c:	2000      	movls	r0, #0
}
  20123e:	4770      	bx	lr

00201240 <mem_cmp>:
	int r = 0;
  201240:	4402      	add	r2, r0
{
  201242:	b510      	push	{r4, lr}
		r = *d++ - *s++;
  201244:	f810 3b01 	ldrb.w	r3, [r0], #1
  201248:	f811 4b01 	ldrb.w	r4, [r1], #1
	} while (--cnt && r == 0);
  20124c:	4290      	cmp	r0, r2
		r = *d++ - *s++;
  20124e:	eba3 0304 	sub.w	r3, r3, r4
	} while (--cnt && r == 0);
  201252:	d001      	beq.n	201258 <mem_cmp+0x18>
  201254:	2b00      	cmp	r3, #0
  201256:	d0f5      	beq.n	201244 <mem_cmp+0x4>
}
  201258:	4618      	mov	r0, r3
  20125a:	bd10      	pop	{r4, pc}

0020125c <st_dword>:
	*ptr++ = (BYTE)val; val >>= 8;
  20125c:	0a0b      	lsrs	r3, r1, #8
  20125e:	7001      	strb	r1, [r0, #0]
	*ptr++ = (BYTE)val; val >>= 8;
  201260:	7043      	strb	r3, [r0, #1]
  201262:	0c0b      	lsrs	r3, r1, #16
	*ptr++ = (BYTE)val; val >>= 8;
  201264:	0e09      	lsrs	r1, r1, #24
  201266:	7083      	strb	r3, [r0, #2]
	*ptr++ = (BYTE)val;
  201268:	70c1      	strb	r1, [r0, #3]
}
  20126a:	4770      	bx	lr

0020126c <ld_dword>:
	rv = rv << 8 | ptr[2];
  20126c:	8842      	ldrh	r2, [r0, #2]
	rv = rv << 8 | ptr[1];
  20126e:	7843      	ldrb	r3, [r0, #1]
	rv = rv << 8 | ptr[0];
  201270:	7800      	ldrb	r0, [r0, #0]
	rv = rv << 8 | ptr[1];
  201272:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
}
  201276:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
  20127a:	4770      	bx	lr

0020127c <queue_prio_insert>:
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  20127c:	460b      	mov	r3, r1
static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
  20127e:	b510      	push	{r4, lr}
  do {
    cp = cp->queue.next;
  201280:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  201282:	4299      	cmp	r1, r3
  201284:	d003      	beq.n	20128e <queue_prio_insert+0x12>
  201286:	689c      	ldr	r4, [r3, #8]
  201288:	6882      	ldr	r2, [r0, #8]
  20128a:	4294      	cmp	r4, r2
  20128c:	d2f8      	bcs.n	201280 <queue_prio_insert+0x4>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  20128e:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
  201290:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
  201292:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
  201294:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
  201296:	6058      	str	r0, [r3, #4]
}
  201298:	bd10      	pop	{r4, pc}
	...

0020129c <chTMStopMeasurementX>:
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
  20129c:	4a0e      	ldr	r2, [pc, #56]	; (2012d8 <chTMStopMeasurementX+0x3c>)
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
  20129e:	4b0f      	ldr	r3, [pc, #60]	; (2012dc <chTMStopMeasurementX+0x40>)
  2012a0:	f8d2 187c 	ldr.w	r1, [r2, #2172]	; 0x87c
  tmp->n++;
  2012a4:	68c2      	ldr	r2, [r0, #12]
  2012a6:	685b      	ldr	r3, [r3, #4]
  2012a8:	3201      	adds	r2, #1
  tmp->last = (now - tmp->last) - offset;
  2012aa:	1a5b      	subs	r3, r3, r1
  tmp->n++;
  2012ac:	60c2      	str	r2, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  2012ae:	6882      	ldr	r2, [r0, #8]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
  2012b0:	b530      	push	{r4, r5, lr}
  tmp->last = (now - tmp->last) - offset;
  2012b2:	1a9b      	subs	r3, r3, r2
  if (tmp->last > tmp->worst) {
  2012b4:	6842      	ldr	r2, [r0, #4]
  tmp->cumulative += (rttime_t)tmp->last;
  2012b6:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
  2012ba:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
  2012bc:	18e4      	adds	r4, r4, r3
  2012be:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
  2012c2:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
  2012c4:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
  2012c6:	bf88      	it	hi
  2012c8:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
  2012ca:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
  2012cc:	e9c0 4504 	strd	r4, r5, [r0, #16]
    tmp->best = tmp->last;
  2012d0:	bf38      	it	cc
  2012d2:	6003      	strcc	r3, [r0, #0]
}
  2012d4:	bd30      	pop	{r4, r5, pc}
  2012d6:	bf00      	nop
  2012d8:	20000e8c 	.word	0x20000e8c
  2012dc:	e0001000 	.word	0xe0001000

002012e0 <chTMStartMeasurementX>:
  2012e0:	4b01      	ldr	r3, [pc, #4]	; (2012e8 <chTMStartMeasurementX+0x8>)
  2012e2:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
  2012e4:	6083      	str	r3, [r0, #8]
}
  2012e6:	4770      	bx	lr
  2012e8:	e0001000 	.word	0xe0001000

002012ec <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
  2012ec:	2300      	movs	r3, #0
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  2012ee:	6882      	ldr	r2, [r0, #8]
  tp->state = CH_STATE_READY;
  2012f0:	f880 3020 	strb.w	r3, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
  2012f4:	4b05      	ldr	r3, [pc, #20]	; (20130c <chSchReadyI+0x20>)
    cp = cp->queue.next;
  2012f6:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
  2012f8:	6899      	ldr	r1, [r3, #8]
  2012fa:	4291      	cmp	r1, r2
  2012fc:	d2fb      	bcs.n	2012f6 <chSchReadyI+0xa>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  2012fe:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
  201300:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
  201302:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
  201304:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
  201306:	6058      	str	r0, [r3, #4]

  return tp;
}
  201308:	4770      	bx	lr
  20130a:	bf00      	nop
  20130c:	20000e8c 	.word	0x20000e8c

00201310 <chThdDequeueAllI.constprop.0>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
  201310:	b538      	push	{r3, r4, r5, lr}
  201312:	4604      	mov	r4, r0

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
  201314:	f06f 0501 	mvn.w	r5, #1
  return (bool)(tqp->next != (const thread_t *)tqp);
  201318:	6820      	ldr	r0, [r4, #0]

  while (queue_notempty(tqp)) {
  20131a:	4284      	cmp	r4, r0
  20131c:	d100      	bne.n	201320 <chThdDequeueAllI.constprop.0+0x10>
    chThdDoDequeueNextI(tqp, msg);
  }
}
  20131e:	bd38      	pop	{r3, r4, r5, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
  201320:	6803      	ldr	r3, [r0, #0]
  201322:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  201324:	605c      	str	r4, [r3, #4]
  201326:	6245      	str	r5, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
  201328:	f7ff ffe0 	bl	2012ec <chSchReadyI>
  20132c:	e7f4      	b.n	201318 <chThdDequeueAllI.constprop.0+0x8>

0020132e <chThdResumeI>:
  if (*trp != NULL) {
  20132e:	6803      	ldr	r3, [r0, #0]
  201330:	b12b      	cbz	r3, 20133e <chThdResumeI+0x10>
    *trp = NULL;
  201332:	2200      	movs	r2, #0
  201334:	6002      	str	r2, [r0, #0]
    (void) chSchReadyI(tp);
  201336:	4618      	mov	r0, r3
    tp->u.rdymsg = msg;
  201338:	6259      	str	r1, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
  20133a:	f7ff bfd7 	b.w	2012ec <chSchReadyI>
}
  20133e:	4770      	bx	lr

00201340 <trace_next>:
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
  201340:	4a0a      	ldr	r2, [pc, #40]	; (20136c <trace_next+0x2c>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
  201342:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  201346:	6b53      	ldr	r3, [r2, #52]	; 0x34
  201348:	6a49      	ldr	r1, [r1, #36]	; 0x24
  20134a:	6059      	str	r1, [r3, #4]
  20134c:	4908      	ldr	r1, [pc, #32]	; (201370 <trace_next+0x30>)
  20134e:	6848      	ldr	r0, [r1, #4]
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
  201350:	6819      	ldr	r1, [r3, #0]
  201352:	f360 211f 	bfi	r1, r0, #8, #24
  201356:	f843 1b10 	str.w	r1, [r3], #16
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
  20135a:	f602 0138 	addw	r1, r2, #2104	; 0x838
  20135e:	428b      	cmp	r3, r1
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
  201360:	bf28      	it	cs
  201362:	f102 0338 	addcs.w	r3, r2, #56	; 0x38
  201366:	6353      	str	r3, [r2, #52]	; 0x34
  }
}
  201368:	4770      	bx	lr
  20136a:	bf00      	nop
  20136c:	20000e8c 	.word	0x20000e8c
  201370:	e0001000 	.word	0xe0001000

00201374 <_trace_switch.constprop.0>:
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
  201374:	4908      	ldr	r1, [pc, #32]	; (201398 <_trace_switch.constprop.0+0x24>)
  201376:	8e0b      	ldrh	r3, [r1, #48]	; 0x30
  201378:	07db      	lsls	r3, r3, #31
  20137a:	d40c      	bmi.n	201396 <_trace_switch.constprop.0+0x22>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
  20137c:	f890 3020 	ldrb.w	r3, [r0, #32]
  201380:	6b4a      	ldr	r2, [r1, #52]	; 0x34
  201382:	00db      	lsls	r3, r3, #3
  201384:	f043 0301 	orr.w	r3, r3, #1
  201388:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
  20138a:	698b      	ldr	r3, [r1, #24]
  20138c:	6093      	str	r3, [r2, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
  20138e:	6a43      	ldr	r3, [r0, #36]	; 0x24
  201390:	60d3      	str	r3, [r2, #12]
    trace_next();
  201392:	f7ff bfd5 	b.w	201340 <trace_next>
  }
}
  201396:	4770      	bx	lr
  201398:	20000e8c 	.word	0x20000e8c

0020139c <chSysHalt.constprop.0>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
  20139c:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
  20139e:	b672      	cpsid	i
 *
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
  2013a0:	4c06      	ldr	r4, [pc, #24]	; (2013bc <chSysHalt.constprop.0+0x20>)
  2013a2:	4d07      	ldr	r5, [pc, #28]	; (2013c0 <chSysHalt.constprop.0+0x24>)
  2013a4:	8e23      	ldrh	r3, [r4, #48]	; 0x30
  2013a6:	f013 0f04 	tst.w	r3, #4
  2013aa:	d105      	bne.n	2013b8 <chSysHalt.constprop.0+0x1c>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
  2013ac:	6b63      	ldr	r3, [r4, #52]	; 0x34
  2013ae:	2204      	movs	r2, #4
    ch.dbg.trace_buffer.ptr->state         = 0;
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
  2013b0:	609d      	str	r5, [r3, #8]
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
  2013b2:	701a      	strb	r2, [r3, #0]
    trace_next();
  2013b4:	f7ff ffc4 	bl	201340 <trace_next>

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
  2013b8:	62e5      	str	r5, [r4, #44]	; 0x2c
  2013ba:	e7fe      	b.n	2013ba <chSysHalt.constprop.0+0x1e>
  2013bc:	20000e8c 	.word	0x20000e8c
  2013c0:	0800d8f8 	.word	0x0800d8f8

002013c4 <spi_lld_serve_tx_interrupt>:
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
  2013c4:	f011 0f0c 	tst.w	r1, #12
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
  2013c8:	b508      	push	{r3, lr}
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
  2013ca:	d001      	beq.n	2013d0 <spi_lld_serve_tx_interrupt+0xc>
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
  2013cc:	f7ff ffe6 	bl	20139c <chSysHalt.constprop.0>
  }
#else
  (void)spip;
  (void)flags;
#endif
}
  2013d0:	bd08      	pop	{r3, pc}
	...

002013d4 <chSysPolledDelayX>:
  2013d4:	4b03      	ldr	r3, [pc, #12]	; (2013e4 <chSysPolledDelayX+0x10>)
  2013d6:	6859      	ldr	r1, [r3, #4]
  2013d8:	685a      	ldr	r2, [r3, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)((cnt - start) < (end - start));
  2013da:	1a52      	subs	r2, r2, r1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
  2013dc:	4290      	cmp	r0, r2
  2013de:	d8fb      	bhi.n	2013d8 <chSysPolledDelayX+0x4>
  }
}
  2013e0:	4770      	bx	lr
  2013e2:	bf00      	nop
  2013e4:	e0001000 	.word	0xe0001000

002013e8 <_idle_thread>:
	if (badge_sleep == TRUE)
  2013e8:	4b02      	ldr	r3, [pc, #8]	; (2013f4 <_idle_thread+0xc>)
  2013ea:	781a      	ldrb	r2, [r3, #0]
  2013ec:	2a01      	cmp	r2, #1
  2013ee:	d1fc      	bne.n	2013ea <_idle_thread+0x2>
		__WFI();
  2013f0:	bf30      	wfi
  2013f2:	e7fa      	b.n	2013ea <_idle_thread+0x2>
  2013f4:	20010044 	.word	0x20010044

002013f8 <sdc_lld_is_card_inserted>:
 */
bool sdc_lld_is_card_inserted(SDCDriver *sdcp) {

  (void)sdcp;

  return !palReadPad(GPIOC, GPIOC_SD_DETECT);
  2013f8:	4b03      	ldr	r3, [pc, #12]	; (201408 <sdc_lld_is_card_inserted+0x10>)
  2013fa:	6918      	ldr	r0, [r3, #16]
  2013fc:	f480 5000 	eor.w	r0, r0, #8192	; 0x2000
}
  201400:	f3c0 3040 	ubfx	r0, r0, #13, #1
  201404:	4770      	bx	lr
  201406:	bf00      	nop
  201408:	40020800 	.word	0x40020800

0020140c <gpio_init>:
  gpiop->OTYPER  = config->otyper;
  20140c:	684b      	ldr	r3, [r1, #4]
  20140e:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
  201410:	688b      	ldr	r3, [r1, #8]
  201412:	6083      	str	r3, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
  201414:	68cb      	ldr	r3, [r1, #12]
  201416:	60c3      	str	r3, [r0, #12]
  gpiop->ODR     = config->odr;
  201418:	690b      	ldr	r3, [r1, #16]
  20141a:	6143      	str	r3, [r0, #20]
  gpiop->AFRL    = config->afrl;
  20141c:	694b      	ldr	r3, [r1, #20]
  20141e:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
  201420:	698b      	ldr	r3, [r1, #24]
  201422:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
  201424:	680b      	ldr	r3, [r1, #0]
  201426:	6003      	str	r3, [r0, #0]
}
  201428:	4770      	bx	lr
	...

0020142c <_sdram_wait_ready>:
 *
 * @notapi
 */
static void _sdram_wait_ready(void) {
  /* Wait until the SDRAM controller is ready */
  while (SDRAMD.sdram->SDSR & FMC_SDSR_BUSY);
  20142c:	4b02      	ldr	r3, [pc, #8]	; (201438 <_sdram_wait_ready+0xc>)
  20142e:	685a      	ldr	r2, [r3, #4]
  201430:	6993      	ldr	r3, [r2, #24]
  201432:	069b      	lsls	r3, r3, #26
  201434:	d4fc      	bmi.n	201430 <_sdram_wait_ready+0x4>
}
  201436:	4770      	bx	lr
  201438:	20000940 	.word	0x20000940

0020143c <notify1.lto_priv.0>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
  20143c:	4a02      	ldr	r2, [pc, #8]	; (201448 <notify1.lto_priv.0+0xc>)
  20143e:	6813      	ldr	r3, [r2, #0]
  201440:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
  201444:	6013      	str	r3, [r2, #0]
}
  201446:	4770      	bx	lr
  201448:	40011000 	.word	0x40011000

0020144c <otg_disable_ep>:
static void otg_disable_ep(USBDriver *usbp) {
  20144c:	b530      	push	{r4, r5, lr}
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  20144e:	2200      	movs	r2, #0
  201450:	e9d0 431b 	ldrd	r4, r3, [r0, #108]	; 0x6c
    otgp->ie[i].DIEPCTL = 0;
  201454:	4611      	mov	r1, r2
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  201456:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  20145a:	689d      	ldr	r5, [r3, #8]
    otgp->ie[i].DIEPCTL = 0;
  20145c:	eb04 1342 	add.w	r3, r4, r2, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  201460:	3201      	adds	r2, #1
  201462:	4295      	cmp	r5, r2
    otgp->ie[i].DIEPCTL = 0;
  201464:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
    otgp->ie[i].DIEPTSIZ = 0;
  201468:	f8c3 1910 	str.w	r1, [r3, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  20146c:	f8c3 0908 	str.w	r0, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPCTL = 0;
  201470:	f8c3 1b00 	str.w	r1, [r3, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
  201474:	f8c3 1b10 	str.w	r1, [r3, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  201478:	f8c3 0b08 	str.w	r0, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  20147c:	d2ee      	bcs.n	20145c <otg_disable_ep+0x10>
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
  20147e:	f04f 1301 	mov.w	r3, #65537	; 0x10001
  201482:	f8c4 381c 	str.w	r3, [r4, #2076]	; 0x81c
}
  201486:	bd30      	pop	{r4, r5, pc}

00201488 <i2c_lld_start>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  201488:	6b02      	ldr	r2, [r0, #48]	; 0x30

  /* Make sure I2C peripheral is disabled */
  dp->CR1 &= ~I2C_CR1_PE;
  20148a:	6813      	ldr	r3, [r2, #0]
  20148c:	f023 0301 	bic.w	r3, r3, #1
void i2c_lld_start(I2CDriver *i2cp) {
  201490:	b530      	push	{r4, r5, lr}
  dp->CR1 &= ~I2C_CR1_PE;
  201492:	6013      	str	r3, [r2, #0]

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
  201494:	7801      	ldrb	r1, [r0, #0]
  201496:	2901      	cmp	r1, #1
  201498:	d123      	bne.n	2014e2 <i2c_lld_start+0x5a>
    i2cp->txdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_M2P;
    i2cp->rxdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_P2M;
#endif

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
  20149a:	4b2b      	ldr	r3, [pc, #172]	; (201548 <i2c_lld_start+0xc0>)
  20149c:	4298      	cmp	r0, r3
  20149e:	d12c      	bne.n	2014fa <i2c_lld_start+0x72>

      rccResetI2C1();
  2014a0:	4b2a      	ldr	r3, [pc, #168]	; (20154c <i2c_lld_start+0xc4>)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2014a2:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
  2014a6:	6a1c      	ldr	r4, [r3, #32]
  2014a8:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
  2014ac:	621c      	str	r4, [r3, #32]
  2014ae:	6a1c      	ldr	r4, [r3, #32]
  2014b0:	f424 1400 	bic.w	r4, r4, #2097152	; 0x200000
  2014b4:	621c      	str	r4, [r3, #32]
  2014b6:	6a1c      	ldr	r4, [r3, #32]
      rccEnableI2C1(true);
  2014b8:	6c1c      	ldr	r4, [r3, #64]	; 0x40
  2014ba:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
  2014be:	641c      	str	r4, [r3, #64]	; 0x40
  2014c0:	6e1c      	ldr	r4, [r3, #96]	; 0x60
  2014c2:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
  2014c6:	661c      	str	r4, [r3, #96]	; 0x60
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2014c8:	2450      	movs	r4, #80	; 0x50
  2014ca:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  2014cc:	4b20      	ldr	r3, [pc, #128]	; (201550 <i2c_lld_start+0xc8>)
  2014ce:	f883 431f 	strb.w	r4, [r3, #799]	; 0x31f
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2014d2:	f8c3 5180 	str.w	r5, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  2014d6:	601d      	str	r5, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2014d8:	f883 4320 	strb.w	r4, [r3, #800]	; 0x320
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2014dc:	f8c3 1184 	str.w	r1, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  2014e0:	6059      	str	r1, [r3, #4]
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->RXDR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->TXDR);
#endif

  /* Reset i2c peripheral, the TCIE bit will be handled separately.*/
  dp->CR1 = i2cp->config->cr1 |
  2014e2:	6841      	ldr	r1, [r0, #4]
#if STM32_I2C_USE_DMA == TRUE
            I2C_CR1_TXDMAEN | I2C_CR1_RXDMAEN | /* Enable only if using DMA */
#endif
            I2C_CR1_ERRIE | I2C_CR1_NACKIE;
  2014e4:	684b      	ldr	r3, [r1, #4]
  2014e6:	f043 0390 	orr.w	r3, r3, #144	; 0x90
  dp->CR1 = i2cp->config->cr1 |
  2014ea:	6013      	str	r3, [r2, #0]

  /* Setup I2C parameters.*/
  dp->TIMINGR = i2cp->config->timingr;
  2014ec:	680b      	ldr	r3, [r1, #0]
  2014ee:	6113      	str	r3, [r2, #16]

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
  2014f0:	6813      	ldr	r3, [r2, #0]
  2014f2:	f043 0301 	orr.w	r3, r3, #1
  2014f6:	6013      	str	r3, [r2, #0]
}
  2014f8:	bd30      	pop	{r4, r5, pc}
    if (&I2CD3 == i2cp) {
  2014fa:	4b16      	ldr	r3, [pc, #88]	; (201554 <i2c_lld_start+0xcc>)
  2014fc:	4298      	cmp	r0, r3
  2014fe:	d1f0      	bne.n	2014e2 <i2c_lld_start+0x5a>
      rccResetI2C3();
  201500:	4b12      	ldr	r3, [pc, #72]	; (20154c <i2c_lld_start+0xc4>)
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  201502:	f44f 7480 	mov.w	r4, #256	; 0x100
  201506:	6a19      	ldr	r1, [r3, #32]
  201508:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
  20150c:	6219      	str	r1, [r3, #32]
  20150e:	6a19      	ldr	r1, [r3, #32]
  201510:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
  201514:	6219      	str	r1, [r3, #32]
  201516:	6a19      	ldr	r1, [r3, #32]
      rccEnableI2C3(true);
  201518:	6c19      	ldr	r1, [r3, #64]	; 0x40
  20151a:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
  20151e:	6419      	str	r1, [r3, #64]	; 0x40
  201520:	6e19      	ldr	r1, [r3, #96]	; 0x60
  201522:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
  201526:	6619      	str	r1, [r3, #96]	; 0x60
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  201528:	2150      	movs	r1, #80	; 0x50
  20152a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  20152c:	4b08      	ldr	r3, [pc, #32]	; (201550 <i2c_lld_start+0xc8>)
  20152e:	f883 1348 	strb.w	r1, [r3, #840]	; 0x348
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  201532:	f8c3 4188 	str.w	r4, [r3, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  201536:	609c      	str	r4, [r3, #8]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  201538:	f883 1349 	strb.w	r1, [r3, #841]	; 0x349
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20153c:	f44f 7100 	mov.w	r1, #512	; 0x200
  201540:	f8c3 1188 	str.w	r1, [r3, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  201544:	6099      	str	r1, [r3, #8]
  201546:	e7cc      	b.n	2014e2 <i2c_lld_start+0x5a>
  201548:	20000824 	.word	0x20000824
  20154c:	40023800 	.word	0x40023800
  201550:	e000e100 	.word	0xe000e100
  201554:	20000858 	.word	0x20000858

00201558 <i2c_lld_setup_tx_transfer>:
  I2C_TypeDef *dp = i2cp->i2c;
  201558:	6b01      	ldr	r1, [r0, #48]	; 0x30
  n = i2c_lld_get_txbytes(i2cp);
  20155a:	6a42      	ldr	r2, [r0, #36]	; 0x24
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
  20155c:	684b      	ldr	r3, [r1, #4]
  20155e:	6840      	ldr	r0, [r0, #4]
  if (n > 255U) {
  201560:	2aff      	cmp	r2, #255	; 0xff
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
  201562:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
  201566:	6880      	ldr	r0, [r0, #8]
    n = 255U;
  201568:	bf88      	it	hi
  20156a:	22ff      	movhi	r2, #255	; 0xff
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
  20156c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
static void i2c_lld_setup_tx_transfer(I2CDriver *i2cp) {
  201570:	b510      	push	{r4, lr}
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
  201572:	ea43 0300 	orr.w	r3, r3, r0
    reload = 0U;
  201576:	bf94      	ite	ls
  201578:	2400      	movls	r4, #0
    reload = I2C_CR2_RELOAD;
  20157a:	f04f 7480 	movhi.w	r4, #16777216	; 0x1000000
            (n << 16U) | reload;
  20157e:	4323      	orrs	r3, r4
  201580:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
  201584:	604b      	str	r3, [r1, #4]
}
  201586:	bd10      	pop	{r4, pc}

00201588 <i2c_lld_setup_rx_transfer>:
static void i2c_lld_setup_rx_transfer(I2CDriver *i2cp) {
  201588:	b530      	push	{r4, r5, lr}
  n = i2c_lld_get_rxbytes(i2cp);
  20158a:	e9d0 140b 	ldrd	r1, r4, [r0, #44]	; 0x2c
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
  20158e:	6843      	ldr	r3, [r0, #4]
  if (n > 255U) {
  201590:	29ff      	cmp	r1, #255	; 0xff
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
  201592:	6862      	ldr	r2, [r4, #4]
            I2C_CR2_RD_WRN | (n << 16U) | reload;
  201594:	689b      	ldr	r3, [r3, #8]
    n = 255U;
  201596:	bf88      	it	hi
  201598:	21ff      	movhi	r1, #255	; 0xff
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
  20159a:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
    reload = 0U;
  20159e:	bf94      	ite	ls
  2015a0:	2500      	movls	r5, #0
    reload = I2C_CR2_RELOAD;
  2015a2:	f04f 7580 	movhi.w	r5, #16777216	; 0x1000000
            I2C_CR2_RD_WRN | (n << 16U) | reload;
  2015a6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
  2015aa:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
            I2C_CR2_RD_WRN | (n << 16U) | reload;
  2015ae:	4313      	orrs	r3, r2
  2015b0:	432b      	orrs	r3, r5
  2015b2:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
  2015b6:	6063      	str	r3, [r4, #4]
}
  2015b8:	bd30      	pop	{r4, r5, pc}

002015ba <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  2015ba:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  2015be:	f002 0803 	and.w	r8, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  2015c2:	09d3      	lsrs	r3, r2, #7
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  2015c4:	f3c2 0ec1 	ubfx	lr, r2, #3, #2
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
  2015c8:	f04f 0901 	mov.w	r9, #1
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  2015cc:	4647      	mov	r7, r8
  uint32_t bit     = 0;
  2015ce:	2200      	movs	r2, #0
      m2 = 3 << (bit * 2);
  2015d0:	f04f 0a03 	mov.w	sl, #3
      m4 = 15 << ((bit & 7) * 4);
  2015d4:	f04f 0b0f 	mov.w	fp, #15
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  2015d8:	9301      	str	r3, [sp, #4]
    if ((mask & 1) != 0) {
  2015da:	07cb      	lsls	r3, r1, #31
  2015dc:	d52e      	bpl.n	20163c <_pal_lld_setgroupmode+0x82>
      altrmask = altr << ((bit & 7) * 4);
  2015de:	f002 0307 	and.w	r3, r2, #7
  2015e2:	9c01      	ldr	r4, [sp, #4]
      m1 = 1 << bit;
  2015e4:	fa09 f502 	lsl.w	r5, r9, r2
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
  2015e8:	f1b8 0f02 	cmp.w	r8, #2
      altrmask = altr << ((bit & 7) * 4);
  2015ec:	ea4f 0383 	mov.w	r3, r3, lsl #2
  2015f0:	fa04 fc03 	lsl.w	ip, r4, r3
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
  2015f4:	6844      	ldr	r4, [r0, #4]
      m4 = 15 << ((bit & 7) * 4);
  2015f6:	fa0b f303 	lsl.w	r3, fp, r3
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
  2015fa:	ea24 0405 	bic.w	r4, r4, r5
      m2 = 3 << (bit * 2);
  2015fe:	ea4f 0542 	mov.w	r5, r2, lsl #1
  201602:	ea6f 0303 	mvn.w	r3, r3
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
  201606:	6044      	str	r4, [r0, #4]
      m2 = 3 << (bit * 2);
  201608:	fa0a f505 	lsl.w	r5, sl, r5
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
  20160c:	6886      	ldr	r6, [r0, #8]
  20160e:	ea6f 0405 	mvn.w	r4, r5
  201612:	ea26 0605 	bic.w	r6, r6, r5
  201616:	ea46 060e 	orr.w	r6, r6, lr
  20161a:	6086      	str	r6, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
  20161c:	68c6      	ldr	r6, [r0, #12]
  20161e:	ea26 0505 	bic.w	r5, r6, r5
  201622:	60c5      	str	r5, [r0, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
  201624:	d117      	bne.n	201656 <_pal_lld_setgroupmode+0x9c>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
  201626:	2a07      	cmp	r2, #7
  201628:	d80f      	bhi.n	20164a <_pal_lld_setgroupmode+0x90>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
  20162a:	6a05      	ldr	r5, [r0, #32]
  20162c:	402b      	ands	r3, r5
  20162e:	ea43 030c 	orr.w	r3, r3, ip
  201632:	6203      	str	r3, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
  201634:	6803      	ldr	r3, [r0, #0]
  201636:	401c      	ands	r4, r3
  201638:	433c      	orrs	r4, r7
  20163a:	6004      	str	r4, [r0, #0]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
  20163c:	0849      	lsrs	r1, r1, #1
  20163e:	d01e      	beq.n	20167e <_pal_lld_setgroupmode+0xc4>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
  201640:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
    pupdr <<= 2;
    moder <<= 2;
    bit++;
  201644:	3201      	adds	r2, #1
    moder <<= 2;
  201646:	00bf      	lsls	r7, r7, #2
    bit++;
  201648:	e7c7      	b.n	2015da <_pal_lld_setgroupmode+0x20>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
  20164a:	6a45      	ldr	r5, [r0, #36]	; 0x24
  20164c:	402b      	ands	r3, r5
  20164e:	ea43 030c 	orr.w	r3, r3, ip
  201652:	6243      	str	r3, [r0, #36]	; 0x24
  201654:	e7ee      	b.n	201634 <_pal_lld_setgroupmode+0x7a>
        port->MODER   = (port->MODER & ~m2) | moder;
  201656:	6805      	ldr	r5, [r0, #0]
        if (bit < 8)
  201658:	2a07      	cmp	r2, #7
        port->MODER   = (port->MODER & ~m2) | moder;
  20165a:	ea04 0405 	and.w	r4, r4, r5
  20165e:	ea44 0407 	orr.w	r4, r4, r7
  201662:	6004      	str	r4, [r0, #0]
        if (bit < 8)
  201664:	d805      	bhi.n	201672 <_pal_lld_setgroupmode+0xb8>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
  201666:	6a04      	ldr	r4, [r0, #32]
  201668:	4023      	ands	r3, r4
  20166a:	ea43 030c 	orr.w	r3, r3, ip
  20166e:	6203      	str	r3, [r0, #32]
  201670:	e7e4      	b.n	20163c <_pal_lld_setgroupmode+0x82>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
  201672:	6a44      	ldr	r4, [r0, #36]	; 0x24
  201674:	4023      	ands	r3, r4
  201676:	ea43 030c 	orr.w	r3, r3, ip
  20167a:	6243      	str	r3, [r0, #36]	; 0x24
  20167c:	e7de      	b.n	20163c <_pal_lld_setgroupmode+0x82>
  }
}
  20167e:	b003      	add	sp, #12
  201680:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00201684 <dmaStreamAllocI.part.0>:
 *                      structure.
 * @retval NULL         if a/the stream is not available.
 *
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
  201684:	b5f0      	push	{r4, r5, r6, r7, lr}
    osalDbgCheck(false);
    return NULL;
  }

  for (i = startid; i <= endid; i++) {
    uint32_t mask = (1U << i);
  201686:	2401      	movs	r4, #1
    if ((dma.allocated_mask & mask) == 0U) {
  201688:	4f2e      	ldr	r7, [pc, #184]	; (201744 <dmaStreamAllocI.part.0+0xc0>)
    uint32_t mask = (1U << i);
  20168a:	4084      	lsls	r4, r0
    if ((dma.allocated_mask & mask) == 0U) {
  20168c:	683e      	ldr	r6, [r7, #0]
  20168e:	4234      	tst	r4, r6
  201690:	d156      	bne.n	201740 <dmaStreamAllocI.part.0+0xbc>
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
  201692:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 20174c <dmaStreamAllocI.part.0+0xc8>
  201696:	250c      	movs	r5, #12

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
  201698:	eb07 0ec0 	add.w	lr, r7, r0, lsl #3
      dma.streams[i].param = param;
      dma.allocated_mask  |= mask;
  20169c:	4326      	orrs	r6, r4

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
  20169e:	f014 0fff 	tst.w	r4, #255	; 0xff
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
  2016a2:	fb05 c500 	mla	r5, r5, r0, ip
      dma.allocated_mask  |= mask;
  2016a6:	603e      	str	r6, [r7, #0]
      dma.streams[i].param = param;
  2016a8:	e9ce 2301 	strd	r2, r3, [lr, #4]
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
  2016ac:	4663      	mov	r3, ip
  2016ae:	d009      	beq.n	2016c4 <dmaStreamAllocI.part.0+0x40>
        rccEnableDMA1(true);
  2016b0:	4e25      	ldr	r6, [pc, #148]	; (201748 <dmaStreamAllocI.part.0+0xc4>)
  2016b2:	6b37      	ldr	r7, [r6, #48]	; 0x30
  2016b4:	f447 1700 	orr.w	r7, r7, #2097152	; 0x200000
  2016b8:	6337      	str	r7, [r6, #48]	; 0x30
  2016ba:	6d37      	ldr	r7, [r6, #80]	; 0x50
  2016bc:	f447 1700 	orr.w	r7, r7, #2097152	; 0x200000
  2016c0:	6537      	str	r7, [r6, #80]	; 0x50
  2016c2:	6d36      	ldr	r6, [r6, #80]	; 0x50
      }
      if ((STM32_DMA2_STREAMS_MASK & mask) != 0U) {
  2016c4:	f414 4f7f 	tst.w	r4, #65280	; 0xff00
  2016c8:	d009      	beq.n	2016de <dmaStreamAllocI.part.0+0x5a>
        rccEnableDMA2(true);
  2016ca:	4c1f      	ldr	r4, [pc, #124]	; (201748 <dmaStreamAllocI.part.0+0xc4>)
  2016cc:	6b26      	ldr	r6, [r4, #48]	; 0x30
  2016ce:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
  2016d2:	6326      	str	r6, [r4, #48]	; 0x30
  2016d4:	6d26      	ldr	r6, [r4, #80]	; 0x50
  2016d6:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
  2016da:	6526      	str	r6, [r4, #80]	; 0x50
  2016dc:	6d24      	ldr	r4, [r4, #80]	; 0x50
        rccEnableDMAMUX(true);
      }
#endif

      /* Putting the stream in a safe state.*/
      dmaStreamDisable(dmastp);
  2016de:	240c      	movs	r4, #12
  2016e0:	4344      	muls	r4, r0
  2016e2:	591c      	ldr	r4, [r3, r4]
  2016e4:	6826      	ldr	r6, [r4, #0]
  2016e6:	f026 061f 	bic.w	r6, r6, #31
  2016ea:	6026      	str	r6, [r4, #0]
  2016ec:	6826      	ldr	r6, [r4, #0]
  2016ee:	f016 0601 	ands.w	r6, r6, #1
  2016f2:	d1fb      	bne.n	2016ec <dmaStreamAllocI.part.0+0x68>
  2016f4:	270c      	movs	r7, #12
  2016f6:	fb07 3300 	mla	r3, r7, r0, r3
  2016fa:	203d      	movs	r0, #61	; 0x3d
  2016fc:	f893 c009 	ldrb.w	ip, [r3, #9]
  201700:	685f      	ldr	r7, [r3, #4]
  201702:	fa00 f00c 	lsl.w	r0, r0, ip
  201706:	6038      	str	r0, [r7, #0]
      dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
      dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
  201708:	2021      	movs	r0, #33	; 0x21
      dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  20170a:	6026      	str	r6, [r4, #0]
      dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
  20170c:	6160      	str	r0, [r4, #20]

      /* Enables the associated IRQ vector if a callback is defined.*/
      if (func != NULL) {
  20170e:	b1aa      	cbz	r2, 20173c <dmaStreamAllocI.part.0+0xb8>
        nvicEnableVector(dmastp->vector, priority);
  201710:	7adb      	ldrb	r3, [r3, #11]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  201712:	0109      	lsls	r1, r1, #4
  201714:	f103 4260 	add.w	r2, r3, #3758096384	; 0xe0000000
  201718:	b2c9      	uxtb	r1, r1
  20171a:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
  20171e:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  201722:	f003 011f 	and.w	r1, r3, #31
  201726:	095b      	lsrs	r3, r3, #5
  201728:	2201      	movs	r2, #1
  20172a:	009b      	lsls	r3, r3, #2
  20172c:	408a      	lsls	r2, r1
  20172e:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
  201732:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
  201736:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20173a:	601a      	str	r2, [r3, #0]
      return dmastp;
    }
  }

  return NULL;
}
  20173c:	4628      	mov	r0, r5
  20173e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  return NULL;
  201740:	2500      	movs	r5, #0
  201742:	e7fb      	b.n	20173c <dmaStreamAllocI.part.0+0xb8>
  201744:	200018a8 	.word	0x200018a8
  201748:	40023800 	.word	0x40023800
  20174c:	0800e524 	.word	0x0800e524

00201750 <chSchWakeupS.constprop.0>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  201750:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
  201752:	4e15      	ldr	r6, [pc, #84]	; (2017a8 <chSchWakeupS.constprop.0+0x58>)
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
  201754:	2300      	movs	r3, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
  201756:	6881      	ldr	r1, [r0, #8]
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  201758:	4605      	mov	r5, r0
  thread_t *otp = currp;
  20175a:	69b4      	ldr	r4, [r6, #24]
  ntp->u.rdymsg = msg;
  20175c:	6243      	str	r3, [r0, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
  20175e:	68a2      	ldr	r2, [r4, #8]
  201760:	4291      	cmp	r1, r2
  201762:	d803      	bhi.n	20176c <chSchWakeupS.constprop.0+0x1c>
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
  201764:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    (void) chSchReadyI(ntp);
  201768:	f7ff bdc0 	b.w	2012ec <chSchReadyI>
  tp->state = CH_STATE_READY;
  20176c:	f884 3020 	strb.w	r3, [r4, #32]
  cp = (thread_t *)&ch.rlist.queue;
  201770:	4633      	mov	r3, r6
    cp = cp->queue.next;
  201772:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
  201774:	6899      	ldr	r1, [r3, #8]
  201776:	428a      	cmp	r2, r1
  201778:	d3fb      	bcc.n	201772 <chSchWakeupS.constprop.0+0x22>
  tp->queue.prev             = cp->queue.prev;
  20177a:	685a      	ldr	r2, [r3, #4]
    chSysSwitch(ntp, otp);
  20177c:	4620      	mov	r0, r4
  tp->queue.next             = cp;
  20177e:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  201780:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  201782:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
  201784:	605c      	str	r4, [r3, #4]
    ntp->state = CH_STATE_CURRENT;
  201786:	2301      	movs	r3, #1
    currp = ntp;
  201788:	61b5      	str	r5, [r6, #24]
    ntp->state = CH_STATE_CURRENT;
  20178a:	f885 3020 	strb.w	r3, [r5, #32]
    chSysSwitch(ntp, otp);
  20178e:	f7ff fdf1 	bl	201374 <_trace_switch.constprop.0>
  201792:	4621      	mov	r1, r4
  201794:	4628      	mov	r0, r5
  201796:	f7fe fdc7 	bl	200328 <_port_switch>
  20179a:	4b04      	ldr	r3, [pc, #16]	; (2017ac <chSchWakeupS.constprop.0+0x5c>)
  20179c:	2207      	movs	r2, #7
  20179e:	609a      	str	r2, [r3, #8]
  2017a0:	69b2      	ldr	r2, [r6, #24]
  2017a2:	69d2      	ldr	r2, [r2, #28]
  2017a4:	60da      	str	r2, [r3, #12]
}
  2017a6:	bd70      	pop	{r4, r5, r6, pc}
  2017a8:	20000e8c 	.word	0x20000e8c
  2017ac:	e000ed90 	.word	0xe000ed90

002017b0 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  2017b0:	b513      	push	{r0, r1, r4, lr}
  thread_t *otp = currp;
  2017b2:	4c0e      	ldr	r4, [pc, #56]	; (2017ec <chSchGoSleepS+0x3c>)
  2017b4:	69a1      	ldr	r1, [r4, #24]
  thread_t *tp = tqp->next;
  2017b6:	6823      	ldr	r3, [r4, #0]
  otp->state = newstate;
  2017b8:	f881 0020 	strb.w	r0, [r1, #32]
  chSysSwitch(currp, otp);
  2017bc:	4608      	mov	r0, r1
  tqp->next             = tp->queue.next;
  2017be:	681a      	ldr	r2, [r3, #0]
  2017c0:	9101      	str	r1, [sp, #4]
  tqp->next->queue.prev = (thread_t *)tqp;
  2017c2:	6054      	str	r4, [r2, #4]
  tqp->next             = tp->queue.next;
  2017c4:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
  2017c6:	2201      	movs	r2, #1
  currp = queue_fifo_remove(&ch.rlist.queue);
  2017c8:	61a3      	str	r3, [r4, #24]
  currp->state = CH_STATE_CURRENT;
  2017ca:	f883 2020 	strb.w	r2, [r3, #32]
  chSysSwitch(currp, otp);
  2017ce:	f7ff fdd1 	bl	201374 <_trace_switch.constprop.0>
  2017d2:	9901      	ldr	r1, [sp, #4]
  2017d4:	69a0      	ldr	r0, [r4, #24]
  2017d6:	f7fe fda7 	bl	200328 <_port_switch>
  2017da:	4b05      	ldr	r3, [pc, #20]	; (2017f0 <chSchGoSleepS+0x40>)
  2017dc:	2207      	movs	r2, #7
  2017de:	609a      	str	r2, [r3, #8]
  2017e0:	69a2      	ldr	r2, [r4, #24]
  2017e2:	69d2      	ldr	r2, [r2, #28]
  2017e4:	60da      	str	r2, [r3, #12]
}
  2017e6:	b002      	add	sp, #8
  2017e8:	bd10      	pop	{r4, pc}
  2017ea:	bf00      	nop
  2017ec:	20000e8c 	.word	0x20000e8c
  2017f0:	e000ed90 	.word	0xe000ed90

002017f4 <chSchGoSleepTimeoutS>:
  if (TIME_INFINITE != timeout) {
  2017f4:	1c4b      	adds	r3, r1, #1
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
  2017f6:	b5f0      	push	{r4, r5, r6, r7, lr}
  2017f8:	4606      	mov	r6, r0
  2017fa:	b087      	sub	sp, #28
  2017fc:	4c3a      	ldr	r4, [pc, #232]	; (2018e8 <chSchGoSleepTimeoutS+0xf4>)
  if (TIME_INFINITE != timeout) {
  2017fe:	d06f      	beq.n	2018e0 <chSchGoSleepTimeoutS+0xec>
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  201800:	69a3      	ldr	r3, [r4, #24]
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
  201802:	4625      	mov	r5, r4
  201804:	2902      	cmp	r1, #2
  201806:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  vtp->par = par;
  20180a:	9305      	str	r3, [sp, #20]
  vtp->func = vtfunc;
  20180c:	4b37      	ldr	r3, [pc, #220]	; (2018ec <chSchGoSleepTimeoutS+0xf8>)
  20180e:	bf38      	it	cc
  201810:	2102      	movcc	r1, #2
  201812:	6a42      	ldr	r2, [r0, #36]	; 0x24
  201814:	9304      	str	r3, [sp, #16]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
  201816:	f855 3f1c 	ldr.w	r3, [r5, #28]!
  20181a:	42ab      	cmp	r3, r5
  20181c:	d124      	bne.n	201868 <chSchGoSleepTimeoutS+0x74>

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
  20181e:	ab01      	add	r3, sp, #4
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;
  201820:	9103      	str	r1, [sp, #12]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
  201822:	4411      	add	r1, r2
      ch.vtlist.lasttime = now;
  201824:	62a2      	str	r2, [r4, #40]	; 0x28
      ch.vtlist.prev = vtp;
  201826:	e9c4 3307 	strd	r3, r3, [r4, #28]
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  STM32_ST_TIM->SR     = 0;
  20182a:	2300      	movs	r3, #0
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
  20182c:	e9cd 5501 	strd	r5, r5, [sp, #4]
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  201830:	6341      	str	r1, [r0, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
  201832:	6103      	str	r3, [r0, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
  201834:	2302      	movs	r3, #2
  201836:	60c3      	str	r3, [r0, #12]
    chSchGoSleepS(newstate);
  201838:	4630      	mov	r0, r6
  20183a:	f7ff ffb9 	bl	2017b0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
  20183e:	9b04      	ldr	r3, [sp, #16]
  201840:	b173      	cbz	r3, 201860 <chSchGoSleepTimeoutS+0x6c>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
  201842:	69e1      	ldr	r1, [r4, #28]
  201844:	ab01      	add	r3, sp, #4
  201846:	9a01      	ldr	r2, [sp, #4]
  201848:	4299      	cmp	r1, r3
  20184a:	d02a      	beq.n	2018a2 <chSchGoSleepTimeoutS+0xae>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
  20184c:	9902      	ldr	r1, [sp, #8]
  20184e:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
  201850:	9b01      	ldr	r3, [sp, #4]
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
  201852:	42ab      	cmp	r3, r5
    vtp->next->prev = vtp->prev;
  201854:	6059      	str	r1, [r3, #4]
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
  201856:	d003      	beq.n	201860 <chSchGoSleepTimeoutS+0x6c>
      vtp->next->delta += vtp->delta;
  201858:	689a      	ldr	r2, [r3, #8]
  20185a:	9903      	ldr	r1, [sp, #12]
  20185c:	440a      	add	r2, r1
  20185e:	609a      	str	r2, [r3, #8]
  return currp->u.rdymsg;
  201860:	69a3      	ldr	r3, [r4, #24]
}
  201862:	6a58      	ldr	r0, [r3, #36]	; 0x24
  201864:	b007      	add	sp, #28
  201866:	bdf0      	pop	{r4, r5, r6, r7, pc}
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
  201868:	6aa7      	ldr	r7, [r4, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
  20186a:	1bd2      	subs	r2, r2, r7
  20186c:	1889      	adds	r1, r1, r2
  20186e:	689a      	ldr	r2, [r3, #8]
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
  201870:	d302      	bcc.n	201878 <chSchGoSleepTimeoutS+0x84>
    delta -= p->delta;
  201872:	1a89      	subs	r1, r1, r2
    p = p->next;
  201874:	681b      	ldr	r3, [r3, #0]
  201876:	e003      	b.n	201880 <chSchGoSleepTimeoutS+0x8c>
    else if (delta < p->delta) {
  201878:	4291      	cmp	r1, r2
  20187a:	d201      	bcs.n	201880 <chSchGoSleepTimeoutS+0x8c>
  return systime + (systime_t)interval;
  20187c:	440f      	add	r7, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  20187e:	6347      	str	r7, [r0, #52]	; 0x34
  while (p->delta < delta) {
  201880:	689a      	ldr	r2, [r3, #8]
  201882:	4291      	cmp	r1, r2
  201884:	d8f5      	bhi.n	201872 <chSchGoSleepTimeoutS+0x7e>
  vtp->prev = vtp->next->prev;
  201886:	6858      	ldr	r0, [r3, #4]
  vtp->prev->next = vtp;
  201888:	aa01      	add	r2, sp, #4
  vtp->next = p;
  20188a:	9301      	str	r3, [sp, #4]
  vtp->prev = vtp->next->prev;
  20188c:	9002      	str	r0, [sp, #8]
  vtp->prev->next = vtp;
  20188e:	6002      	str	r2, [r0, #0]
  p->prev = vtp;
  201890:	605a      	str	r2, [r3, #4]
  vtp->delta = delta;
  201892:	9103      	str	r1, [sp, #12]
  p->delta -= delta;
  201894:	689a      	ldr	r2, [r3, #8]
  201896:	1a51      	subs	r1, r2, r1
  201898:	6099      	str	r1, [r3, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
  20189a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  20189e:	6263      	str	r3, [r4, #36]	; 0x24
  2018a0:	e7ca      	b.n	201838 <chSchGoSleepTimeoutS+0x44>
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
  2018a2:	2300      	movs	r3, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
  2018a4:	42aa      	cmp	r2, r5
  ch.vtlist.next = vtp->next;
  2018a6:	61e2      	str	r2, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  2018a8:	6055      	str	r5, [r2, #4]
  vtp->func = NULL;
  2018aa:	9304      	str	r3, [sp, #16]
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
  2018ac:	d103      	bne.n	2018b6 <chSchGoSleepTimeoutS+0xc2>
  STM32_ST_TIM->DIER = 0;
  2018ae:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  2018b2:	60d3      	str	r3, [r2, #12]
    port_timer_stop_alarm();

    return;
  2018b4:	e7d4      	b.n	201860 <chSchGoSleepTimeoutS+0x6c>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
  2018b6:	6893      	ldr	r3, [r2, #8]
  2018b8:	9903      	ldr	r1, [sp, #12]
  2018ba:	440b      	add	r3, r1
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
  2018bc:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  ch.vtlist.next->delta += vtp->delta;
  2018be:	6093      	str	r3, [r2, #8]
  return (systime_t)STM32_ST_TIM->CNT;
  2018c0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  2018c4:	6a52      	ldr	r2, [r2, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
  2018c6:	1a50      	subs	r0, r2, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
  2018c8:	4283      	cmp	r3, r0
  2018ca:	d9c9      	bls.n	201860 <chSchGoSleepTimeoutS+0x6c>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
  2018cc:	1a8a      	subs	r2, r1, r2
  2018ce:	441a      	add	r2, r3

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
  2018d0:	2a01      	cmp	r2, #1
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  2018d2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
  2018d6:	bf98      	it	ls
  2018d8:	1c83      	addls	r3, r0, #2
  return systime + (systime_t)interval;
  2018da:	440b      	add	r3, r1
  2018dc:	6353      	str	r3, [r2, #52]	; 0x34
  2018de:	e7bf      	b.n	201860 <chSchGoSleepTimeoutS+0x6c>
    chSchGoSleepS(newstate);
  2018e0:	f7ff ff66 	bl	2017b0 <chSchGoSleepS>
  2018e4:	e7bc      	b.n	201860 <chSchGoSleepTimeoutS+0x6c>
  2018e6:	bf00      	nop
  2018e8:	20000e8c 	.word	0x20000e8c
  2018ec:	00204901 	.word	0x00204901

002018f0 <chThdExitS>:
void chThdExitS(msg_t msg) {
  2018f0:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
  2018f2:	4b0e      	ldr	r3, [pc, #56]	; (20192c <chThdExitS+0x3c>)
  2018f4:	699c      	ldr	r4, [r3, #24]
  while (list_notempty(&tp->waiting)) {
  2018f6:	f104 0528 	add.w	r5, r4, #40	; 0x28
  tp->u.exitcode = msg;
  2018fa:	6260      	str	r0, [r4, #36]	; 0x24
  return (bool)(tlp->next != (thread_t *)tlp);
  2018fc:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  while (list_notempty(&tp->waiting)) {
  2018fe:	42a8      	cmp	r0, r5
  201900:	d10f      	bne.n	201922 <chThdExitS+0x32>
  if ((tp->refs == (trefs_t)0) &&
  201902:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
  201906:	b93b      	cbnz	r3, 201918 <chThdExitS+0x28>
  201908:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
  20190c:	079b      	lsls	r3, r3, #30
    REG_REMOVE(tp);
  20190e:	bf02      	ittt	eq
  201910:	e9d4 3204 	ldrdeq	r3, r2, [r4, #16]
  201914:	6113      	streq	r3, [r2, #16]
  201916:	615a      	streq	r2, [r3, #20]
  chSchGoSleepS(CH_STATE_FINAL);
  201918:	200f      	movs	r0, #15
}
  20191a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
  20191e:	f7ff bf47 	b.w	2017b0 <chSchGoSleepS>
  tlp->next = tp->queue.next;
  201922:	6803      	ldr	r3, [r0, #0]
  201924:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
  201926:	f7ff fce1 	bl	2012ec <chSchReadyI>
  20192a:	e7e7      	b.n	2018fc <chThdExitS+0xc>
  20192c:	20000e8c 	.word	0x20000e8c

00201930 <dumpFrame>:

static void
dumpFrame (int type, uint32_t lr, EXC_FRAME *p)
{
  201930:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
  201934:	4607      	mov	r7, r0
  201936:	460e      	mov	r6, r1
  201938:	4614      	mov	r4, r2
	int i;

	for (i = 0; i < 32; i++) {
  20193a:	2500      	movs	r5, #0
		if (SCB->CFSR & (1 << i) && exc_msg[i] != NULL)
  20193c:	f8df 8138 	ldr.w	r8, [pc, #312]	; 201a78 <dumpFrame+0x148>
  201940:	f04f 0901 	mov.w	r9, #1
  201944:	f8df a178 	ldr.w	sl, [pc, #376]	; 201ac0 <dumpFrame+0x190>
  201948:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
  20194c:	fa09 f205 	lsl.w	r2, r9, r5
  201950:	421a      	tst	r2, r3
  201952:	d004      	beq.n	20195e <dumpFrame+0x2e>
  201954:	f85a 0025 	ldr.w	r0, [sl, r5, lsl #2]
  201958:	b108      	cbz	r0, 20195e <dumpFrame+0x2e>
			_puts (exc_msg[i]);
  20195a:	f7fe ffa3 	bl	2008a4 <_puts>
	for (i = 0; i < 32; i++) {
  20195e:	3501      	adds	r5, #1
  201960:	2d20      	cmp	r5, #32
  201962:	d1f1      	bne.n	201948 <dumpFrame+0x18>
	}

	if (SCB->HFSR & SCB_HFSR_VECTTBL_Msk)
  201964:	4d44      	ldr	r5, [pc, #272]	; (201a78 <dumpFrame+0x148>)
  201966:	6aea      	ldr	r2, [r5, #44]	; 0x2c
  201968:	0790      	lsls	r0, r2, #30
  20196a:	d502      	bpl.n	201972 <dumpFrame+0x42>
		_puts ("Bus fault on vector table read during exception");
  20196c:	4843      	ldr	r0, [pc, #268]	; (201a7c <dumpFrame+0x14c>)
  20196e:	f7fe ff99 	bl	2008a4 <_puts>

	if (type == HARD_FAULT && SCB->HFSR & SCB_HFSR_FORCED_Msk)
  201972:	b92f      	cbnz	r7, 201980 <dumpFrame+0x50>
  201974:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  201976:	0059      	lsls	r1, r3, #1
  201978:	d502      	bpl.n	201980 <dumpFrame+0x50>
		_puts ("Forced fault due to configurable priority violation");
  20197a:	4841      	ldr	r0, [pc, #260]	; (201a80 <dumpFrame+0x150>)
  20197c:	f7fe ff92 	bl	2008a4 <_puts>

	if (SCB->CFSR & SCB_CFSR_MMARVALID_Msk) {
  201980:	4d3d      	ldr	r5, [pc, #244]	; (201a78 <dumpFrame+0x148>)
  201982:	6aab      	ldr	r3, [r5, #40]	; 0x28
  201984:	061a      	lsls	r2, r3, #24
  201986:	d507      	bpl.n	201998 <dumpFrame+0x68>
		sprintf (exc_msgbuf, "Memory fault address: 0x%08lX",
  201988:	6baa      	ldr	r2, [r5, #56]	; 0x38
  20198a:	493e      	ldr	r1, [pc, #248]	; (201a84 <dumpFrame+0x154>)
  20198c:	483e      	ldr	r0, [pc, #248]	; (201a88 <dumpFrame+0x158>)
  20198e:	f008 fb7f 	bl	20a090 <siprintf>
		    SCB->BFAR);
		_puts (exc_msgbuf);
  201992:	483d      	ldr	r0, [pc, #244]	; (201a88 <dumpFrame+0x158>)
  201994:	f7fe ff86 	bl	2008a4 <_puts>
	}

	if (SCB->CFSR & SCB_CFSR_BFARVALID_Msk) {
  201998:	6aab      	ldr	r3, [r5, #40]	; 0x28
  20199a:	041b      	lsls	r3, r3, #16
  20199c:	d507      	bpl.n	2019ae <dumpFrame+0x7e>
		sprintf (exc_msgbuf, "Bus fault address: 0x%08lX",
  20199e:	6baa      	ldr	r2, [r5, #56]	; 0x38
  2019a0:	493a      	ldr	r1, [pc, #232]	; (201a8c <dumpFrame+0x15c>)
  2019a2:	4839      	ldr	r0, [pc, #228]	; (201a88 <dumpFrame+0x158>)
  2019a4:	f008 fb74 	bl	20a090 <siprintf>
		    SCB->BFAR);
		_puts (exc_msgbuf);
  2019a8:	4837      	ldr	r0, [pc, #220]	; (201a88 <dumpFrame+0x158>)
  2019aa:	f7fe ff7b 	bl	2008a4 <_puts>
	}

	sprintf (exc_msgbuf, "Fault while in %s mode", lr & 0x8 ?
  2019ae:	f016 0f08 	tst.w	r6, #8
  2019b2:	4b37      	ldr	r3, [pc, #220]	; (201a90 <dumpFrame+0x160>)
  2019b4:	4a37      	ldr	r2, [pc, #220]	; (201a94 <dumpFrame+0x164>)
  2019b6:	4938      	ldr	r1, [pc, #224]	; (201a98 <dumpFrame+0x168>)
  2019b8:	bf08      	it	eq
  2019ba:	461a      	moveq	r2, r3
  2019bc:	4832      	ldr	r0, [pc, #200]	; (201a88 <dumpFrame+0x158>)
  2019be:	f008 fb67 	bl	20a090 <siprintf>
	    "thread" : "handler");
	_puts (exc_msgbuf);
  2019c2:	4831      	ldr	r0, [pc, #196]	; (201a88 <dumpFrame+0x158>)
  2019c4:	f7fe ff6e 	bl	2008a4 <_puts>

	sprintf (exc_msgbuf, "Floating point context %ssaved on stack",
  2019c8:	f016 0610 	ands.w	r6, r6, #16
  2019cc:	4b33      	ldr	r3, [pc, #204]	; (201a9c <dumpFrame+0x16c>)
  2019ce:	4a34      	ldr	r2, [pc, #208]	; (201aa0 <dumpFrame+0x170>)
  2019d0:	4934      	ldr	r1, [pc, #208]	; (201aa4 <dumpFrame+0x174>)
  2019d2:	bf08      	it	eq
  2019d4:	461a      	moveq	r2, r3
  2019d6:	482c      	ldr	r0, [pc, #176]	; (201a88 <dumpFrame+0x158>)
	    lr & 0x10 ? "not " : "");
	_puts (exc_msgbuf);

	if (SCB->ICSR & SCB_ICSR_VECTPENDING_Msk) {
  2019d8:	4d27      	ldr	r5, [pc, #156]	; (201a78 <dumpFrame+0x148>)
	sprintf (exc_msgbuf, "Floating point context %ssaved on stack",
  2019da:	f008 fb59 	bl	20a090 <siprintf>
	_puts (exc_msgbuf);
  2019de:	482a      	ldr	r0, [pc, #168]	; (201a88 <dumpFrame+0x158>)
  2019e0:	f7fe ff60 	bl	2008a4 <_puts>
	if (SCB->ICSR & SCB_ICSR_VECTPENDING_Msk) {
  2019e4:	4f30      	ldr	r7, [pc, #192]	; (201aa8 <dumpFrame+0x178>)
  2019e6:	686a      	ldr	r2, [r5, #4]
  2019e8:	423a      	tst	r2, r7
  2019ea:	d006      	beq.n	2019fa <dumpFrame+0xca>
		sprintf (exc_msgbuf, "Interrupt is pending");
  2019ec:	492f      	ldr	r1, [pc, #188]	; (201aac <dumpFrame+0x17c>)
  2019ee:	4826      	ldr	r0, [pc, #152]	; (201a88 <dumpFrame+0x158>)
  2019f0:	f00b feff 	bl	20d7f2 <strcpy>
		_puts (exc_msgbuf);
  2019f4:	4824      	ldr	r0, [pc, #144]	; (201a88 <dumpFrame+0x158>)
  2019f6:	f7fe ff55 	bl	2008a4 <_puts>
	}

	if (SCB->ICSR & SCB_ICSR_VECTPENDING_Msk) {
  2019fa:	686b      	ldr	r3, [r5, #4]
  2019fc:	423b      	tst	r3, r7
  2019fe:	d009      	beq.n	201a14 <dumpFrame+0xe4>
		sprintf (exc_msgbuf, "Exception pending: %ld",
		    (SCB->ICSR & SCB_ICSR_VECTPENDING_Msk) >>
  201a00:	686a      	ldr	r2, [r5, #4]
		sprintf (exc_msgbuf, "Exception pending: %ld",
  201a02:	492b      	ldr	r1, [pc, #172]	; (201ab0 <dumpFrame+0x180>)
  201a04:	f3c2 3208 	ubfx	r2, r2, #12, #9
  201a08:	481f      	ldr	r0, [pc, #124]	; (201a88 <dumpFrame+0x158>)
  201a0a:	f008 fb41 	bl	20a090 <siprintf>
		    SCB_ICSR_VECTPENDING_Pos);
		_puts (exc_msgbuf);
  201a0e:	481e      	ldr	r0, [pc, #120]	; (201a88 <dumpFrame+0x158>)
  201a10:	f7fe ff48 	bl	2008a4 <_puts>
	}

	if (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) {
  201a14:	4a18      	ldr	r2, [pc, #96]	; (201a78 <dumpFrame+0x148>)
  201a16:	6853      	ldr	r3, [r2, #4]
  201a18:	f3c3 0308 	ubfx	r3, r3, #0, #9
  201a1c:	b14b      	cbz	r3, 201a32 <dumpFrame+0x102>
		sprintf (exc_msgbuf, "Exception active: %ld",
		    (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) >>
  201a1e:	6852      	ldr	r2, [r2, #4]
		sprintf (exc_msgbuf, "Exception active: %ld",
  201a20:	4924      	ldr	r1, [pc, #144]	; (201ab4 <dumpFrame+0x184>)
  201a22:	f3c2 0208 	ubfx	r2, r2, #0, #9
  201a26:	4818      	ldr	r0, [pc, #96]	; (201a88 <dumpFrame+0x158>)
  201a28:	f008 fb32 	bl	20a090 <siprintf>
		    SCB_ICSR_VECTACTIVE_Pos);
		_puts (exc_msgbuf);
  201a2c:	4816      	ldr	r0, [pc, #88]	; (201a88 <dumpFrame+0x158>)
  201a2e:	f7fe ff39 	bl	2008a4 <_puts>
	}

	sprintf (exc_msgbuf, "PC: 0x%08lX LR: 0x%08lX "
	    "SP: 0x%08lX SR: 0x%08lX",
	    p->exc_PC, p->exc_LR,
	    (uint32_t)p + (lr & 0x10 ? 32 : sizeof(EXC_FRAME)),
  201a32:	2e00      	cmp	r6, #0
	sprintf (exc_msgbuf, "PC: 0x%08lX LR: 0x%08lX "
  201a34:	69e2      	ldr	r2, [r4, #28]
  201a36:	4920      	ldr	r1, [pc, #128]	; (201ab8 <dumpFrame+0x188>)
	    (uint32_t)p + (lr & 0x10 ? 32 : sizeof(EXC_FRAME)),
  201a38:	bf14      	ite	ne
  201a3a:	2320      	movne	r3, #32
  201a3c:	2368      	moveq	r3, #104	; 0x68
	sprintf (exc_msgbuf, "PC: 0x%08lX LR: 0x%08lX "
  201a3e:	9201      	str	r2, [sp, #4]
  201a40:	4423      	add	r3, r4
  201a42:	4811      	ldr	r0, [pc, #68]	; (201a88 <dumpFrame+0x158>)
  201a44:	9300      	str	r3, [sp, #0]
  201a46:	e9d4 3205 	ldrd	r3, r2, [r4, #20]
  201a4a:	f008 fb21 	bl	20a090 <siprintf>
	    p->exc_xPSR);
	_puts (exc_msgbuf);
  201a4e:	480e      	ldr	r0, [pc, #56]	; (201a88 <dumpFrame+0x158>)
  201a50:	f7fe ff28 	bl	2008a4 <_puts>
	sprintf (exc_msgbuf, "R0: 0x%08lX R1: 0x%08lX "
  201a54:	6923      	ldr	r3, [r4, #16]
  201a56:	4919      	ldr	r1, [pc, #100]	; (201abc <dumpFrame+0x18c>)
  201a58:	9302      	str	r3, [sp, #8]
  201a5a:	68e3      	ldr	r3, [r4, #12]
  201a5c:	480a      	ldr	r0, [pc, #40]	; (201a88 <dumpFrame+0x158>)
  201a5e:	9301      	str	r3, [sp, #4]
  201a60:	68a3      	ldr	r3, [r4, #8]
  201a62:	9300      	str	r3, [sp, #0]
  201a64:	e9d4 2300 	ldrd	r2, r3, [r4]
  201a68:	f008 fb12 	bl	20a090 <siprintf>
	    "R2: 0x%08lX R3: 0x%08lX R12: 0x%08lX",
	    p->exc_R[0], p->exc_R[1], p->exc_R[2], p->exc_R[3], p->exc_R12);
	_puts (exc_msgbuf);
  201a6c:	4806      	ldr	r0, [pc, #24]	; (201a88 <dumpFrame+0x158>)

	return;
}
  201a6e:	b004      	add	sp, #16
  201a70:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	_puts (exc_msgbuf);
  201a74:	f7fe bf16 	b.w	2008a4 <_puts>
  201a78:	e000ed00 	.word	0xe000ed00
  201a7c:	0800d918 	.word	0x0800d918
  201a80:	0800d948 	.word	0x0800d948
  201a84:	0800d97c 	.word	0x0800d97c
  201a88:	20001978 	.word	0x20001978
  201a8c:	0800d99a 	.word	0x0800d99a
  201a90:	0800d90b 	.word	0x0800d90b
  201a94:	0800d904 	.word	0x0800d904
  201a98:	0800d9b5 	.word	0x0800d9b5
  201a9c:	0800dc16 	.word	0x0800dc16
  201aa0:	0800d913 	.word	0x0800d913
  201aa4:	0800d9cc 	.word	0x0800d9cc
  201aa8:	001ff000 	.word	0x001ff000
  201aac:	0800d9f4 	.word	0x0800d9f4
  201ab0:	0800da09 	.word	0x0800da09
  201ab4:	0800da20 	.word	0x0800da20
  201ab8:	0800da36 	.word	0x0800da36
  201abc:	0800da66 	.word	0x0800da66
  201ac0:	0800e6d4 	.word	0x0800e6d4

00201ac4 <cmd_reset>:
static void
cmd_reset(BaseSequentialStream *chp, int argc, char *argv[])
{
	(void)argv;
	(void)chp;
	if (argc > 0) {
  201ac4:	2900      	cmp	r1, #0
  201ac6:	dd02      	ble.n	201ace <cmd_reset+0xa>
		printf ("Usage: reset\r\n");
  201ac8:	4807      	ldr	r0, [pc, #28]	; (201ae8 <cmd_reset+0x24>)
  201aca:	f00b be7d 	b.w	20d7c8 <puts>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
  201ace:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
  201ad2:	4906      	ldr	r1, [pc, #24]	; (201aec <cmd_reset+0x28>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
  201ad4:	4b06      	ldr	r3, [pc, #24]	; (201af0 <cmd_reset+0x2c>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
  201ad6:	68ca      	ldr	r2, [r1, #12]
  201ad8:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
  201adc:	4313      	orrs	r3, r2
  201ade:	60cb      	str	r3, [r1, #12]
  201ae0:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
  201ae4:	bf00      	nop
  201ae6:	e7fd      	b.n	201ae4 <cmd_reset+0x20>
  201ae8:	0800daa3 	.word	0x0800daa3
  201aec:	e000ed00 	.word	0xe000ed00
  201af0:	05fa0004 	.word	0x05fa0004

00201af4 <gdispImageOpen_NATIVE>:
gdispImageError gdispImageOpen_NATIVE(gdispImage *img) {
  201af4:	b537      	push	{r0, r1, r2, r4, r5, lr}
  201af6:	4605      	mov	r5, r0
	if (gfileRead(img->f, hdr, 8) != 8)
  201af8:	2208      	movs	r2, #8
  201afa:	4669      	mov	r1, sp
  201afc:	68c0      	ldr	r0, [r0, #12]
  201afe:	f7ff f838 	bl	200b72 <gfileRead>
  201b02:	2808      	cmp	r0, #8
  201b04:	d130      	bne.n	201b68 <gdispImageOpen_NATIVE+0x74>
	if (hdr[0] != 'N' || hdr[1] != 'I')
  201b06:	f89d 3000 	ldrb.w	r3, [sp]
  201b0a:	2b4e      	cmp	r3, #78	; 0x4e
  201b0c:	d12c      	bne.n	201b68 <gdispImageOpen_NATIVE+0x74>
  201b0e:	f89d 3001 	ldrb.w	r3, [sp, #1]
  201b12:	2b49      	cmp	r3, #73	; 0x49
  201b14:	d128      	bne.n	201b68 <gdispImageOpen_NATIVE+0x74>
	if (hdr[6] != GDISP_PIXELFORMAT/256 || hdr[7] != (GDISP_PIXELFORMAT & 0xFF))
  201b16:	f89d 3006 	ldrb.w	r3, [sp, #6]
  201b1a:	2b25      	cmp	r3, #37	; 0x25
  201b1c:	d127      	bne.n	201b6e <gdispImageOpen_NATIVE+0x7a>
  201b1e:	f89d 3007 	ldrb.w	r3, [sp, #7]
  201b22:	2b65      	cmp	r3, #101	; 0x65
  201b24:	d123      	bne.n	201b6e <gdispImageOpen_NATIVE+0x7a>
	img->width = (((gU16)hdr[2])<<8) | (hdr[3]);
  201b26:	f89d 3002 	ldrb.w	r3, [sp, #2]
	img->flags = 0;
  201b2a:	2400      	movs	r4, #0
	img->width = (((gU16)hdr[2])<<8) | (hdr[3]);
  201b2c:	f89d 2003 	ldrb.w	r2, [sp, #3]
	img->height = (((gU16)hdr[4])<<8) | (hdr[5]);
  201b30:	f89d 1004 	ldrb.w	r1, [sp, #4]
	img->width = (((gU16)hdr[2])<<8) | (hdr[3]);
  201b34:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
	img->height = (((gU16)hdr[4])<<8) | (hdr[5]);
  201b38:	f89d 3005 	ldrb.w	r3, [sp, #5]
	img->flags = 0;
  201b3c:	806c      	strh	r4, [r5, #2]
	img->width = (((gU16)hdr[2])<<8) | (hdr[3]);
  201b3e:	b212      	sxth	r2, r2
	img->height = (((gU16)hdr[4])<<8) | (hdr[5]);
  201b40:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	if (img->width < 1 || img->height < 1)
  201b44:	42a2      	cmp	r2, r4
	img->width = (((gU16)hdr[2])<<8) | (hdr[3]);
  201b46:	80ea      	strh	r2, [r5, #6]
	img->height = (((gU16)hdr[4])<<8) | (hdr[5]);
  201b48:	b21b      	sxth	r3, r3
  201b4a:	812b      	strh	r3, [r5, #8]
	if (img->width < 1 || img->height < 1)
  201b4c:	dd12      	ble.n	201b74 <gdispImageOpen_NATIVE+0x80>
  201b4e:	42a3      	cmp	r3, r4
  201b50:	dd10      	ble.n	201b74 <gdispImageOpen_NATIVE+0x80>
				img->maxmemused = img->memused;
		}
		return ptr;
	#else
		(void) img;
		return gfxAlloc(sz);
  201b52:	2044      	movs	r0, #68	; 0x44
  201b54:	f00a fb5e 	bl	20c214 <malloc>
	if (!(img->priv = gdispImageAlloc(img, sizeof(gdispImagePrivate_NATIVE))))
  201b58:	6168      	str	r0, [r5, #20]
  201b5a:	b170      	cbz	r0, 201b7a <gdispImageOpen_NATIVE+0x86>
	img->type = GDISP_IMAGE_TYPE_NATIVE;
  201b5c:	2301      	movs	r3, #1
	((gdispImagePrivate_NATIVE *)(img->priv))->frame0cache = 0;
  201b5e:	6004      	str	r4, [r0, #0]
	return GDISP_IMAGE_ERR_OK;
  201b60:	4620      	mov	r0, r4
	img->type = GDISP_IMAGE_TYPE_NATIVE;
  201b62:	802b      	strh	r3, [r5, #0]
}
  201b64:	b003      	add	sp, #12
  201b66:	bd30      	pop	{r4, r5, pc}
		return GDISP_IMAGE_ERR_BADFORMAT;		// It can't be us
  201b68:	f248 0001 	movw	r0, #32769	; 0x8001
  201b6c:	e7fa      	b.n	201b64 <gdispImageOpen_NATIVE+0x70>
		return GDISP_IMAGE_ERR_UNSUPPORTED;		// Unsupported pixel format
  201b6e:	f248 0003 	movw	r0, #32771	; 0x8003
  201b72:	e7f7      	b.n	201b64 <gdispImageOpen_NATIVE+0x70>
		return GDISP_IMAGE_ERR_BADDATA;
  201b74:	f248 0002 	movw	r0, #32770	; 0x8002
  201b78:	e7f4      	b.n	201b64 <gdispImageOpen_NATIVE+0x70>
		return GDISP_IMAGE_ERR_NOMEMORY;
  201b7a:	f248 0004 	movw	r0, #32772	; 0x8004
  201b7e:	e7f1      	b.n	201b64 <gdispImageOpen_NATIVE+0x70>

00201b80 <gdispImageCache_NATIVE>:
gdispImageError gdispImageCache_NATIVE(gdispImage *img) {
  201b80:	b570      	push	{r4, r5, r6, lr}
	priv = (gdispImagePrivate_NATIVE *)img->priv;
  201b82:	6946      	ldr	r6, [r0, #20]
gdispImageError gdispImageCache_NATIVE(gdispImage *img) {
  201b84:	4605      	mov	r5, r0
	if (priv->frame0cache)
  201b86:	6833      	ldr	r3, [r6, #0]
  201b88:	b10b      	cbz	r3, 201b8e <gdispImageCache_NATIVE+0xe>
		return GDISP_IMAGE_ERR_OK;
  201b8a:	2000      	movs	r0, #0
}
  201b8c:	bd70      	pop	{r4, r5, r6, pc}
	len = img->width * img->height * sizeof(gPixel);
  201b8e:	88c4      	ldrh	r4, [r0, #6]
  201b90:	8902      	ldrh	r2, [r0, #8]
  201b92:	fb14 f402 	smulbb	r4, r4, r2
  201b96:	0064      	lsls	r4, r4, #1
  201b98:	4620      	mov	r0, r4
  201b9a:	f00a fb3b 	bl	20c214 <malloc>
	priv->frame0cache = (gPixel *)gdispImageAlloc(img, len);
  201b9e:	6030      	str	r0, [r6, #0]
	if (!priv->frame0cache)
  201ba0:	b168      	cbz	r0, 201bbe <gdispImageCache_NATIVE+0x3e>
	gfileSetPos(img->f, FRAME0POS_NATIVE);
  201ba2:	2108      	movs	r1, #8
  201ba4:	68e8      	ldr	r0, [r5, #12]
  201ba6:	f7fe ffc7 	bl	200b38 <gfileSetPos>
	if (gfileRead(img->f, priv->frame0cache, len) != len)
  201baa:	4622      	mov	r2, r4
  201bac:	6831      	ldr	r1, [r6, #0]
  201bae:	68e8      	ldr	r0, [r5, #12]
  201bb0:	f7fe ffdf 	bl	200b72 <gfileRead>
  201bb4:	42a0      	cmp	r0, r4
  201bb6:	d0e8      	beq.n	201b8a <gdispImageCache_NATIVE+0xa>
		return GDISP_IMAGE_ERR_BADDATA;
  201bb8:	f248 0002 	movw	r0, #32770	; 0x8002
  201bbc:	e7e6      	b.n	201b8c <gdispImageCache_NATIVE+0xc>
		return GDISP_IMAGE_ERR_NOMEMORY;
  201bbe:	f248 0004 	movw	r0, #32772	; 0x8004
  201bc2:	e7e3      	b.n	201b8c <gdispImageCache_NATIVE+0xc>

00201bc4 <cmd_cpu>:
	uint32_t pll_sysclk_divisor;

	(void)argv;
	(void)chp;

	if (argc > 0) {
  201bc4:	2900      	cmp	r1, #0
{
  201bc6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (argc > 0) {
  201bc8:	dd04      	ble.n	201bd4 <cmd_cpu+0x10>
		printf ("Usage: cpu\n");
  201bca:	482f      	ldr	r0, [pc, #188]	; (201c88 <cmd_cpu+0xc4>)

		printf ("CPU speed: %ldMHz\n", freq);
	}

	return;
}
  201bcc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			printf ("<unknown>\n");
  201bd0:	f00b bdfa 	b.w	20d7c8 <puts>
	switch (RCC->CFGR & RCC_CFGR_SW_Msk) {
  201bd4:	4c2d      	ldr	r4, [pc, #180]	; (201c8c <cmd_cpu+0xc8>)
	printf ("System clock source is: ");
  201bd6:	482e      	ldr	r0, [pc, #184]	; (201c90 <cmd_cpu+0xcc>)
  201bd8:	f00b fd82 	bl	20d6e0 <iprintf>
	switch (RCC->CFGR & RCC_CFGR_SW_Msk) {
  201bdc:	68a3      	ldr	r3, [r4, #8]
  201bde:	f003 0303 	and.w	r3, r3, #3
  201be2:	2b01      	cmp	r3, #1
  201be4:	d007      	beq.n	201bf6 <cmd_cpu+0x32>
  201be6:	2b02      	cmp	r3, #2
  201be8:	d043      	beq.n	201c72 <cmd_cpu+0xae>
  201bea:	2b00      	cmp	r3, #0
  201bec:	d143      	bne.n	201c76 <cmd_cpu+0xb2>
			printf ("High speed internal 16MHz oscillator\n");
  201bee:	4829      	ldr	r0, [pc, #164]	; (201c94 <cmd_cpu+0xd0>)
			printf ("PLL output\n");
  201bf0:	f00b fdea 	bl	20d7c8 <puts>
			break;
  201bf4:	e003      	b.n	201bfe <cmd_cpu+0x3a>
			printf ("High speed external %luMHz clock\n",
  201bf6:	2119      	movs	r1, #25
  201bf8:	4827      	ldr	r0, [pc, #156]	; (201c98 <cmd_cpu+0xd4>)
  201bfa:	f00b fd71 	bl	20d6e0 <iprintf>
	if ((RCC->CFGR & RCC_CFGR_SW_Msk) == RCC_CFGR_SW_PLL) {
  201bfe:	68a3      	ldr	r3, [r4, #8]
  201c00:	f003 0303 	and.w	r3, r3, #3
  201c04:	2b02      	cmp	r3, #2
  201c06:	d13d      	bne.n	201c84 <cmd_cpu+0xc0>
		printf ("PLL source: ");
  201c08:	4824      	ldr	r0, [pc, #144]	; (201c9c <cmd_cpu+0xd8>)
  201c0a:	f00b fd69 	bl	20d6e0 <iprintf>
		switch (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC_Msk) {
  201c0e:	6863      	ldr	r3, [r4, #4]
  201c10:	025b      	lsls	r3, r3, #9
  201c12:	d532      	bpl.n	201c7a <cmd_cpu+0xb6>
	freq = STM32_HSECLK / 1000000;
  201c14:	2419      	movs	r4, #25
				printf ("High speed external %luMHz clock\n",
  201c16:	2119      	movs	r1, #25
  201c18:	481f      	ldr	r0, [pc, #124]	; (201c98 <cmd_cpu+0xd4>)
  201c1a:	f00b fd61 	bl	20d6e0 <iprintf>
		printf ("PLL configuration: 0x%lX\n", RCC->PLLCFGR);
  201c1e:	4d1b      	ldr	r5, [pc, #108]	; (201c8c <cmd_cpu+0xc8>)
  201c20:	481f      	ldr	r0, [pc, #124]	; (201ca0 <cmd_cpu+0xdc>)
  201c22:	6869      	ldr	r1, [r5, #4]
  201c24:	f00b fd5c 	bl	20d6e0 <iprintf>
		pll_pll_divisor = RCC->PLLCFGR & RCC_PLLCFGR_PLLM_Msk;
  201c28:	686f      	ldr	r7, [r5, #4]
		printf ("PLL input divisor: %ld\n", pll_pll_divisor);
  201c2a:	481e      	ldr	r0, [pc, #120]	; (201ca4 <cmd_cpu+0xe0>)
		pll_pll_divisor = RCC->PLLCFGR & RCC_PLLCFGR_PLLM_Msk;
  201c2c:	f007 073f 	and.w	r7, r7, #63	; 0x3f
		printf ("PLL input divisor: %ld\n", pll_pll_divisor);
  201c30:	4639      	mov	r1, r7
  201c32:	f00b fd55 	bl	20d6e0 <iprintf>
		pll_multiplier = RCC->PLLCFGR & RCC_PLLCFGR_PLLN_Msk;
  201c36:	686e      	ldr	r6, [r5, #4]
		printf ("PLL multiplier: %ld\n", pll_multiplier);
  201c38:	481b      	ldr	r0, [pc, #108]	; (201ca8 <cmd_cpu+0xe4>)
		pll_multiplier >>= RCC_PLLCFGR_PLLN_Pos;
  201c3a:	f3c6 1688 	ubfx	r6, r6, #6, #9
		printf ("PLL multiplier: %ld\n", pll_multiplier);
  201c3e:	4631      	mov	r1, r6
  201c40:	f00b fd4e 	bl	20d6e0 <iprintf>
		pll_sysclk_divisor = RCC->PLLCFGR & RCC_PLLCFGR_PLLP_Msk;
  201c44:	686d      	ldr	r5, [r5, #4]
		printf ("PLL system clock divisor: %ld\n", pll_sysclk_divisor);
  201c46:	4819      	ldr	r0, [pc, #100]	; (201cac <cmd_cpu+0xe8>)
		pll_sysclk_divisor >>= RCC_PLLCFGR_PLLP_Pos;
  201c48:	f3c5 4501 	ubfx	r5, r5, #16, #2
		pll_sysclk_divisor += 1;
  201c4c:	3501      	adds	r5, #1
		pll_sysclk_divisor *= 2;
  201c4e:	006d      	lsls	r5, r5, #1
		printf ("PLL system clock divisor: %ld\n", pll_sysclk_divisor);
  201c50:	4629      	mov	r1, r5
  201c52:	f00b fd45 	bl	20d6e0 <iprintf>
		freq *= 1000000;
  201c56:	4916      	ldr	r1, [pc, #88]	; (201cb0 <cmd_cpu+0xec>)
		printf ("CPU speed: %ldMHz\n", freq);
  201c58:	4816      	ldr	r0, [pc, #88]	; (201cb4 <cmd_cpu+0xf0>)
		freq *= 1000000;
  201c5a:	434c      	muls	r4, r1
		freq /= pll_pll_divisor;
  201c5c:	fbb4 f4f7 	udiv	r4, r4, r7
		freq *= pll_multiplier;
  201c60:	4374      	muls	r4, r6
		freq /= pll_sysclk_divisor;
  201c62:	fbb4 f4f5 	udiv	r4, r4, r5
		printf ("CPU speed: %ldMHz\n", freq);
  201c66:	fbb4 f1f1 	udiv	r1, r4, r1
}
  201c6a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		printf ("CPU speed: %ldMHz\n", freq);
  201c6e:	f00b bd37 	b.w	20d6e0 <iprintf>
			printf ("PLL output\n");
  201c72:	4811      	ldr	r0, [pc, #68]	; (201cb8 <cmd_cpu+0xf4>)
  201c74:	e7bc      	b.n	201bf0 <cmd_cpu+0x2c>
			printf ("<unknown>\n");
  201c76:	4811      	ldr	r0, [pc, #68]	; (201cbc <cmd_cpu+0xf8>)
  201c78:	e7a8      	b.n	201bcc <cmd_cpu+0x8>
				printf ("High speed internal "
  201c7a:	4806      	ldr	r0, [pc, #24]	; (201c94 <cmd_cpu+0xd0>)
				freq = 16;
  201c7c:	2410      	movs	r4, #16
				printf ("High speed internal "
  201c7e:	f00b fda3 	bl	20d7c8 <puts>
				break;
  201c82:	e7cc      	b.n	201c1e <cmd_cpu+0x5a>
}
  201c84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  201c86:	bf00      	nop
  201c88:	0800dab1 	.word	0x0800dab1
  201c8c:	40023800 	.word	0x40023800
  201c90:	0800dabc 	.word	0x0800dabc
  201c94:	0800dad5 	.word	0x0800dad5
  201c98:	0800dafa 	.word	0x0800dafa
  201c9c:	0800db31 	.word	0x0800db31
  201ca0:	0800db3e 	.word	0x0800db3e
  201ca4:	0800db58 	.word	0x0800db58
  201ca8:	0800db70 	.word	0x0800db70
  201cac:	0800db85 	.word	0x0800db85
  201cb0:	000f4240 	.word	0x000f4240
  201cb4:	0800dba4 	.word	0x0800dba4
  201cb8:	0800db1c 	.word	0x0800db1c
  201cbc:	0800db27 	.word	0x0800db27

00201cc0 <cmd_memtest>:
	char * p;
	uint32_t i;

	(void)argv;
	(void)chp;
	if (argc > 0) {
  201cc0:	2900      	cmp	r1, #0
{
  201cc2:	b510      	push	{r4, lr}
	if (argc > 0) {
  201cc4:	dd04      	ble.n	201cd0 <cmd_memtest+0x10>
		printf ("Usage: memtest\n");
  201cc6:	480e      	ldr	r0, [pc, #56]	; (201d00 <cmd_memtest+0x40>)
		}
	}
	free (p);

	return;
}
  201cc8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		printf ("Usage: memtest\n");
  201ccc:	f00b bd7c 	b.w	20d7c8 <puts>
	p = malloc (65536 * 16);
  201cd0:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  201cd4:	f00a fa9e 	bl	20c214 <malloc>
  201cd8:	4604      	mov	r4, r0
	printf ("allocated at %p\n", p);
  201cda:	4601      	mov	r1, r0
  201cdc:	4809      	ldr	r0, [pc, #36]	; (201d04 <cmd_memtest+0x44>)
  201cde:	f00b fcff 	bl	20d6e0 <iprintf>
	for (i = 0; i < (65536 * 16); i++) {
  201ce2:	f504 237f 	add.w	r3, r4, #1044480	; 0xff000
  201ce6:	1e62      	subs	r2, r4, #1
		p[i] = 0xa5;
  201ce8:	21a5      	movs	r1, #165	; 0xa5
  201cea:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
  201cee:	f802 1f01 	strb.w	r1, [r2, #1]!
	for (i = 0; i < (65536 * 16); i++) {
  201cf2:	429a      	cmp	r2, r3
  201cf4:	d1fb      	bne.n	201cee <cmd_memtest+0x2e>
	free (p);
  201cf6:	4620      	mov	r0, r4
}
  201cf8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	free (p);
  201cfc:	f00a ba92 	b.w	20c224 <free>
  201d00:	0800dbb7 	.word	0x0800dbb7
  201d04:	0800dbc6 	.word	0x0800dbc6

00201d08 <gdispImageClose_GIF>:
void gdispImageClose_GIF(gdispImage *img) {
  201d08:	b570      	push	{r4, r5, r6, lr}
	priv = (gdispImagePrivate_GIF *)img->priv;
  201d0a:	6945      	ldr	r5, [r0, #20]
void gdispImageClose_GIF(gdispImage *img) {
  201d0c:	4604      	mov	r4, r0
	if (priv) {
  201d0e:	b155      	cbz	r5, 201d26 <gdispImageClose_GIF+0x1e>
		cache = priv->cache;
  201d10:	6928      	ldr	r0, [r5, #16]
		while(cache) {
  201d12:	b948      	cbnz	r0, 201d28 <gdispImageClose_GIF+0x20>
		if (priv->palette)
  201d14:	68a8      	ldr	r0, [r5, #8]
  201d16:	b108      	cbz	r0, 201d1c <gdispImageClose_GIF+0x14>
		gfxFree(ptr);
		img->memused -= sz;
	#else
		(void) img;
		(void) sz;
		gfxFree(ptr);
  201d18:	f00a fa84 	bl	20c224 <free>
  201d1c:	4628      	mov	r0, r5
  201d1e:	f00a fa81 	bl	20c224 <free>
		img->priv = 0;
  201d22:	2300      	movs	r3, #0
  201d24:	6163      	str	r3, [r4, #20]
}
  201d26:	bd70      	pop	{r4, r5, r6, pc}
			ncache = cache->next;
  201d28:	6a86      	ldr	r6, [r0, #40]	; 0x28
  201d2a:	f00a fa7b 	bl	20c224 <free>
			cache = ncache;
  201d2e:	4630      	mov	r0, r6
  201d30:	e7ef      	b.n	201d12 <gdispImageClose_GIF+0xa>
	...

00201d34 <gdispImageOpen_GIF>:
gdispImageError gdispImageOpen_GIF(gdispImage *img) {
  201d34:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	if (gfileRead(img->f, hdr, 6) != 6)
  201d38:	2206      	movs	r2, #6
gdispImageError gdispImageOpen_GIF(gdispImage *img) {
  201d3a:	4605      	mov	r5, r0
	if (gfileRead(img->f, hdr, 6) != 6)
  201d3c:	4669      	mov	r1, sp
  201d3e:	68c0      	ldr	r0, [r0, #12]
  201d40:	f7fe ff17 	bl	200b72 <gfileRead>
  201d44:	2806      	cmp	r0, #6
  201d46:	f040 8099 	bne.w	201e7c <gdispImageOpen_GIF+0x148>
	if (hdr[0] != 'G' || hdr[1] != 'I' || hdr[2] != 'F'
  201d4a:	f89d 3000 	ldrb.w	r3, [sp]
  201d4e:	2b47      	cmp	r3, #71	; 0x47
  201d50:	f040 8094 	bne.w	201e7c <gdispImageOpen_GIF+0x148>
  201d54:	f89d 3001 	ldrb.w	r3, [sp, #1]
  201d58:	2b49      	cmp	r3, #73	; 0x49
  201d5a:	f040 808f 	bne.w	201e7c <gdispImageOpen_GIF+0x148>
  201d5e:	f89d 3002 	ldrb.w	r3, [sp, #2]
  201d62:	2b46      	cmp	r3, #70	; 0x46
  201d64:	f040 808a 	bne.w	201e7c <gdispImageOpen_GIF+0x148>
			|| hdr[3] != '8' || (hdr[4] != '7' && hdr[4] != '9') || hdr[5] != 'a')
  201d68:	f89d 3003 	ldrb.w	r3, [sp, #3]
  201d6c:	2b38      	cmp	r3, #56	; 0x38
  201d6e:	f040 8085 	bne.w	201e7c <gdispImageOpen_GIF+0x148>
  201d72:	f89d 3004 	ldrb.w	r3, [sp, #4]
  201d76:	2b37      	cmp	r3, #55	; 0x37
  201d78:	d001      	beq.n	201d7e <gdispImageOpen_GIF+0x4a>
  201d7a:	2b39      	cmp	r3, #57	; 0x39
  201d7c:	d17e      	bne.n	201e7c <gdispImageOpen_GIF+0x148>
  201d7e:	f89d 3005 	ldrb.w	r3, [sp, #5]
  201d82:	2b61      	cmp	r3, #97	; 0x61
  201d84:	d17a      	bne.n	201e7c <gdispImageOpen_GIF+0x148>
	img->flags = 0;
  201d86:	2600      	movs	r6, #0
		return gfxAlloc(sz);
  201d88:	2088      	movs	r0, #136	; 0x88
  201d8a:	806e      	strh	r6, [r5, #2]
  201d8c:	f00a fa42 	bl	20c214 <malloc>
  201d90:	4604      	mov	r4, r0
	if (!(img->priv = gdispImageAlloc(img, sizeof(gdispImagePrivate_GIF))))
  201d92:	6168      	str	r0, [r5, #20]
  201d94:	2800      	cmp	r0, #0
  201d96:	d068      	beq.n	201e6a <gdispImageOpen_GIF+0x136>
	if (gfileRead(img->f, priv->buf, 7) != 7)
  201d98:	f100 0746 	add.w	r7, r0, #70	; 0x46
	priv->flags = 0;
  201d9c:	7006      	strb	r6, [r0, #0]
	priv->palsize = 0;
  201d9e:	8086      	strh	r6, [r0, #4]
	if (gfileRead(img->f, priv->buf, 7) != 7)
  201da0:	2207      	movs	r2, #7
	priv->palette = 0;
  201da2:	6086      	str	r6, [r0, #8]
	if (gfileRead(img->f, priv->buf, 7) != 7)
  201da4:	4639      	mov	r1, r7
	priv->frame.flags = 0;
  201da6:	f880 6026 	strb.w	r6, [r0, #38]	; 0x26
	priv->decode = 0;
  201daa:	6186      	str	r6, [r0, #24]
	priv->curcache = 0;
  201dac:	e9c0 6604 	strd	r6, r6, [r0, #16]
	if (gfileRead(img->f, priv->buf, 7) != 7)
  201db0:	68e8      	ldr	r0, [r5, #12]
  201db2:	f7fe fede 	bl	200b72 <gfileRead>
  201db6:	2807      	cmp	r0, #7
  201db8:	d15a      	bne.n	201e70 <gdispImageOpen_GIF+0x13c>
	img->width = gdispImageGetAlignedLE16(priv->buf, 0);
  201dba:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
	if (((gU8 *)priv->buf)[4] & 0x80) {
  201dbe:	f894 004a 	ldrb.w	r0, [r4, #74]	; 0x4a
	img->width = gdispImageGetAlignedLE16(priv->buf, 0);
  201dc2:	80eb      	strh	r3, [r5, #6]
	img->height = gdispImageGetAlignedLE16(priv->buf, 2);
  201dc4:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
  201dc8:	812b      	strh	r3, [r5, #8]
	if (((gU8 *)priv->buf)[4] & 0x80) {
  201dca:	f994 304a 	ldrsb.w	r3, [r4, #74]	; 0x4a
  201dce:	42b3      	cmp	r3, r6
  201dd0:	da2a      	bge.n	201e28 <gdispImageOpen_GIF+0xf4>
		priv->palsize = 2 << (((gU8 *)priv->buf)[4] & 0x07);
  201dd2:	f000 0307 	and.w	r3, r0, #7
  201dd6:	2002      	movs	r0, #2
  201dd8:	4098      	lsls	r0, r3
  201dda:	80a0      	strh	r0, [r4, #4]
  201ddc:	0040      	lsls	r0, r0, #1
  201dde:	f00a fa19 	bl	20c214 <malloc>
		if (!(priv->palette = (gColor *)gdispImageAlloc(img, priv->palsize*sizeof(gColor))))
  201de2:	60a0      	str	r0, [r4, #8]
  201de4:	2800      	cmp	r0, #0
  201de6:	d03d      	beq.n	201e64 <gdispImageOpen_GIF+0x130>
			priv->palette[aword] = RGB2COLOR(((gU8 *)priv->buf)[0], ((gU8 *)priv->buf)[1], ((gU8 *)priv->buf)[2]);
  201de8:	f8df 8098 	ldr.w	r8, [pc, #152]	; 201e84 <gdispImageOpen_GIF+0x150>
			if (gfileRead(img->f, &priv->buf, 3) != 3)
  201dec:	2203      	movs	r2, #3
  201dee:	4639      	mov	r1, r7
  201df0:	68e8      	ldr	r0, [r5, #12]
  201df2:	f7fe febe 	bl	200b72 <gfileRead>
  201df6:	2803      	cmp	r0, #3
  201df8:	d13a      	bne.n	201e70 <gdispImageOpen_GIF+0x13c>
			priv->palette[aword] = RGB2COLOR(((gU8 *)priv->buf)[0], ((gU8 *)priv->buf)[1], ((gU8 *)priv->buf)[2]);
  201dfa:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
  201dfe:	b2b0      	uxth	r0, r6
  201e00:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
  201e04:	3601      	adds	r6, #1
  201e06:	00c9      	lsls	r1, r1, #3
  201e08:	68a2      	ldr	r2, [r4, #8]
  201e0a:	ea08 2303 	and.w	r3, r8, r3, lsl #8
  201e0e:	f401 61fc 	and.w	r1, r1, #2016	; 0x7e0
  201e12:	430b      	orrs	r3, r1
  201e14:	f894 1048 	ldrb.w	r1, [r4, #72]	; 0x48
  201e18:	ea43 03d1 	orr.w	r3, r3, r1, lsr #3
  201e1c:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
		for(aword = 0; aword < priv->palsize; aword++) {
  201e20:	b2b3      	uxth	r3, r6
  201e22:	88a2      	ldrh	r2, [r4, #4]
  201e24:	429a      	cmp	r2, r3
  201e26:	d8e1      	bhi.n	201dec <gdispImageOpen_GIF+0xb8>
	priv->bgcolor = ((gU8 *)priv->buf)[5];
  201e28:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
	priv->frame0pos = gfileGetPos(img->f);
  201e2c:	68e8      	ldr	r0, [r5, #12]
	priv->bgcolor = ((gU8 *)priv->buf)[5];
  201e2e:	7063      	strb	r3, [r4, #1]
	priv->frame0pos = gfileGetPos(img->f);
  201e30:	f7fe fe96 	bl	200b60 <gfileGetPos>
  201e34:	60e0      	str	r0, [r4, #12]
	switch(initFrameGif(img)) {
  201e36:	4628      	mov	r0, r5
  201e38:	f7fe febd 	bl	200bb6 <initFrameGif>
  201e3c:	f248 0303 	movw	r3, #32771	; 0x8003
  201e40:	4604      	mov	r4, r0
  201e42:	4298      	cmp	r0, r3
  201e44:	d00a      	beq.n	201e5c <gdispImageOpen_GIF+0x128>
  201e46:	f248 0304 	movw	r3, #32772	; 0x8004
  201e4a:	4298      	cmp	r0, r3
  201e4c:	d00a      	beq.n	201e64 <gdispImageOpen_GIF+0x130>
  201e4e:	b978      	cbnz	r0, 201e70 <gdispImageOpen_GIF+0x13c>
		img->type = GDISP_IMAGE_TYPE_GIF;
  201e50:	2302      	movs	r3, #2
  201e52:	802b      	strh	r3, [r5, #0]
}
  201e54:	4620      	mov	r0, r4
  201e56:	b002      	add	sp, #8
  201e58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		gdispImageClose_GIF(img);					// Clean up the private data area
  201e5c:	4628      	mov	r0, r5
  201e5e:	f7ff ff53 	bl	201d08 <gdispImageClose_GIF>
		return GDISP_IMAGE_ERR_UNSUPPORTED;
  201e62:	e7f7      	b.n	201e54 <gdispImageOpen_GIF+0x120>
		gdispImageClose_GIF(img);					// Clean up the private data area
  201e64:	4628      	mov	r0, r5
  201e66:	f7ff ff4f 	bl	201d08 <gdispImageClose_GIF>
		return GDISP_IMAGE_ERR_NOMEMORY;
  201e6a:	f248 0404 	movw	r4, #32772	; 0x8004
  201e6e:	e7f1      	b.n	201e54 <gdispImageOpen_GIF+0x120>
		gdispImageClose_GIF(img);					// Clean up the private data area
  201e70:	4628      	mov	r0, r5
		return GDISP_IMAGE_ERR_BADDATA;
  201e72:	f248 0402 	movw	r4, #32770	; 0x8002
		gdispImageClose_GIF(img);					// Clean up the private data area
  201e76:	f7ff ff47 	bl	201d08 <gdispImageClose_GIF>
		return GDISP_IMAGE_ERR_BADDATA;
  201e7a:	e7eb      	b.n	201e54 <gdispImageOpen_GIF+0x120>
		return GDISP_IMAGE_ERR_BADFORMAT;		// It can't be us
  201e7c:	f248 0401 	movw	r4, #32769	; 0x8001
  201e80:	e7e8      	b.n	201e54 <gdispImageOpen_GIF+0x120>
  201e82:	bf00      	nop
  201e84:	fffff800 	.word	0xfffff800

00201e88 <stopDecodeGif>:
static void stopDecodeGif(gdispImage *img) {
  201e88:	b510      	push	{r4, lr}
	priv = (gdispImagePrivate_GIF *)img->priv;
  201e8a:	6944      	ldr	r4, [r0, #20]
	if (priv->decode) {
  201e8c:	69a0      	ldr	r0, [r4, #24]
  201e8e:	b118      	cbz	r0, 201e98 <stopDecodeGif+0x10>
		gfxFree(ptr);
  201e90:	f00a f9c8 	bl	20c224 <free>
		priv->decode = 0;
  201e94:	2300      	movs	r3, #0
  201e96:	61a3      	str	r3, [r4, #24]
}
  201e98:	bd10      	pop	{r4, pc}

00201e9a <startDecodeGif>:
static gdispImageError startDecodeGif(gdispImage *img) {
  201e9a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	priv = (gdispImagePrivate_GIF *)img->priv;
  201e9e:	6945      	ldr	r5, [r0, #20]
static gdispImageError startDecodeGif(gdispImage *img) {
  201ea0:	4607      	mov	r7, r0
	if (!(decode = (gifimgdecode *)gdispImageAlloc(img, sizeof(gifimgdecode)+priv->frame.palsize*sizeof(gColor))))
  201ea2:	8d2e      	ldrh	r6, [r5, #40]	; 0x28
  201ea4:	f506 5000 	add.w	r0, r6, #8192	; 0x2000
  201ea8:	301e      	adds	r0, #30
		return gfxAlloc(sz);
  201eaa:	0040      	lsls	r0, r0, #1
  201eac:	f00a f9b2 	bl	20c214 <malloc>
  201eb0:	4604      	mov	r4, r0
  201eb2:	2800      	cmp	r0, #0
  201eb4:	d06f      	beq.n	201f96 <startDecodeGif+0xfc>
	decode->blocksz = 0;
  201eb6:	f04f 0800 	mov.w	r8, #0
  201eba:	f880 8000 	strb.w	r8, [r0]
	if (priv->frame.palsize) {
  201ebe:	2e00      	cmp	r6, #0
  201ec0:	d05c      	beq.n	201f7c <startDecodeGif+0xe2>
		decode->maxpixel = priv->frame.palsize-1;
  201ec2:	1e73      	subs	r3, r6, #1
			if (gfileRead(img->f, &decode->buf, 3) != 3)
  201ec4:	f104 091c 	add.w	r9, r4, #28
		gfileSetPos(img->f, priv->frame.pospal);
  201ec8:	4646      	mov	r6, r8
			decode->palette[cnt] = RGB2COLOR(decode->buf[0], decode->buf[1], decode->buf[2]);
  201eca:	f5a8 6800 	sub.w	r8, r8, #2048	; 0x800
		decode->maxpixel = priv->frame.palsize-1;
  201ece:	7043      	strb	r3, [r0, #1]
		decode->palette = (gColor *)(decode+1);
  201ed0:	f500 4380 	add.w	r3, r0, #16384	; 0x4000
		gfileSetPos(img->f, priv->frame.pospal);
  201ed4:	6b29      	ldr	r1, [r5, #48]	; 0x30
		decode->palette = (gColor *)(decode+1);
  201ed6:	333c      	adds	r3, #60	; 0x3c
  201ed8:	6183      	str	r3, [r0, #24]
		gfileSetPos(img->f, priv->frame.pospal);
  201eda:	68f8      	ldr	r0, [r7, #12]
  201edc:	f7fe fe2c 	bl	200b38 <gfileSetPos>
		for(cnt = 0; cnt < priv->frame.palsize; cnt++) {
  201ee0:	8d2a      	ldrh	r2, [r5, #40]	; 0x28
  201ee2:	b2b3      	uxth	r3, r6
  201ee4:	68f8      	ldr	r0, [r7, #12]
  201ee6:	429a      	cmp	r2, r3
  201ee8:	d82f      	bhi.n	201f4a <startDecodeGif+0xb0>
	gfileSetPos(img->f, priv->frame.posimg);
  201eea:	6b69      	ldr	r1, [r5, #52]	; 0x34
  201eec:	68f8      	ldr	r0, [r7, #12]
  201eee:	f7fe fe23 	bl	200b38 <gfileSetPos>
	if (gfileRead(img->f, &decode->bitsperpixel, 1) != 1 || decode->bitsperpixel >= GIF_MAX_CODE_BITS)
  201ef2:	2201      	movs	r2, #1
  201ef4:	1ca1      	adds	r1, r4, #2
  201ef6:	68f8      	ldr	r0, [r7, #12]
  201ef8:	f7fe fe3b 	bl	200b72 <gfileRead>
  201efc:	2801      	cmp	r0, #1
  201efe:	d144      	bne.n	201f8a <startDecodeGif+0xf0>
  201f00:	78a3      	ldrb	r3, [r4, #2]
  201f02:	2b0b      	cmp	r3, #11
  201f04:	d841      	bhi.n	201f8a <startDecodeGif+0xf0>
	decode->code_clear = 1 << decode->bitsperpixel;
  201f06:	fa00 f203 	lsl.w	r2, r0, r3
	decode->bitspercode = decode->bitsperpixel+1;
  201f0a:	3301      	adds	r3, #1
  201f0c:	b2db      	uxtb	r3, r3
	decode->code_clear = 1 << decode->bitsperpixel;
  201f0e:	b292      	uxth	r2, r2
	decode->bitspercode = decode->bitsperpixel+1;
  201f10:	70e3      	strb	r3, [r4, #3]
	decode->maxcodesz = 1 << decode->bitspercode;
  201f12:	fa00 f303 	lsl.w	r3, r0, r3
	decode->code_eof = decode->code_clear + 1;
  201f16:	1c51      	adds	r1, r2, #1
	decode->code_clear = 1 << decode->bitsperpixel;
  201f18:	8162      	strh	r2, [r4, #10]
	decode->maxcodesz = 1 << decode->bitspercode;
  201f1a:	80e3      	strh	r3, [r4, #6]
	decode->shiftbits = 0;
  201f1c:	2300      	movs	r3, #0
	decode->code_max = decode->code_clear + 2;
  201f1e:	3202      	adds	r2, #2
	decode->code_eof = decode->code_clear + 1;
  201f20:	81a1      	strh	r1, [r4, #12]
	decode->shiftbits = 0;
  201f22:	7123      	strb	r3, [r4, #4]
  201f24:	f104 013c 	add.w	r1, r4, #60	; 0x3c
	decode->shiftdata = 0;
  201f28:	6163      	str	r3, [r4, #20]
	decode->stackcnt = 0;
  201f2a:	8123      	strh	r3, [r4, #8]
  201f2c:	f504 5300 	add.w	r3, r4, #8192	; 0x2000
	decode->code_max = decode->code_clear + 2;
  201f30:	81e2      	strh	r2, [r4, #14]
	decode->code_last = GIF_CODE_NONE;
  201f32:	f241 0202 	movw	r2, #4098	; 0x1002
  201f36:	333c      	adds	r3, #60	; 0x3c
  201f38:	8222      	strh	r2, [r4, #16]
		decode->prefix[cnt] = GIF_CODE_NONE;
  201f3a:	f821 2b02 	strh.w	r2, [r1], #2
	for(cnt = 0; cnt <= GIF_CODE_MAX; cnt++)
  201f3e:	4299      	cmp	r1, r3
  201f40:	d1fb      	bne.n	201f3a <startDecodeGif+0xa0>
	return GDISP_IMAGE_ERR_OK;
  201f42:	2000      	movs	r0, #0
	priv->decode = decode;
  201f44:	61ac      	str	r4, [r5, #24]
}
  201f46:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (gfileRead(img->f, &decode->buf, 3) != 3)
  201f4a:	2203      	movs	r2, #3
  201f4c:	4649      	mov	r1, r9
  201f4e:	f7fe fe10 	bl	200b72 <gfileRead>
  201f52:	2803      	cmp	r0, #3
  201f54:	f106 0c01 	add.w	ip, r6, #1
  201f58:	d117      	bne.n	201f8a <startDecodeGif+0xf0>
			decode->palette[cnt] = RGB2COLOR(decode->buf[0], decode->buf[1], decode->buf[2]);
  201f5a:	7f61      	ldrb	r1, [r4, #29]
  201f5c:	b2b6      	uxth	r6, r6
  201f5e:	7f23      	ldrb	r3, [r4, #28]
  201f60:	00c9      	lsls	r1, r1, #3
  201f62:	69a2      	ldr	r2, [r4, #24]
  201f64:	ea08 2303 	and.w	r3, r8, r3, lsl #8
  201f68:	f401 61fc 	and.w	r1, r1, #2016	; 0x7e0
  201f6c:	430b      	orrs	r3, r1
  201f6e:	7fa1      	ldrb	r1, [r4, #30]
  201f70:	ea43 03d1 	orr.w	r3, r3, r1, lsr #3
  201f74:	f822 3016 	strh.w	r3, [r2, r6, lsl #1]
  201f78:	4666      	mov	r6, ip
  201f7a:	e7b1      	b.n	201ee0 <startDecodeGif+0x46>
	} else if (priv->palette) {
  201f7c:	68aa      	ldr	r2, [r5, #8]
  201f7e:	b122      	cbz	r2, 201f8a <startDecodeGif+0xf0>
		decode->maxpixel = priv->palsize-1;
  201f80:	792b      	ldrb	r3, [r5, #4]
		decode->palette = priv->palette;
  201f82:	6182      	str	r2, [r0, #24]
		decode->maxpixel = priv->palsize-1;
  201f84:	3b01      	subs	r3, #1
  201f86:	7043      	strb	r3, [r0, #1]
		decode->palette = priv->palette;
  201f88:	e7af      	b.n	201eea <startDecodeGif+0x50>
		gfxFree(ptr);
  201f8a:	4620      	mov	r0, r4
  201f8c:	f00a f94a 	bl	20c224 <free>
	return GDISP_IMAGE_ERR_BADDATA;
  201f90:	f248 0002 	movw	r0, #32770	; 0x8002
  201f94:	e7d7      	b.n	201f46 <startDecodeGif+0xac>
		return GDISP_IMAGE_ERR_NOMEMORY;
  201f96:	f248 0004 	movw	r0, #32772	; 0x8004
  201f9a:	e7d4      	b.n	201f46 <startDecodeGif+0xac>

00201f9c <gdispImageCache_GIF>:
gdispImageError gdispImageCache_GIF(gdispImage *img) {
  201f9c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	priv = (gdispImagePrivate_GIF *)img->priv;
  201fa0:	f8d0 9014 	ldr.w	r9, [r0, #20]
gdispImageError gdispImageCache_GIF(gdispImage *img) {
  201fa4:	4680      	mov	r8, r0
	if (priv->curcache)
  201fa6:	f8d9 6014 	ldr.w	r6, [r9, #20]
  201faa:	2e00      	cmp	r6, #0
  201fac:	f040 81ce 	bne.w	20234c <gdispImageCache_GIF+0x3b0>
	if (!(cache = (gifimgcache *)gdispImageAlloc(img, sizeof(gifimgcache) + priv->frame.palsize*sizeof(gColor) + priv->frame.width*priv->frame.height)))
  201fb0:	f8b9 0028 	ldrh.w	r0, [r9, #40]	; 0x28
  201fb4:	f8b9 3020 	ldrh.w	r3, [r9, #32]
  201fb8:	f8b9 2022 	ldrh.w	r2, [r9, #34]	; 0x22
  201fbc:	3016      	adds	r0, #22
  201fbe:	fb13 f302 	smulbb	r3, r3, r2
		return gfxAlloc(sz);
  201fc2:	eb03 0040 	add.w	r0, r3, r0, lsl #1
  201fc6:	f00a f925 	bl	20c214 <malloc>
  201fca:	4605      	mov	r5, r0
  201fcc:	2800      	cmp	r0, #0
  201fce:	f000 81bf 	beq.w	202350 <gdispImageCache_GIF+0x3b4>
	cache->frame = priv->frame;
  201fd2:	f109 071c 	add.w	r7, r9, #28
  201fd6:	4604      	mov	r4, r0
  201fd8:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
  201fda:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  201fdc:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
  201fe0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	cache->imagebits = (gU8 *)(cache+1) + cache->frame.palsize*sizeof(gColor);
  201fe4:	89ab      	ldrh	r3, [r5, #12]
	switch(startDecodeGif(img)) {
  201fe6:	4640      	mov	r0, r8
	cache->imagebits = (gU8 *)(cache+1) + cache->frame.palsize*sizeof(gColor);
  201fe8:	eb05 0343 	add.w	r3, r5, r3, lsl #1
  201fec:	332c      	adds	r3, #44	; 0x2c
	cache->next = 0;
  201fee:	e9c5 3609 	strd	r3, r6, [r5, #36]	; 0x24
	switch(startDecodeGif(img)) {
  201ff2:	f7ff ff52 	bl	201e9a <startDecodeGif>
  201ff6:	4604      	mov	r4, r0
  201ff8:	b170      	cbz	r0, 202018 <gdispImageCache_GIF+0x7c>
  201ffa:	f248 0304 	movw	r3, #32772	; 0x8004
  201ffe:	4298      	cmp	r0, r3
  202000:	f040 819b 	bne.w	20233a <gdispImageCache_GIF+0x39e>
	stopDecodeGif(img);
  202004:	4640      	mov	r0, r8
  202006:	f7ff ff3f 	bl	201e88 <stopDecodeGif>
		gfxFree(ptr);
  20200a:	4628      	mov	r0, r5
  20200c:	f00a f90a 	bl	20c224 <free>
}
  202010:	4620      	mov	r0, r4
  202012:	b003      	add	sp, #12
  202014:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (cache->frame.palsize) {
  202018:	89ab      	ldrh	r3, [r5, #12]
	decode = priv->decode;
  20201a:	f8d9 7018 	ldr.w	r7, [r9, #24]
	if (cache->frame.palsize) {
  20201e:	b30b      	cbz	r3, 202064 <gdispImageCache_GIF+0xc8>
	cache->imagebits = (gU8 *)(cache+1) + cache->frame.palsize*sizeof(gColor);
  202020:	f105 012c 	add.w	r1, r5, #44	; 0x2c
		cache->palette = (gColor *)(cache+1);
  202024:	4603      	mov	r3, r0
  202026:	6229      	str	r1, [r5, #32]
		for(cnt = 0; cnt < cache->frame.palsize; cnt++)
  202028:	89a8      	ldrh	r0, [r5, #12]
  20202a:	b29a      	uxth	r2, r3
  20202c:	4290      	cmp	r0, r2
  20202e:	d811      	bhi.n	202054 <gdispImageCache_GIF+0xb8>
	if (cache->frame.flags & GIFL_INTERLACE) {
  202030:	f895 a00a 	ldrb.w	sl, [r5, #10]
  202034:	f8d5 b024 	ldr.w	fp, [r5, #36]	; 0x24
  202038:	f01a 0a08 	ands.w	sl, sl, #8
  20203c:	f040 8090 	bne.w	202160 <gdispImageCache_GIF+0x1c4>
		for(my=0; my < cache->frame.height; my++) {
  202040:	f9b5 2006 	ldrsh.w	r2, [r5, #6]
  202044:	fa0f f38a 	sxth.w	r3, sl
  202048:	429a      	cmp	r2, r3
  20204a:	dd69      	ble.n	202120 <gdispImageCache_GIF+0x184>
  20204c:	465a      	mov	r2, fp
					q = decode->buf;
  20204e:	f107 011c 	add.w	r1, r7, #28
  202052:	e156      	b.n	202302 <gdispImageCache_GIF+0x366>
			cache->palette[cnt] = decode->palette[cnt];
  202054:	b298      	uxth	r0, r3
  202056:	69ba      	ldr	r2, [r7, #24]
  202058:	3301      	adds	r3, #1
  20205a:	f832 2010 	ldrh.w	r2, [r2, r0, lsl #1]
  20205e:	f821 2010 	strh.w	r2, [r1, r0, lsl #1]
  202062:	e7e1      	b.n	202028 <gdispImageCache_GIF+0x8c>
		cache->palette = priv->palette;
  202064:	f8d9 3008 	ldr.w	r3, [r9, #8]
  202068:	622b      	str	r3, [r5, #32]
  20206a:	e7e1      	b.n	202030 <gdispImageCache_GIF+0x94>
				if (!cnt) {
  20206c:	b9ec      	cbnz	r4, 2020aa <gdispImageCache_GIF+0x10e>
					if (!(cnt = getBytesGif(img))) {
  20206e:	4640      	mov	r0, r8
  202070:	e9cd 2100 	strd	r2, r1, [sp]
  202074:	f7fe ff3e 	bl	200ef4 <getBytesGif>
  202078:	4604      	mov	r4, r0
  20207a:	e9dd 2100 	ldrd	r2, r1, [sp]
  20207e:	b998      	cbnz	r0, 2020a8 <gdispImageCache_GIF+0x10c>
						if (decode->code_last != decode->code_eof)
  202080:	8a38      	ldrh	r0, [r7, #16]
  202082:	89bb      	ldrh	r3, [r7, #12]
  202084:	4298      	cmp	r0, r3
  202086:	f040 8158 	bne.w	20233a <gdispImageCache_GIF+0x39e>
  20208a:	7aab      	ldrb	r3, [r5, #10]
  20208c:	f107 001c 	add.w	r0, r7, #28
  202090:	f107 063c 	add.w	r6, r7, #60	; 0x3c
  202094:	f003 0301 	and.w	r3, r3, #1
							decode->buf[cnt++] = (cache->frame.flags & GIFL_TRANSPARENT) ? cache->frame.paltrans : 0;
  202098:	2b00      	cmp	r3, #0
  20209a:	d05b      	beq.n	202154 <gdispImageCache_GIF+0x1b8>
  20209c:	7aec      	ldrb	r4, [r5, #11]
  20209e:	f800 4b01 	strb.w	r4, [r0], #1
						while(cnt < sizeof(decode->buf))
  2020a2:	4286      	cmp	r6, r0
  2020a4:	d1f8      	bne.n	202098 <gdispImageCache_GIF+0xfc>
  2020a6:	2420      	movs	r4, #32
					q = decode->buf;
  2020a8:	460e      	mov	r6, r1
				cnt--;
  2020aa:	1e60      	subs	r0, r4, #1
				*p++ = *q++;
  2020ac:	f816 3b01 	ldrb.w	r3, [r6], #1
				cnt--;
  2020b0:	b284      	uxth	r4, r0
				*p++ = *q++;
  2020b2:	f802 3b01 	strb.w	r3, [r2], #1
			for(mx=0; mx < cache->frame.width; mx++) {
  2020b6:	eba2 000b 	sub.w	r0, r2, fp
  2020ba:	f9b5 3004 	ldrsh.w	r3, [r5, #4]
  2020be:	b200      	sxth	r0, r0
  2020c0:	4283      	cmp	r3, r0
  2020c2:	dcd3      	bgt.n	20206c <gdispImageCache_GIF+0xd0>
  2020c4:	f10a 0a08 	add.w	sl, sl, #8
		for(p=cache->imagebits, my=0; my < cache->frame.height; my+=8, p += cache->frame.width*7) {
  2020c8:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
  2020cc:	fa0f fa8a 	sxth.w	sl, sl
  2020d0:	eb02 0b03 	add.w	fp, r2, r3
  2020d4:	f9b5 3006 	ldrsh.w	r3, [r5, #6]
  2020d8:	4553      	cmp	r3, sl
  2020da:	dc3d      	bgt.n	202158 <gdispImageCache_GIF+0x1bc>
		for(p=cache->imagebits+cache->frame.width*4, my=4; my < cache->frame.height; my+=8, p += cache->frame.width*7) {
  2020dc:	f9b5 b004 	ldrsh.w	fp, [r5, #4]
  2020e0:	f04f 0a04 	mov.w	sl, #4
  2020e4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  2020e6:	eb03 0b8b 	add.w	fp, r3, fp, lsl #2
  2020ea:	f9b5 3006 	ldrsh.w	r3, [r5, #6]
  2020ee:	4553      	cmp	r3, sl
  2020f0:	dc6f      	bgt.n	2021d2 <gdispImageCache_GIF+0x236>
		for(p=cache->imagebits+cache->frame.width*2, my=2; my < cache->frame.height; my+=4, p += cache->frame.width*3) {
  2020f2:	f9b5 b004 	ldrsh.w	fp, [r5, #4]
  2020f6:	f04f 0a02 	mov.w	sl, #2
  2020fa:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  2020fc:	eb03 0b4b 	add.w	fp, r3, fp, lsl #1
  202100:	f9b5 3006 	ldrsh.w	r3, [r5, #6]
  202104:	4553      	cmp	r3, sl
  202106:	f300 809e 	bgt.w	202246 <gdispImageCache_GIF+0x2aa>
		for(p=cache->imagebits+cache->frame.width, my=1; my < cache->frame.height; my+=2, p += cache->frame.width) {
  20210a:	f9b5 b004 	ldrsh.w	fp, [r5, #4]
  20210e:	f04f 0a01 	mov.w	sl, #1
  202112:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  202114:	449b      	add	fp, r3
  202116:	f9b5 3006 	ldrsh.w	r3, [r5, #6]
  20211a:	4553      	cmp	r3, sl
  20211c:	f300 80ca 	bgt.w	2022b4 <gdispImageCache_GIF+0x318>
	while(getBytesGif(img));
  202120:	4640      	mov	r0, r8
  202122:	f7fe fee7 	bl	200ef4 <getBytesGif>
  202126:	4604      	mov	r4, r0
  202128:	2800      	cmp	r0, #0
  20212a:	d1f9      	bne.n	202120 <gdispImageCache_GIF+0x184>
	priv->frame.posend = cache->frame.posend = gfileGetPos(img->f);
  20212c:	f8d8 000c 	ldr.w	r0, [r8, #12]
  202130:	f7fe fd16 	bl	200b60 <gfileGetPos>
	if (!priv->cache)
  202134:	f8d9 3010 	ldr.w	r3, [r9, #16]
	priv->frame.posend = cache->frame.posend = gfileGetPos(img->f);
  202138:	61e8      	str	r0, [r5, #28]
  20213a:	f8c9 0038 	str.w	r0, [r9, #56]	; 0x38
	priv->curcache = cache;
  20213e:	f8c9 5014 	str.w	r5, [r9, #20]
	if (!priv->cache)
  202142:	2b00      	cmp	r3, #0
  202144:	f040 80ea 	bne.w	20231c <gdispImageCache_GIF+0x380>
		priv->cache = cache;
  202148:	f8c9 5010 	str.w	r5, [r9, #16]
	stopDecodeGif(img);
  20214c:	4640      	mov	r0, r8
  20214e:	f7ff fe9b 	bl	201e88 <stopDecodeGif>
	return GDISP_IMAGE_ERR_OK;
  202152:	e75d      	b.n	202010 <gdispImageCache_GIF+0x74>
							decode->buf[cnt++] = (cache->frame.flags & GIFL_TRANSPARENT) ? cache->frame.paltrans : 0;
  202154:	461c      	mov	r4, r3
  202156:	e7a2      	b.n	20209e <gdispImageCache_GIF+0x102>
		for(p=cache->imagebits, my=0; my < cache->frame.height; my+=8, p += cache->frame.width*7) {
  202158:	465a      	mov	r2, fp
					q = decode->buf;
  20215a:	f107 011c 	add.w	r1, r7, #28
  20215e:	e7aa      	b.n	2020b6 <gdispImageCache_GIF+0x11a>
		for(p=cache->imagebits, my=0; my < cache->frame.height; my+=8, p += cache->frame.width*7) {
  202160:	f04f 0a00 	mov.w	sl, #0
  202164:	e7b6      	b.n	2020d4 <gdispImageCache_GIF+0x138>
				if (!cnt) {
  202166:	b9e4      	cbnz	r4, 2021a2 <gdispImageCache_GIF+0x206>
					if (!(cnt = getBytesGif(img))) {
  202168:	4640      	mov	r0, r8
  20216a:	e9cd 2100 	strd	r2, r1, [sp]
  20216e:	f7fe fec1 	bl	200ef4 <getBytesGif>
  202172:	4604      	mov	r4, r0
  202174:	e9dd 2100 	ldrd	r2, r1, [sp]
  202178:	b990      	cbnz	r0, 2021a0 <gdispImageCache_GIF+0x204>
						if (decode->code_last != decode->code_eof)
  20217a:	8a38      	ldrh	r0, [r7, #16]
  20217c:	89bb      	ldrh	r3, [r7, #12]
  20217e:	4298      	cmp	r0, r3
  202180:	f040 80db 	bne.w	20233a <gdispImageCache_GIF+0x39e>
  202184:	7aab      	ldrb	r3, [r5, #10]
  202186:	f107 001c 	add.w	r0, r7, #28
  20218a:	f107 063c 	add.w	r6, r7, #60	; 0x3c
  20218e:	f003 0301 	and.w	r3, r3, #1
							decode->buf[cnt++] = (cache->frame.flags & GIFL_TRANSPARENT) ? cache->frame.paltrans : 0;
  202192:	b1e3      	cbz	r3, 2021ce <gdispImageCache_GIF+0x232>
  202194:	7aec      	ldrb	r4, [r5, #11]
  202196:	f800 4b01 	strb.w	r4, [r0], #1
						while(cnt < sizeof(decode->buf))
  20219a:	42b0      	cmp	r0, r6
  20219c:	d1f9      	bne.n	202192 <gdispImageCache_GIF+0x1f6>
  20219e:	2420      	movs	r4, #32
					q = decode->buf;
  2021a0:	460e      	mov	r6, r1
				cnt--;
  2021a2:	1e60      	subs	r0, r4, #1
				*p++ = *q++;
  2021a4:	f816 3b01 	ldrb.w	r3, [r6], #1
				cnt--;
  2021a8:	b284      	uxth	r4, r0
				*p++ = *q++;
  2021aa:	f802 3b01 	strb.w	r3, [r2], #1
			for(mx=0; mx < cache->frame.width; mx++) {
  2021ae:	eba2 000b 	sub.w	r0, r2, fp
  2021b2:	f9b5 3004 	ldrsh.w	r3, [r5, #4]
  2021b6:	b200      	sxth	r0, r0
  2021b8:	4283      	cmp	r3, r0
  2021ba:	dcd4      	bgt.n	202166 <gdispImageCache_GIF+0x1ca>
  2021bc:	f10a 0a08 	add.w	sl, sl, #8
		for(p=cache->imagebits+cache->frame.width*4, my=4; my < cache->frame.height; my+=8, p += cache->frame.width*7) {
  2021c0:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
  2021c4:	fa0f fa8a 	sxth.w	sl, sl
  2021c8:	eb02 0b03 	add.w	fp, r2, r3
  2021cc:	e78d      	b.n	2020ea <gdispImageCache_GIF+0x14e>
							decode->buf[cnt++] = (cache->frame.flags & GIFL_TRANSPARENT) ? cache->frame.paltrans : 0;
  2021ce:	461c      	mov	r4, r3
  2021d0:	e7e1      	b.n	202196 <gdispImageCache_GIF+0x1fa>
		for(p=cache->imagebits+cache->frame.width*4, my=4; my < cache->frame.height; my+=8, p += cache->frame.width*7) {
  2021d2:	465a      	mov	r2, fp
					q = decode->buf;
  2021d4:	f107 011c 	add.w	r1, r7, #28
  2021d8:	e7e9      	b.n	2021ae <gdispImageCache_GIF+0x212>
				if (!cnt) {
  2021da:	b9e4      	cbnz	r4, 202216 <gdispImageCache_GIF+0x27a>
					if (!(cnt = getBytesGif(img))) {
  2021dc:	4640      	mov	r0, r8
  2021de:	e9cd 2100 	strd	r2, r1, [sp]
  2021e2:	f7fe fe87 	bl	200ef4 <getBytesGif>
  2021e6:	4604      	mov	r4, r0
  2021e8:	e9dd 2100 	ldrd	r2, r1, [sp]
  2021ec:	b990      	cbnz	r0, 202214 <gdispImageCache_GIF+0x278>
						if (decode->code_last != decode->code_eof)
  2021ee:	8a38      	ldrh	r0, [r7, #16]
  2021f0:	89bb      	ldrh	r3, [r7, #12]
  2021f2:	4298      	cmp	r0, r3
  2021f4:	f040 80a1 	bne.w	20233a <gdispImageCache_GIF+0x39e>
  2021f8:	7aab      	ldrb	r3, [r5, #10]
  2021fa:	f107 001c 	add.w	r0, r7, #28
  2021fe:	f107 063c 	add.w	r6, r7, #60	; 0x3c
  202202:	f003 0301 	and.w	r3, r3, #1
							decode->buf[cnt++] = (cache->frame.flags & GIFL_TRANSPARENT) ? cache->frame.paltrans : 0;
  202206:	b1e3      	cbz	r3, 202242 <gdispImageCache_GIF+0x2a6>
  202208:	7aec      	ldrb	r4, [r5, #11]
  20220a:	f800 4b01 	strb.w	r4, [r0], #1
						while(cnt < sizeof(decode->buf))
  20220e:	4286      	cmp	r6, r0
  202210:	d1f9      	bne.n	202206 <gdispImageCache_GIF+0x26a>
  202212:	2420      	movs	r4, #32
					q = decode->buf;
  202214:	460e      	mov	r6, r1
				cnt--;
  202216:	1e60      	subs	r0, r4, #1
				*p++ = *q++;
  202218:	f816 3b01 	ldrb.w	r3, [r6], #1
				cnt--;
  20221c:	b284      	uxth	r4, r0
				*p++ = *q++;
  20221e:	f802 3b01 	strb.w	r3, [r2], #1
			for(mx=0; mx < cache->frame.width; mx++) {
  202222:	eba2 000b 	sub.w	r0, r2, fp
  202226:	f9b5 3004 	ldrsh.w	r3, [r5, #4]
  20222a:	b200      	sxth	r0, r0
  20222c:	4298      	cmp	r0, r3
  20222e:	dbd4      	blt.n	2021da <gdispImageCache_GIF+0x23e>
  202230:	f10a 0a04 	add.w	sl, sl, #4
		for(p=cache->imagebits+cache->frame.width*2, my=2; my < cache->frame.height; my+=4, p += cache->frame.width*3) {
  202234:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  202238:	fa0f fa8a 	sxth.w	sl, sl
  20223c:	eb02 0b03 	add.w	fp, r2, r3
  202240:	e75e      	b.n	202100 <gdispImageCache_GIF+0x164>
							decode->buf[cnt++] = (cache->frame.flags & GIFL_TRANSPARENT) ? cache->frame.paltrans : 0;
  202242:	461c      	mov	r4, r3
  202244:	e7e1      	b.n	20220a <gdispImageCache_GIF+0x26e>
		for(p=cache->imagebits+cache->frame.width*2, my=2; my < cache->frame.height; my+=4, p += cache->frame.width*3) {
  202246:	465a      	mov	r2, fp
					q = decode->buf;
  202248:	f107 011c 	add.w	r1, r7, #28
  20224c:	e7e9      	b.n	202222 <gdispImageCache_GIF+0x286>
				if (!cnt) {
  20224e:	b9dc      	cbnz	r4, 202288 <gdispImageCache_GIF+0x2ec>
					if (!(cnt = getBytesGif(img))) {
  202250:	4640      	mov	r0, r8
  202252:	e9cd 3100 	strd	r3, r1, [sp]
  202256:	f7fe fe4d 	bl	200ef4 <getBytesGif>
  20225a:	4604      	mov	r4, r0
  20225c:	e9dd 3100 	ldrd	r3, r1, [sp]
  202260:	b988      	cbnz	r0, 202286 <gdispImageCache_GIF+0x2ea>
						if (decode->code_last != decode->code_eof)
  202262:	8a38      	ldrh	r0, [r7, #16]
  202264:	89ba      	ldrh	r2, [r7, #12]
  202266:	4290      	cmp	r0, r2
  202268:	d167      	bne.n	20233a <gdispImageCache_GIF+0x39e>
  20226a:	7aaa      	ldrb	r2, [r5, #10]
  20226c:	f107 001c 	add.w	r0, r7, #28
  202270:	f107 063c 	add.w	r6, r7, #60	; 0x3c
  202274:	f002 0201 	and.w	r2, r2, #1
							decode->buf[cnt++] = (cache->frame.flags & GIFL_TRANSPARENT) ? cache->frame.paltrans : 0;
  202278:	b1d2      	cbz	r2, 2022b0 <gdispImageCache_GIF+0x314>
  20227a:	7aec      	ldrb	r4, [r5, #11]
  20227c:	f800 4b01 	strb.w	r4, [r0], #1
						while(cnt < sizeof(decode->buf))
  202280:	4286      	cmp	r6, r0
  202282:	d1f9      	bne.n	202278 <gdispImageCache_GIF+0x2dc>
  202284:	2420      	movs	r4, #32
					q = decode->buf;
  202286:	460e      	mov	r6, r1
				cnt--;
  202288:	1e60      	subs	r0, r4, #1
				*p++ = *q++;
  20228a:	f816 2b01 	ldrb.w	r2, [r6], #1
				cnt--;
  20228e:	b284      	uxth	r4, r0
				*p++ = *q++;
  202290:	f803 2b01 	strb.w	r2, [r3], #1
			for(mx=0; mx < cache->frame.width; mx++) {
  202294:	eba3 020b 	sub.w	r2, r3, fp
  202298:	f9b5 0004 	ldrsh.w	r0, [r5, #4]
  20229c:	b212      	sxth	r2, r2
  20229e:	4290      	cmp	r0, r2
  2022a0:	dcd5      	bgt.n	20224e <gdispImageCache_GIF+0x2b2>
  2022a2:	f10a 0a02 	add.w	sl, sl, #2
		for(p=cache->imagebits+cache->frame.width, my=1; my < cache->frame.height; my+=2, p += cache->frame.width) {
  2022a6:	eb03 0b00 	add.w	fp, r3, r0
  2022aa:	fa0f fa8a 	sxth.w	sl, sl
  2022ae:	e732      	b.n	202116 <gdispImageCache_GIF+0x17a>
							decode->buf[cnt++] = (cache->frame.flags & GIFL_TRANSPARENT) ? cache->frame.paltrans : 0;
  2022b0:	4614      	mov	r4, r2
  2022b2:	e7e3      	b.n	20227c <gdispImageCache_GIF+0x2e0>
		for(p=cache->imagebits+cache->frame.width, my=1; my < cache->frame.height; my+=2, p += cache->frame.width) {
  2022b4:	465b      	mov	r3, fp
					q = decode->buf;
  2022b6:	f107 011c 	add.w	r1, r7, #28
  2022ba:	e7eb      	b.n	202294 <gdispImageCache_GIF+0x2f8>
				if (!cnt) {
  2022bc:	b9dc      	cbnz	r4, 2022f6 <gdispImageCache_GIF+0x35a>
					if (!(cnt = getBytesGif(img))) {
  2022be:	4640      	mov	r0, r8
  2022c0:	e9cd 2100 	strd	r2, r1, [sp]
  2022c4:	f7fe fe16 	bl	200ef4 <getBytesGif>
  2022c8:	4604      	mov	r4, r0
  2022ca:	e9dd 2100 	ldrd	r2, r1, [sp]
  2022ce:	b988      	cbnz	r0, 2022f4 <gdispImageCache_GIF+0x358>
						if (decode->code_last != decode->code_eof)
  2022d0:	8a38      	ldrh	r0, [r7, #16]
  2022d2:	89bb      	ldrh	r3, [r7, #12]
  2022d4:	4298      	cmp	r0, r3
  2022d6:	d130      	bne.n	20233a <gdispImageCache_GIF+0x39e>
  2022d8:	7aab      	ldrb	r3, [r5, #10]
  2022da:	f107 001c 	add.w	r0, r7, #28
  2022de:	f107 063c 	add.w	r6, r7, #60	; 0x3c
  2022e2:	f003 0301 	and.w	r3, r3, #1
							decode->buf[cnt++] = (cache->frame.flags & GIFL_TRANSPARENT) ? cache->frame.paltrans : 0;
  2022e6:	b1bb      	cbz	r3, 202318 <gdispImageCache_GIF+0x37c>
  2022e8:	7aec      	ldrb	r4, [r5, #11]
  2022ea:	f800 4b01 	strb.w	r4, [r0], #1
						while(cnt < sizeof(decode->buf))
  2022ee:	42b0      	cmp	r0, r6
  2022f0:	d1f9      	bne.n	2022e6 <gdispImageCache_GIF+0x34a>
  2022f2:	2420      	movs	r4, #32
					q = decode->buf;
  2022f4:	460e      	mov	r6, r1
				cnt--;
  2022f6:	1e60      	subs	r0, r4, #1
				*p++ = *q++;
  2022f8:	f816 3b01 	ldrb.w	r3, [r6], #1
				cnt--;
  2022fc:	b284      	uxth	r4, r0
				*p++ = *q++;
  2022fe:	f802 3b01 	strb.w	r3, [r2], #1
			for(mx=0; mx < cache->frame.width; mx++) {
  202302:	eba2 030b 	sub.w	r3, r2, fp
  202306:	f9b5 0004 	ldrsh.w	r0, [r5, #4]
  20230a:	b21b      	sxth	r3, r3
  20230c:	4298      	cmp	r0, r3
  20230e:	dcd5      	bgt.n	2022bc <gdispImageCache_GIF+0x320>
  202310:	f10a 0a01 	add.w	sl, sl, #1
  202314:	4693      	mov	fp, r2
  202316:	e693      	b.n	202040 <gdispImageCache_GIF+0xa4>
							decode->buf[cnt++] = (cache->frame.flags & GIFL_TRANSPARENT) ? cache->frame.paltrans : 0;
  202318:	461c      	mov	r4, r3
  20231a:	e7e6      	b.n	2022ea <gdispImageCache_GIF+0x34e>
	else if (priv->cache->frame.posstart > cache->frame.posstart) {
  20231c:	692a      	ldr	r2, [r5, #16]
  20231e:	6919      	ldr	r1, [r3, #16]
  202320:	4291      	cmp	r1, r2
  202322:	dd01      	ble.n	202328 <gdispImageCache_GIF+0x38c>
		cache->next = priv->cache;
  202324:	62ab      	str	r3, [r5, #40]	; 0x28
  202326:	e70f      	b.n	202148 <gdispImageCache_GIF+0x1ac>
			if (!pc->next || pc->next->frame.posstart > cache->frame.posstart) {
  202328:	4619      	mov	r1, r3
  20232a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  20232c:	b113      	cbz	r3, 202334 <gdispImageCache_GIF+0x398>
  20232e:	6918      	ldr	r0, [r3, #16]
  202330:	4282      	cmp	r2, r0
  202332:	daf9      	bge.n	202328 <gdispImageCache_GIF+0x38c>
				cache->next = pc->next;
  202334:	62ab      	str	r3, [r5, #40]	; 0x28
				pc->next = cache;
  202336:	628d      	str	r5, [r1, #40]	; 0x28
				break;
  202338:	e708      	b.n	20214c <gdispImageCache_GIF+0x1b0>
	stopDecodeGif(img);
  20233a:	4640      	mov	r0, r8
	return GDISP_IMAGE_ERR_BADDATA;
  20233c:	f248 0402 	movw	r4, #32770	; 0x8002
	stopDecodeGif(img);
  202340:	f7ff fda2 	bl	201e88 <stopDecodeGif>
  202344:	4628      	mov	r0, r5
  202346:	f009 ff6d 	bl	20c224 <free>
  20234a:	e661      	b.n	202010 <gdispImageCache_GIF+0x74>
		return GDISP_IMAGE_ERR_OK;
  20234c:	2400      	movs	r4, #0
  20234e:	e65f      	b.n	202010 <gdispImageCache_GIF+0x74>
		return GDISP_IMAGE_ERR_NOMEMORY;
  202350:	f248 0404 	movw	r4, #32772	; 0x8004
  202354:	e65c      	b.n	202010 <gdispImageCache_GIF+0x74>

00202356 <gdispImageClose_NATIVE>:
void gdispImageClose_NATIVE(gdispImage *img) {
  202356:	b538      	push	{r3, r4, r5, lr}
	priv = (gdispImagePrivate_NATIVE *)img->priv;
  202358:	6945      	ldr	r5, [r0, #20]
void gdispImageClose_NATIVE(gdispImage *img) {
  20235a:	4604      	mov	r4, r0
	if (priv) {
  20235c:	b145      	cbz	r5, 202370 <gdispImageClose_NATIVE+0x1a>
		if (priv->frame0cache)
  20235e:	6828      	ldr	r0, [r5, #0]
  202360:	b108      	cbz	r0, 202366 <gdispImageClose_NATIVE+0x10>
  202362:	f009 ff5f 	bl	20c224 <free>
  202366:	4628      	mov	r0, r5
  202368:	f009 ff5c 	bl	20c224 <free>
		img->priv = 0;
  20236c:	2300      	movs	r3, #0
  20236e:	6163      	str	r3, [r4, #20]
}
  202370:	bd38      	pop	{r3, r4, r5, pc}
	...

00202374 <cmd_mem>:
	if (argc > 0) {
  202374:	2900      	cmp	r1, #0
{
  202376:	b508      	push	{r3, lr}
	if (argc > 0) {
  202378:	dd04      	ble.n	202384 <cmd_mem+0x10>
		printf ("Usage: mem\n");
  20237a:	4806      	ldr	r0, [pc, #24]	; (202394 <cmd_mem+0x20>)
}
  20237c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		printf ("Usage: mem\n");
  202380:	f00b ba22 	b.w	20d7c8 <puts>
	printf ("total heap size  = %10u\n", HEAP_END - HEAP_BASE);
  202384:	4904      	ldr	r1, [pc, #16]	; (202398 <cmd_mem+0x24>)
  202386:	4805      	ldr	r0, [pc, #20]	; (20239c <cmd_mem+0x28>)
  202388:	f00b f9aa 	bl	20d6e0 <iprintf>
}
  20238c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	malloc_stats ();
  202390:	f006 bf60 	b.w	209254 <malloc_stats>
  202394:	0800dbd7 	.word	0x0800dbd7
  202398:	007c03ff 	.word	0x007c03ff
  20239c:	0800dbe2 	.word	0x0800dbe2

002023a0 <disk_write>:
    BYTE pdrv,        /* Physical drive number (0..) */
    const BYTE *buff, /* Data to be written */
    DWORD sector,     /* Sector address (LBA) */
    UINT count        /* Number of sectors to write (1..255) */
)
{
  2023a0:	b410      	push	{r4}
  2023a2:	460c      	mov	r4, r1
  2023a4:	4611      	mov	r1, r2
  switch (pdrv) {
  2023a6:	b940      	cbnz	r0, 2023ba <disk_write+0x1a>
    if (mmcStopSequentialWrite(&FATFS_HAL_DEVICE))
        return RES_ERROR;
    return RES_OK;
#else
  case SDC:
    if (blkGetDriverState(&FATFS_HAL_DEVICE) != BLK_READY)
  2023a8:	4807      	ldr	r0, [pc, #28]	; (2023c8 <disk_write+0x28>)
  2023aa:	7902      	ldrb	r2, [r0, #4]
  2023ac:	2a05      	cmp	r2, #5
  2023ae:	d108      	bne.n	2023c2 <disk_write+0x22>
      return RES_NOTRDY;
    if (sdcWrite(&FATFS_HAL_DEVICE, sector, buff, count))
  2023b0:	4622      	mov	r2, r4
      return RES_ERROR;
    return RES_OK;
#endif
  }
  return RES_PARERR;
}
  2023b2:	f85d 4b04 	ldr.w	r4, [sp], #4
    if (sdcWrite(&FATFS_HAL_DEVICE, sector, buff, count))
  2023b6:	f006 ba17 	b.w	2087e8 <sdcWrite>
  return RES_PARERR;
  2023ba:	2004      	movs	r0, #4
}
  2023bc:	f85d 4b04 	ldr.w	r4, [sp], #4
  2023c0:	4770      	bx	lr
      return RES_NOTRDY;
  2023c2:	2003      	movs	r0, #3
  2023c4:	e7fa      	b.n	2023bc <disk_write+0x1c>
  2023c6:	bf00      	nop
  2023c8:	200008ec 	.word	0x200008ec

002023cc <sync_window.part.0>:
static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
  2023cc:	b537      	push	{r0, r1, r2, r4, r5, lr}
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write it back into the volume */
  2023ce:	f100 0130 	add.w	r1, r0, #48	; 0x30
  2023d2:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
  2023d4:	4604      	mov	r4, r0
		if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {	/* Write it back into the volume */
  2023d6:	2301      	movs	r3, #1
  2023d8:	7840      	ldrb	r0, [r0, #1]
  2023da:	9101      	str	r1, [sp, #4]
  2023dc:	f7ff ffe0 	bl	2023a0 <disk_write>
  2023e0:	4605      	mov	r5, r0
  2023e2:	b990      	cbnz	r0, 20240a <sync_window.part.0+0x3e>
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
  2023e4:	6a23      	ldr	r3, [r4, #32]
			fs->wflag = 0;	/* Clear window dirty flag */
  2023e6:	70e0      	strb	r0, [r4, #3]
			if (fs->winsect - fs->fatbase < fs->fsize) {	/* Is it in the 1st FAT? */
  2023e8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  2023ea:	69a2      	ldr	r2, [r4, #24]
  2023ec:	1ac3      	subs	r3, r0, r3
  2023ee:	4293      	cmp	r3, r2
  2023f0:	d208      	bcs.n	202404 <sync_window.part.0+0x38>
				if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);	/* Reflect it to 2nd FAT if needed */
  2023f2:	78a3      	ldrb	r3, [r4, #2]
  2023f4:	9901      	ldr	r1, [sp, #4]
  2023f6:	2b02      	cmp	r3, #2
  2023f8:	d104      	bne.n	202404 <sync_window.part.0+0x38>
  2023fa:	4402      	add	r2, r0
  2023fc:	2301      	movs	r3, #1
  2023fe:	7860      	ldrb	r0, [r4, #1]
  202400:	f7ff ffce 	bl	2023a0 <disk_write>
}
  202404:	4628      	mov	r0, r5
  202406:	b003      	add	sp, #12
  202408:	bd30      	pop	{r4, r5, pc}
			res = FR_DISK_ERR;
  20240a:	2501      	movs	r5, #1
  20240c:	e7fa      	b.n	202404 <sync_window.part.0+0x38>

0020240e <sync_fs>:
{
  20240e:	b570      	push	{r4, r5, r6, lr}
	if (fs->wflag) {	/* Is the disk access window dirty? */
  202410:	78c3      	ldrb	r3, [r0, #3]
{
  202412:	4604      	mov	r4, r0
	if (fs->wflag) {	/* Is the disk access window dirty? */
  202414:	2b00      	cmp	r3, #0
  202416:	d141      	bne.n	20249c <sync_fs+0x8e>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
  202418:	7823      	ldrb	r3, [r4, #0]
  20241a:	2b03      	cmp	r3, #3
  20241c:	d139      	bne.n	202492 <sync_fs+0x84>
  20241e:	7923      	ldrb	r3, [r4, #4]
  202420:	2b01      	cmp	r3, #1
  202422:	d136      	bne.n	202492 <sync_fs+0x84>
			mem_set(fs->win, 0, sizeof fs->win);
  202424:	f104 0630 	add.w	r6, r4, #48	; 0x30
	BYTE *d = (BYTE*)dst;
  202428:	f504 720c 	add.w	r2, r4, #560	; 0x230
		*d++ = (BYTE)val;
  20242c:	2500      	movs	r5, #0
	BYTE *d = (BYTE*)dst;
  20242e:	4633      	mov	r3, r6
		*d++ = (BYTE)val;
  202430:	f803 5b01 	strb.w	r5, [r3], #1
	} while (--cnt);
  202434:	4293      	cmp	r3, r2
  202436:	d1fb      	bne.n	202430 <sync_fs+0x22>
	*ptr++ = (BYTE)val; val >>= 8;
  202438:	2355      	movs	r3, #85	; 0x55
	*ptr++ = (BYTE)val;
  20243a:	2241      	movs	r2, #65	; 0x41
	*ptr++ = (BYTE)val; val >>= 8;
  20243c:	2172      	movs	r1, #114	; 0x72
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
  20243e:	f504 7006 	add.w	r0, r4, #536	; 0x218
	*ptr++ = (BYTE)val; val >>= 8;
  202442:	f884 322e 	strb.w	r3, [r4, #558]	; 0x22e
	*ptr++ = (BYTE)val;
  202446:	23aa      	movs	r3, #170	; 0xaa
	*ptr++ = (BYTE)val;
  202448:	f884 2033 	strb.w	r2, [r4, #51]	; 0x33
	*ptr++ = (BYTE)val;
  20244c:	f884 322f 	strb.w	r3, [r4, #559]	; 0x22f
	*ptr++ = (BYTE)val; val >>= 8;
  202450:	2352      	movs	r3, #82	; 0x52
	*ptr++ = (BYTE)val; val >>= 8;
  202452:	f884 2216 	strb.w	r2, [r4, #534]	; 0x216
	*ptr++ = (BYTE)val; val >>= 8;
  202456:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
	*ptr++ = (BYTE)val; val >>= 8;
  20245a:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
	*ptr++ = (BYTE)val; val >>= 8;
  20245e:	2361      	movs	r3, #97	; 0x61
	*ptr++ = (BYTE)val; val >>= 8;
  202460:	f884 1214 	strb.w	r1, [r4, #532]	; 0x214
	*ptr++ = (BYTE)val; val >>= 8;
  202464:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
	*ptr++ = (BYTE)val;
  202468:	f884 3217 	strb.w	r3, [r4, #535]	; 0x217
	*ptr++ = (BYTE)val; val >>= 8;
  20246c:	f884 1215 	strb.w	r1, [r4, #533]	; 0x215
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
  202470:	6921      	ldr	r1, [r4, #16]
  202472:	f7fe fef3 	bl	20125c <st_dword>
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
  202476:	68e1      	ldr	r1, [r4, #12]
  202478:	f504 7007 	add.w	r0, r4, #540	; 0x21c
  20247c:	f7fe feee 	bl	20125c <st_dword>
			fs->winsect = fs->volbase + 1;
  202480:	69e2      	ldr	r2, [r4, #28]
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
  202482:	2301      	movs	r3, #1
  202484:	4631      	mov	r1, r6
			fs->winsect = fs->volbase + 1;
  202486:	3201      	adds	r2, #1
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
  202488:	7860      	ldrb	r0, [r4, #1]
			fs->winsect = fs->volbase + 1;
  20248a:	62e2      	str	r2, [r4, #44]	; 0x2c
			disk_write(fs->pdrv, fs->win, fs->winsect, 1);
  20248c:	f7ff ff88 	bl	2023a0 <disk_write>
			fs->fsi_flag = 0;
  202490:	7125      	strb	r5, [r4, #4]
    void *buff        /* Buffer to send/receive control data */
)
{
  (void)buff;

  switch (pdrv) {
  202492:	7860      	ldrb	r0, [r4, #1]
	res = sync_window(fs);
  202494:	3800      	subs	r0, #0
  202496:	bf18      	it	ne
  202498:	2001      	movne	r0, #1
  20249a:	e003      	b.n	2024a4 <sync_fs+0x96>
  20249c:	f7ff ff96 	bl	2023cc <sync_window.part.0>
	if (res == FR_OK) {
  2024a0:	2800      	cmp	r0, #0
  2024a2:	d0b9      	beq.n	202418 <sync_fs+0xa>
}
  2024a4:	bd70      	pop	{r4, r5, r6, pc}
	...

002024a8 <disk_read>:
{
  2024a8:	b410      	push	{r4}
  2024aa:	460c      	mov	r4, r1
  2024ac:	4611      	mov	r1, r2
  switch (pdrv) {
  2024ae:	b940      	cbnz	r0, 2024c2 <disk_read+0x1a>
    if (blkGetDriverState(&FATFS_HAL_DEVICE) != BLK_READY)
  2024b0:	4807      	ldr	r0, [pc, #28]	; (2024d0 <disk_read+0x28>)
  2024b2:	7902      	ldrb	r2, [r0, #4]
  2024b4:	2a05      	cmp	r2, #5
  2024b6:	d108      	bne.n	2024ca <disk_read+0x22>
    if (sdcRead(&FATFS_HAL_DEVICE, sector, buff, count))
  2024b8:	4622      	mov	r2, r4
}
  2024ba:	f85d 4b04 	ldr.w	r4, [sp], #4
    if (sdcRead(&FATFS_HAL_DEVICE, sector, buff, count))
  2024be:	f006 b9e1 	b.w	208884 <sdcRead>
  return RES_PARERR;
  2024c2:	2004      	movs	r0, #4
}
  2024c4:	f85d 4b04 	ldr.w	r4, [sp], #4
  2024c8:	4770      	bx	lr
      return RES_NOTRDY;
  2024ca:	2003      	movs	r0, #3
  2024cc:	e7fa      	b.n	2024c4 <disk_read+0x1c>
  2024ce:	bf00      	nop
  2024d0:	200008ec 	.word	0x200008ec

002024d4 <move_window>:
{
  2024d4:	b538      	push	{r3, r4, r5, lr}
	if (sect != fs->winsect) {	/* Window offset changed? */
  2024d6:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
{
  2024d8:	4604      	mov	r4, r0
  2024da:	460d      	mov	r5, r1
	if (sect != fs->winsect) {	/* Window offset changed? */
  2024dc:	428b      	cmp	r3, r1
  2024de:	d014      	beq.n	20250a <move_window+0x36>
	if (fs->wflag) {	/* Is the disk access window dirty? */
  2024e0:	78c3      	ldrb	r3, [r0, #3]
  2024e2:	b96b      	cbnz	r3, 202500 <move_window+0x2c>
			if (disk_read(fs->pdrv, fs->win, sect, 1) != RES_OK) {
  2024e4:	462a      	mov	r2, r5
  2024e6:	2301      	movs	r3, #1
  2024e8:	f104 0130 	add.w	r1, r4, #48	; 0x30
  2024ec:	7860      	ldrb	r0, [r4, #1]
  2024ee:	f7ff ffdb 	bl	2024a8 <disk_read>
				res = FR_DISK_ERR;
  2024f2:	2800      	cmp	r0, #0
  2024f4:	bf1c      	itt	ne
  2024f6:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
  2024fa:	2001      	movne	r0, #1
			fs->winsect = sect;
  2024fc:	62e5      	str	r5, [r4, #44]	; 0x2c
}
  2024fe:	bd38      	pop	{r3, r4, r5, pc}
  202500:	f7ff ff64 	bl	2023cc <sync_window.part.0>
		if (res == FR_OK) {			/* Fill sector window with new data */
  202504:	2800      	cmp	r0, #0
  202506:	d1fa      	bne.n	2024fe <move_window+0x2a>
  202508:	e7ec      	b.n	2024e4 <move_window+0x10>
	FRESULT res = FR_OK;
  20250a:	2000      	movs	r0, #0
  20250c:	e7f7      	b.n	2024fe <move_window+0x2a>

0020250e <get_fat.isra.0>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
  20250e:	2901      	cmp	r1, #1
static DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
  202510:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  202512:	4605      	mov	r5, r0
  202514:	460c      	mov	r4, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
  202516:	d952      	bls.n	2025be <get_fat.isra.0+0xb0>
  202518:	6943      	ldr	r3, [r0, #20]
  20251a:	4299      	cmp	r1, r3
  20251c:	d24f      	bcs.n	2025be <get_fat.isra.0+0xb0>
		switch (fs->fs_type) {
  20251e:	7803      	ldrb	r3, [r0, #0]
  202520:	2b02      	cmp	r3, #2
  202522:	d029      	beq.n	202578 <get_fat.isra.0+0x6a>
  202524:	2b03      	cmp	r3, #3
  202526:	d038      	beq.n	20259a <get_fat.isra.0+0x8c>
  202528:	2b01      	cmp	r3, #1
  20252a:	d148      	bne.n	2025be <get_fat.isra.0+0xb0>
			bc = (UINT)clst; bc += bc / 2;
  20252c:	eb01 0651 	add.w	r6, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
  202530:	6a01      	ldr	r1, [r0, #32]
  202532:	eb01 2156 	add.w	r1, r1, r6, lsr #9
  202536:	f7ff ffcd 	bl	2024d4 <move_window>
  20253a:	b110      	cbz	r0, 202542 <get_fat.isra.0+0x34>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
  20253c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  202540:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
  202542:	1c77      	adds	r7, r6, #1
  202544:	f3c6 0608 	ubfx	r6, r6, #0, #9
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
  202548:	6a29      	ldr	r1, [r5, #32]
  20254a:	4628      	mov	r0, r5
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
  20254c:	442e      	add	r6, r5
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
  20254e:	eb01 2157 	add.w	r1, r1, r7, lsr #9
			wc = fs->win[bc++ % SS(fs)];		/* Get 1st byte of the entry */
  202552:	f896 6030 	ldrb.w	r6, [r6, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
  202556:	f7ff ffbd 	bl	2024d4 <move_window>
  20255a:	2800      	cmp	r0, #0
  20255c:	d1ee      	bne.n	20253c <get_fat.isra.0+0x2e>
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
  20255e:	f3c7 0708 	ubfx	r7, r7, #0, #9
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
  202562:	07e3      	lsls	r3, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;	/* Merge 2nd byte of the entry */
  202564:	443d      	add	r5, r7
  202566:	f895 0030 	ldrb.w	r0, [r5, #48]	; 0x30
  20256a:	ea46 2000 	orr.w	r0, r6, r0, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);	/* Adjust bit position */
  20256e:	bf4c      	ite	mi
  202570:	0900      	lsrmi	r0, r0, #4
  202572:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
  202576:	e7e3      	b.n	202540 <get_fat.isra.0+0x32>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
  202578:	6a01      	ldr	r1, [r0, #32]
  20257a:	eb01 2114 	add.w	r1, r1, r4, lsr #8
  20257e:	f7ff ffa9 	bl	2024d4 <move_window>
  202582:	2800      	cmp	r0, #0
  202584:	d1da      	bne.n	20253c <get_fat.isra.0+0x2e>
			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
  202586:	0064      	lsls	r4, r4, #1
  202588:	3530      	adds	r5, #48	; 0x30
  20258a:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
  20258e:	192b      	adds	r3, r5, r4
	rv = rv << 8 | ptr[0];
  202590:	5d28      	ldrb	r0, [r5, r4]
  202592:	785b      	ldrb	r3, [r3, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));		/* Simple WORD array */
  202594:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
			break;
  202598:	e7d2      	b.n	202540 <get_fat.isra.0+0x32>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
  20259a:	6a01      	ldr	r1, [r0, #32]
  20259c:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
  2025a0:	f7ff ff98 	bl	2024d4 <move_window>
  2025a4:	2800      	cmp	r0, #0
  2025a6:	d1c9      	bne.n	20253c <get_fat.isra.0+0x2e>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;	/* Simple DWORD array but mask out upper 4 bits */
  2025a8:	00a4      	lsls	r4, r4, #2
  2025aa:	f105 0030 	add.w	r0, r5, #48	; 0x30
  2025ae:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
  2025b2:	4420      	add	r0, r4
  2025b4:	f7fe fe5a 	bl	20126c <ld_dword>
  2025b8:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
			break;
  2025bc:	e7c0      	b.n	202540 <get_fat.isra.0+0x32>
		switch (fs->fs_type) {
  2025be:	2001      	movs	r0, #1
	return val;
  2025c0:	e7be      	b.n	202540 <get_fat.isra.0+0x32>

002025c2 <dir_sdi.constprop.0>:
static FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
  2025c2:	b538      	push	{r3, r4, r5, lr}
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
  2025c4:	6882      	ldr	r2, [r0, #8]
	dp->dptr = ofs;				/* Set current offset */
  2025c6:	2300      	movs	r3, #0
static FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
  2025c8:	4604      	mov	r4, r0
	FATFS *fs = dp->obj.fs;
  2025ca:	6805      	ldr	r5, [r0, #0]
	dp->dptr = ofs;				/* Set current offset */
  2025cc:	6103      	str	r3, [r0, #16]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
  2025ce:	b99a      	cbnz	r2, 2025f8 <dir_sdi.constprop.0+0x36>
  2025d0:	782b      	ldrb	r3, [r5, #0]
  2025d2:	2b02      	cmp	r3, #2
  2025d4:	d901      	bls.n	2025da <dir_sdi.constprop.0+0x18>
		clst = (DWORD)fs->dirbase;
  2025d6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
  2025d8:	b96b      	cbnz	r3, 2025f6 <dir_sdi.constprop.0+0x34>
		if (ofs / SZDIRE >= fs->n_rootdir) return FR_INT_ERR;	/* Is index out of range? */
  2025da:	892b      	ldrh	r3, [r5, #8]
  2025dc:	b90b      	cbnz	r3, 2025e2 <dir_sdi.constprop.0+0x20>
  2025de:	2002      	movs	r0, #2
}
  2025e0:	bd38      	pop	{r3, r4, r5, pc}
		dp->sect = fs->dirbase;
  2025e2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  2025e4:	61a3      	str	r3, [r4, #24]
	if (dp->sect == 0) return FR_INT_ERR;
  2025e6:	69a3      	ldr	r3, [r4, #24]
	dp->clust = clst;					/* Current cluster# */
  2025e8:	6162      	str	r2, [r4, #20]
	if (dp->sect == 0) return FR_INT_ERR;
  2025ea:	2b00      	cmp	r3, #0
  2025ec:	d0f7      	beq.n	2025de <dir_sdi.constprop.0+0x1c>
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
  2025ee:	3530      	adds	r5, #48	; 0x30
	return FR_OK;
  2025f0:	2000      	movs	r0, #0
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
  2025f2:	61e5      	str	r5, [r4, #28]
  2025f4:	e7f4      	b.n	2025e0 <dir_sdi.constprop.0+0x1e>
	if (clst == 0) {	/* Static table (root-directory on the FAT volume) */
  2025f6:	461a      	mov	r2, r3
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
  2025f8:	896b      	ldrh	r3, [r5, #10]
		while (ofs >= csz) {				/* Follow cluster chain */
  2025fa:	b963      	cbnz	r3, 202616 <dir_sdi.constprop.0+0x54>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
  2025fc:	4611      	mov	r1, r2
  2025fe:	6820      	ldr	r0, [r4, #0]
  202600:	f7ff ff85 	bl	20250e <get_fat.isra.0>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  202604:	1c43      	adds	r3, r0, #1
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
  202606:	4602      	mov	r2, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  202608:	d00b      	beq.n	202622 <dir_sdi.constprop.0+0x60>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
  20260a:	2801      	cmp	r0, #1
  20260c:	d9e7      	bls.n	2025de <dir_sdi.constprop.0+0x1c>
  20260e:	696b      	ldr	r3, [r5, #20]
  202610:	4298      	cmp	r0, r3
  202612:	d3f3      	bcc.n	2025fc <dir_sdi.constprop.0+0x3a>
  202614:	e7e3      	b.n	2025de <dir_sdi.constprop.0+0x1c>
		dp->sect = clst2sect(fs, clst);
  202616:	4611      	mov	r1, r2
  202618:	4628      	mov	r0, r5
  20261a:	f7fe fe06 	bl	20122a <clst2sect>
  20261e:	61a0      	str	r0, [r4, #24]
  202620:	e7e1      	b.n	2025e6 <dir_sdi.constprop.0+0x24>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  202622:	2001      	movs	r0, #1
  202624:	e7dc      	b.n	2025e0 <dir_sdi.constprop.0+0x1e>

00202626 <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
  202626:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  20262a:	b087      	sub	sp, #28
  20262c:	4616      	mov	r6, r2
  20262e:	4689      	mov	r9, r1
  202630:	4604      	mov	r4, r0
  202632:	9301      	str	r3, [sp, #4]
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
  202634:	2300      	movs	r3, #0
  202636:	9a01      	ldr	r2, [sp, #4]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
  202638:	a905      	add	r1, sp, #20
	*br = 0;	/* Clear read byte counter */
  20263a:	6013      	str	r3, [r2, #0]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
  20263c:	f7fe fdb8 	bl	2011b0 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
  202640:	4605      	mov	r5, r0
  202642:	bb18      	cbnz	r0, 20268c <f_read+0x66>
  202644:	7c65      	ldrb	r5, [r4, #17]
  202646:	bb0d      	cbnz	r5, 20268c <f_read+0x66>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
  202648:	7c23      	ldrb	r3, [r4, #16]
  20264a:	f013 0301 	ands.w	r3, r3, #1
  20264e:	9302      	str	r3, [sp, #8]
  202650:	f000 8099 	beq.w	202786 <f_read+0x160>
	remain = fp->obj.objsize - fp->fptr;
  202654:	68e2      	ldr	r2, [r4, #12]
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
#if FF_FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#else
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
  202656:	f104 0a2c 	add.w	sl, r4, #44	; 0x2c
	remain = fp->obj.objsize - fp->fptr;
  20265a:	6963      	ldr	r3, [r4, #20]
  20265c:	1ad2      	subs	r2, r2, r3
  20265e:	4296      	cmp	r6, r2
  202660:	bf28      	it	cs
  202662:	4616      	movcs	r6, r2
	for ( ;  btr;								/* Repeat until btr bytes read */
  202664:	b196      	cbz	r6, 20268c <f_read+0x66>
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
  202666:	6961      	ldr	r1, [r4, #20]
  202668:	f3c1 0308 	ubfx	r3, r1, #0, #9
  20266c:	2b00      	cmp	r3, #0
  20266e:	d17c      	bne.n	20276a <f_read+0x144>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
  202670:	9b05      	ldr	r3, [sp, #20]
  202672:	f8b3 800a 	ldrh.w	r8, [r3, #10]
  202676:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
			if (csect == 0) {					/* On the cluster boundary? */
  20267a:	ea18 2851 	ands.w	r8, r8, r1, lsr #9
  20267e:	d11b      	bne.n	2026b8 <f_read+0x92>
				if (fp->fptr == 0) {			/* On the top of the file? */
  202680:	b941      	cbnz	r1, 202694 <f_read+0x6e>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
  202682:	68a0      	ldr	r0, [r4, #8]
				if (clst < 2) ABORT(fs, FR_INT_ERR);
  202684:	2801      	cmp	r0, #1
  202686:	d810      	bhi.n	2026aa <f_read+0x84>
  202688:	2502      	movs	r5, #2
  20268a:	7465      	strb	r5, [r4, #17]
#endif
	}

	LEAVE_FF(fs, FR_OK);
}
  20268c:	4628      	mov	r0, r5
  20268e:	b007      	add	sp, #28
  202690:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					if (fp->cltbl) {
  202694:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  202696:	b11b      	cbz	r3, 2026a0 <f_read+0x7a>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
  202698:	4620      	mov	r0, r4
  20269a:	f7fe fdb5 	bl	201208 <clmt_clust>
  20269e:	e7f1      	b.n	202684 <f_read+0x5e>
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
  2026a0:	69a1      	ldr	r1, [r4, #24]
  2026a2:	6820      	ldr	r0, [r4, #0]
  2026a4:	f7ff ff33 	bl	20250e <get_fat.isra.0>
  2026a8:	e7ec      	b.n	202684 <f_read+0x5e>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
  2026aa:	1c43      	adds	r3, r0, #1
  2026ac:	d103      	bne.n	2026b6 <f_read+0x90>
  2026ae:	2301      	movs	r3, #1
  2026b0:	9d02      	ldr	r5, [sp, #8]
  2026b2:	7463      	strb	r3, [r4, #17]
  2026b4:	e7ea      	b.n	20268c <f_read+0x66>
				fp->clust = clst;				/* Update current cluster */
  2026b6:	61a0      	str	r0, [r4, #24]
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
  2026b8:	f8dd b014 	ldr.w	fp, [sp, #20]
  2026bc:	69a1      	ldr	r1, [r4, #24]
  2026be:	4658      	mov	r0, fp
  2026c0:	f7fe fdb3 	bl	20122a <clst2sect>
			if (sect == 0) ABORT(fs, FR_INT_ERR);
  2026c4:	2800      	cmp	r0, #0
  2026c6:	d0df      	beq.n	202688 <f_read+0x62>
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
  2026c8:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
			sect += csect;
  2026cc:	eb08 0700 	add.w	r7, r8, r0
			if (cc > 0) {						/* Read maximum contiguous sectors directly */
  2026d0:	d32e      	bcc.n	202730 <f_read+0x10a>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
  2026d2:	f8bb 200a 	ldrh.w	r2, [fp, #10]
  2026d6:	eb08 2156 	add.w	r1, r8, r6, lsr #9
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
  2026da:	0a73      	lsrs	r3, r6, #9
				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
  2026dc:	f89b 0001 	ldrb.w	r0, [fp, #1]
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
  2026e0:	4291      	cmp	r1, r2
				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
  2026e2:	4649      	mov	r1, r9
					cc = fs->csize - csect;
  2026e4:	bf88      	it	hi
  2026e6:	eba2 0308 	subhi.w	r3, r2, r8
				if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
  2026ea:	463a      	mov	r2, r7
  2026ec:	9303      	str	r3, [sp, #12]
  2026ee:	f7ff fedb 	bl	2024a8 <disk_read>
  2026f2:	2800      	cmp	r0, #0
  2026f4:	d1db      	bne.n	2026ae <f_read+0x88>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
  2026f6:	f994 2010 	ldrsb.w	r2, [r4, #16]
  2026fa:	9b03      	ldr	r3, [sp, #12]
  2026fc:	2a00      	cmp	r2, #0
  2026fe:	da0b      	bge.n	202718 <f_read+0xf2>
  202700:	69e0      	ldr	r0, [r4, #28]
  202702:	1bc0      	subs	r0, r0, r7
  202704:	4298      	cmp	r0, r3
  202706:	d207      	bcs.n	202718 <f_read+0xf2>
	if (cnt != 0) {
  202708:	f44f 7200 	mov.w	r2, #512	; 0x200
  20270c:	4651      	mov	r1, sl
  20270e:	eb09 2040 	add.w	r0, r9, r0, lsl #9
  202712:	f7fe fd44 	bl	20119e <mem_cpy.part.0>
  202716:	9b03      	ldr	r3, [sp, #12]
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
  202718:	025f      	lsls	r7, r3, #9
		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
  20271a:	9b01      	ldr	r3, [sp, #4]
  20271c:	1bf6      	subs	r6, r6, r7
  20271e:	9a01      	ldr	r2, [sp, #4]
  202720:	44b9      	add	r9, r7
  202722:	681b      	ldr	r3, [r3, #0]
  202724:	443b      	add	r3, r7
  202726:	6013      	str	r3, [r2, #0]
  202728:	6963      	ldr	r3, [r4, #20]
  20272a:	443b      	add	r3, r7
  20272c:	6163      	str	r3, [r4, #20]
  20272e:	e799      	b.n	202664 <f_read+0x3e>
			if (fp->sect != sect) {			/* Load data sector if not in cache */
  202730:	69e2      	ldr	r2, [r4, #28]
  202732:	42ba      	cmp	r2, r7
  202734:	d018      	beq.n	202768 <f_read+0x142>
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
  202736:	f994 3010 	ldrsb.w	r3, [r4, #16]
  20273a:	2b00      	cmp	r3, #0
  20273c:	da0b      	bge.n	202756 <f_read+0x130>
					if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
  20273e:	2301      	movs	r3, #1
  202740:	4651      	mov	r1, sl
  202742:	f89b 0001 	ldrb.w	r0, [fp, #1]
  202746:	f7ff fe2b 	bl	2023a0 <disk_write>
  20274a:	2800      	cmp	r0, #0
  20274c:	d1af      	bne.n	2026ae <f_read+0x88>
					fp->flag &= (BYTE)~FA_DIRTY;
  20274e:	7c23      	ldrb	r3, [r4, #16]
  202750:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  202754:	7423      	strb	r3, [r4, #16]
				if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
  202756:	9805      	ldr	r0, [sp, #20]
  202758:	2301      	movs	r3, #1
  20275a:	463a      	mov	r2, r7
  20275c:	4651      	mov	r1, sl
  20275e:	7840      	ldrb	r0, [r0, #1]
  202760:	f7ff fea2 	bl	2024a8 <disk_read>
  202764:	2800      	cmp	r0, #0
  202766:	d1a2      	bne.n	2026ae <f_read+0x88>
			fp->sect = sect;
  202768:	61e7      	str	r7, [r4, #28]
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
  20276a:	6961      	ldr	r1, [r4, #20]
  20276c:	4648      	mov	r0, r9
  20276e:	f3c1 0108 	ubfx	r1, r1, #0, #9
  202772:	f5c1 7700 	rsb	r7, r1, #512	; 0x200
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
  202776:	4451      	add	r1, sl
  202778:	42b7      	cmp	r7, r6
  20277a:	bf28      	it	cs
  20277c:	4637      	movcs	r7, r6
	if (cnt != 0) {
  20277e:	463a      	mov	r2, r7
  202780:	f7fe fd0d 	bl	20119e <mem_cpy.part.0>
  202784:	e7c9      	b.n	20271a <f_read+0xf4>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
  202786:	2507      	movs	r5, #7
  202788:	e780      	b.n	20268c <f_read+0x66>

0020278a <fatfsRead>:
{
  20278a:	b507      	push	{r0, r1, r2, lr}
	f_read( (FIL*)f->obj, buf, size, (UINT*)&br);
  20278c:	6880      	ldr	r0, [r0, #8]
  20278e:	ab01      	add	r3, sp, #4
  202790:	f7ff ff49 	bl	202626 <f_read>
}
  202794:	9801      	ldr	r0, [sp, #4]
  202796:	b003      	add	sp, #12
  202798:	f85d fb04 	ldr.w	pc, [sp], #4

0020279c <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
  20279c:	b513      	push	{r0, r1, r4, lr}
	FATFS *fs;
	DWORD tm;
	BYTE *dir;


	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
  20279e:	a901      	add	r1, sp, #4
{
  2027a0:	4604      	mov	r4, r0
	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
  2027a2:	f7fe fd05 	bl	2011b0 <validate>
	if (res == FR_OK) {
  2027a6:	2800      	cmp	r0, #0
  2027a8:	d141      	bne.n	20282e <f_sync+0x92>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
  2027aa:	7c23      	ldrb	r3, [r4, #16]
  2027ac:	f013 0040 	ands.w	r0, r3, #64	; 0x40
  2027b0:	d03d      	beq.n	20282e <f_sync+0x92>
#if !FF_FS_TINY
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
  2027b2:	061b      	lsls	r3, r3, #24
  2027b4:	d50d      	bpl.n	2027d2 <f_sync+0x36>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
  2027b6:	9801      	ldr	r0, [sp, #4]
  2027b8:	2301      	movs	r3, #1
  2027ba:	69e2      	ldr	r2, [r4, #28]
  2027bc:	f104 012c 	add.w	r1, r4, #44	; 0x2c
  2027c0:	7840      	ldrb	r0, [r0, #1]
  2027c2:	f7ff fded 	bl	2023a0 <disk_write>
  2027c6:	2800      	cmp	r0, #0
  2027c8:	d133      	bne.n	202832 <f_sync+0x96>
				fp->flag &= (BYTE)~FA_DIRTY;
  2027ca:	7c23      	ldrb	r3, [r4, #16]
  2027cc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  2027d0:	7423      	strb	r3, [r4, #16]
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
  2027d2:	6a21      	ldr	r1, [r4, #32]
  2027d4:	9801      	ldr	r0, [sp, #4]
  2027d6:	f7ff fe7d 	bl	2024d4 <move_window>
				if (res == FR_OK) {
  2027da:	bb40      	cbnz	r0, 20282e <f_sync+0x92>
					dir = fp->dir_ptr;
  2027dc:	6a62      	ldr	r2, [r4, #36]	; 0x24
					dir[DIR_Attr] |= AM_ARC;						/* Set archive attribute to indicate that the file has been changed */
  2027de:	7ad3      	ldrb	r3, [r2, #11]
  2027e0:	f043 0320 	orr.w	r3, r3, #32
  2027e4:	72d3      	strb	r3, [r2, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation information  */
  2027e6:	68a3      	ldr	r3, [r4, #8]
  2027e8:	6821      	ldr	r1, [r4, #0]
	*ptr++ = (BYTE)val; val >>= 8;
  2027ea:	f3c3 2007 	ubfx	r0, r3, #8, #8
  2027ee:	7693      	strb	r3, [r2, #26]
	*ptr++ = (BYTE)val;
  2027f0:	76d0      	strb	r0, [r2, #27]
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
  2027f2:	f102 001c 	add.w	r0, r2, #28
	if (fs->fs_type == FS_FAT32) {
  2027f6:	7809      	ldrb	r1, [r1, #0]
  2027f8:	2903      	cmp	r1, #3
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
  2027fa:	bf01      	itttt	eq
  2027fc:	0c1b      	lsreq	r3, r3, #16
	*ptr++ = (BYTE)val; val >>= 8;
  2027fe:	7513      	strbeq	r3, [r2, #20]
  202800:	0a1b      	lsreq	r3, r3, #8
	*ptr++ = (BYTE)val;
  202802:	7553      	strbeq	r3, [r2, #21]
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
  202804:	68e1      	ldr	r1, [r4, #12]
  202806:	f7fe fd29 	bl	20125c <st_dword>
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
  20280a:	f44f 1104 	mov.w	r1, #2162688	; 0x210000
  20280e:	f102 0016 	add.w	r0, r2, #22
  202812:	f7fe fd23 	bl	20125c <st_dword>
	*ptr++ = (BYTE)val; val >>= 8;
  202816:	2300      	movs	r3, #0
					st_word(dir + DIR_LstAccDate, 0);
					fs->wflag = 1;
  202818:	9801      	ldr	r0, [sp, #4]
	*ptr++ = (BYTE)val; val >>= 8;
  20281a:	7493      	strb	r3, [r2, #18]
	*ptr++ = (BYTE)val;
  20281c:	74d3      	strb	r3, [r2, #19]
					fs->wflag = 1;
  20281e:	2301      	movs	r3, #1
  202820:	70c3      	strb	r3, [r0, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
  202822:	f7ff fdf4 	bl	20240e <sync_fs>
					fp->flag &= (BYTE)~FA_MODIFIED;
  202826:	7c23      	ldrb	r3, [r4, #16]
  202828:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  20282c:	7423      	strb	r3, [r4, #16]
			}
		}
	}

	LEAVE_FF(fs, res);
}
  20282e:	b002      	add	sp, #8
  202830:	bd10      	pop	{r4, pc}
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
  202832:	2001      	movs	r0, #1
  202834:	e7fb      	b.n	20282e <f_sync+0x92>

00202836 <fatfsSync>:

static gBool fatfsSync(GFILE *f)
{
  202836:	b508      	push	{r3, lr}
	FRESULT ferr;

	ferr = f_sync( (FIL*)f->obj );
  202838:	6880      	ldr	r0, [r0, #8]
  20283a:	f7ff ffaf 	bl	20279c <f_sync>
	if (ferr != FR_OK) {
  20283e:	fab0 f080 	clz	r0, r0
  202842:	0940      	lsrs	r0, r0, #5
		return gFalse;
	}

	return gTrue;
}
  202844:	4240      	negs	r0, r0
  202846:	bd08      	pop	{r3, pc}

00202848 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
  202848:	b513      	push	{r0, r1, r4, lr}
  20284a:	4604      	mov	r4, r0
	FRESULT res;
	FATFS *fs;

#if !FF_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
  20284c:	f7ff ffa6 	bl	20279c <f_sync>
	if (res == FR_OK)
  202850:	b928      	cbnz	r0, 20285e <f_close+0x16>
#endif
	{
		res = validate(&fp->obj, &fs);	/* Lock volume */
  202852:	a901      	add	r1, sp, #4
  202854:	4620      	mov	r0, r4
  202856:	f7fe fcab 	bl	2011b0 <validate>
		if (res == FR_OK) {
  20285a:	b900      	cbnz	r0, 20285e <f_close+0x16>
#if FF_FS_LOCK != 0
			res = dec_lock(fp->obj.lockid);		/* Decrement file open counter */
			if (res == FR_OK) fp->obj.fs = 0;	/* Invalidate file object */
#else
			fp->obj.fs = 0;	/* Invalidate file object */
  20285c:	6020      	str	r0, [r4, #0]
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
  20285e:	b002      	add	sp, #8
  202860:	bd10      	pop	{r4, pc}

00202862 <fatfsClose>:
{
  202862:	b510      	push	{r4, lr}
  202864:	4604      	mov	r4, r0
	if ((FIL*)f->obj != 0) { 
  202866:	6880      	ldr	r0, [r0, #8]
  202868:	b130      	cbz	r0, 202878 <fatfsClose+0x16>
		f_close( (FIL*)f->obj );
  20286a:	f7ff ffed 	bl	202848 <f_close>
		gfxFree( (FIL*)f->obj );
  20286e:	68a0      	ldr	r0, [r4, #8]
}
  202870:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		gfxFree( (FIL*)f->obj );
  202874:	f009 bcd6 	b.w	20c224 <free>
}
  202878:	bd10      	pop	{r4, pc}
	...

0020287c <check_fs>:
	fs->wflag = 0; fs->winsect = (LBA_t)0 - 1;		/* Invaidate window */
  20287c:	2300      	movs	r3, #0
{
  20287e:	b510      	push	{r4, lr}
	fs->wflag = 0; fs->winsect = (LBA_t)0 - 1;		/* Invaidate window */
  202880:	70c3      	strb	r3, [r0, #3]
  202882:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  202886:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = (LBA_t)0 - 1;		/* Invaidate window */
  202888:	62c3      	str	r3, [r0, #44]	; 0x2c
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load the boot sector */
  20288a:	f7ff fe23 	bl	2024d4 <move_window>
  20288e:	bb18      	cbnz	r0, 2028d8 <check_fs+0x5c>
	rv = rv << 8 | ptr[0];
  202890:	f894 222f 	ldrb.w	r2, [r4, #559]	; 0x22f
  202894:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
  202898:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot signature (always here regardless of the sector size) */
  20289c:	f64a 2255 	movw	r2, #43605	; 0xaa55
  2028a0:	4293      	cmp	r3, r2
  2028a2:	d11b      	bne.n	2028dc <check_fs+0x60>
	if (fs->win[BS_JmpBoot] == 0xE9 || fs->win[BS_JmpBoot] == 0xEB || fs->win[BS_JmpBoot] == 0xE8) {	/* Valid JumpBoot code? */
  2028a4:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
  2028a8:	2beb      	cmp	r3, #235	; 0xeb
  2028aa:	d003      	beq.n	2028b4 <check_fs+0x38>
  2028ac:	3318      	adds	r3, #24
  2028ae:	b2db      	uxtb	r3, r3
  2028b0:	2b01      	cmp	r3, #1
  2028b2:	d815      	bhi.n	2028e0 <check_fs+0x64>
		if (!mem_cmp(fs->win + BS_FilSysType, "FAT", 3)) return 0;		/* Is it an FAT VBR? */
  2028b4:	2203      	movs	r2, #3
  2028b6:	490b      	ldr	r1, [pc, #44]	; (2028e4 <check_fs+0x68>)
  2028b8:	f104 0066 	add.w	r0, r4, #102	; 0x66
  2028bc:	f7fe fcc0 	bl	201240 <mem_cmp>
  2028c0:	b148      	cbz	r0, 2028d6 <check_fs+0x5a>
		if (!mem_cmp(fs->win + BS_FilSysType32, "FAT32", 5)) return 0;	/* Is it an FAT32 VBR? */
  2028c2:	2205      	movs	r2, #5
  2028c4:	4908      	ldr	r1, [pc, #32]	; (2028e8 <check_fs+0x6c>)
  2028c6:	f104 0082 	add.w	r0, r4, #130	; 0x82
  2028ca:	f7fe fcb9 	bl	201240 <mem_cmp>
  2028ce:	2800      	cmp	r0, #0
  2028d0:	bf14      	ite	ne
  2028d2:	2002      	movne	r0, #2
  2028d4:	2000      	moveq	r0, #0
}
  2028d6:	bd10      	pop	{r4, pc}
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load the boot sector */
  2028d8:	2004      	movs	r0, #4
  2028da:	e7fc      	b.n	2028d6 <check_fs+0x5a>
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot signature (always here regardless of the sector size) */
  2028dc:	2003      	movs	r0, #3
  2028de:	e7fa      	b.n	2028d6 <check_fs+0x5a>
	return 2;	/* Valid BS but not FAT */
  2028e0:	2002      	movs	r0, #2
  2028e2:	e7f8      	b.n	2028d6 <check_fs+0x5a>
  2028e4:	0800dbfb 	.word	0x0800dbfb
  2028e8:	0800dbff 	.word	0x0800dbff

002028ec <mount_volume>:
	*rfs = 0;
  2028ec:	2300      	movs	r3, #0
{
  2028ee:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	*rfs = 0;
  2028f2:	600b      	str	r3, [r1, #0]
{
  2028f4:	b085      	sub	sp, #20
  2028f6:	460f      	mov	r7, r1
  2028f8:	4615      	mov	r5, r2
	vol = get_ldnumber(path);
  2028fa:	f7fe fc70 	bl	2011de <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
  2028fe:	1e06      	subs	r6, r0, #0
  202900:	f2c0 8134 	blt.w	202b6c <mount_volume+0x280>
	fs = FatFs[vol];					/* Get pointer to the filesystem object */
  202904:	4ba1      	ldr	r3, [pc, #644]	; (202b8c <mount_volume+0x2a0>)
  202906:	f853 4026 	ldr.w	r4, [r3, r6, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
  20290a:	2c00      	cmp	r4, #0
  20290c:	f000 8130 	beq.w	202b70 <mount_volume+0x284>
	*rfs = fs;							/* Return pointer to the filesystem object */
  202910:	603c      	str	r4, [r7, #0]
	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
  202912:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	if (fs->fs_type != 0) {				/* If the volume has been mounted */
  202916:	7823      	ldrb	r3, [r4, #0]
  202918:	b16b      	cbz	r3, 202936 <mount_volume+0x4a>
		stat = disk_status(fs->pdrv);
  20291a:	7860      	ldrb	r0, [r4, #1]
  20291c:	f7fe fc24 	bl	201168 <disk_initialize>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
  202920:	07c7      	lsls	r7, r0, #31
  202922:	d408      	bmi.n	202936 <mount_volume+0x4a>
			if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
  202924:	b11d      	cbz	r5, 20292e <mount_volume+0x42>
  202926:	f010 0504 	ands.w	r5, r0, #4
  20292a:	d000      	beq.n	20292e <mount_volume+0x42>
				return FR_WRITE_PROTECTED;
  20292c:	250a      	movs	r5, #10
}
  20292e:	4628      	mov	r0, r5
  202930:	b005      	add	sp, #20
  202932:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	fs->fs_type = 0;					/* Clear the filesystem object */
  202936:	2300      	movs	r3, #0
	fs->pdrv = LD2PD(vol);				/* Volume hosting physical drive */
  202938:	b2f0      	uxtb	r0, r6
	fs->fs_type = 0;					/* Clear the filesystem object */
  20293a:	7023      	strb	r3, [r4, #0]
	fs->pdrv = LD2PD(vol);				/* Volume hosting physical drive */
  20293c:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->pdrv);	/* Initialize the physical drive */
  20293e:	f7fe fc13 	bl	201168 <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
  202942:	07c1      	lsls	r1, r0, #31
  202944:	f100 8116 	bmi.w	202b74 <mount_volume+0x288>
	if (!FF_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
  202948:	b10d      	cbz	r5, 20294e <mount_volume+0x62>
  20294a:	0742      	lsls	r2, r0, #29
  20294c:	d4ee      	bmi.n	20292c <mount_volume+0x40>
	fmt = check_fs(fs, 0);				/* Load sector 0 and check if it is an FAT VBR as SFD */
  20294e:	2100      	movs	r1, #0
  202950:	4620      	mov	r0, r4
  202952:	f7ff ff93 	bl	20287c <check_fs>
	if (fmt != 2 && (fmt >= 3 || part == 0)) return fmt;	/* Returns if it is a FAT VBR as auto scan, not a BS or disk error */
  202956:	2802      	cmp	r0, #2
  202958:	f040 80eb 	bne.w	202b32 <mount_volume+0x246>
  20295c:	466e      	mov	r6, sp
  20295e:	f504 71fb 	add.w	r1, r4, #502	; 0x1f6
  202962:	f204 2736 	addw	r7, r4, #566	; 0x236
  202966:	4635      	mov	r5, r6
		mbr_pt[i] = ld_dword(fs->win + MBR_Table + i * SZ_PTE + PTE_StLba);
  202968:	4608      	mov	r0, r1
  20296a:	f7fe fc7f 	bl	20126c <ld_dword>
  20296e:	3110      	adds	r1, #16
  202970:	f845 0b04 	str.w	r0, [r5], #4
	for (i = 0; i < 4; i++) {		/* Load partition offset in the MBR */
  202974:	428f      	cmp	r7, r1
  202976:	d1f7      	bne.n	202968 <mount_volume+0x7c>
  202978:	2500      	movs	r5, #0
		fmt = mbr_pt[i] ? check_fs(fs, mbr_pt[i]) : 3;	/* Check if the partition is FAT */
  20297a:	f856 1b04 	ldr.w	r1, [r6], #4
  20297e:	2900      	cmp	r1, #0
  202980:	f000 80ce 	beq.w	202b20 <mount_volume+0x234>
  202984:	4620      	mov	r0, r4
  202986:	f7ff ff79 	bl	20287c <check_fs>
	} while (part == 0 && fmt >= 2 && ++i < 4);
  20298a:	2801      	cmp	r0, #1
  20298c:	f200 80c9 	bhi.w	202b22 <mount_volume+0x236>
	rv = rv << 8 | ptr[0];
  202990:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
  202994:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
  202998:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
  20299c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  2029a0:	f040 80cc 	bne.w	202b3c <mount_volume+0x250>
	rv = rv << 8 | ptr[0];
  2029a4:	f894 0047 	ldrb.w	r0, [r4, #71]	; 0x47
  2029a8:	f894 6046 	ldrb.w	r6, [r4, #70]	; 0x46
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
  2029ac:	ea56 2600 	orrs.w	r6, r6, r0, lsl #8
  2029b0:	d104      	bne.n	2029bc <mount_volume+0xd0>
  2029b2:	f104 0054 	add.w	r0, r4, #84	; 0x54
  2029b6:	f7fe fc59 	bl	20126c <ld_dword>
  2029ba:	4606      	mov	r6, r0
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
  2029bc:	f894 5040 	ldrb.w	r5, [r4, #64]	; 0x40
	bsect = fs->winsect;					/* Volume location */
  2029c0:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
  2029c2:	1e6b      	subs	r3, r5, #1
		fs->fsize = fasize;
  2029c4:	61a6      	str	r6, [r4, #24]
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
  2029c6:	70a5      	strb	r5, [r4, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
  2029c8:	2b01      	cmp	r3, #1
  2029ca:	f200 80b7 	bhi.w	202b3c <mount_volume+0x250>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
  2029ce:	f894 903d 	ldrb.w	r9, [r4, #61]	; 0x3d
  2029d2:	464b      	mov	r3, r9
  2029d4:	f8a4 900a 	strh.w	r9, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  2029d8:	2b00      	cmp	r3, #0
  2029da:	f000 80af 	beq.w	202b3c <mount_volume+0x250>
  2029de:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
  2029e2:	ea13 0f09 	tst.w	r3, r9
  2029e6:	f040 80a9 	bne.w	202b3c <mount_volume+0x250>
	rv = rv << 8 | ptr[0];
  2029ea:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
  2029ee:	f894 7041 	ldrb.w	r7, [r4, #65]	; 0x41
  2029f2:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
  2029f6:	073b      	lsls	r3, r7, #28
	rv = rv << 8 | ptr[0];
  2029f8:	fa0f f887 	sxth.w	r8, r7
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
  2029fc:	8127      	strh	r7, [r4, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
  2029fe:	f040 809d 	bne.w	202b3c <mount_volume+0x250>
	rv = rv << 8 | ptr[0];
  202a02:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
  202a06:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
  202a0a:	ea53 2300 	orrs.w	r3, r3, r0, lsl #8
  202a0e:	f000 8097 	beq.w	202b40 <mount_volume+0x254>
		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
  202a12:	4618      	mov	r0, r3
	rv = rv << 8 | ptr[0];
  202a14:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
  202a18:	f894 203e 	ldrb.w	r2, [r4, #62]	; 0x3e
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
  202a1c:	ea52 2203 	orrs.w	r2, r2, r3, lsl #8
  202a20:	f000 808c 	beq.w	202b3c <mount_volume+0x250>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
  202a24:	fb06 fe05 	mul.w	lr, r6, r5
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
  202a28:	eb02 1c17 	add.w	ip, r2, r7, lsr #4
  202a2c:	44f4      	add	ip, lr
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
  202a2e:	4560      	cmp	r0, ip
  202a30:	f0c0 8084 	bcc.w	202b3c <mount_volume+0x250>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
  202a34:	eba0 030c 	sub.w	r3, r0, ip
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  202a38:	454b      	cmp	r3, r9
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
  202a3a:	fbb3 f0f9 	udiv	r0, r3, r9
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  202a3e:	d37d      	bcc.n	202b3c <mount_volume+0x250>
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
  202a40:	4b53      	ldr	r3, [pc, #332]	; (202b90 <mount_volume+0x2a4>)
  202a42:	4298      	cmp	r0, r3
  202a44:	d87a      	bhi.n	202b3c <mount_volume+0x250>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
  202a46:	f64f 73f5 	movw	r3, #65525	; 0xfff5
  202a4a:	4298      	cmp	r0, r3
  202a4c:	f240 8094 	bls.w	202b78 <mount_volume+0x28c>
		if (nclst <= MAX_FAT32) fmt = FS_FAT32;
  202a50:	f04f 0903 	mov.w	r9, #3
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
  202a54:	1c85      	adds	r5, r0, #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
  202a56:	440a      	add	r2, r1
		fs->database = bsect + sysect;					/* Data start sector */
  202a58:	eb01 030c 	add.w	r3, r1, ip
		if (fmt == FS_FAT32) {
  202a5c:	f1b9 0f03 	cmp.w	r9, #3
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
  202a60:	6165      	str	r5, [r4, #20]
		fs->volbase = bsect;							/* Volume start sector */
  202a62:	61e1      	str	r1, [r4, #28]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
  202a64:	6222      	str	r2, [r4, #32]
		fs->database = bsect + sysect;					/* Data start sector */
  202a66:	62a3      	str	r3, [r4, #40]	; 0x28
		if (fmt == FS_FAT32) {
  202a68:	d16f      	bne.n	202b4a <mount_volume+0x25e>
	rv = rv << 8 | ptr[0];
  202a6a:	f894 205b 	ldrb.w	r2, [r4, #91]	; 0x5b
  202a6e:	f894 305a 	ldrb.w	r3, [r4, #90]	; 0x5a
  202a72:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
  202a76:	ea48 0803 	orr.w	r8, r8, r3
  202a7a:	fa0f f388 	sxth.w	r3, r8
  202a7e:	2b00      	cmp	r3, #0
  202a80:	d15c      	bne.n	202b3c <mount_volume+0x250>
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
  202a82:	00ad      	lsls	r5, r5, #2
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
  202a84:	f104 005c 	add.w	r0, r4, #92	; 0x5c
  202a88:	f7fe fbf0 	bl	20126c <ld_dword>
  202a8c:	6260      	str	r0, [r4, #36]	; 0x24
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
  202a8e:	f205 15ff 	addw	r5, r5, #511	; 0x1ff
  202a92:	ebb6 2f55 	cmp.w	r6, r5, lsr #9
  202a96:	d351      	bcc.n	202b3c <mount_volume+0x250>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
  202a98:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
		if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
  202a9c:	f1b9 0f03 	cmp.w	r9, #3
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
  202aa0:	e9c4 3303 	strd	r3, r3, [r4, #12]
		fs->fsi_flag = 0x80;
  202aa4:	f04f 0380 	mov.w	r3, #128	; 0x80
  202aa8:	7123      	strb	r3, [r4, #4]
		if (fmt == FS_FAT32				/* Allow to update FSInfo only if BPB_FSInfo32 == 1 */
  202aaa:	d12f      	bne.n	202b0c <mount_volume+0x220>
	rv = rv << 8 | ptr[0];
  202aac:	f894 2061 	ldrb.w	r2, [r4, #97]	; 0x61
  202ab0:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
  202ab4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			&& ld_word(fs->win + BPB_FSInfo32) == 1
  202ab8:	2b01      	cmp	r3, #1
  202aba:	d127      	bne.n	202b0c <mount_volume+0x220>
			&& move_window(fs, bsect + 1) == FR_OK)
  202abc:	3101      	adds	r1, #1
  202abe:	4620      	mov	r0, r4
  202ac0:	f7ff fd08 	bl	2024d4 <move_window>
  202ac4:	bb10      	cbnz	r0, 202b0c <mount_volume+0x220>
	rv = rv << 8 | ptr[0];
  202ac6:	f894 222f 	ldrb.w	r2, [r4, #559]	; 0x22f
  202aca:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
			fs->fsi_flag = 0;
  202ace:	7120      	strb	r0, [r4, #4]
	rv = rv << 8 | ptr[0];
  202ad0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSInfo data if available */
  202ad4:	f64a 2255 	movw	r2, #43605	; 0xaa55
  202ad8:	4293      	cmp	r3, r2
  202ada:	d117      	bne.n	202b0c <mount_volume+0x220>
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
  202adc:	f104 0030 	add.w	r0, r4, #48	; 0x30
  202ae0:	f7fe fbc4 	bl	20126c <ld_dword>
  202ae4:	4b2b      	ldr	r3, [pc, #172]	; (202b94 <mount_volume+0x2a8>)
  202ae6:	4298      	cmp	r0, r3
  202ae8:	d110      	bne.n	202b0c <mount_volume+0x220>
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
  202aea:	f504 7005 	add.w	r0, r4, #532	; 0x214
  202aee:	f7fe fbbd 	bl	20126c <ld_dword>
  202af2:	4b29      	ldr	r3, [pc, #164]	; (202b98 <mount_volume+0x2ac>)
  202af4:	4298      	cmp	r0, r3
  202af6:	d109      	bne.n	202b0c <mount_volume+0x220>
				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
  202af8:	f504 7006 	add.w	r0, r4, #536	; 0x218
  202afc:	f7fe fbb6 	bl	20126c <ld_dword>
  202b00:	6120      	str	r0, [r4, #16]
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
  202b02:	f504 7007 	add.w	r0, r4, #540	; 0x21c
  202b06:	f7fe fbb1 	bl	20126c <ld_dword>
  202b0a:	60e0      	str	r0, [r4, #12]
	fs->id = ++Fsid;		/* Volume mount ID */
  202b0c:	4a23      	ldr	r2, [pc, #140]	; (202b9c <mount_volume+0x2b0>)
	return FR_OK;
  202b0e:	2500      	movs	r5, #0
	fs->fs_type = (BYTE)fmt;/* FAT sub-type */
  202b10:	f884 9000 	strb.w	r9, [r4]
	fs->id = ++Fsid;		/* Volume mount ID */
  202b14:	8813      	ldrh	r3, [r2, #0]
  202b16:	3301      	adds	r3, #1
  202b18:	b29b      	uxth	r3, r3
  202b1a:	8013      	strh	r3, [r2, #0]
  202b1c:	80e3      	strh	r3, [r4, #6]
	return FR_OK;
  202b1e:	e706      	b.n	20292e <mount_volume+0x42>
		fmt = mbr_pt[i] ? check_fs(fs, mbr_pt[i]) : 3;	/* Check if the partition is FAT */
  202b20:	2003      	movs	r0, #3
	} while (part == 0 && fmt >= 2 && ++i < 4);
  202b22:	3501      	adds	r5, #1
  202b24:	2d04      	cmp	r5, #4
  202b26:	f47f af28 	bne.w	20297a <mount_volume+0x8e>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
  202b2a:	2804      	cmp	r0, #4
  202b2c:	d106      	bne.n	202b3c <mount_volume+0x250>
  202b2e:	2501      	movs	r5, #1
  202b30:	e6fd      	b.n	20292e <mount_volume+0x42>
  202b32:	2804      	cmp	r0, #4
  202b34:	d0fb      	beq.n	202b2e <mount_volume+0x242>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
  202b36:	2801      	cmp	r0, #1
  202b38:	f67f af2a 	bls.w	202990 <mount_volume+0xa4>
  202b3c:	250d      	movs	r5, #13
  202b3e:	e6f6      	b.n	20292e <mount_volume+0x42>
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
  202b40:	f104 0050 	add.w	r0, r4, #80	; 0x50
  202b44:	f7fe fb92 	bl	20126c <ld_dword>
  202b48:	e764      	b.n	202a14 <mount_volume+0x128>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  202b4a:	2f00      	cmp	r7, #0
  202b4c:	d0f6      	beq.n	202b3c <mount_volume+0x250>
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  202b4e:	f1b9 0f02 	cmp.w	r9, #2
  202b52:	ea4f 0345 	mov.w	r3, r5, lsl #1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
  202b56:	4472      	add	r2, lr
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  202b58:	bf1a      	itte	ne
  202b5a:	195b      	addne	r3, r3, r5
  202b5c:	f005 0501 	andne.w	r5, r5, #1
  202b60:	461d      	moveq	r5, r3
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
  202b62:	6262      	str	r2, [r4, #36]	; 0x24
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  202b64:	bf18      	it	ne
  202b66:	eb05 0553 	addne.w	r5, r5, r3, lsr #1
  202b6a:	e790      	b.n	202a8e <mount_volume+0x1a2>
	if (vol < 0) return FR_INVALID_DRIVE;
  202b6c:	250b      	movs	r5, #11
  202b6e:	e6de      	b.n	20292e <mount_volume+0x42>
	if (!fs) return FR_NOT_ENABLED;		/* Is the filesystem object available? */
  202b70:	250c      	movs	r5, #12
  202b72:	e6dc      	b.n	20292e <mount_volume+0x42>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
  202b74:	2503      	movs	r5, #3
  202b76:	e6da      	b.n	20292e <mount_volume+0x42>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
  202b78:	f640 79f5 	movw	r9, #4085	; 0xff5
  202b7c:	4548      	cmp	r0, r9
  202b7e:	bf8c      	ite	hi
  202b80:	f04f 0902 	movhi.w	r9, #2
  202b84:	f04f 0901 	movls.w	r9, #1
  202b88:	e764      	b.n	202a54 <mount_volume+0x168>
  202b8a:	bf00      	nop
  202b8c:	20000808 	.word	0x20000808
  202b90:	0ffffff5 	.word	0x0ffffff5
  202b94:	41615252 	.word	0x41615252
  202b98:	61417272 	.word	0x61417272
  202b9c:	2000080c 	.word	0x2000080c

00202ba0 <fatfsMount>:
{
  202ba0:	b530      	push	{r4, r5, lr}
	if (!fatfs_mounted) {
  202ba2:	4d14      	ldr	r5, [pc, #80]	; (202bf4 <fatfsMount+0x54>)
{
  202ba4:	b085      	sub	sp, #20
	if (!fatfs_mounted) {
  202ba6:	f995 4000 	ldrsb.w	r4, [r5]
  202baa:	b11c      	cbz	r4, 202bb4 <fatfsMount+0x14>
	return gFalse;
  202bac:	2400      	movs	r4, #0
}
  202bae:	4620      	mov	r0, r4
  202bb0:	b005      	add	sp, #20
  202bb2:	bd30      	pop	{r4, r5, pc}
		ferr = f_mount(&fatfs_fs, drive, 1);
  202bb4:	4b10      	ldr	r3, [pc, #64]	; (202bf8 <fatfsMount+0x58>)
  202bb6:	9001      	str	r0, [sp, #4]
	const TCHAR *rp = path;
  202bb8:	e9cd 0302 	strd	r0, r3, [sp, #8]
	vol = get_ldnumber(&rp);
  202bbc:	a802      	add	r0, sp, #8
  202bbe:	f7fe fb0e 	bl	2011de <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
  202bc2:	2800      	cmp	r0, #0
  202bc4:	dbf3      	blt.n	202bae <fatfsMount+0xe>
	cfs = FatFs[vol];					/* Pointer to fs object */
  202bc6:	4b0d      	ldr	r3, [pc, #52]	; (202bfc <fatfsMount+0x5c>)
  202bc8:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
	if (cfs) {
  202bcc:	b102      	cbz	r2, 202bd0 <fatfsMount+0x30>
		cfs->fs_type = 0;				/* Clear old fs object */
  202bce:	7014      	strb	r4, [r2, #0]
	if (fs) {
  202bd0:	9a03      	ldr	r2, [sp, #12]
  202bd2:	b10a      	cbz	r2, 202bd8 <fatfsMount+0x38>
		fs->fs_type = 0;				/* Clear new fs object */
  202bd4:	2100      	movs	r1, #0
  202bd6:	7011      	strb	r1, [r2, #0]
	FatFs[vol] = fs;					/* Register new fs object */
  202bd8:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
	res = mount_volume(&path, &fs, 0);	/* Force mounted the volume */
  202bdc:	a903      	add	r1, sp, #12
  202bde:	2200      	movs	r2, #0
  202be0:	a801      	add	r0, sp, #4
  202be2:	f7ff fe83 	bl	2028ec <mount_volume>
		if (ferr !=  FR_OK)
  202be6:	2800      	cmp	r0, #0
  202be8:	d1e0      	bne.n	202bac <fatfsMount+0xc>
		fatfs_mounted = gTrue;
  202bea:	23ff      	movs	r3, #255	; 0xff
		return gTrue;
  202bec:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		fatfs_mounted = gTrue;
  202bf0:	702b      	strb	r3, [r5, #0]
		return gTrue;
  202bf2:	e7dc      	b.n	202bae <fatfsMount+0xe>
  202bf4:	20001bf8 	.word	0x20001bf8
  202bf8:	200019c8 	.word	0x200019c8
  202bfc:	20000808 	.word	0x20000808

00202c00 <put_fat>:
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
  202c00:	2901      	cmp	r1, #1
{
  202c02:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  202c06:	4606      	mov	r6, r0
  202c08:	460c      	mov	r4, r1
  202c0a:	4617      	mov	r7, r2
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
  202c0c:	d974      	bls.n	202cf8 <put_fat+0xf8>
  202c0e:	6943      	ldr	r3, [r0, #20]
  202c10:	428b      	cmp	r3, r1
  202c12:	d971      	bls.n	202cf8 <put_fat+0xf8>
		switch (fs->fs_type) {
  202c14:	7803      	ldrb	r3, [r0, #0]
  202c16:	2b02      	cmp	r3, #2
  202c18:	d040      	beq.n	202c9c <put_fat+0x9c>
  202c1a:	2b03      	cmp	r3, #3
  202c1c:	d051      	beq.n	202cc2 <put_fat+0xc2>
  202c1e:	2b01      	cmp	r3, #1
  202c20:	d16a      	bne.n	202cf8 <put_fat+0xf8>
			bc = (UINT)clst; bc += bc / 2;	/* bc: byte offset of the entry */
  202c22:	eb01 0851 	add.w	r8, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  202c26:	6a01      	ldr	r1, [r0, #32]
  202c28:	eb01 2158 	add.w	r1, r1, r8, lsr #9
  202c2c:	f7ff fc52 	bl	2024d4 <move_window>
  202c30:	4605      	mov	r5, r0
			if (res != FR_OK) break;
  202c32:	bb40      	cbnz	r0, 202c86 <put_fat+0x86>
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Update 1st byte */
  202c34:	f014 0401 	ands.w	r4, r4, #1
			p = fs->win + bc++ % SS(fs);
  202c38:	f106 0930 	add.w	r9, r6, #48	; 0x30
  202c3c:	f108 0a01 	add.w	sl, r8, #1
  202c40:	f3c8 0808 	ubfx	r8, r8, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Update 1st byte */
  202c44:	bf08      	it	eq
  202c46:	b2fb      	uxtbeq	r3, r7
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  202c48:	4630      	mov	r0, r6
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;		/* Update 1st byte */
  202c4a:	bf1f      	itttt	ne
  202c4c:	f819 3008 	ldrbne.w	r3, [r9, r8]
  202c50:	f003 020f 	andne.w	r2, r3, #15
  202c54:	013b      	lslne	r3, r7, #4
  202c56:	f003 03f0 	andne.w	r3, r3, #240	; 0xf0
  202c5a:	bf18      	it	ne
  202c5c:	4313      	orrne	r3, r2
  202c5e:	f809 3008 	strb.w	r3, [r9, r8]
			fs->wflag = 1;
  202c62:	2301      	movs	r3, #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  202c64:	6a31      	ldr	r1, [r6, #32]
			fs->wflag = 1;
  202c66:	70f3      	strb	r3, [r6, #3]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  202c68:	eb01 215a 	add.w	r1, r1, sl, lsr #9
  202c6c:	f7ff fc32 	bl	2024d4 <move_window>
			if (res != FR_OK) break;
  202c70:	4605      	mov	r5, r0
  202c72:	b940      	cbnz	r0, 202c86 <put_fat+0x86>
			p = fs->win + bc % SS(fs);
  202c74:	f3ca 0a08 	ubfx	sl, sl, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Update 2nd byte */
  202c78:	b144      	cbz	r4, 202c8c <put_fat+0x8c>
  202c7a:	f3c7 1707 	ubfx	r7, r7, #4, #8
  202c7e:	f809 700a 	strb.w	r7, [r9, sl]
			fs->wflag = 1;
  202c82:	2301      	movs	r3, #1
  202c84:	70f3      	strb	r3, [r6, #3]
}
  202c86:	4628      	mov	r0, r5
  202c88:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));	/* Update 2nd byte */
  202c8c:	f819 300a 	ldrb.w	r3, [r9, sl]
  202c90:	f3c7 2703 	ubfx	r7, r7, #8, #4
  202c94:	f023 030f 	bic.w	r3, r3, #15
  202c98:	431f      	orrs	r7, r3
  202c9a:	e7f0      	b.n	202c7e <put_fat+0x7e>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
  202c9c:	6a01      	ldr	r1, [r0, #32]
  202c9e:	eb01 2114 	add.w	r1, r1, r4, lsr #8
  202ca2:	f7ff fc17 	bl	2024d4 <move_window>
			if (res != FR_OK) break;
  202ca6:	4605      	mov	r5, r0
  202ca8:	2800      	cmp	r0, #0
  202caa:	d1ec      	bne.n	202c86 <put_fat+0x86>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
  202cac:	0064      	lsls	r4, r4, #1
  202cae:	f106 0330 	add.w	r3, r6, #48	; 0x30
  202cb2:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
	*ptr++ = (BYTE)val; val >>= 8;
  202cb6:	551f      	strb	r7, [r3, r4]
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);	/* Simple WORD array */
  202cb8:	1918      	adds	r0, r3, r4
	*ptr++ = (BYTE)val; val >>= 8;
  202cba:	f3c7 2707 	ubfx	r7, r7, #8, #8
	*ptr++ = (BYTE)val;
  202cbe:	7047      	strb	r7, [r0, #1]
			fs->wflag = 1;
  202cc0:	e7df      	b.n	202c82 <put_fat+0x82>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
  202cc2:	6a01      	ldr	r1, [r0, #32]
  202cc4:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
  202cc8:	f7ff fc04 	bl	2024d4 <move_window>
			if (res != FR_OK) break;
  202ccc:	4605      	mov	r5, r0
  202cce:	2800      	cmp	r0, #0
  202cd0:	d1d9      	bne.n	202c86 <put_fat+0x86>
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
  202cd2:	00a4      	lsls	r4, r4, #2
  202cd4:	f106 0330 	add.w	r3, r6, #48	; 0x30
  202cd8:	f027 4770 	bic.w	r7, r7, #4026531840	; 0xf0000000
  202cdc:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
  202ce0:	441c      	add	r4, r3
  202ce2:	4620      	mov	r0, r4
  202ce4:	f7fe fac2 	bl	20126c <ld_dword>
  202ce8:	f000 4070 	and.w	r0, r0, #4026531840	; 0xf0000000
			st_dword(fs->win + clst * 4 % SS(fs), val);
  202cec:	ea47 0100 	orr.w	r1, r7, r0
  202cf0:	4620      	mov	r0, r4
  202cf2:	f7fe fab3 	bl	20125c <st_dword>
  202cf6:	e7c4      	b.n	202c82 <put_fat+0x82>
		switch (fs->fs_type) {
  202cf8:	2502      	movs	r5, #2
  202cfa:	e7c4      	b.n	202c86 <put_fat+0x86>

00202cfc <remove_chain.constprop.0>:
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
  202cfc:	2901      	cmp	r1, #1
static FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
  202cfe:	b573      	push	{r0, r1, r4, r5, r6, lr}
  202d00:	4606      	mov	r6, r0
  202d02:	460c      	mov	r4, r1
	FATFS *fs = obj->fs;
  202d04:	6805      	ldr	r5, [r0, #0]
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
  202d06:	d925      	bls.n	202d54 <remove_chain.constprop.0+0x58>
  202d08:	696b      	ldr	r3, [r5, #20]
  202d0a:	4299      	cmp	r1, r3
  202d0c:	d222      	bcs.n	202d54 <remove_chain.constprop.0+0x58>
  202d0e:	4621      	mov	r1, r4
		nxt = get_fat(obj, clst);			/* Get cluster status */
  202d10:	6830      	ldr	r0, [r6, #0]
  202d12:	9401      	str	r4, [sp, #4]
  202d14:	f7ff fbfb 	bl	20250e <get_fat.isra.0>
		if (nxt == 0) break;				/* Empty cluster? */
  202d18:	9901      	ldr	r1, [sp, #4]
  202d1a:	4604      	mov	r4, r0
  202d1c:	b910      	cbnz	r0, 202d24 <remove_chain.constprop.0+0x28>
	return FR_OK;
  202d1e:	2000      	movs	r0, #0
}
  202d20:	b002      	add	sp, #8
  202d22:	bd70      	pop	{r4, r5, r6, pc}
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
  202d24:	2801      	cmp	r0, #1
  202d26:	d015      	beq.n	202d54 <remove_chain.constprop.0+0x58>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
  202d28:	1c43      	adds	r3, r0, #1
  202d2a:	d015      	beq.n	202d58 <remove_chain.constprop.0+0x5c>
			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
  202d2c:	2200      	movs	r2, #0
  202d2e:	4628      	mov	r0, r5
  202d30:	f7ff ff66 	bl	202c00 <put_fat>
			if (res != FR_OK) return res;
  202d34:	2800      	cmp	r0, #0
  202d36:	d1f3      	bne.n	202d20 <remove_chain.constprop.0+0x24>
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
  202d38:	e9d5 3204 	ldrd	r3, r2, [r5, #16]
  202d3c:	1e91      	subs	r1, r2, #2
  202d3e:	428b      	cmp	r3, r1
  202d40:	d205      	bcs.n	202d4e <remove_chain.constprop.0+0x52>
			fs->free_clst++;
  202d42:	3301      	adds	r3, #1
  202d44:	612b      	str	r3, [r5, #16]
			fs->fsi_flag |= 1;
  202d46:	792b      	ldrb	r3, [r5, #4]
  202d48:	f043 0301 	orr.w	r3, r3, #1
  202d4c:	712b      	strb	r3, [r5, #4]
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
  202d4e:	4294      	cmp	r4, r2
  202d50:	d3dd      	bcc.n	202d0e <remove_chain.constprop.0+0x12>
  202d52:	e7e4      	b.n	202d1e <remove_chain.constprop.0+0x22>
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
  202d54:	2002      	movs	r0, #2
  202d56:	e7e3      	b.n	202d20 <remove_chain.constprop.0+0x24>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
  202d58:	2001      	movs	r0, #1
  202d5a:	e7e1      	b.n	202d20 <remove_chain.constprop.0+0x24>

00202d5c <create_chain>:
{
  202d5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  202d60:	4680      	mov	r8, r0
	FATFS *fs = obj->fs;
  202d62:	6805      	ldr	r5, [r0, #0]
	if (clst == 0) {	/* Create a new chain */
  202d64:	460f      	mov	r7, r1
  202d66:	b949      	cbnz	r1, 202d7c <create_chain+0x20>
		scl = fs->last_clst;				/* Suggested cluster to start to find */
  202d68:	68ee      	ldr	r6, [r5, #12]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
  202d6a:	b1c6      	cbz	r6, 202d9e <create_chain+0x42>
  202d6c:	696b      	ldr	r3, [r5, #20]
  202d6e:	42b3      	cmp	r3, r6
  202d70:	bf98      	it	ls
  202d72:	2601      	movls	r6, #1
	if (fs->free_clst == 0) return 0;		/* No free cluster */
  202d74:	692b      	ldr	r3, [r5, #16]
  202d76:	b9a3      	cbnz	r3, 202da2 <create_chain+0x46>
  202d78:	2400      	movs	r4, #0
  202d7a:	e006      	b.n	202d8a <create_chain+0x2e>
		cs = get_fat(obj, clst);			/* Check the cluster status */
  202d7c:	4628      	mov	r0, r5
  202d7e:	f7ff fbc6 	bl	20250e <get_fat.isra.0>
		if (cs < 2) return 1;				/* Test for insanity */
  202d82:	2801      	cmp	r0, #1
		cs = get_fat(obj, clst);			/* Check the cluster status */
  202d84:	4604      	mov	r4, r0
		if (cs < 2) return 1;				/* Test for insanity */
  202d86:	d803      	bhi.n	202d90 <create_chain+0x34>
  202d88:	2401      	movs	r4, #1
}
  202d8a:	4620      	mov	r0, r4
  202d8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (cs == 0xFFFFFFFF) return cs;	/* Test for disk error */
  202d90:	1c42      	adds	r2, r0, #1
  202d92:	d051      	beq.n	202e38 <create_chain+0xdc>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
  202d94:	696b      	ldr	r3, [r5, #20]
  202d96:	4283      	cmp	r3, r0
  202d98:	d8f7      	bhi.n	202d8a <create_chain+0x2e>
  202d9a:	463e      	mov	r6, r7
  202d9c:	e7ea      	b.n	202d74 <create_chain+0x18>
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
  202d9e:	2601      	movs	r6, #1
  202da0:	e7e8      	b.n	202d74 <create_chain+0x18>
		if (scl == clst) {						/* Stretching an existing chain? */
  202da2:	42be      	cmp	r6, r7
  202da4:	d115      	bne.n	202dd2 <create_chain+0x76>
			if (ncl >= fs->n_fatent) ncl = 2;
  202da6:	696b      	ldr	r3, [r5, #20]
  202da8:	1c74      	adds	r4, r6, #1
			cs = get_fat(obj, ncl);				/* Get next cluster status */
  202daa:	f8d8 0000 	ldr.w	r0, [r8]
			if (ncl >= fs->n_fatent) ncl = 2;
  202dae:	42a3      	cmp	r3, r4
  202db0:	bf98      	it	ls
  202db2:	2402      	movls	r4, #2
			cs = get_fat(obj, ncl);				/* Get next cluster status */
  202db4:	4621      	mov	r1, r4
  202db6:	f7ff fbaa 	bl	20250e <get_fat.isra.0>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
  202dba:	2801      	cmp	r0, #1
  202dbc:	d0e4      	beq.n	202d88 <create_chain+0x2c>
  202dbe:	1c43      	adds	r3, r0, #1
  202dc0:	d03a      	beq.n	202e38 <create_chain+0xdc>
			if (cs != 0) {						/* Not free? */
  202dc2:	b1d8      	cbz	r0, 202dfc <create_chain+0xa0>
				cs = fs->last_clst;				/* Start at suggested cluster if it is valid */
  202dc4:	68eb      	ldr	r3, [r5, #12]
				if (cs >= 2 && cs < fs->n_fatent) scl = cs;
  202dc6:	2b01      	cmp	r3, #1
  202dc8:	d903      	bls.n	202dd2 <create_chain+0x76>
  202dca:	696a      	ldr	r2, [r5, #20]
  202dcc:	4293      	cmp	r3, r2
  202dce:	bf38      	it	cc
  202dd0:	461e      	movcc	r6, r3
  202dd2:	4634      	mov	r4, r6
				ncl++;							/* Next cluster */
  202dd4:	3401      	adds	r4, #1
				if (ncl >= fs->n_fatent) {		/* Check wrap-around */
  202dd6:	696b      	ldr	r3, [r5, #20]
  202dd8:	42a3      	cmp	r3, r4
  202dda:	d802      	bhi.n	202de2 <create_chain+0x86>
					if (ncl > scl) return 0;	/* No free cluster found? */
  202ddc:	2e01      	cmp	r6, #1
  202dde:	d9cb      	bls.n	202d78 <create_chain+0x1c>
					ncl = 2;
  202de0:	2402      	movs	r4, #2
				cs = get_fat(obj, ncl);			/* Get the cluster status */
  202de2:	4621      	mov	r1, r4
  202de4:	f8d8 0000 	ldr.w	r0, [r8]
  202de8:	f7ff fb91 	bl	20250e <get_fat.isra.0>
				if (cs == 0) break;				/* Found a free cluster? */
  202dec:	b140      	cbz	r0, 202e00 <create_chain+0xa4>
				if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* Test for error */
  202dee:	2801      	cmp	r0, #1
  202df0:	d0ca      	beq.n	202d88 <create_chain+0x2c>
  202df2:	3001      	adds	r0, #1
  202df4:	d020      	beq.n	202e38 <create_chain+0xdc>
				if (ncl == scl) return 0;		/* No free cluster found? */
  202df6:	42b4      	cmp	r4, r6
  202df8:	d1ec      	bne.n	202dd4 <create_chain+0x78>
  202dfa:	e7bd      	b.n	202d78 <create_chain+0x1c>
		if (ncl == 0) {	/* The new cluster cannot be contiguous and find another fragment */
  202dfc:	2c00      	cmp	r4, #0
  202dfe:	d0e8      	beq.n	202dd2 <create_chain+0x76>
		res = put_fat(fs, ncl, 0xFFFFFFFF);		/* Mark the new cluster 'EOC' */
  202e00:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  202e04:	4621      	mov	r1, r4
  202e06:	4628      	mov	r0, r5
  202e08:	f7ff fefa 	bl	202c00 <put_fat>
		if (res == FR_OK && clst != 0) {
  202e0c:	b990      	cbnz	r0, 202e34 <create_chain+0xd8>
  202e0e:	b957      	cbnz	r7, 202e26 <create_chain+0xca>
		fs->last_clst = ncl;
  202e10:	60ec      	str	r4, [r5, #12]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
  202e12:	e9d5 3204 	ldrd	r3, r2, [r5, #16]
  202e16:	3a02      	subs	r2, #2
  202e18:	4293      	cmp	r3, r2
  202e1a:	d910      	bls.n	202e3e <create_chain+0xe2>
		fs->fsi_flag |= 1;
  202e1c:	792b      	ldrb	r3, [r5, #4]
  202e1e:	f043 0301 	orr.w	r3, r3, #1
  202e22:	712b      	strb	r3, [r5, #4]
  202e24:	e7b1      	b.n	202d8a <create_chain+0x2e>
			res = put_fat(fs, clst, ncl);		/* Link it from the previous one if needed */
  202e26:	4622      	mov	r2, r4
  202e28:	4639      	mov	r1, r7
  202e2a:	4628      	mov	r0, r5
  202e2c:	f7ff fee8 	bl	202c00 <put_fat>
	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
  202e30:	2800      	cmp	r0, #0
  202e32:	d0ed      	beq.n	202e10 <create_chain+0xb4>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
  202e34:	2801      	cmp	r0, #1
  202e36:	d1a7      	bne.n	202d88 <create_chain+0x2c>
  202e38:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  202e3c:	e7a5      	b.n	202d8a <create_chain+0x2e>
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
  202e3e:	3b01      	subs	r3, #1
  202e40:	612b      	str	r3, [r5, #16]
  202e42:	e7eb      	b.n	202e1c <create_chain+0xc0>

00202e44 <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File pointer from top of file */
)
{
  202e44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  202e48:	b085      	sub	sp, #20
  202e4a:	460d      	mov	r5, r1
  202e4c:	4604      	mov	r4, r0
#if FF_USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, tlen, ulen, *tbl;
	LBA_t dsc;
#endif

	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
  202e4e:	a903      	add	r1, sp, #12
  202e50:	f7fe f9ae 	bl	2011b0 <validate>
	if (res == FR_OK) res = (FRESULT)fp->err;
  202e54:	4606      	mov	r6, r0
  202e56:	b9e8      	cbnz	r0, 202e94 <f_lseek+0x50>
  202e58:	7c66      	ldrb	r6, [r4, #17]
#if FF_FS_EXFAT && !FF_FS_READONLY
	if (res == FR_OK && fs->fs_type == FS_EXFAT) {
		res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
	}
#endif
	if (res != FR_OK) LEAVE_FF(fs, res);
  202e5a:	b9de      	cbnz	r6, 202e94 <f_lseek+0x50>

#if FF_USE_FASTSEEK
	if (fp->cltbl) {	/* Fast seek */
  202e5c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  202e5e:	2b00      	cmp	r3, #0
  202e60:	d07b      	beq.n	202f5a <f_lseek+0x116>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
  202e62:	1c6a      	adds	r2, r5, #1
  202e64:	d139      	bne.n	202eda <f_lseek+0x96>
			tbl = fp->cltbl;
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
  202e66:	461d      	mov	r5, r3
			cl = fp->obj.sclust;		/* Origin of the chain */
  202e68:	f8d4 8008 	ldr.w	r8, [r4, #8]
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
  202e6c:	2702      	movs	r7, #2
  202e6e:	f855 bb04 	ldr.w	fp, [r5], #4
			if (cl != 0) {
  202e72:	f1b8 0f00 	cmp.w	r8, #0
  202e76:	d028      	beq.n	202eca <f_lseek+0x86>
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
					} while (cl == pcl + 1);
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
						*tbl++ = ncl; *tbl++ = tcl;
					}
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
  202e78:	4640      	mov	r0, r8
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
  202e7a:	f04f 0a00 	mov.w	sl, #0
						cl = get_fat(&fp->obj, cl);
  202e7e:	4601      	mov	r1, r0
  202e80:	4681      	mov	r9, r0
  202e82:	6820      	ldr	r0, [r4, #0]
						pcl = cl; ncl++;
  202e84:	f10a 0a01 	add.w	sl, sl, #1
						cl = get_fat(&fp->obj, cl);
  202e88:	f7ff fb41 	bl	20250e <get_fat.isra.0>
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
  202e8c:	2801      	cmp	r0, #1
  202e8e:	d807      	bhi.n	202ea0 <f_lseek+0x5c>
  202e90:	2602      	movs	r6, #2
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
  202e92:	7466      	strb	r6, [r4, #17]
			fp->sect = nsect;
		}
	}

	LEAVE_FF(fs, res);
}
  202e94:	4630      	mov	r0, r6
  202e96:	b005      	add	sp, #20
  202e98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
  202e9c:	4680      	mov	r8, r0
  202e9e:	e7eb      	b.n	202e78 <f_lseek+0x34>
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
  202ea0:	1c43      	adds	r3, r0, #1
  202ea2:	d101      	bne.n	202ea8 <f_lseek+0x64>
  202ea4:	2601      	movs	r6, #1
  202ea6:	e7f4      	b.n	202e92 <f_lseek+0x4e>
					} while (cl == pcl + 1);
  202ea8:	f109 0901 	add.w	r9, r9, #1
  202eac:	4581      	cmp	r9, r0
  202eae:	d0e6      	beq.n	202e7e <f_lseek+0x3a>
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
  202eb0:	3702      	adds	r7, #2
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
  202eb2:	45bb      	cmp	fp, r7
						*tbl++ = ncl; *tbl++ = tcl;
  202eb4:	bf21      	itttt	cs
  202eb6:	462b      	movcs	r3, r5
  202eb8:	f843 ab08 	strcs.w	sl, [r3], #8
  202ebc:	f8c5 8004 	strcs.w	r8, [r5, #4]
  202ec0:	461d      	movcs	r5, r3
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
  202ec2:	9b03      	ldr	r3, [sp, #12]
  202ec4:	695b      	ldr	r3, [r3, #20]
  202ec6:	4283      	cmp	r3, r0
  202ec8:	d8e8      	bhi.n	202e9c <f_lseek+0x58>
			*fp->cltbl = ulen;	/* Number of items used */
  202eca:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			if (ulen <= tlen) {
  202ecc:	455f      	cmp	r7, fp
			*fp->cltbl = ulen;	/* Number of items used */
  202ece:	601f      	str	r7, [r3, #0]
			if (ulen <= tlen) {
  202ed0:	f200 80c3 	bhi.w	20305a <f_lseek+0x216>
				*tbl = 0;		/* Terminate table */
  202ed4:	2300      	movs	r3, #0
  202ed6:	602b      	str	r3, [r5, #0]
  202ed8:	e7dc      	b.n	202e94 <f_lseek+0x50>
			if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
  202eda:	68e7      	ldr	r7, [r4, #12]
  202edc:	42af      	cmp	r7, r5
  202ede:	bf28      	it	cs
  202ee0:	462f      	movcs	r7, r5
			fp->fptr = ofs;				/* Set file pointer */
  202ee2:	6167      	str	r7, [r4, #20]
			if (ofs > 0) {
  202ee4:	2f00      	cmp	r7, #0
  202ee6:	d0d5      	beq.n	202e94 <f_lseek+0x50>
				fp->clust = clmt_clust(fp, ofs - 1);
  202ee8:	1e7d      	subs	r5, r7, #1
  202eea:	4620      	mov	r0, r4
  202eec:	4629      	mov	r1, r5
  202eee:	f7fe f98b 	bl	201208 <clmt_clust>
				dsc = clst2sect(fs, fp->clust);
  202ef2:	f8dd 800c 	ldr.w	r8, [sp, #12]
				fp->clust = clmt_clust(fp, ofs - 1);
  202ef6:	4601      	mov	r1, r0
  202ef8:	61a0      	str	r0, [r4, #24]
				dsc = clst2sect(fs, fp->clust);
  202efa:	4640      	mov	r0, r8
  202efc:	f7fe f995 	bl	20122a <clst2sect>
				if (dsc == 0) ABORT(fs, FR_INT_ERR);
  202f00:	2800      	cmp	r0, #0
  202f02:	d0c5      	beq.n	202e90 <f_lseek+0x4c>
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
  202f04:	f3c7 0708 	ubfx	r7, r7, #0, #9
  202f08:	2f00      	cmp	r7, #0
  202f0a:	d0c3      	beq.n	202e94 <f_lseek+0x50>
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
  202f0c:	f8b8 100a 	ldrh.w	r1, [r8, #10]
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
  202f10:	69e2      	ldr	r2, [r4, #28]
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
  202f12:	3901      	subs	r1, #1
  202f14:	ea01 2155 	and.w	r1, r1, r5, lsr #9
  202f18:	180d      	adds	r5, r1, r0
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
  202f1a:	42aa      	cmp	r2, r5
  202f1c:	d0ba      	beq.n	202e94 <f_lseek+0x50>
					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
  202f1e:	f994 3010 	ldrsb.w	r3, [r4, #16]
  202f22:	f104 012c 	add.w	r1, r4, #44	; 0x2c
  202f26:	2b00      	cmp	r3, #0
  202f28:	da0c      	bge.n	202f44 <f_lseek+0x100>
						if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
  202f2a:	2301      	movs	r3, #1
  202f2c:	f898 0001 	ldrb.w	r0, [r8, #1]
  202f30:	9101      	str	r1, [sp, #4]
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
  202f32:	f7ff fa35 	bl	2023a0 <disk_write>
  202f36:	2800      	cmp	r0, #0
  202f38:	d1b4      	bne.n	202ea4 <f_lseek+0x60>
				fp->flag &= (BYTE)~FA_DIRTY;
  202f3a:	7c23      	ldrb	r3, [r4, #16]
  202f3c:	9901      	ldr	r1, [sp, #4]
  202f3e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  202f42:	7423      	strb	r3, [r4, #16]
			if (disk_read(fs->pdrv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
  202f44:	9803      	ldr	r0, [sp, #12]
  202f46:	2301      	movs	r3, #1
  202f48:	462a      	mov	r2, r5
  202f4a:	7840      	ldrb	r0, [r0, #1]
  202f4c:	f7ff faac 	bl	2024a8 <disk_read>
  202f50:	4606      	mov	r6, r0
  202f52:	2800      	cmp	r0, #0
  202f54:	d1a6      	bne.n	202ea4 <f_lseek+0x60>
			fp->sect = nsect;
  202f56:	61e5      	str	r5, [r4, #28]
  202f58:	e79c      	b.n	202e94 <f_lseek+0x50>
		if (ofs > fp->obj.objsize && (FF_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
  202f5a:	68e3      	ldr	r3, [r4, #12]
  202f5c:	42ab      	cmp	r3, r5
  202f5e:	d204      	bcs.n	202f6a <f_lseek+0x126>
  202f60:	7c22      	ldrb	r2, [r4, #16]
  202f62:	f012 0f02 	tst.w	r2, #2
  202f66:	bf08      	it	eq
  202f68:	461d      	moveq	r5, r3
		fp->fptr = nsect = 0;
  202f6a:	2200      	movs	r2, #0
		ifptr = fp->fptr;
  202f6c:	6963      	ldr	r3, [r4, #20]
		fp->fptr = nsect = 0;
  202f6e:	6162      	str	r2, [r4, #20]
		if (ofs > 0) {
  202f70:	b9ed      	cbnz	r5, 202fae <f_lseek+0x16a>
		fp->fptr = nsect = 0;
  202f72:	2500      	movs	r5, #0
		if (!FF_FS_READONLY && fp->fptr > fp->obj.objsize) {	/* Set file change flag if the file size is extended */
  202f74:	68e2      	ldr	r2, [r4, #12]
  202f76:	6963      	ldr	r3, [r4, #20]
  202f78:	4293      	cmp	r3, r2
			fp->flag |= FA_MODIFIED;
  202f7a:	bf84      	itt	hi
  202f7c:	7c22      	ldrbhi	r2, [r4, #16]
			fp->obj.objsize = fp->fptr;
  202f7e:	60e3      	strhi	r3, [r4, #12]
		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
  202f80:	f3c3 0308 	ubfx	r3, r3, #0, #9
			fp->flag |= FA_MODIFIED;
  202f84:	bf84      	itt	hi
  202f86:	f042 0240 	orrhi.w	r2, r2, #64	; 0x40
  202f8a:	7422      	strbhi	r2, [r4, #16]
		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
  202f8c:	2b00      	cmp	r3, #0
  202f8e:	d081      	beq.n	202e94 <f_lseek+0x50>
  202f90:	69e2      	ldr	r2, [r4, #28]
  202f92:	42aa      	cmp	r2, r5
  202f94:	f43f af7e 	beq.w	202e94 <f_lseek+0x50>
			if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
  202f98:	f994 3010 	ldrsb.w	r3, [r4, #16]
  202f9c:	f104 012c 	add.w	r1, r4, #44	; 0x2c
  202fa0:	2b00      	cmp	r3, #0
  202fa2:	dacf      	bge.n	202f44 <f_lseek+0x100>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
  202fa4:	9803      	ldr	r0, [sp, #12]
  202fa6:	2301      	movs	r3, #1
  202fa8:	9101      	str	r1, [sp, #4]
  202faa:	7840      	ldrb	r0, [r0, #1]
  202fac:	e7c1      	b.n	202f32 <f_lseek+0xee>
			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
  202fae:	9a03      	ldr	r2, [sp, #12]
  202fb0:	8957      	ldrh	r7, [r2, #10]
  202fb2:	027f      	lsls	r7, r7, #9
			if (ifptr > 0 &&
  202fb4:	b30b      	cbz	r3, 202ffa <f_lseek+0x1b6>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
  202fb6:	3b01      	subs	r3, #1
  202fb8:	1e6a      	subs	r2, r5, #1
  202fba:	fbb3 f1f7 	udiv	r1, r3, r7
  202fbe:	fbb2 f2f7 	udiv	r2, r2, r7
			if (ifptr > 0 &&
  202fc2:	428a      	cmp	r2, r1
  202fc4:	d319      	bcc.n	202ffa <f_lseek+0x1b6>
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
  202fc6:	427a      	negs	r2, r7
				clst = fp->clust;
  202fc8:	69a1      	ldr	r1, [r4, #24]
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
  202fca:	4013      	ands	r3, r2
				ofs -= fp->fptr;
  202fcc:	1aed      	subs	r5, r5, r3
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
  202fce:	6163      	str	r3, [r4, #20]
			if (clst != 0) {
  202fd0:	2900      	cmp	r1, #0
  202fd2:	d0ce      	beq.n	202f72 <f_lseek+0x12e>
				while (ofs > bcs) {						/* Cluster following loop */
  202fd4:	42bd      	cmp	r5, r7
  202fd6:	6963      	ldr	r3, [r4, #20]
  202fd8:	d81e      	bhi.n	203018 <f_lseek+0x1d4>
				fp->fptr += ofs;
  202fda:	6963      	ldr	r3, [r4, #20]
  202fdc:	442b      	add	r3, r5
  202fde:	6163      	str	r3, [r4, #20]
				if (ofs % SS(fs)) {
  202fe0:	f3c5 0308 	ubfx	r3, r5, #0, #9
  202fe4:	2b00      	cmp	r3, #0
  202fe6:	d0c4      	beq.n	202f72 <f_lseek+0x12e>
					nsect = clst2sect(fs, clst);	/* Current sector */
  202fe8:	9803      	ldr	r0, [sp, #12]
  202fea:	f7fe f91e 	bl	20122a <clst2sect>
					if (nsect == 0) ABORT(fs, FR_INT_ERR);
  202fee:	2800      	cmp	r0, #0
  202ff0:	f43f af4e 	beq.w	202e90 <f_lseek+0x4c>
					nsect += (DWORD)(ofs / SS(fs));
  202ff4:	eb00 2555 	add.w	r5, r0, r5, lsr #9
  202ff8:	e7bc      	b.n	202f74 <f_lseek+0x130>
				clst = fp->obj.sclust;					/* start from the first cluster */
  202ffa:	68a1      	ldr	r1, [r4, #8]
				if (clst == 0) {						/* If no cluster chain, create a new chain */
  202ffc:	b951      	cbnz	r1, 203014 <f_lseek+0x1d0>
					clst = create_chain(&fp->obj, 0);
  202ffe:	4620      	mov	r0, r4
  203000:	f7ff feac 	bl	202d5c <create_chain>
					if (clst == 1) ABORT(fs, FR_INT_ERR);
  203004:	2801      	cmp	r0, #1
					clst = create_chain(&fp->obj, 0);
  203006:	4601      	mov	r1, r0
					if (clst == 1) ABORT(fs, FR_INT_ERR);
  203008:	f43f af42 	beq.w	202e90 <f_lseek+0x4c>
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
  20300c:	1c48      	adds	r0, r1, #1
  20300e:	f43f af49 	beq.w	202ea4 <f_lseek+0x60>
					fp->obj.sclust = clst;
  203012:	60a1      	str	r1, [r4, #8]
				fp->clust = clst;
  203014:	61a1      	str	r1, [r4, #24]
  203016:	e7db      	b.n	202fd0 <f_lseek+0x18c>
					ofs -= bcs; fp->fptr += bcs;
  203018:	443b      	add	r3, r7
  20301a:	eba5 0807 	sub.w	r8, r5, r7
  20301e:	6163      	str	r3, [r4, #20]
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
  203020:	7c23      	ldrb	r3, [r4, #16]
  203022:	079a      	lsls	r2, r3, #30
  203024:	d506      	bpl.n	203034 <f_lseek+0x1f0>
						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
  203026:	4620      	mov	r0, r4
  203028:	f7ff fe98 	bl	202d5c <create_chain>
						if (clst == 0) {				/* Clip file size in case of disk full */
  20302c:	4605      	mov	r5, r0
  20302e:	b928      	cbnz	r0, 20303c <f_lseek+0x1f8>
  203030:	4601      	mov	r1, r0
  203032:	e7d2      	b.n	202fda <f_lseek+0x196>
						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
  203034:	6820      	ldr	r0, [r4, #0]
  203036:	f7ff fa6a 	bl	20250e <get_fat.isra.0>
  20303a:	4605      	mov	r5, r0
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
  20303c:	1c6b      	adds	r3, r5, #1
  20303e:	f43f af31 	beq.w	202ea4 <f_lseek+0x60>
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
  203042:	2d01      	cmp	r5, #1
  203044:	f67f af24 	bls.w	202e90 <f_lseek+0x4c>
  203048:	9b03      	ldr	r3, [sp, #12]
  20304a:	695b      	ldr	r3, [r3, #20]
  20304c:	42ab      	cmp	r3, r5
  20304e:	f67f af1f 	bls.w	202e90 <f_lseek+0x4c>
					fp->clust = clst;
  203052:	4629      	mov	r1, r5
  203054:	61a5      	str	r5, [r4, #24]
					ofs -= bcs; fp->fptr += bcs;
  203056:	4645      	mov	r5, r8
  203058:	e7bc      	b.n	202fd4 <f_lseek+0x190>
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
  20305a:	2611      	movs	r6, #17
  20305c:	e71a      	b.n	202e94 <f_lseek+0x50>

0020305e <fatfsSetPos>:
{
  20305e:	b508      	push	{r3, lr}
	ferr = f_lseek( (FIL*)f->obj, (DWORD)pos );
  203060:	6880      	ldr	r0, [r0, #8]
  203062:	f7ff feef 	bl	202e44 <f_lseek>
	if (ferr != FR_OK)
  203066:	fab0 f080 	clz	r0, r0
  20306a:	0940      	lsrs	r0, r0, #5
}
  20306c:	4240      	negs	r0, r0
  20306e:	bd08      	pop	{r3, pc}

00203070 <f_write>:
{
  203070:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  203074:	4699      	mov	r9, r3
  203076:	b085      	sub	sp, #20
	*bw = 0;	/* Clear write byte counter */
  203078:	2300      	movs	r3, #0
{
  20307a:	4688      	mov	r8, r1
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
  20307c:	a903      	add	r1, sp, #12
{
  20307e:	4604      	mov	r4, r0
	*bw = 0;	/* Clear write byte counter */
  203080:	f8c9 3000 	str.w	r3, [r9]
{
  203084:	4616      	mov	r6, r2
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
  203086:	f7fe f893 	bl	2011b0 <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
  20308a:	4605      	mov	r5, r0
  20308c:	bb50      	cbnz	r0, 2030e4 <f_write+0x74>
  20308e:	7c65      	ldrb	r5, [r4, #17]
  203090:	bb45      	cbnz	r5, 2030e4 <f_write+0x74>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
  203092:	7c23      	ldrb	r3, [r4, #16]
  203094:	079a      	lsls	r2, r3, #30
  203096:	f140 80af 	bpl.w	2031f8 <f_write+0x188>
	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
  20309a:	6963      	ldr	r3, [r4, #20]
		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
  20309c:	f104 0a2c 	add.w	sl, r4, #44	; 0x2c
	if ((!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
  2030a0:	42f3      	cmn	r3, r6
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
  2030a2:	bf28      	it	cs
  2030a4:	43de      	mvncs	r6, r3
	for ( ;  btw;							/* Repeat until all data written */
  2030a6:	b1ce      	cbz	r6, 2030dc <f_write+0x6c>
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
  2030a8:	6961      	ldr	r1, [r4, #20]
  2030aa:	f3c1 0308 	ubfx	r3, r1, #0, #9
  2030ae:	2b00      	cmp	r3, #0
  2030b0:	f040 8090 	bne.w	2031d4 <f_write+0x164>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
  2030b4:	9b03      	ldr	r3, [sp, #12]
  2030b6:	895f      	ldrh	r7, [r3, #10]
  2030b8:	3f01      	subs	r7, #1
			if (csect == 0) {				/* On the cluster boundary? */
  2030ba:	ea17 2751 	ands.w	r7, r7, r1, lsr #9
  2030be:	d124      	bne.n	20310a <f_write+0x9a>
				if (fp->fptr == 0) {		/* On the top of the file? */
  2030c0:	b931      	cbnz	r1, 2030d0 <f_write+0x60>
					clst = fp->obj.sclust;	/* Follow from the origin */
  2030c2:	68a0      	ldr	r0, [r4, #8]
					if (clst == 0) {		/* If no cluster is allocated, */
  2030c4:	b9a0      	cbnz	r0, 2030f0 <f_write+0x80>
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
  2030c6:	4601      	mov	r1, r0
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
  2030c8:	4620      	mov	r0, r4
  2030ca:	f7ff fe47 	bl	202d5c <create_chain>
  2030ce:	e004      	b.n	2030da <f_write+0x6a>
					if (fp->cltbl) {
  2030d0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  2030d2:	b15b      	cbz	r3, 2030ec <f_write+0x7c>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
  2030d4:	4620      	mov	r0, r4
  2030d6:	f7fe f897 	bl	201208 <clmt_clust>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
  2030da:	b948      	cbnz	r0, 2030f0 <f_write+0x80>
	fp->flag |= FA_MODIFIED;				/* Set file change flag */
  2030dc:	7c23      	ldrb	r3, [r4, #16]
  2030de:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  2030e2:	7423      	strb	r3, [r4, #16]
}
  2030e4:	4628      	mov	r0, r5
  2030e6:	b005      	add	sp, #20
  2030e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
  2030ec:	69a1      	ldr	r1, [r4, #24]
  2030ee:	e7eb      	b.n	2030c8 <f_write+0x58>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
  2030f0:	2801      	cmp	r0, #1
  2030f2:	d102      	bne.n	2030fa <f_write+0x8a>
  2030f4:	2502      	movs	r5, #2
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
  2030f6:	7465      	strb	r5, [r4, #17]
  2030f8:	e7f4      	b.n	2030e4 <f_write+0x74>
  2030fa:	1c43      	adds	r3, r0, #1
  2030fc:	d101      	bne.n	203102 <f_write+0x92>
  2030fe:	2501      	movs	r5, #1
  203100:	e7f9      	b.n	2030f6 <f_write+0x86>
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
  203102:	68a3      	ldr	r3, [r4, #8]
				fp->clust = clst;			/* Update current cluster */
  203104:	61a0      	str	r0, [r4, #24]
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
  203106:	b903      	cbnz	r3, 20310a <f_write+0x9a>
  203108:	60a0      	str	r0, [r4, #8]
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
  20310a:	f994 3010 	ldrsb.w	r3, [r4, #16]
  20310e:	2b00      	cmp	r3, #0
  203110:	da0c      	bge.n	20312c <f_write+0xbc>
				if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
  203112:	9803      	ldr	r0, [sp, #12]
  203114:	2301      	movs	r3, #1
  203116:	69e2      	ldr	r2, [r4, #28]
  203118:	4651      	mov	r1, sl
  20311a:	7840      	ldrb	r0, [r0, #1]
  20311c:	f7ff f940 	bl	2023a0 <disk_write>
  203120:	2800      	cmp	r0, #0
  203122:	d1ec      	bne.n	2030fe <f_write+0x8e>
				fp->flag &= (BYTE)~FA_DIRTY;
  203124:	7c23      	ldrb	r3, [r4, #16]
  203126:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  20312a:	7423      	strb	r3, [r4, #16]
			sect = clst2sect(fs, fp->clust);	/* Get current sector */
  20312c:	f8dd b00c 	ldr.w	fp, [sp, #12]
  203130:	69a1      	ldr	r1, [r4, #24]
  203132:	4658      	mov	r0, fp
  203134:	f7fe f879 	bl	20122a <clst2sect>
			if (sect == 0) ABORT(fs, FR_INT_ERR);
  203138:	2800      	cmp	r0, #0
  20313a:	d0db      	beq.n	2030f4 <f_write+0x84>
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
  20313c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
			sect += csect;
  203140:	eb07 0200 	add.w	r2, r7, r0
			if (cc > 0) {					/* Write maximum contiguous sectors directly */
  203144:	d334      	bcc.n	2031b0 <f_write+0x140>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
  203146:	f8bb 100a 	ldrh.w	r1, [fp, #10]
  20314a:	eb07 2056 	add.w	r0, r7, r6, lsr #9
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
  20314e:	0a73      	lsrs	r3, r6, #9
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
  203150:	4288      	cmp	r0, r1
				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
  203152:	f89b 0001 	ldrb.w	r0, [fp, #1]
					cc = fs->csize - csect;
  203156:	bf88      	it	hi
  203158:	1bcb      	subhi	r3, r1, r7
				if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
  20315a:	4641      	mov	r1, r8
  20315c:	e9cd 2300 	strd	r2, r3, [sp]
  203160:	f7ff f91e 	bl	2023a0 <disk_write>
  203164:	2800      	cmp	r0, #0
  203166:	d1ca      	bne.n	2030fe <f_write+0x8e>
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
  203168:	69e1      	ldr	r1, [r4, #28]
  20316a:	9a00      	ldr	r2, [sp, #0]
  20316c:	9b01      	ldr	r3, [sp, #4]
  20316e:	1a89      	subs	r1, r1, r2
  203170:	4299      	cmp	r1, r3
  203172:	d20c      	bcs.n	20318e <f_write+0x11e>
  203174:	f44f 7200 	mov.w	r2, #512	; 0x200
  203178:	eb08 2141 	add.w	r1, r8, r1, lsl #9
  20317c:	4650      	mov	r0, sl
  20317e:	9300      	str	r3, [sp, #0]
	if (cnt != 0) {
  203180:	f7fe f80d 	bl	20119e <mem_cpy.part.0>
					fp->flag &= (BYTE)~FA_DIRTY;
  203184:	7c22      	ldrb	r2, [r4, #16]
  203186:	9b00      	ldr	r3, [sp, #0]
  203188:	f002 027f 	and.w	r2, r2, #127	; 0x7f
  20318c:	7422      	strb	r2, [r4, #16]
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
  20318e:	025f      	lsls	r7, r3, #9
		btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
  203190:	f8d9 3000 	ldr.w	r3, [r9]
  203194:	1bf6      	subs	r6, r6, r7
  203196:	44b8      	add	r8, r7
  203198:	443b      	add	r3, r7
  20319a:	f8c9 3000 	str.w	r3, [r9]
  20319e:	6962      	ldr	r2, [r4, #20]
  2031a0:	68e3      	ldr	r3, [r4, #12]
  2031a2:	4417      	add	r7, r2
  2031a4:	6167      	str	r7, [r4, #20]
  2031a6:	42bb      	cmp	r3, r7
  2031a8:	bf2c      	ite	cs
  2031aa:	60e3      	strcs	r3, [r4, #12]
  2031ac:	60e7      	strcc	r7, [r4, #12]
  2031ae:	e77a      	b.n	2030a6 <f_write+0x36>
			if (fp->sect != sect && 		/* Fill sector cache with file data */
  2031b0:	69e3      	ldr	r3, [r4, #28]
  2031b2:	4293      	cmp	r3, r2
  2031b4:	d00d      	beq.n	2031d2 <f_write+0x162>
  2031b6:	68e1      	ldr	r1, [r4, #12]
  2031b8:	6963      	ldr	r3, [r4, #20]
  2031ba:	4299      	cmp	r1, r3
  2031bc:	d909      	bls.n	2031d2 <f_write+0x162>
				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
  2031be:	2301      	movs	r3, #1
  2031c0:	4651      	mov	r1, sl
  2031c2:	f89b 0001 	ldrb.w	r0, [fp, #1]
  2031c6:	9200      	str	r2, [sp, #0]
  2031c8:	f7ff f96e 	bl	2024a8 <disk_read>
				fp->fptr < fp->obj.objsize &&
  2031cc:	9a00      	ldr	r2, [sp, #0]
  2031ce:	2800      	cmp	r0, #0
  2031d0:	d195      	bne.n	2030fe <f_write+0x8e>
			fp->sect = sect;
  2031d2:	61e2      	str	r2, [r4, #28]
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes remains in the sector */
  2031d4:	6960      	ldr	r0, [r4, #20]
  2031d6:	4641      	mov	r1, r8
  2031d8:	f3c0 0008 	ubfx	r0, r0, #0, #9
  2031dc:	f5c0 7700 	rsb	r7, r0, #512	; 0x200
		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
  2031e0:	4450      	add	r0, sl
  2031e2:	42b7      	cmp	r7, r6
  2031e4:	bf28      	it	cs
  2031e6:	4637      	movcs	r7, r6
	if (cnt != 0) {
  2031e8:	463a      	mov	r2, r7
  2031ea:	f7fd ffd8 	bl	20119e <mem_cpy.part.0>
		fp->flag |= FA_DIRTY;
  2031ee:	7c23      	ldrb	r3, [r4, #16]
  2031f0:	f063 037f 	orn	r3, r3, #127	; 0x7f
  2031f4:	7423      	strb	r3, [r4, #16]
  2031f6:	e7cb      	b.n	203190 <f_write+0x120>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
  2031f8:	2507      	movs	r5, #7
  2031fa:	e773      	b.n	2030e4 <f_write+0x74>

002031fc <fatfsWrite>:
{
  2031fc:	b513      	push	{r0, r1, r4, lr}
  2031fe:	4604      	mov	r4, r0
	f_write( (FIL*)f->obj, buf, size, (UINT*)&wr);
  203200:	ab01      	add	r3, sp, #4
  203202:	6880      	ldr	r0, [r0, #8]
  203204:	f7ff ff34 	bl	203070 <f_write>
		f_sync( (FIL*)f->obj );
  203208:	68a0      	ldr	r0, [r4, #8]
  20320a:	f7ff fac7 	bl	20279c <f_sync>
}
  20320e:	9801      	ldr	r0, [sp, #4]
  203210:	b002      	add	sp, #8
  203212:	bd10      	pop	{r4, pc}

00203214 <dir_next>:
{
  203214:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	ofs = dp->dptr + SZDIRE;	/* Next entry */
  203218:	6903      	ldr	r3, [r0, #16]
{
  20321a:	4605      	mov	r5, r0
  20321c:	4688      	mov	r8, r1
	FATFS *fs = dp->obj.fs;
  20321e:	6804      	ldr	r4, [r0, #0]
	ofs = dp->dptr + SZDIRE;	/* Next entry */
  203220:	f103 0a20 	add.w	sl, r3, #32
	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
  203224:	f5ba 1f00 	cmp.w	sl, #2097152	; 0x200000
  203228:	bf24      	itt	cs
  20322a:	2300      	movcs	r3, #0
  20322c:	6183      	strcs	r3, [r0, #24]
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
  20322e:	6983      	ldr	r3, [r0, #24]
  203230:	b173      	cbz	r3, 203250 <dir_next+0x3c>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
  203232:	f3ca 0908 	ubfx	r9, sl, #0, #9
  203236:	f1b9 0f00 	cmp.w	r9, #0
  20323a:	d14c      	bne.n	2032d6 <dir_next+0xc2>
		dp->sect++;				/* Next sector */
  20323c:	3301      	adds	r3, #1
		if (dp->clust == 0) {	/* Static table */
  20323e:	6941      	ldr	r1, [r0, #20]
		dp->sect++;				/* Next sector */
  203240:	6183      	str	r3, [r0, #24]
		if (dp->clust == 0) {	/* Static table */
  203242:	b939      	cbnz	r1, 203254 <dir_next+0x40>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
  203244:	8923      	ldrh	r3, [r4, #8]
  203246:	ebb3 1f5a 	cmp.w	r3, sl, lsr #5
  20324a:	d844      	bhi.n	2032d6 <dir_next+0xc2>
				dp->sect = 0; return FR_NO_FILE;
  20324c:	2300      	movs	r3, #0
  20324e:	61ab      	str	r3, [r5, #24]
	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
  203250:	2004      	movs	r0, #4
  203252:	e00b      	b.n	20326c <dir_next+0x58>
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {	/* Cluster changed? */
  203254:	8967      	ldrh	r7, [r4, #10]
  203256:	3f01      	subs	r7, #1
  203258:	ea17 275a 	ands.w	r7, r7, sl, lsr #9
  20325c:	d13b      	bne.n	2032d6 <dir_next+0xc2>
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
  20325e:	4620      	mov	r0, r4
  203260:	f7ff f955 	bl	20250e <get_fat.isra.0>
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
  203264:	2801      	cmp	r0, #1
				clst = get_fat(&dp->obj, dp->clust);		/* Get next cluster */
  203266:	4606      	mov	r6, r0
				if (clst <= 1) return FR_INT_ERR;			/* Internal error */
  203268:	d802      	bhi.n	203270 <dir_next+0x5c>
  20326a:	2002      	movs	r0, #2
}
  20326c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  203270:	1c42      	adds	r2, r0, #1
  203272:	d101      	bne.n	203278 <dir_next+0x64>
  203274:	2001      	movs	r0, #1
  203276:	e7f9      	b.n	20326c <dir_next+0x58>
				if (clst >= fs->n_fatent) {					/* It reached end of dynamic table */
  203278:	6963      	ldr	r3, [r4, #20]
  20327a:	4283      	cmp	r3, r0
  20327c:	d825      	bhi.n	2032ca <dir_next+0xb6>
					if (!stretch) {								/* If no stretch, report EOT */
  20327e:	f1b8 0f00 	cmp.w	r8, #0
  203282:	d0e3      	beq.n	20324c <dir_next+0x38>
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
  203284:	6969      	ldr	r1, [r5, #20]
  203286:	4628      	mov	r0, r5
  203288:	f7ff fd68 	bl	202d5c <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
  20328c:	4606      	mov	r6, r0
  20328e:	2800      	cmp	r0, #0
  203290:	d039      	beq.n	203306 <dir_next+0xf2>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
  203292:	2801      	cmp	r0, #1
  203294:	d0e9      	beq.n	20326a <dir_next+0x56>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  203296:	1c43      	adds	r3, r0, #1
  203298:	d0ec      	beq.n	203274 <dir_next+0x60>
	if (fs->wflag) {	/* Is the disk access window dirty? */
  20329a:	78e3      	ldrb	r3, [r4, #3]
  20329c:	bb13      	cbnz	r3, 2032e4 <dir_next+0xd0>
	mem_set(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
  20329e:	f104 0b30 	add.w	fp, r4, #48	; 0x30
	sect = clst2sect(fs, clst);		/* Top of the cluster */
  2032a2:	4631      	mov	r1, r6
  2032a4:	4620      	mov	r0, r4
  2032a6:	f7fd ffc0 	bl	20122a <clst2sect>
  2032aa:	f504 720c 	add.w	r2, r4, #560	; 0x230
  2032ae:	4680      	mov	r8, r0
	BYTE *d = (BYTE*)dst;
  2032b0:	465b      	mov	r3, fp
		*d++ = (BYTE)val;
  2032b2:	2100      	movs	r1, #0
	fs->winsect = sect;				/* Set window to top of the cluster */
  2032b4:	62e0      	str	r0, [r4, #44]	; 0x2c
		*d++ = (BYTE)val;
  2032b6:	f803 1b01 	strb.w	r1, [r3], #1
	} while (--cnt);
  2032ba:	429a      	cmp	r2, r3
  2032bc:	d1fb      	bne.n	2032b6 <dir_next+0xa2>
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
  2032be:	8963      	ldrh	r3, [r4, #10]
  2032c0:	429f      	cmp	r7, r3
  2032c2:	d315      	bcc.n	2032f0 <dir_next+0xdc>
	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
  2032c4:	8963      	ldrh	r3, [r4, #10]
					if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;	/* Clean up the stretched table */
  2032c6:	429f      	cmp	r7, r3
  2032c8:	d1d4      	bne.n	203274 <dir_next+0x60>
				dp->sect = clst2sect(fs, clst);
  2032ca:	4631      	mov	r1, r6
  2032cc:	4620      	mov	r0, r4
				dp->clust = clst;		/* Initialize data for new cluster */
  2032ce:	616e      	str	r6, [r5, #20]
				dp->sect = clst2sect(fs, clst);
  2032d0:	f7fd ffab 	bl	20122a <clst2sect>
  2032d4:	61a8      	str	r0, [r5, #24]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
  2032d6:	3430      	adds	r4, #48	; 0x30
	return FR_OK;
  2032d8:	2000      	movs	r0, #0
	dp->dptr = ofs;						/* Current entry */
  2032da:	f8c5 a010 	str.w	sl, [r5, #16]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
  2032de:	444c      	add	r4, r9
  2032e0:	61ec      	str	r4, [r5, #28]
	return FR_OK;
  2032e2:	e7c3      	b.n	20326c <dir_next+0x58>
  2032e4:	4620      	mov	r0, r4
  2032e6:	f7ff f871 	bl	2023cc <sync_window.part.0>
	if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
  2032ea:	2800      	cmp	r0, #0
  2032ec:	d1c2      	bne.n	203274 <dir_next+0x60>
  2032ee:	e7d6      	b.n	20329e <dir_next+0x8a>
		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
  2032f0:	2301      	movs	r3, #1
  2032f2:	eb08 0207 	add.w	r2, r8, r7
  2032f6:	4659      	mov	r1, fp
  2032f8:	7860      	ldrb	r0, [r4, #1]
  2032fa:	f7ff f851 	bl	2023a0 <disk_write>
  2032fe:	2800      	cmp	r0, #0
  203300:	d1e0      	bne.n	2032c4 <dir_next+0xb0>
  203302:	3701      	adds	r7, #1
  203304:	e7db      	b.n	2032be <dir_next+0xaa>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
  203306:	2007      	movs	r0, #7
  203308:	e7b0      	b.n	20326c <dir_next+0x58>
	...

0020330c <follow_path>:
{
  20330c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  203310:	4605      	mov	r5, r0
	FATFS *fs = dp->obj.fs;
  203312:	f8d0 8000 	ldr.w	r8, [r0]
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
  203316:	460e      	mov	r6, r1
  203318:	f811 3b01 	ldrb.w	r3, [r1], #1
  20331c:	2b2f      	cmp	r3, #47	; 0x2f
  20331e:	d0fa      	beq.n	203316 <follow_path+0xa>
  203320:	2b5c      	cmp	r3, #92	; 0x5c
  203322:	d0f8      	beq.n	203316 <follow_path+0xa>
		dp->obj.sclust = 0;					/* Start from root directory */
  203324:	2300      	movs	r3, #0
  203326:	60ab      	str	r3, [r5, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
  203328:	7833      	ldrb	r3, [r6, #0]
  20332a:	2b1f      	cmp	r3, #31
  20332c:	d954      	bls.n	2033d8 <follow_path+0xcc>
	p = *path; sfn = dp->fn;
  20332e:	f105 0720 	add.w	r7, r5, #32
  203332:	f105 092b 	add.w	r9, r5, #43	; 0x2b
	BYTE *d = (BYTE*)dst;
  203336:	463b      	mov	r3, r7
		*d++ = (BYTE)val;
  203338:	2220      	movs	r2, #32
  20333a:	f803 2b01 	strb.w	r2, [r3], #1
	} while (--cnt);
  20333e:	454b      	cmp	r3, r9
  203340:	d1fb      	bne.n	20333a <follow_path+0x2e>
	si = i = 0; ni = 8;
  203342:	2000      	movs	r0, #0
  203344:	2408      	movs	r4, #8
  203346:	4603      	mov	r3, r0
		c = (BYTE)p[si++];				/* Get a byte */
  203348:	f816 c003 	ldrb.w	ip, [r6, r3]
  20334c:	1c59      	adds	r1, r3, #1
		if (c <= ' ') break; 			/* Break if end of the path name */
  20334e:	f1bc 0f20 	cmp.w	ip, #32
  203352:	d90a      	bls.n	20336a <follow_path+0x5e>
		if (c == '/' || c == '\\') {	/* Break if a separator is found */
  203354:	f1bc 0f2f 	cmp.w	ip, #47	; 0x2f
  203358:	d002      	beq.n	203360 <follow_path+0x54>
  20335a:	f1bc 0f5c 	cmp.w	ip, #92	; 0x5c
  20335e:	d145      	bne.n	2033ec <follow_path+0xe0>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
  203360:	5c73      	ldrb	r3, [r6, r1]
  203362:	2b2f      	cmp	r3, #47	; 0x2f
  203364:	d040      	beq.n	2033e8 <follow_path+0xdc>
  203366:	2b5c      	cmp	r3, #92	; 0x5c
  203368:	d03e      	beq.n	2033e8 <follow_path+0xdc>
	*path = p + si;						/* Return pointer to the next segment */
  20336a:	440e      	add	r6, r1
	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
  20336c:	2800      	cmp	r0, #0
  20336e:	d068      	beq.n	203442 <follow_path+0x136>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
  203370:	f895 3020 	ldrb.w	r3, [r5, #32]
	res = dir_sdi(dp, 0);			/* Rewind directory object */
  203374:	4628      	mov	r0, r5
	FATFS *fs = dp->obj.fs;
  203376:	f8d5 a000 	ldr.w	sl, [r5]
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
  20337a:	2be5      	cmp	r3, #229	; 0xe5
  20337c:	bf04      	itt	eq
  20337e:	2305      	moveq	r3, #5
  203380:	f885 3020 	strbeq.w	r3, [r5, #32]
	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
  203384:	f1bc 0f21 	cmp.w	ip, #33	; 0x21
  203388:	bf34      	ite	cc
  20338a:	2304      	movcc	r3, #4
  20338c:	2300      	movcs	r3, #0
  20338e:	f885 302b 	strb.w	r3, [r5, #43]	; 0x2b
	res = dir_sdi(dp, 0);			/* Rewind directory object */
  203392:	f7ff f916 	bl	2025c2 <dir_sdi.constprop.0>
	if (res != FR_OK) return res;
  203396:	4604      	mov	r4, r0
  203398:	2800      	cmp	r0, #0
  20339a:	d161      	bne.n	203460 <follow_path+0x154>
		res = move_window(fs, dp->sect);
  20339c:	69a9      	ldr	r1, [r5, #24]
  20339e:	4650      	mov	r0, sl
  2033a0:	f7ff f898 	bl	2024d4 <move_window>
		if (res != FR_OK) break;
  2033a4:	4604      	mov	r4, r0
  2033a6:	2800      	cmp	r0, #0
  2033a8:	d15a      	bne.n	203460 <follow_path+0x154>
		c = dp->dir[DIR_Name];
  2033aa:	69e8      	ldr	r0, [r5, #28]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  2033ac:	7803      	ldrb	r3, [r0, #0]
  2033ae:	2b00      	cmp	r3, #0
  2033b0:	d055      	beq.n	20345e <follow_path+0x152>
		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
  2033b2:	7ac3      	ldrb	r3, [r0, #11]
  2033b4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  2033b8:	71ab      	strb	r3, [r5, #6]
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
  2033ba:	7ac4      	ldrb	r4, [r0, #11]
  2033bc:	f014 0408 	ands.w	r4, r4, #8
  2033c0:	d105      	bne.n	2033ce <follow_path+0xc2>
  2033c2:	220b      	movs	r2, #11
  2033c4:	4639      	mov	r1, r7
  2033c6:	f7fd ff3b 	bl	201240 <mem_cmp>
  2033ca:	2800      	cmp	r0, #0
  2033cc:	d048      	beq.n	203460 <follow_path+0x154>
		res = dir_next(dp, 0);	/* Next entry */
  2033ce:	2100      	movs	r1, #0
  2033d0:	4628      	mov	r0, r5
  2033d2:	f7ff ff1f 	bl	203214 <dir_next>
  2033d6:	e7de      	b.n	203396 <follow_path+0x8a>
		dp->fn[NSFLAG] = NS_NONAME;
  2033d8:	2380      	movs	r3, #128	; 0x80
		res = dir_sdi(dp, 0);
  2033da:	4628      	mov	r0, r5
		dp->fn[NSFLAG] = NS_NONAME;
  2033dc:	f885 302b 	strb.w	r3, [r5, #43]	; 0x2b
}
  2033e0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		res = dir_sdi(dp, 0);
  2033e4:	f7ff b8ed 	b.w	2025c2 <dir_sdi.constprop.0>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
  2033e8:	3101      	adds	r1, #1
  2033ea:	e7b9      	b.n	203360 <follow_path+0x54>
		if (c == '.' || i >= ni) {		/* End of body or field overflow? */
  2033ec:	f1bc 0f2e 	cmp.w	ip, #46	; 0x2e
  2033f0:	d055      	beq.n	20349e <follow_path+0x192>
  2033f2:	4284      	cmp	r4, r0
  2033f4:	d925      	bls.n	203442 <follow_path+0x136>
	if (c >= DbcTbl[0]) {
  2033f6:	f1bc 0f80 	cmp.w	ip, #128	; 0x80
  2033fa:	d91c      	bls.n	203436 <follow_path+0x12a>
		if (c <= DbcTbl[1]) return 1;
  2033fc:	f1bc 0f9f 	cmp.w	ip, #159	; 0x9f
  203400:	d904      	bls.n	20340c <follow_path+0x100>
		if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;
  203402:	f10c 0220 	add.w	r2, ip, #32
  203406:	b2d2      	uxtb	r2, r2
  203408:	2a1c      	cmp	r2, #28
  20340a:	d814      	bhi.n	203436 <follow_path+0x12a>
			d = (BYTE)p[si++];			/* Get 2nd byte */
  20340c:	1c9a      	adds	r2, r3, #2
  20340e:	5c73      	ldrb	r3, [r6, r1]
	if (c >= DbcTbl[4]) {
  203410:	2b3f      	cmp	r3, #63	; 0x3f
  203412:	d916      	bls.n	203442 <follow_path+0x136>
		if (c <= DbcTbl[5]) return 1;
  203414:	2b7e      	cmp	r3, #126	; 0x7e
  203416:	d903      	bls.n	203420 <follow_path+0x114>
		if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;
  203418:	f083 0180 	eor.w	r1, r3, #128	; 0x80
  20341c:	297c      	cmp	r1, #124	; 0x7c
  20341e:	d810      	bhi.n	203442 <follow_path+0x136>
			if (!dbc_2nd(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
  203420:	1e61      	subs	r1, r4, #1
  203422:	4288      	cmp	r0, r1
  203424:	d20d      	bcs.n	203442 <follow_path+0x136>
			sfn[i++] = c;
  203426:	1c41      	adds	r1, r0, #1
  203428:	f807 c000 	strb.w	ip, [r7, r0]
			sfn[i++] = d;
  20342c:	3002      	adds	r0, #2
  20342e:	547b      	strb	r3, [r7, r1]
			d = (BYTE)p[si++];			/* Get 2nd byte */
  203430:	4611      	mov	r1, r2
			i = 8; ni = 11;				/* Enter file extension field */
  203432:	460b      	mov	r3, r1
  203434:	e788      	b.n	203348 <follow_path+0x3c>
  203436:	4a1c      	ldr	r2, [pc, #112]	; (2034a8 <follow_path+0x19c>)
	while (*str && *str != chr) str++;
  203438:	f812 3b01 	ldrb.w	r3, [r2], #1
  20343c:	b11b      	cbz	r3, 203446 <follow_path+0x13a>
  20343e:	459c      	cmp	ip, r3
  203440:	d1fa      	bne.n	203438 <follow_path+0x12c>
			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Field overflow or invalid dot? */
  203442:	2406      	movs	r4, #6
	return res;
  203444:	e015      	b.n	203472 <follow_path+0x166>
			if (IsLower(c)) c -= 0x20;	/* To upper */
  203446:	f1ac 0361 	sub.w	r3, ip, #97	; 0x61
  20344a:	2b19      	cmp	r3, #25
  20344c:	bf9c      	itt	ls
  20344e:	f1ac 0c20 	subls.w	ip, ip, #32
  203452:	fa5f fc8c 	uxtbls.w	ip, ip
			sfn[i++] = c;
  203456:	f807 c000 	strb.w	ip, [r7, r0]
  20345a:	3001      	adds	r0, #1
  20345c:	e7e9      	b.n	203432 <follow_path+0x126>
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  20345e:	2404      	movs	r4, #4
			ns = dp->fn[NSFLAG];
  203460:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
			if (res != FR_OK) {				/* Failed to find the object */
  203464:	b144      	cbz	r4, 203478 <follow_path+0x16c>
				if (res == FR_NO_FILE) {	/* Object is not found */
  203466:	2c04      	cmp	r4, #4
  203468:	d103      	bne.n	203472 <follow_path+0x166>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
  20346a:	f013 0f04 	tst.w	r3, #4
  20346e:	bf08      	it	eq
  203470:	2405      	moveq	r4, #5
}
  203472:	4620      	mov	r0, r4
  203474:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
  203478:	075a      	lsls	r2, r3, #29
  20347a:	d4fa      	bmi.n	203472 <follow_path+0x166>
			if (!(dp->obj.attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
  20347c:	79ab      	ldrb	r3, [r5, #6]
  20347e:	06db      	lsls	r3, r3, #27
  203480:	d50b      	bpl.n	20349a <follow_path+0x18e>
				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
  203482:	692b      	ldr	r3, [r5, #16]
  203484:	f108 0130 	add.w	r1, r8, #48	; 0x30
  203488:	f898 0000 	ldrb.w	r0, [r8]
  20348c:	f3c3 0308 	ubfx	r3, r3, #0, #9
  203490:	4419      	add	r1, r3
  203492:	f7fd fe75 	bl	201180 <ld_clust.isra.0>
  203496:	60a8      	str	r0, [r5, #8]
  203498:	e74d      	b.n	203336 <follow_path+0x2a>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
  20349a:	2405      	movs	r4, #5
  20349c:	e7e9      	b.n	203472 <follow_path+0x166>
			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Field overflow or invalid dot? */
  20349e:	2c0b      	cmp	r4, #11
  2034a0:	d0cf      	beq.n	203442 <follow_path+0x136>
			i = 8; ni = 11;				/* Enter file extension field */
  2034a2:	2008      	movs	r0, #8
  2034a4:	240b      	movs	r4, #11
  2034a6:	e7c4      	b.n	203432 <follow_path+0x126>
  2034a8:	0800dc05 	.word	0x0800dc05

002034ac <fatfsDel>:
{
  2034ac:	b570      	push	{r4, r5, r6, lr}
  2034ae:	b098      	sub	sp, #96	; 0x60
#endif
	DEF_NAMBUF


	/* Get logical drive */
	res = mount_volume(&path, &fs, FA_WRITE);
  2034b0:	2202      	movs	r2, #2
  2034b2:	9000      	str	r0, [sp, #0]
  2034b4:	a901      	add	r1, sp, #4
  2034b6:	4668      	mov	r0, sp
  2034b8:	f7ff fa18 	bl	2028ec <mount_volume>
	if (res == FR_OK) {
  2034bc:	b9e8      	cbnz	r0, 2034fa <fatfsDel+0x4e>
		dj.obj.fs = fs;
  2034be:	9b01      	ldr	r3, [sp, #4]
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);		/* Follow the file path */
  2034c0:	a802      	add	r0, sp, #8
  2034c2:	9900      	ldr	r1, [sp, #0]
		dj.obj.fs = fs;
  2034c4:	9302      	str	r3, [sp, #8]
		res = follow_path(&dj, path);		/* Follow the file path */
  2034c6:	f7ff ff21 	bl	20330c <follow_path>
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
		}
#if FF_FS_LOCK != 0
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
#endif
		if (res == FR_OK) {					/* The object is accessible */
  2034ca:	b9b0      	cbnz	r0, 2034fa <fatfsDel+0x4e>
			if (dj.fn[NSFLAG] & NS_NONAME) {
  2034cc:	f99d 3033 	ldrsb.w	r3, [sp, #51]	; 0x33
  2034d0:	2b00      	cmp	r3, #0
  2034d2:	db12      	blt.n	2034fa <fatfsDel+0x4e>
				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
			} else {
				if (dj.obj.attr & AM_RDO) {
  2034d4:	f89d 600e 	ldrb.w	r6, [sp, #14]
  2034d8:	07f2      	lsls	r2, r6, #31
  2034da:	d40e      	bmi.n	2034fa <fatfsDel+0x4e>
					init_alloc_info(fs, &obj);
					dclst = obj.sclust;
				} else
#endif
				{
					dclst = ld_clust(fs, dj.dir);
  2034dc:	9d01      	ldr	r5, [sp, #4]
  2034de:	9909      	ldr	r1, [sp, #36]	; 0x24
  2034e0:	7828      	ldrb	r0, [r5, #0]
  2034e2:	f7fd fe4d 	bl	201180 <ld_clust.isra.0>
				}
				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
  2034e6:	06f3      	lsls	r3, r6, #27
					dclst = ld_clust(fs, dj.dir);
  2034e8:	4604      	mov	r4, r0
				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
  2034ea:	d408      	bmi.n	2034fe <fatfsDel+0x52>
	FATFS *fs = dp->obj.fs;
  2034ec:	9d02      	ldr	r5, [sp, #8]
	res = move_window(fs, dp->sect);
  2034ee:	9908      	ldr	r1, [sp, #32]
  2034f0:	4628      	mov	r0, r5
  2034f2:	f7fe ffef 	bl	2024d4 <move_window>
	if (res == FR_OK) {
  2034f6:	2800      	cmp	r0, #0
  2034f8:	d032      	beq.n	203560 <fatfsDel+0xb4>
		return gFalse;
  2034fa:	2000      	movs	r0, #0
  2034fc:	e03d      	b.n	20357a <fatfsDel+0xce>
						res = FR_DENIED;
					} else
#endif
					{
						sdj.obj.fs = fs;				/* Open the sub-directory */
						sdj.obj.sclust = dclst;
  2034fe:	900f      	str	r0, [sp, #60]	; 0x3c
						if (fs->fs_type == FS_EXFAT) {
							sdj.obj.objsize = obj.objsize;
							sdj.obj.stat = obj.stat;
						}
#endif
						res = dir_sdi(&sdj, 0);
  203500:	a80d      	add	r0, sp, #52	; 0x34
						sdj.obj.fs = fs;				/* Open the sub-directory */
  203502:	950d      	str	r5, [sp, #52]	; 0x34
						res = dir_sdi(&sdj, 0);
  203504:	f7ff f85d 	bl	2025c2 <dir_sdi.constprop.0>
						if (res == FR_OK) {
  203508:	2800      	cmp	r0, #0
  20350a:	d1f6      	bne.n	2034fa <fatfsDel+0x4e>
	FATFS *fs = dp->obj.fs;
  20350c:	9d0d      	ldr	r5, [sp, #52]	; 0x34
	FRESULT res = FR_NO_FILE;
  20350e:	2004      	movs	r0, #4
	while (dp->sect) {
  203510:	9913      	ldr	r1, [sp, #76]	; 0x4c
  203512:	b911      	cbnz	r1, 20351a <fatfsDel+0x6e>
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
  203514:	2800      	cmp	r0, #0
  203516:	d0f0      	beq.n	2034fa <fatfsDel+0x4e>
  203518:	e01b      	b.n	203552 <fatfsDel+0xa6>
		res = move_window(fs, dp->sect);
  20351a:	4628      	mov	r0, r5
  20351c:	f7fe ffda 	bl	2024d4 <move_window>
		if (res != FR_OK) break;
  203520:	b9b8      	cbnz	r0, 203552 <fatfsDel+0xa6>
		b = dp->dir[DIR_Name];	/* Test for the entry type */
  203522:	9b14      	ldr	r3, [sp, #80]	; 0x50
  203524:	781a      	ldrb	r2, [r3, #0]
		if (b == 0) {
  203526:	b1ca      	cbz	r2, 20355c <fatfsDel+0xb0>
			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
  203528:	7adb      	ldrb	r3, [r3, #11]
			if (b != DDEM && b != '.' && attr != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
  20352a:	2ae5      	cmp	r2, #229	; 0xe5
			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
  20352c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  203530:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
			if (b != DDEM && b != '.' && attr != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
  203534:	d007      	beq.n	203546 <fatfsDel+0x9a>
  203536:	2a2e      	cmp	r2, #46	; 0x2e
  203538:	d005      	beq.n	203546 <fatfsDel+0x9a>
  20353a:	2b0f      	cmp	r3, #15
  20353c:	d003      	beq.n	203546 <fatfsDel+0x9a>
  20353e:	f023 0320 	bic.w	r3, r3, #32
  203542:	2b08      	cmp	r3, #8
  203544:	d1d9      	bne.n	2034fa <fatfsDel+0x4e>
		res = dir_next(dp, 0);		/* Next entry */
  203546:	2100      	movs	r1, #0
  203548:	a80d      	add	r0, sp, #52	; 0x34
  20354a:	f7ff fe63 	bl	203214 <dir_next>
		if (res != FR_OK) break;
  20354e:	2800      	cmp	r0, #0
  203550:	d0de      	beq.n	203510 <fatfsDel+0x64>
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
  203552:	2300      	movs	r3, #0
							res = DIR_READ_FILE(&sdj);			/* Test if the directory is empty */
							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
  203554:	2804      	cmp	r0, #4
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
  203556:	9313      	str	r3, [sp, #76]	; 0x4c
							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
  203558:	d1cf      	bne.n	2034fa <fatfsDel+0x4e>
  20355a:	e7c7      	b.n	2034ec <fatfsDel+0x40>
			res = FR_NO_FILE; break; /* Reached to end of the directory */
  20355c:	2004      	movs	r0, #4
  20355e:	e7f8      	b.n	203552 <fatfsDel+0xa6>
		dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'.*/
  203560:	9b09      	ldr	r3, [sp, #36]	; 0x24
  203562:	22e5      	movs	r2, #229	; 0xe5
  203564:	701a      	strb	r2, [r3, #0]
		fs->wflag = 1;
  203566:	2301      	movs	r3, #1
  203568:	70eb      	strb	r3, [r5, #3]
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);			/* Remove the directory entry */
				if (res == FR_OK && dclst != 0) {	/* Remove the cluster chain if exist */
  20356a:	b944      	cbnz	r4, 20357e <fatfsDel+0xd2>
					res = remove_chain(&obj, dclst, 0);
#else
					res = remove_chain(&dj.obj, dclst, 0);
#endif
				}
				if (res == FR_OK) res = sync_fs(fs);
  20356c:	9801      	ldr	r0, [sp, #4]
  20356e:	f7fe ff4e 	bl	20240e <sync_fs>
	if (ferr != FR_OK)
  203572:	fab0 f080 	clz	r0, r0
  203576:	0940      	lsrs	r0, r0, #5
  203578:	4240      	negs	r0, r0
}
  20357a:	b018      	add	sp, #96	; 0x60
  20357c:	bd70      	pop	{r4, r5, r6, pc}
					res = remove_chain(&dj.obj, dclst, 0);
  20357e:	4621      	mov	r1, r4
  203580:	a802      	add	r0, sp, #8
  203582:	f7ff fbbb 	bl	202cfc <remove_chain.constprop.0>
				if (res == FR_OK) res = sync_fs(fs);
  203586:	2800      	cmp	r0, #0
  203588:	d1b7      	bne.n	2034fa <fatfsDel+0x4e>
  20358a:	e7ef      	b.n	20356c <fatfsDel+0xc0>

0020358c <f_stat>:
{
  20358c:	b5f0      	push	{r4, r5, r6, r7, lr}
  20358e:	b08f      	sub	sp, #60	; 0x3c
  203590:	460d      	mov	r5, r1
	res = mount_volume(&path, &dj.obj.fs, 0);
  203592:	2200      	movs	r2, #0
{
  203594:	9001      	str	r0, [sp, #4]
	res = mount_volume(&path, &dj.obj.fs, 0);
  203596:	a903      	add	r1, sp, #12
  203598:	a801      	add	r0, sp, #4
  20359a:	f7ff f9a7 	bl	2028ec <mount_volume>
	if (res == FR_OK) {
  20359e:	4604      	mov	r4, r0
  2035a0:	2800      	cmp	r0, #0
  2035a2:	d13b      	bne.n	20361c <f_stat+0x90>
		res = follow_path(&dj, path);	/* Follow the file path */
  2035a4:	9901      	ldr	r1, [sp, #4]
  2035a6:	a803      	add	r0, sp, #12
  2035a8:	f7ff feb0 	bl	20330c <follow_path>
		if (res == FR_OK) {				/* Follow completed */
  2035ac:	4604      	mov	r4, r0
  2035ae:	2800      	cmp	r0, #0
  2035b0:	d134      	bne.n	20361c <f_stat+0x90>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
  2035b2:	f99d 3037 	ldrsb.w	r3, [sp, #55]	; 0x37
  2035b6:	2b00      	cmp	r3, #0
  2035b8:	db33      	blt.n	203622 <f_stat+0x96>
	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
  2035ba:	9b09      	ldr	r3, [sp, #36]	; 0x24
	fno->fname[0] = 0;			/* Invaidate file info */
  2035bc:	7268      	strb	r0, [r5, #9]
	if (dp->sect == 0) return;	/* Exit if read pointer has reached end of directory */
  2035be:	b36b      	cbz	r3, 20361c <f_stat+0x90>
		c = (TCHAR)dp->dir[si++];
  2035c0:	990a      	ldr	r1, [sp, #40]	; 0x28
	si = di = 0;
  2035c2:	4603      	mov	r3, r0
		if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
  2035c4:	272e      	movs	r7, #46	; 0x2e
  2035c6:	1e4e      	subs	r6, r1, #1
		c = (TCHAR)dp->dir[si++];
  2035c8:	f816 2f01 	ldrb.w	r2, [r6, #1]!
  2035cc:	3001      	adds	r0, #1
		if (c == ' ') continue;		/* Skip padding spaces */
  2035ce:	2a20      	cmp	r2, #32
  2035d0:	d00e      	beq.n	2035f0 <f_stat+0x64>
		if (c == RDDEM) c = DDEM;	/* Restore replaced DDEM character */
  2035d2:	2a05      	cmp	r2, #5
  2035d4:	bf08      	it	eq
  2035d6:	22e5      	moveq	r2, #229	; 0xe5
		if (si == 9) fno->fname[di++] = '.';/* Insert a . if extension is exist */
  2035d8:	2809      	cmp	r0, #9
  2035da:	bf02      	ittt	eq
  2035dc:	eb05 0c03 	addeq.w	ip, r5, r3
  2035e0:	3301      	addeq	r3, #1
  2035e2:	f88c 7009 	strbeq.w	r7, [ip, #9]
		fno->fname[di++] = c;
  2035e6:	eb05 0c03 	add.w	ip, r5, r3
  2035ea:	3301      	adds	r3, #1
  2035ec:	f88c 2009 	strb.w	r2, [ip, #9]
	while (si < 11) {		/* Copy name body and extension */
  2035f0:	280b      	cmp	r0, #11
  2035f2:	d1e9      	bne.n	2035c8 <f_stat+0x3c>
	fno->fname[di] = 0;
  2035f4:	2200      	movs	r2, #0
  2035f6:	442b      	add	r3, r5
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);		/* Size */
  2035f8:	f101 001c 	add.w	r0, r1, #28
	fno->fname[di] = 0;
  2035fc:	725a      	strb	r2, [r3, #9]
	fno->fattrib = dp->dir[DIR_Attr];					/* Attribute */
  2035fe:	7acb      	ldrb	r3, [r1, #11]
  203600:	722b      	strb	r3, [r5, #8]
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);		/* Size */
  203602:	f7fd fe33 	bl	20126c <ld_dword>
  203606:	6028      	str	r0, [r5, #0]
	rv = rv << 8 | ptr[0];
  203608:	7dca      	ldrb	r2, [r1, #23]
  20360a:	7d8b      	ldrb	r3, [r1, #22]
  20360c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	fno->ftime = ld_word(dp->dir + DIR_ModTime + 0);	/* Time */
  203610:	80eb      	strh	r3, [r5, #6]
	rv = rv << 8 | ptr[0];
  203612:	7e4a      	ldrb	r2, [r1, #25]
  203614:	7e0b      	ldrb	r3, [r1, #24]
  203616:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	fno->fdate = ld_word(dp->dir + DIR_ModTime + 2);	/* Date */
  20361a:	80ab      	strh	r3, [r5, #4]
}
  20361c:	4620      	mov	r0, r4
  20361e:	b00f      	add	sp, #60	; 0x3c
  203620:	bdf0      	pop	{r4, r5, r6, r7, pc}
				res = FR_INVALID_NAME;
  203622:	2406      	movs	r4, #6
  203624:	e7fa      	b.n	20361c <f_stat+0x90>

00203626 <fatfsFileSize>:
{
  203626:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	ferr = f_stat( (const TCHAR*)fname, &fno );
  203628:	4669      	mov	r1, sp
  20362a:	f7ff ffaf 	bl	20358c <f_stat>
	if (ferr != FR_OK)
  20362e:	b918      	cbnz	r0, 203638 <fatfsFileSize+0x12>
	return (gFileSize)fno.fsize;
  203630:	9800      	ldr	r0, [sp, #0]
}
  203632:	b007      	add	sp, #28
  203634:	f85d fb04 	ldr.w	pc, [sp], #4
		return 0;
  203638:	2000      	movs	r0, #0
  20363a:	e7fa      	b.n	203632 <fatfsFileSize+0xc>

0020363c <fatfsExists>:
{
  20363c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	ferr = f_stat( (const TCHAR*)fname, &fno);
  20363e:	4669      	mov	r1, sp
  203640:	f7ff ffa4 	bl	20358c <f_stat>
	if (ferr != FR_OK)
  203644:	fab0 f080 	clz	r0, r0
  203648:	0940      	lsrs	r0, r0, #5
}
  20364a:	4240      	negs	r0, r0
  20364c:	b007      	add	sp, #28
  20364e:	f85d fb04 	ldr.w	pc, [sp], #4

00203652 <dir_register>:
{
  203652:	b570      	push	{r4, r5, r6, lr}
  203654:	4605      	mov	r5, r0
	FATFS *fs = dp->obj.fs;
  203656:	6806      	ldr	r6, [r0, #0]
	res = dir_sdi(dp, 0);
  203658:	f7fe ffb3 	bl	2025c2 <dir_sdi.constprop.0>
	if (res == FR_OK) {
  20365c:	4604      	mov	r4, r0
  20365e:	bb40      	cbnz	r0, 2036b2 <dir_register+0x60>
			res = move_window(fs, dp->sect);
  203660:	69a9      	ldr	r1, [r5, #24]
  203662:	4630      	mov	r0, r6
  203664:	f7fe ff36 	bl	2024d4 <move_window>
			if (res != FR_OK) break;
  203668:	4604      	mov	r4, r0
  20366a:	bb10      	cbnz	r0, 2036b2 <dir_register+0x60>
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
  20366c:	69eb      	ldr	r3, [r5, #28]
  20366e:	781b      	ldrb	r3, [r3, #0]
  203670:	2be5      	cmp	r3, #229	; 0xe5
  203672:	d117      	bne.n	2036a4 <dir_register+0x52>
		res = move_window(fs, dp->sect);
  203674:	69a9      	ldr	r1, [r5, #24]
  203676:	4630      	mov	r0, r6
  203678:	f7fe ff2c 	bl	2024d4 <move_window>
		if (res == FR_OK) {
  20367c:	4604      	mov	r4, r0
  20367e:	b978      	cbnz	r0, 2036a0 <dir_register+0x4e>
			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
  203680:	69eb      	ldr	r3, [r5, #28]
		*d++ = (BYTE)val;
  203682:	4601      	mov	r1, r0
  203684:	f103 0220 	add.w	r2, r3, #32
  203688:	f803 1b01 	strb.w	r1, [r3], #1
	} while (--cnt);
  20368c:	4293      	cmp	r3, r2
  20368e:	d1fb      	bne.n	203688 <dir_register+0x36>
	if (cnt != 0) {
  203690:	220b      	movs	r2, #11
  203692:	f105 0120 	add.w	r1, r5, #32
  203696:	69e8      	ldr	r0, [r5, #28]
  203698:	f7fd fd81 	bl	20119e <mem_cpy.part.0>
			fs->wflag = 1;
  20369c:	2301      	movs	r3, #1
  20369e:	70f3      	strb	r3, [r6, #3]
}
  2036a0:	4620      	mov	r0, r4
  2036a2:	bd70      	pop	{r4, r5, r6, pc}
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
  2036a4:	2b00      	cmp	r3, #0
  2036a6:	d0e5      	beq.n	203674 <dir_register+0x22>
			res = dir_next(dp, 1);
  2036a8:	2101      	movs	r1, #1
  2036aa:	4628      	mov	r0, r5
  2036ac:	f7ff fdb2 	bl	203214 <dir_next>
  2036b0:	e7d4      	b.n	20365c <dir_register+0xa>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
  2036b2:	2c04      	cmp	r4, #4
  2036b4:	bf08      	it	eq
  2036b6:	2407      	moveq	r4, #7
  2036b8:	e7f2      	b.n	2036a0 <dir_register+0x4e>

002036ba <fatfsRename>:
{
  2036ba:	b530      	push	{r4, r5, lr}
  2036bc:	b0a3      	sub	sp, #140	; 0x8c
  2036be:	e9cd 0101 	strd	r0, r1, [sp, #4]
	BYTE buf[FF_FS_EXFAT ? SZDIRE * 2 : SZDIRE], *dir;
	LBA_t sect;
	DEF_NAMBUF


	get_ldnumber(&path_new);						/* Snip the drive number of new name off */
  2036c2:	a802      	add	r0, sp, #8
  2036c4:	f7fd fd8b 	bl	2011de <get_ldnumber>
	res = mount_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive of the old object */
  2036c8:	2202      	movs	r2, #2
  2036ca:	a903      	add	r1, sp, #12
  2036cc:	a801      	add	r0, sp, #4
  2036ce:	f7ff f90d 	bl	2028ec <mount_volume>
	if (res == FR_OK) {
  2036d2:	b958      	cbnz	r0, 2036ec <fatfsRename+0x32>
		djo.obj.fs = fs;
  2036d4:	9b03      	ldr	r3, [sp, #12]
		INIT_NAMBUF(fs);
		res = follow_path(&djo, path_old);		/* Check old object */
  2036d6:	a80c      	add	r0, sp, #48	; 0x30
  2036d8:	9901      	ldr	r1, [sp, #4]
		djo.obj.fs = fs;
  2036da:	930c      	str	r3, [sp, #48]	; 0x30
		res = follow_path(&djo, path_old);		/* Check old object */
  2036dc:	f7ff fe16 	bl	20330c <follow_path>
		if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check validity of name */
  2036e0:	b920      	cbnz	r0, 2036ec <fatfsRename+0x32>
  2036e2:	f89d 305b 	ldrb.w	r3, [sp, #91]	; 0x5b
  2036e6:	f013 0fa0 	tst.w	r3, #160	; 0xa0
  2036ea:	d002      	beq.n	2036f2 <fatfsRename+0x38>
		return gFalse;
  2036ec:	2000      	movs	r0, #0
}
  2036ee:	b023      	add	sp, #140	; 0x8c
  2036f0:	bd30      	pop	{r4, r5, pc}
	if (cnt != 0) {
  2036f2:	2220      	movs	r2, #32
  2036f4:	9913      	ldr	r1, [sp, #76]	; 0x4c
  2036f6:	a804      	add	r0, sp, #16
  2036f8:	f7fd fd51 	bl	20119e <mem_cpy.part.0>
  2036fc:	a90c      	add	r1, sp, #48	; 0x30
  2036fe:	a817      	add	r0, sp, #92	; 0x5c
  203700:	222c      	movs	r2, #44	; 0x2c
  203702:	f7fd fd4c 	bl	20119e <mem_cpy.part.0>
			} else
#endif
			{	/* At FAT/FAT32 volume */
				mem_cpy(buf, djo.dir, SZDIRE);			/* Save directory entry of the object */
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
  203706:	9902      	ldr	r1, [sp, #8]
  203708:	a817      	add	r0, sp, #92	; 0x5c
  20370a:	f7ff fdff 	bl	20330c <follow_path>
				if (res == FR_OK) {						/* Is new name already in use by any other object? */
  20370e:	2800      	cmp	r0, #0
  203710:	d160      	bne.n	2037d4 <fatfsRename+0x11a>
					res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
  203712:	9a19      	ldr	r2, [sp, #100]	; 0x64
  203714:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  203716:	429a      	cmp	r2, r3
  203718:	d1e8      	bne.n	2036ec <fatfsRename+0x32>
  20371a:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
  20371c:	9b10      	ldr	r3, [sp, #64]	; 0x40
  20371e:	429a      	cmp	r2, r3
				}
				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
  203720:	d1e4      	bne.n	2036ec <fatfsRename+0x32>
					res = dir_register(&djn);			/* Register the new entry */
  203722:	a817      	add	r0, sp, #92	; 0x5c
  203724:	f7ff ff95 	bl	203652 <dir_register>
					if (res == FR_OK) {
  203728:	2800      	cmp	r0, #0
  20372a:	d1df      	bne.n	2036ec <fatfsRename+0x32>
						dir = djn.dir;					/* Copy directory entry of the object except name */
  20372c:	9c1e      	ldr	r4, [sp, #120]	; 0x78
	if (cnt != 0) {
  20372e:	2213      	movs	r2, #19
  203730:	f10d 011d 	add.w	r1, sp, #29
  203734:	f104 000d 	add.w	r0, r4, #13
  203738:	f7fd fd31 	bl	20119e <mem_cpy.part.0>
						mem_cpy(dir + 13, buf + 13, SZDIRE - 13);
						dir[DIR_Attr] = buf[DIR_Attr];
  20373c:	f89d 301b 	ldrb.w	r3, [sp, #27]
						if (!(dir[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
						fs->wflag = 1;
  203740:	9d03      	ldr	r5, [sp, #12]
						if (!(dir[DIR_Attr] & AM_DIR)) dir[DIR_Attr] |= AM_ARC;	/* Set archive attribute if it is a file */
  203742:	06da      	lsls	r2, r3, #27
  203744:	bf58      	it	pl
  203746:	f043 0320 	orrpl.w	r3, r3, #32
  20374a:	72e3      	strb	r3, [r4, #11]
						fs->wflag = 1;
  20374c:	2301      	movs	r3, #1
  20374e:	70eb      	strb	r3, [r5, #3]
						if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory if needed */
  203750:	7ae3      	ldrb	r3, [r4, #11]
  203752:	06db      	lsls	r3, r3, #27
  203754:	d52a      	bpl.n	2037ac <fatfsRename+0xf2>
  203756:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  203758:	9b19      	ldr	r3, [sp, #100]	; 0x64
  20375a:	429a      	cmp	r2, r3
  20375c:	d026      	beq.n	2037ac <fatfsRename+0xf2>
							sect = clst2sect(fs, ld_clust(fs, dir));
  20375e:	4621      	mov	r1, r4
  203760:	7828      	ldrb	r0, [r5, #0]
  203762:	f7fd fd0d 	bl	201180 <ld_clust.isra.0>
  203766:	4601      	mov	r1, r0
  203768:	4628      	mov	r0, r5
  20376a:	f7fd fd5e 	bl	20122a <clst2sect>
							if (sect == 0) {
  20376e:	4601      	mov	r1, r0
  203770:	2800      	cmp	r0, #0
  203772:	d0bb      	beq.n	2036ec <fatfsRename+0x32>
								res = FR_INT_ERR;
							} else {
/* Start of critical section where an interruption can cause a cross-link */
								res = move_window(fs, sect);
  203774:	4628      	mov	r0, r5
  203776:	f7fe fead 	bl	2024d4 <move_window>
								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
								if (res == FR_OK && dir[1] == '.') {
  20377a:	2800      	cmp	r0, #0
  20377c:	d1b6      	bne.n	2036ec <fatfsRename+0x32>
								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
  20377e:	9a03      	ldr	r2, [sp, #12]
								if (res == FR_OK && dir[1] == '.') {
  203780:	f892 3051 	ldrb.w	r3, [r2, #81]	; 0x51
  203784:	2b2e      	cmp	r3, #46	; 0x2e
  203786:	d111      	bne.n	2037ac <fatfsRename+0xf2>
									st_clust(fs, dir, djn.obj.sclust);
  203788:	9b19      	ldr	r3, [sp, #100]	; 0x64
	*ptr++ = (BYTE)val; val >>= 8;
  20378a:	f3c3 2107 	ubfx	r1, r3, #8, #8
  20378e:	f882 306a 	strb.w	r3, [r2, #106]	; 0x6a
	*ptr++ = (BYTE)val;
  203792:	f882 106b 	strb.w	r1, [r2, #107]	; 0x6b
	if (fs->fs_type == FS_FAT32) {
  203796:	7811      	ldrb	r1, [r2, #0]
  203798:	2903      	cmp	r1, #3
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
  20379a:	bf01      	itttt	eq
  20379c:	0c1b      	lsreq	r3, r3, #16
	*ptr++ = (BYTE)val; val >>= 8;
  20379e:	f882 3064 	strbeq.w	r3, [r2, #100]	; 0x64
  2037a2:	0a1b      	lsreq	r3, r3, #8
	*ptr++ = (BYTE)val;
  2037a4:	f882 3065 	strbeq.w	r3, [r2, #101]	; 0x65
									fs->wflag = 1;
  2037a8:	2301      	movs	r3, #1
  2037aa:	70d3      	strb	r3, [r2, #3]
	FATFS *fs = dp->obj.fs;
  2037ac:	9c0c      	ldr	r4, [sp, #48]	; 0x30
	res = move_window(fs, dp->sect);
  2037ae:	9912      	ldr	r1, [sp, #72]	; 0x48
  2037b0:	4620      	mov	r0, r4
  2037b2:	f7fe fe8f 	bl	2024d4 <move_window>
	if (res == FR_OK) {
  2037b6:	2800      	cmp	r0, #0
  2037b8:	d198      	bne.n	2036ec <fatfsRename+0x32>
		dp->dir[DIR_Name] = DDEM;	/* Mark the entry 'deleted'.*/
  2037ba:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  2037bc:	22e5      	movs	r2, #229	; 0xe5
  2037be:	701a      	strb	r2, [r3, #0]
		fs->wflag = 1;
  2037c0:	2301      	movs	r3, #1
  2037c2:	70e3      	strb	r3, [r4, #3]
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&djo);		/* Remove old entry */
				if (res == FR_OK) {
					res = sync_fs(fs);
  2037c4:	9803      	ldr	r0, [sp, #12]
  2037c6:	f7fe fe22 	bl	20240e <sync_fs>
	if (ferr != FR_OK)
  2037ca:	fab0 f080 	clz	r0, r0
  2037ce:	0940      	lsrs	r0, r0, #5
  2037d0:	4240      	negs	r0, r0
  2037d2:	e78c      	b.n	2036ee <fatfsRename+0x34>
				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
  2037d4:	2804      	cmp	r0, #4
  2037d6:	e7a3      	b.n	203720 <fatfsRename+0x66>

002037d8 <f_open>:
{
  2037d8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  2037dc:	b08f      	sub	sp, #60	; 0x3c
  2037de:	4617      	mov	r7, r2
	if (!fp) return FR_INVALID_OBJECT;
  2037e0:	4604      	mov	r4, r0
{
  2037e2:	9101      	str	r1, [sp, #4]
	if (!fp) return FR_INVALID_OBJECT;
  2037e4:	2800      	cmp	r0, #0
  2037e6:	f000 80d7 	beq.w	203998 <f_open+0x1c0>
	mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND;
  2037ea:	f002 053f 	and.w	r5, r2, #63	; 0x3f
	res = mount_volume(&path, &fs, mode);
  2037ee:	a902      	add	r1, sp, #8
  2037f0:	a801      	add	r0, sp, #4
  2037f2:	462a      	mov	r2, r5
  2037f4:	f7ff f87a 	bl	2028ec <mount_volume>
	if (res == FR_OK) {
  2037f8:	4606      	mov	r6, r0
  2037fa:	2800      	cmp	r0, #0
  2037fc:	d14b      	bne.n	203896 <f_open+0xbe>
		dj.obj.fs = fs;
  2037fe:	9b02      	ldr	r3, [sp, #8]
		res = follow_path(&dj, path);	/* Follow the file path */
  203800:	a803      	add	r0, sp, #12
  203802:	9901      	ldr	r1, [sp, #4]
		dj.obj.fs = fs;
  203804:	9303      	str	r3, [sp, #12]
		res = follow_path(&dj, path);	/* Follow the file path */
  203806:	f7ff fd81 	bl	20330c <follow_path>
		if (res == FR_OK) {
  20380a:	b920      	cbnz	r0, 203816 <f_open+0x3e>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
  20380c:	f99d 3037 	ldrsb.w	r3, [sp, #55]	; 0x37
				res = FR_INVALID_NAME;
  203810:	2b00      	cmp	r3, #0
  203812:	bfb8      	it	lt
  203814:	2006      	movlt	r0, #6
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  203816:	f017 0f1c 	tst.w	r7, #28
  20381a:	f000 809d 	beq.w	203958 <f_open+0x180>
			if (res != FR_OK) {					/* No file, create new */
  20381e:	2800      	cmp	r0, #0
  203820:	d040      	beq.n	2038a4 <f_open+0xcc>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
  203822:	2804      	cmp	r0, #4
  203824:	d137      	bne.n	203896 <f_open+0xbe>
					res = dir_register(&dj);
  203826:	a803      	add	r0, sp, #12
  203828:	f7ff ff13 	bl	203652 <dir_register>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
  20382c:	bb98      	cbnz	r0, 203896 <f_open+0xbe>
				mode |= FA_CREATE_ALWAYS;		/* File is created */
  20382e:	f045 0508 	orr.w	r5, r5, #8
					cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
  203832:	9b02      	ldr	r3, [sp, #8]
  203834:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
  203838:	7818      	ldrb	r0, [r3, #0]
  20383a:	4641      	mov	r1, r8
  20383c:	f7fd fca0 	bl	201180 <ld_clust.isra.0>
					st_dword(dj.dir + DIR_CrtTime, GET_FATTIME());	/* Set created time */
  203840:	f44f 1104 	mov.w	r1, #2162688	; 0x210000
					cl = ld_clust(fs, dj.dir);			/* Get current cluster chain */
  203844:	4607      	mov	r7, r0
					st_dword(dj.dir + DIR_CrtTime, GET_FATTIME());	/* Set created time */
  203846:	f108 000e 	add.w	r0, r8, #14
  20384a:	f7fd fd07 	bl	20125c <st_dword>
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
  20384e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  203850:	2220      	movs	r2, #32
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
  203852:	9902      	ldr	r1, [sp, #8]
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
  203854:	72da      	strb	r2, [r3, #11]
	*ptr++ = (BYTE)val; val >>= 8;
  203856:	2300      	movs	r3, #0
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
  203858:	9a0a      	ldr	r2, [sp, #40]	; 0x28
	*ptr++ = (BYTE)val; val >>= 8;
  20385a:	7693      	strb	r3, [r2, #26]
	*ptr++ = (BYTE)val;
  20385c:	76d3      	strb	r3, [r2, #27]
	if (fs->fs_type == FS_FAT32) {
  20385e:	7808      	ldrb	r0, [r1, #0]
  203860:	2803      	cmp	r0, #3
	*ptr++ = (BYTE)val; val >>= 8;
  203862:	bf04      	itt	eq
  203864:	7513      	strbeq	r3, [r2, #20]
	*ptr++ = (BYTE)val;
  203866:	7553      	strbeq	r3, [r2, #21]
					st_dword(dj.dir + DIR_FileSize, 0);
  203868:	9a0a      	ldr	r2, [sp, #40]	; 0x28
	*ptr++ = (BYTE)val; val >>= 8;
  20386a:	7713      	strb	r3, [r2, #28]
	*ptr++ = (BYTE)val; val >>= 8;
  20386c:	7753      	strb	r3, [r2, #29]
	*ptr++ = (BYTE)val; val >>= 8;
  20386e:	7793      	strb	r3, [r2, #30]
	*ptr++ = (BYTE)val;
  203870:	77d3      	strb	r3, [r2, #31]
					fs->wflag = 1;
  203872:	2301      	movs	r3, #1
  203874:	70cb      	strb	r3, [r1, #3]
					if (cl != 0) {						/* Remove the cluster chain if exist */
  203876:	b1f7      	cbz	r7, 2038b6 <f_open+0xde>
						sc = fs->winsect;
  203878:	f8d1 802c 	ldr.w	r8, [r1, #44]	; 0x2c
						res = remove_chain(&dj.obj, cl, 0);
  20387c:	a803      	add	r0, sp, #12
  20387e:	4639      	mov	r1, r7
  203880:	f7ff fa3c 	bl	202cfc <remove_chain.constprop.0>
						if (res == FR_OK) {
  203884:	b938      	cbnz	r0, 203896 <f_open+0xbe>
							res = move_window(fs, sc);
  203886:	4641      	mov	r1, r8
  203888:	9802      	ldr	r0, [sp, #8]
  20388a:	f7fe fe23 	bl	2024d4 <move_window>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
  20388e:	3f01      	subs	r7, #1
  203890:	9b02      	ldr	r3, [sp, #8]
  203892:	60df      	str	r7, [r3, #12]
		if (res == FR_OK) {
  203894:	b178      	cbz	r0, 2038b6 <f_open+0xde>
	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
  203896:	2300      	movs	r3, #0
  203898:	4606      	mov	r6, r0
  20389a:	6023      	str	r3, [r4, #0]
}
  20389c:	4630      	mov	r0, r6
  20389e:	b00f      	add	sp, #60	; 0x3c
  2038a0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
  2038a4:	f89d 3012 	ldrb.w	r3, [sp, #18]
  2038a8:	f013 0f11 	tst.w	r3, #17
  2038ac:	d15e      	bne.n	20396c <f_open+0x194>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
  2038ae:	0778      	lsls	r0, r7, #29
  2038b0:	d46c      	bmi.n	20398c <f_open+0x1b4>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate the file if overwrite mode */
  2038b2:	0739      	lsls	r1, r7, #28
  2038b4:	d4bd      	bmi.n	203832 <f_open+0x5a>
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
  2038b6:	f8dd 9008 	ldr.w	r9, [sp, #8]
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
  2038ba:	0729      	lsls	r1, r5, #28
			fp->dir_ptr = dj.dir;
  2038bc:	990a      	ldr	r1, [sp, #40]	; 0x28
			mem_set(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
  2038be:	f104 072c 	add.w	r7, r4, #44	; 0x2c
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
  2038c2:	f8d9 302c 	ldr.w	r3, [r9, #44]	; 0x2c
			if (mode & FA_CREATE_ALWAYS) mode |= FA_MODIFIED;	/* Set file change flag if created or overwritten */
  2038c6:	bf48      	it	mi
  2038c8:	f045 0540 	orrmi.w	r5, r5, #64	; 0x40
			fp->dir_ptr = dj.dir;
  2038cc:	6261      	str	r1, [r4, #36]	; 0x24
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
  2038ce:	6223      	str	r3, [r4, #32]
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
  2038d0:	f899 0000 	ldrb.w	r0, [r9]
  2038d4:	f7fd fc54 	bl	201180 <ld_clust.isra.0>
  2038d8:	60a0      	str	r0, [r4, #8]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
  2038da:	f101 001c 	add.w	r0, r1, #28
  2038de:	f7fd fcc5 	bl	20126c <ld_dword>
			fp->obj.id = fs->id;
  2038e2:	f8b9 2006 	ldrh.w	r2, [r9, #6]
			fp->cltbl = 0;			/* Disable fast seek mode */
  2038e6:	2300      	movs	r3, #0
  2038e8:	f504 710b 	add.w	r1, r4, #556	; 0x22c
			fp->obj.id = fs->id;
  2038ec:	80a2      	strh	r2, [r4, #4]
	BYTE *d = (BYTE*)dst;
  2038ee:	463a      	mov	r2, r7
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
  2038f0:	60e0      	str	r0, [r4, #12]
			fp->cltbl = 0;			/* Disable fast seek mode */
  2038f2:	62a3      	str	r3, [r4, #40]	; 0x28
			fp->obj.fs = fs;	 	/* Validate the file object */
  2038f4:	f8c4 9000 	str.w	r9, [r4]
			fp->flag = mode;		/* Set file access mode */
  2038f8:	7425      	strb	r5, [r4, #16]
			fp->err = 0;			/* Clear error flag */
  2038fa:	7463      	strb	r3, [r4, #17]
			fp->sect = 0;			/* Invalidate current data sector */
  2038fc:	61e3      	str	r3, [r4, #28]
			fp->fptr = 0;			/* Set file pointer top of the file */
  2038fe:	6163      	str	r3, [r4, #20]
		*d++ = (BYTE)val;
  203900:	f802 3b01 	strb.w	r3, [r2], #1
	} while (--cnt);
  203904:	4291      	cmp	r1, r2
  203906:	d1fb      	bne.n	203900 <f_open+0x128>
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
  203908:	06aa      	lsls	r2, r5, #26
  20390a:	d5c7      	bpl.n	20389c <f_open+0xc4>
  20390c:	f8d4 800c 	ldr.w	r8, [r4, #12]
  203910:	f1b8 0f00 	cmp.w	r8, #0
  203914:	d0c2      	beq.n	20389c <f_open+0xc4>
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
  203916:	f8b9 500a 	ldrh.w	r5, [r9, #10]
				clst = fp->obj.sclust;				/* Follow the cluster chain */
  20391a:	68a1      	ldr	r1, [r4, #8]
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
  20391c:	026d      	lsls	r5, r5, #9
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
  20391e:	f8c4 8014 	str.w	r8, [r4, #20]
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
  203922:	4545      	cmp	r5, r8
  203924:	d324      	bcc.n	203970 <f_open+0x198>
  203926:	2000      	movs	r0, #0
				fp->clust = clst;
  203928:	61a1      	str	r1, [r4, #24]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
  20392a:	2800      	cmp	r0, #0
  20392c:	d1b3      	bne.n	203896 <f_open+0xbe>
  20392e:	f3c8 0308 	ubfx	r3, r8, #0, #9
  203932:	2b00      	cmp	r3, #0
  203934:	d0b2      	beq.n	20389c <f_open+0xc4>
					sc = clst2sect(fs, clst);
  203936:	9d02      	ldr	r5, [sp, #8]
  203938:	4628      	mov	r0, r5
  20393a:	f7fd fc76 	bl	20122a <clst2sect>
					if (sc == 0) {
  20393e:	b348      	cbz	r0, 203994 <f_open+0x1bc>
						fp->sect = sc + (DWORD)(ofs / SS(fs));
  203940:	eb00 2258 	add.w	r2, r0, r8, lsr #9
						if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
  203944:	2301      	movs	r3, #1
  203946:	4639      	mov	r1, r7
						fp->sect = sc + (DWORD)(ofs / SS(fs));
  203948:	61e2      	str	r2, [r4, #28]
						if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
  20394a:	7868      	ldrb	r0, [r5, #1]
  20394c:	f7fe fdac 	bl	2024a8 <disk_read>
  203950:	2800      	cmp	r0, #0
  203952:	d0a3      	beq.n	20389c <f_open+0xc4>
  203954:	2001      	movs	r0, #1
  203956:	e79e      	b.n	203896 <f_open+0xbe>
			if (res == FR_OK) {					/* Is the object exsiting? */
  203958:	2800      	cmp	r0, #0
  20395a:	d19c      	bne.n	203896 <f_open+0xbe>
				if (dj.obj.attr & AM_DIR) {		/* File open against a directory */
  20395c:	f89d 3012 	ldrb.w	r3, [sp, #18]
  203960:	06da      	lsls	r2, r3, #27
  203962:	d415      	bmi.n	203990 <f_open+0x1b8>
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* Write mode open against R/O file */
  203964:	07bf      	lsls	r7, r7, #30
  203966:	d5a6      	bpl.n	2038b6 <f_open+0xde>
  203968:	07d8      	lsls	r0, r3, #31
  20396a:	d5a4      	bpl.n	2038b6 <f_open+0xde>
					res = FR_DENIED;
  20396c:	2007      	movs	r0, #7
  20396e:	e792      	b.n	203896 <f_open+0xbe>
					clst = get_fat(&fp->obj, clst);
  203970:	6820      	ldr	r0, [r4, #0]
  203972:	eba8 0805 	sub.w	r8, r8, r5
  203976:	f7fe fdca 	bl	20250e <get_fat.isra.0>
					if (clst <= 1) res = FR_INT_ERR;
  20397a:	2801      	cmp	r0, #1
					clst = get_fat(&fp->obj, clst);
  20397c:	4601      	mov	r1, r0
					if (clst <= 1) res = FR_INT_ERR;
  20397e:	d903      	bls.n	203988 <f_open+0x1b0>
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
  203980:	1c43      	adds	r3, r0, #1
  203982:	d1ce      	bne.n	203922 <f_open+0x14a>
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
  203984:	2001      	movs	r0, #1
  203986:	e7cf      	b.n	203928 <f_open+0x150>
					if (clst <= 1) res = FR_INT_ERR;
  203988:	2002      	movs	r0, #2
  20398a:	e7cd      	b.n	203928 <f_open+0x150>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
  20398c:	2008      	movs	r0, #8
  20398e:	e782      	b.n	203896 <f_open+0xbe>
					res = FR_NO_FILE;
  203990:	2004      	movs	r0, #4
  203992:	e780      	b.n	203896 <f_open+0xbe>
						res = FR_INT_ERR;
  203994:	2002      	movs	r0, #2
  203996:	e77e      	b.n	203896 <f_open+0xbe>
	if (!fp) return FR_INVALID_OBJECT;
  203998:	2609      	movs	r6, #9
  20399a:	e77f      	b.n	20389c <f_open+0xc4>

0020399c <fatfsOpen>:
		if (!fatfs_mounted && !fatfsMount(""))
  20399c:	4b1c      	ldr	r3, [pc, #112]	; (203a10 <fatfsOpen+0x74>)
{
  20399e:	b570      	push	{r4, r5, r6, lr}
		if (!fatfs_mounted && !fatfsMount(""))
  2039a0:	f993 3000 	ldrsb.w	r3, [r3]
{
  2039a4:	4605      	mov	r5, r0
  2039a6:	460e      	mov	r6, r1
		if (!fatfs_mounted && !fatfsMount(""))
  2039a8:	b13b      	cbz	r3, 2039ba <fatfsOpen+0x1e>
	if (!(fd = gfxAlloc(sizeof(FIL))))
  2039aa:	f44f 700b 	mov.w	r0, #556	; 0x22c
  2039ae:	f008 fc31 	bl	20c214 <malloc>
  2039b2:	4604      	mov	r4, r0
  2039b4:	b938      	cbnz	r0, 2039c6 <fatfsOpen+0x2a>
			return gFalse;
  2039b6:	2000      	movs	r0, #0
}
  2039b8:	bd70      	pop	{r4, r5, r6, pc}
		if (!fatfs_mounted && !fatfsMount(""))
  2039ba:	4816      	ldr	r0, [pc, #88]	; (203a14 <fatfsOpen+0x78>)
  2039bc:	f7ff f8f0 	bl	202ba0 <fatfsMount>
  2039c0:	2800      	cmp	r0, #0
  2039c2:	d1f2      	bne.n	2039aa <fatfsOpen+0xe>
  2039c4:	e7f7      	b.n	2039b6 <fatfsOpen+0x1a>
	if (f_open(fd, fname, fatfs_flags2mode(f)) != FR_OK) {
  2039c6:	88ab      	ldrh	r3, [r5, #4]
		mode |= FA_READ;
  2039c8:	f3c3 0240 	ubfx	r2, r3, #1, #1
	if (f->flags & GFILEFLG_WRITE)
  2039cc:	0759      	lsls	r1, r3, #29
		mode |= FA_WRITE;
  2039ce:	bf48      	it	mi
  2039d0:	f042 0202 	orrmi.w	r2, r2, #2
	if (f->flags & GFILEFLG_APPEND)
  2039d4:	0718      	lsls	r0, r3, #28
	if (f_open(fd, fname, fatfs_flags2mode(f)) != FR_OK) {
  2039d6:	4620      	mov	r0, r4
		mode |= FA_OPEN_APPEND;
  2039d8:	bf48      	it	mi
  2039da:	f042 0230 	orrmi.w	r2, r2, #48	; 0x30
	if (f->flags & GFILEFLG_TRUNC)
  2039de:	0559      	lsls	r1, r3, #21
	if (f_open(fd, fname, fatfs_flags2mode(f)) != FR_OK) {
  2039e0:	4631      	mov	r1, r6
		mode |= FA_CREATE_ALWAYS;
  2039e2:	bf48      	it	mi
  2039e4:	f042 0208 	orrmi.w	r2, r2, #8
	if (f_open(fd, fname, fatfs_flags2mode(f)) != FR_OK) {
  2039e8:	f7ff fef6 	bl	2037d8 <f_open>
  2039ec:	b128      	cbz	r0, 2039fa <fatfsOpen+0x5e>
		gfxFree(fd);
  2039ee:	4620      	mov	r0, r4
  2039f0:	f008 fc18 	bl	20c224 <free>
		f->obj = 0;
  2039f4:	2000      	movs	r0, #0
  2039f6:	60a8      	str	r0, [r5, #8]
		return gFalse;
  2039f8:	e7de      	b.n	2039b8 <fatfsOpen+0x1c>
		if (f->flags & GFILEFLG_WRITE) {
  2039fa:	88ab      	ldrh	r3, [r5, #4]
	f->obj = (void*)fd;
  2039fc:	60ac      	str	r4, [r5, #8]
		if (f->flags & GFILEFLG_WRITE) {
  2039fe:	075b      	lsls	r3, r3, #29
  203a00:	d502      	bpl.n	203a08 <fatfsOpen+0x6c>
			f_sync( (FIL*)f->obj );
  203a02:	4620      	mov	r0, r4
  203a04:	f7fe feca 	bl	20279c <f_sync>
	return gTrue;	
  203a08:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  203a0c:	e7d4      	b.n	2039b8 <fatfsOpen+0x1c>
  203a0e:	bf00      	nop
  203a10:	20001bf8 	.word	0x20001bf8
  203a14:	0800dc16 	.word	0x0800dc16

00203a18 <parse_arguments>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static char *parse_arguments(char *str, char **saveptr) {
  203a18:	b570      	push	{r4, r5, r6, lr}
  203a1a:	460d      	mov	r5, r1
  char *p;

  if (str != NULL)
  203a1c:	b100      	cbz	r0, 203a20 <parse_arguments+0x8>
    *saveptr = str;
  203a1e:	6008      	str	r0, [r1, #0]

  p = *saveptr;
  203a20:	682e      	ldr	r6, [r5, #0]
  if (!p) {
  203a22:	b17e      	cbz	r6, 203a44 <parse_arguments+0x2c>
    return NULL;
  }

  /* Skipping white space.*/
  p += strspn(p, " \t");
  203a24:	490e      	ldr	r1, [pc, #56]	; (203a60 <parse_arguments+0x48>)
  203a26:	4630      	mov	r0, r6
  203a28:	f009 ff05 	bl	20d836 <strspn>

  if (*p == '"') {
  203a2c:	5c31      	ldrb	r1, [r6, r0]
  p += strspn(p, " \t");
  203a2e:	1834      	adds	r4, r6, r0
  if (*p == '"') {
  203a30:	2922      	cmp	r1, #34	; 0x22
  203a32:	d10a      	bne.n	203a4a <parse_arguments+0x32>
    /* If an argument starts with a double quote then its delimiter is another
       quote.*/
    p++;
  203a34:	3401      	adds	r4, #1
    *saveptr = strpbrk(p, "\"");
  203a36:	4620      	mov	r0, r4
  203a38:	f009 fece 	bl	20d7d8 <strchr>
    /* The delimiter is white space.*/
    *saveptr = strpbrk(p, " \t");
  }

  /* Replacing the delimiter with a zero.*/
  if (*saveptr != NULL) {
  203a3c:	b950      	cbnz	r0, 203a54 <parse_arguments+0x3c>
  203a3e:	6028      	str	r0, [r5, #0]
    *(*saveptr)++ = '\0';
  }

  return *p != '\0' ? p : NULL;
  203a40:	7823      	ldrb	r3, [r4, #0]
  203a42:	b903      	cbnz	r3, 203a46 <parse_arguments+0x2e>
  203a44:	2400      	movs	r4, #0
}
  203a46:	4620      	mov	r0, r4
  203a48:	bd70      	pop	{r4, r5, r6, pc}
    *saveptr = strpbrk(p, " \t");
  203a4a:	4905      	ldr	r1, [pc, #20]	; (203a60 <parse_arguments+0x48>)
  203a4c:	4620      	mov	r0, r4
  203a4e:	f009 fed8 	bl	20d802 <strpbrk>
  203a52:	e7f3      	b.n	203a3c <parse_arguments+0x24>
    *(*saveptr)++ = '\0';
  203a54:	1c43      	adds	r3, r0, #1
  203a56:	602b      	str	r3, [r5, #0]
  203a58:	2300      	movs	r3, #0
  203a5a:	7003      	strb	r3, [r0, #0]
  203a5c:	e7f0      	b.n	203a40 <parse_arguments+0x28>
  203a5e:	bf00      	nop
  203a60:	0800dc14 	.word	0x0800dc14

00203a64 <chprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  203a64:	b40e      	push	{r1, r2, r3}
  203a66:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  203a6a:	b086      	sub	sp, #24
  203a6c:	4680      	mov	r8, r0
  int n = 0;
  203a6e:	f04f 0900 	mov.w	r9, #0
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
  203a72:	ac0f      	add	r4, sp, #60	; 0x3c
  203a74:	f854 3b04 	ldr.w	r3, [r4], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  203a78:	9402      	str	r4, [sp, #8]
    c = *fmt++;
  203a7a:	461f      	mov	r7, r3
  203a7c:	f817 1b01 	ldrb.w	r1, [r7], #1
    if (c == 0)
  203a80:	2900      	cmp	r1, #0
  203a82:	f000 8151 	beq.w	203d28 <chprintf+0x2c4>
    if (c != '%') {
  203a86:	2925      	cmp	r1, #37	; 0x25
  203a88:	d007      	beq.n	203a9a <chprintf+0x36>
      streamPut(chp, (uint8_t)c);
  203a8a:	f8d8 3000 	ldr.w	r3, [r8]
  203a8e:	4640      	mov	r0, r8
      n++;
  203a90:	f109 0901 	add.w	r9, r9, #1
      streamPut(chp, (uint8_t)c);
  203a94:	68db      	ldr	r3, [r3, #12]
  203a96:	4798      	blx	r3
      continue;
  203a98:	e110      	b.n	203cbc <chprintf+0x258>
    if (*fmt == '-') {
  203a9a:	785a      	ldrb	r2, [r3, #1]
    width = 0;
  203a9c:	f04f 0b00 	mov.w	fp, #0
    if (*fmt == '-') {
  203aa0:	2a2d      	cmp	r2, #45	; 0x2d
      fmt++;
  203aa2:	bf0a      	itet	eq
  203aa4:	1c9f      	addeq	r7, r3, #2
    left_align = FALSE;
  203aa6:	2300      	movne	r3, #0
      left_align = TRUE;
  203aa8:	2301      	moveq	r3, #1
    if (*fmt == '0') {
  203aaa:	f897 a000 	ldrb.w	sl, [r7]
    left_align = FALSE;
  203aae:	9301      	str	r3, [sp, #4]
    if (*fmt == '0') {
  203ab0:	f1ba 0f30 	cmp.w	sl, #48	; 0x30
  203ab4:	bf0c      	ite	eq
  203ab6:	3701      	addeq	r7, #1
    filler = ' ';
  203ab8:	f04f 0a20 	movne.w	sl, #32
      c = *fmt++;
  203abc:	f817 2b01 	ldrb.w	r2, [r7], #1
      if (c >= '0' && c <= '9')
  203ac0:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
  203ac4:	b2c9      	uxtb	r1, r1
  203ac6:	2909      	cmp	r1, #9
  203ac8:	d904      	bls.n	203ad4 <chprintf+0x70>
      else if (c == '*')
  203aca:	2a2a      	cmp	r2, #42	; 0x2a
  203acc:	d106      	bne.n	203adc <chprintf+0x78>
        c = va_arg(ap, int);
  203ace:	f854 1b04 	ldr.w	r1, [r4], #4
  203ad2:	b2c9      	uxtb	r1, r1
      width = width * 10 + c;
  203ad4:	230a      	movs	r3, #10
  203ad6:	fb03 1b0b 	mla	fp, r3, fp, r1
  203ada:	e7ef      	b.n	203abc <chprintf+0x58>
    if (c == '.') {
  203adc:	2a2e      	cmp	r2, #46	; 0x2e
    precision = 0;
  203ade:	f04f 0100 	mov.w	r1, #0
    if (c == '.') {
  203ae2:	d10f      	bne.n	203b04 <chprintf+0xa0>
        c = *fmt++;
  203ae4:	f817 2b01 	ldrb.w	r2, [r7], #1
        if (c >= '0' && c <= '9')
  203ae8:	f1a2 0030 	sub.w	r0, r2, #48	; 0x30
  203aec:	b2c0      	uxtb	r0, r0
  203aee:	2809      	cmp	r0, #9
  203af0:	d904      	bls.n	203afc <chprintf+0x98>
        else if (c == '*')
  203af2:	2a2a      	cmp	r2, #42	; 0x2a
  203af4:	d106      	bne.n	203b04 <chprintf+0xa0>
          c = va_arg(ap, int);
  203af6:	f854 0b04 	ldr.w	r0, [r4], #4
  203afa:	b2c0      	uxtb	r0, r0
        precision += c;
  203afc:	230a      	movs	r3, #10
  203afe:	fb03 0101 	mla	r1, r3, r1, r0
  203b02:	e7ef      	b.n	203ae4 <chprintf+0x80>
    if (c == 'l' || c == 'L') {
  203b04:	f002 00df 	and.w	r0, r2, #223	; 0xdf
  203b08:	284c      	cmp	r0, #76	; 0x4c
  203b0a:	d115      	bne.n	203b38 <chprintf+0xd4>
      if (*fmt)
  203b0c:	7838      	ldrb	r0, [r7, #0]
  203b0e:	b108      	cbz	r0, 203b14 <chprintf+0xb0>
  203b10:	3701      	adds	r7, #1
  203b12:	4602      	mov	r2, r0
    switch (c) {
  203b14:	2a64      	cmp	r2, #100	; 0x64
  203b16:	d070      	beq.n	203bfa <chprintf+0x196>
  203b18:	f200 80e3 	bhi.w	203ce2 <chprintf+0x27e>
  203b1c:	2a58      	cmp	r2, #88	; 0x58
  203b1e:	f000 80d9 	beq.w	203cd4 <chprintf+0x270>
  203b22:	d821      	bhi.n	203b68 <chprintf+0x104>
  203b24:	2a4f      	cmp	r2, #79	; 0x4f
  203b26:	f000 80b5 	beq.w	203c94 <chprintf+0x230>
  203b2a:	f200 80d5 	bhi.w	203cd8 <chprintf+0x274>
  203b2e:	2a44      	cmp	r2, #68	; 0x44
  203b30:	d063      	beq.n	203bfa <chprintf+0x196>
  203b32:	2a49      	cmp	r2, #73	; 0x49
  203b34:	d061      	beq.n	203bfa <chprintf+0x196>
  203b36:	e010      	b.n	203b5a <chprintf+0xf6>
      is_long = (c >= 'A') && (c <= 'Z');
  203b38:	f1a2 0041 	sub.w	r0, r2, #65	; 0x41
    switch (c) {
  203b3c:	2a64      	cmp	r2, #100	; 0x64
      is_long = (c >= 'A') && (c <= 'Z');
  203b3e:	b2c0      	uxtb	r0, r0
    switch (c) {
  203b40:	d057      	beq.n	203bf2 <chprintf+0x18e>
  203b42:	d81e      	bhi.n	203b82 <chprintf+0x11e>
  203b44:	2a55      	cmp	r2, #85	; 0x55
  203b46:	f000 8096 	beq.w	203c76 <chprintf+0x212>
  203b4a:	d80a      	bhi.n	203b62 <chprintf+0xfe>
  203b4c:	2a49      	cmp	r2, #73	; 0x49
  203b4e:	d050      	beq.n	203bf2 <chprintf+0x18e>
  203b50:	2a4f      	cmp	r2, #79	; 0x4f
  203b52:	f000 809b 	beq.w	203c8c <chprintf+0x228>
  203b56:	2a44      	cmp	r2, #68	; 0x44
  203b58:	d04b      	beq.n	203bf2 <chprintf+0x18e>
      *p++ = c;
  203b5a:	4626      	mov	r6, r4
  203b5c:	f88d 200c 	strb.w	r2, [sp, #12]
      break;
  203b60:	e00b      	b.n	203b7a <chprintf+0x116>
    switch (c) {
  203b62:	2a58      	cmp	r2, #88	; 0x58
  203b64:	f000 8094 	beq.w	203c90 <chprintf+0x22c>
  203b68:	2a63      	cmp	r2, #99	; 0x63
  203b6a:	d1f6      	bne.n	203b5a <chprintf+0xf6>
      *p++ = va_arg(ap, int);
  203b6c:	4626      	mov	r6, r4
      filler = ' ';
  203b6e:	f04f 0a20 	mov.w	sl, #32
      *p++ = va_arg(ap, int);
  203b72:	f856 2b04 	ldr.w	r2, [r6], #4
  203b76:	f88d 200c 	strb.w	r2, [sp, #12]
    s = tmpbuf;
  203b7a:	ad03      	add	r5, sp, #12
      *p++ = c;
  203b7c:	f10d 000d 	add.w	r0, sp, #13
  203b80:	e04c      	b.n	203c1c <chprintf+0x1b8>
    switch (c) {
  203b82:	2a69      	cmp	r2, #105	; 0x69
  203b84:	d035      	beq.n	203bf2 <chprintf+0x18e>
  203b86:	f1a2 056f 	sub.w	r5, r2, #111	; 0x6f
  203b8a:	b2ee      	uxtb	r6, r5
  203b8c:	2e09      	cmp	r6, #9
  203b8e:	d8e4      	bhi.n	203b5a <chprintf+0xf6>
  203b90:	2d09      	cmp	r5, #9
  203b92:	d8e2      	bhi.n	203b5a <chprintf+0xf6>
  203b94:	a301      	add	r3, pc, #4	; (adr r3, 203b9c <chprintf+0x138>)
  203b96:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
  203b9a:	bf00      	nop
  203b9c:	00203c8d 	.word	0x00203c8d
  203ba0:	00203b5b 	.word	0x00203b5b
  203ba4:	00203b5b 	.word	0x00203b5b
  203ba8:	00203b5b 	.word	0x00203b5b
  203bac:	00203bc5 	.word	0x00203bc5
  203bb0:	00203b5b 	.word	0x00203b5b
  203bb4:	00203c77 	.word	0x00203c77
  203bb8:	00203b5b 	.word	0x00203b5b
  203bbc:	00203b5b 	.word	0x00203b5b
  203bc0:	00203c91 	.word	0x00203c91
      if ((s = va_arg(ap, char *)) == 0)
  203bc4:	4626      	mov	r6, r4
        s = "(null)";
  203bc6:	4b5b      	ldr	r3, [pc, #364]	; (203d34 <chprintf+0x2d0>)
        precision = 32767;
  203bc8:	f647 72ff 	movw	r2, #32767	; 0x7fff
      if ((s = va_arg(ap, char *)) == 0)
  203bcc:	f856 5b04 	ldr.w	r5, [r6], #4
        precision = 32767;
  203bd0:	2900      	cmp	r1, #0
  203bd2:	bf08      	it	eq
  203bd4:	4611      	moveq	r1, r2
        s = "(null)";
  203bd6:	2d00      	cmp	r5, #0
  203bd8:	bf08      	it	eq
  203bda:	461d      	moveq	r5, r3
      if (precision == 0)
  203bdc:	4429      	add	r1, r5
        precision = 32767;
  203bde:	4628      	mov	r0, r5
      for (p = s; *p && (--precision >= 0); p++)
  203be0:	7802      	ldrb	r2, [r0, #0]
  203be2:	b10a      	cbz	r2, 203be8 <chprintf+0x184>
  203be4:	4288      	cmp	r0, r1
  203be6:	d102      	bne.n	203bee <chprintf+0x18a>
      filler = ' ';
  203be8:	f04f 0a20 	mov.w	sl, #32
  203bec:	e016      	b.n	203c1c <chprintf+0x1b8>
      for (p = s; *p && (--precision >= 0); p++)
  203bee:	3001      	adds	r0, #1
  203bf0:	e7f6      	b.n	203be0 <chprintf+0x17c>
      if (is_long)
  203bf2:	2819      	cmp	r0, #25
  203bf4:	f104 0604 	add.w	r6, r4, #4
  203bf8:	d83b      	bhi.n	203c72 <chprintf+0x20e>
        l = va_arg(ap, long);
  203bfa:	4626      	mov	r6, r4
  203bfc:	f856 1b04 	ldr.w	r1, [r6], #4
      if (l < 0) {
  203c00:	2900      	cmp	r1, #0
        *p++ = '-';
  203c02:	bfbd      	ittte	lt
  203c04:	222d      	movlt	r2, #45	; 0x2d
        l = -l;
  203c06:	4249      	neglt	r1, r1
        *p++ = '-';
  203c08:	f10d 000d 	addlt.w	r0, sp, #13
    p = tmpbuf;
  203c0c:	a803      	addge	r0, sp, #12
        *p++ = '-';
  203c0e:	bfb8      	it	lt
  203c10:	f88d 200c 	strblt.w	r2, [sp, #12]
  return long_to_string_with_divisor(p, num, radix, 0);
  203c14:	220a      	movs	r2, #10
    s = tmpbuf;
  203c16:	ad03      	add	r5, sp, #12
  return long_to_string_with_divisor(p, num, radix, 0);
  203c18:	f7fc fe1c 	bl	200854 <long_to_string_with_divisor.constprop.0>
    i = (int)(p - s);
  203c1c:	1b44      	subs	r4, r0, r5
    if (left_align == FALSE)
  203c1e:	9901      	ldr	r1, [sp, #4]
    if ((width -= i) < 0)
  203c20:	ebab 0304 	sub.w	r3, fp, r4
  203c24:	ea23 72e3 	bic.w	r2, r3, r3, asr #31
    if (left_align == FALSE)
  203c28:	2900      	cmp	r1, #0
  203c2a:	d149      	bne.n	203cc0 <chprintf+0x25c>
    if (width < 0) {
  203c2c:	2b00      	cmp	r3, #0
      width = -width;
  203c2e:	f1c2 0b00 	rsb	fp, r2, #0
    if (width < 0) {
  203c32:	dd1c      	ble.n	203c6e <chprintf+0x20a>
      if (*s == '-' && filler == '0') {
  203c34:	7829      	ldrb	r1, [r5, #0]
  203c36:	292d      	cmp	r1, #45	; 0x2d
  203c38:	d10d      	bne.n	203c56 <chprintf+0x1f2>
  203c3a:	f1ba 0f30 	cmp.w	sl, #48	; 0x30
  203c3e:	d10a      	bne.n	203c56 <chprintf+0x1f2>
        streamPut(chp, (uint8_t)*s++);
  203c40:	f8d8 3000 	ldr.w	r3, [r8]
  203c44:	4640      	mov	r0, r8
  203c46:	9201      	str	r2, [sp, #4]
  203c48:	3c01      	subs	r4, #1
  203c4a:	68db      	ldr	r3, [r3, #12]
  203c4c:	f109 0901 	add.w	r9, r9, #1
  203c50:	4798      	blx	r3
  203c52:	3501      	adds	r5, #1
  203c54:	9a01      	ldr	r2, [sp, #4]
        streamPut(chp, (uint8_t)filler);
  203c56:	f8d8 3000 	ldr.w	r3, [r8]
  203c5a:	4651      	mov	r1, sl
  203c5c:	4640      	mov	r0, r8
  203c5e:	9201      	str	r2, [sp, #4]
  203c60:	68db      	ldr	r3, [r3, #12]
  203c62:	4798      	blx	r3
      } while (++width != 0);
  203c64:	f11b 0b01 	adds.w	fp, fp, #1
  203c68:	9a01      	ldr	r2, [sp, #4]
  203c6a:	d1f4      	bne.n	203c56 <chprintf+0x1f2>
  203c6c:	4491      	add	r9, r2
    if (left_align == FALSE)
  203c6e:	4623      	mov	r3, r4
  203c70:	e01b      	b.n	203caa <chprintf+0x246>
        l = va_arg(ap, int);
  203c72:	6821      	ldr	r1, [r4, #0]
  203c74:	e7c4      	b.n	203c00 <chprintf+0x19c>
      c = 10;
  203c76:	220a      	movs	r2, #10
      if (is_long)
  203c78:	4626      	mov	r6, r4
  203c7a:	2819      	cmp	r0, #25
  203c7c:	f856 1b04 	ldr.w	r1, [r6], #4
  203c80:	d802      	bhi.n	203c88 <chprintf+0x224>
        l = va_arg(ap, unsigned long);
  203c82:	4626      	mov	r6, r4
  203c84:	f856 1b04 	ldr.w	r1, [r6], #4
  return long_to_string_with_divisor(p, num, radix, 0);
  203c88:	a803      	add	r0, sp, #12
  203c8a:	e7c4      	b.n	203c16 <chprintf+0x1b2>
      c = 8;
  203c8c:	2208      	movs	r2, #8
  203c8e:	e7f3      	b.n	203c78 <chprintf+0x214>
    switch (c) {
  203c90:	2210      	movs	r2, #16
  203c92:	e7f1      	b.n	203c78 <chprintf+0x214>
  203c94:	2208      	movs	r2, #8
  203c96:	e7f4      	b.n	203c82 <chprintf+0x21e>
      streamPut(chp, (uint8_t)*s++);
  203c98:	f8d8 2000 	ldr.w	r2, [r8]
  203c9c:	4640      	mov	r0, r8
  203c9e:	f815 1b01 	ldrb.w	r1, [r5], #1
  203ca2:	68d2      	ldr	r2, [r2, #12]
  203ca4:	9301      	str	r3, [sp, #4]
  203ca6:	4790      	blx	r2
      n++;
  203ca8:	9b01      	ldr	r3, [sp, #4]
    while (--i >= 0) {
  203caa:	3b01      	subs	r3, #1
  203cac:	d5f4      	bpl.n	203c98 <chprintf+0x234>
  203cae:	2c00      	cmp	r4, #0
  203cb0:	bfa8      	it	ge
  203cb2:	44a1      	addge	r9, r4
  203cb4:	465d      	mov	r5, fp
    while (width) {
  203cb6:	b92d      	cbnz	r5, 203cc4 <chprintf+0x260>
  203cb8:	44d9      	add	r9, fp
  203cba:	4634      	mov	r4, r6
  203cbc:	463b      	mov	r3, r7
  203cbe:	e6dc      	b.n	203a7a <chprintf+0x16>
    if (left_align == FALSE)
  203cc0:	4693      	mov	fp, r2
  203cc2:	e7d4      	b.n	203c6e <chprintf+0x20a>
      streamPut(chp, (uint8_t)filler);
  203cc4:	f8d8 3000 	ldr.w	r3, [r8]
  203cc8:	4651      	mov	r1, sl
  203cca:	4640      	mov	r0, r8
      width--;
  203ccc:	3d01      	subs	r5, #1
      streamPut(chp, (uint8_t)filler);
  203cce:	68db      	ldr	r3, [r3, #12]
  203cd0:	4798      	blx	r3
      width--;
  203cd2:	e7f0      	b.n	203cb6 <chprintf+0x252>
    switch (c) {
  203cd4:	2210      	movs	r2, #16
  203cd6:	e7d4      	b.n	203c82 <chprintf+0x21e>
  203cd8:	2a55      	cmp	r2, #85	; 0x55
  203cda:	f47f af3e 	bne.w	203b5a <chprintf+0xf6>
      c = 10;
  203cde:	220a      	movs	r2, #10
      if (is_long)
  203ce0:	e7cf      	b.n	203c82 <chprintf+0x21e>
    switch (c) {
  203ce2:	2a69      	cmp	r2, #105	; 0x69
  203ce4:	d089      	beq.n	203bfa <chprintf+0x196>
  203ce6:	f1a2 006f 	sub.w	r0, r2, #111	; 0x6f
  203cea:	b2c5      	uxtb	r5, r0
  203cec:	2d09      	cmp	r5, #9
  203cee:	f63f af34 	bhi.w	203b5a <chprintf+0xf6>
  203cf2:	2809      	cmp	r0, #9
  203cf4:	f63f af31 	bhi.w	203b5a <chprintf+0xf6>
  203cf8:	a301      	add	r3, pc, #4	; (adr r3, 203d00 <chprintf+0x29c>)
  203cfa:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
  203cfe:	bf00      	nop
  203d00:	00203c95 	.word	0x00203c95
  203d04:	00203b5b 	.word	0x00203b5b
  203d08:	00203b5b 	.word	0x00203b5b
  203d0c:	00203b5b 	.word	0x00203b5b
  203d10:	00203bc5 	.word	0x00203bc5
  203d14:	00203b5b 	.word	0x00203b5b
  203d18:	00203cdf 	.word	0x00203cdf
  203d1c:	00203b5b 	.word	0x00203b5b
  203d20:	00203b5b 	.word	0x00203b5b
  203d24:	00203cd5 	.word	0x00203cd5
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
  203d28:	4648      	mov	r0, r9
  203d2a:	b006      	add	sp, #24
  203d2c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  203d30:	b003      	add	sp, #12
  203d32:	4770      	bx	lr
  203d34:	0800dc17 	.word	0x0800dc17

00203d38 <cmd_info>:

#if (SHELL_CMD_INFO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
  203d38:	2900      	cmp	r1, #0
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
  203d3a:	b513      	push	{r0, r1, r4, lr}
  203d3c:	4604      	mov	r4, r0
  if (argc > 0) {
  203d3e:	dd06      	ble.n	203d4e <cmd_info+0x16>
    shellUsage(chp, "info");
  203d40:	4a19      	ldr	r2, [pc, #100]	; (203da8 <cmd_info+0x70>)
  203d42:	491a      	ldr	r1, [pc, #104]	; (203dac <cmd_info+0x74>)
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s" SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
#endif
#endif
}
  203d44:	b002      	add	sp, #8
  203d46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    shellUsage(chp, "info");
  203d4a:	f7ff be8b 	b.w	203a64 <chprintf>
  chprintf(chp, "Kernel:       %s" SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
  203d4e:	4a18      	ldr	r2, [pc, #96]	; (203db0 <cmd_info+0x78>)
  203d50:	4918      	ldr	r1, [pc, #96]	; (203db4 <cmd_info+0x7c>)
  203d52:	f7ff fe87 	bl	203a64 <chprintf>
  chprintf(chp, "Compiler:     %s" SHELL_NEWLINE_STR, PORT_COMPILER_NAME);
  203d56:	4a18      	ldr	r2, [pc, #96]	; (203db8 <cmd_info+0x80>)
  203d58:	4918      	ldr	r1, [pc, #96]	; (203dbc <cmd_info+0x84>)
  203d5a:	4620      	mov	r0, r4
  203d5c:	f7ff fe82 	bl	203a64 <chprintf>
  chprintf(chp, "Architecture: %s" SHELL_NEWLINE_STR, PORT_ARCHITECTURE_NAME);
  203d60:	4a17      	ldr	r2, [pc, #92]	; (203dc0 <cmd_info+0x88>)
  203d62:	4918      	ldr	r1, [pc, #96]	; (203dc4 <cmd_info+0x8c>)
  203d64:	4620      	mov	r0, r4
  203d66:	f7ff fe7d 	bl	203a64 <chprintf>
  chprintf(chp, "Core Variant: %s" SHELL_NEWLINE_STR, PORT_CORE_VARIANT_NAME);
  203d6a:	4a17      	ldr	r2, [pc, #92]	; (203dc8 <cmd_info+0x90>)
  203d6c:	4917      	ldr	r1, [pc, #92]	; (203dcc <cmd_info+0x94>)
  203d6e:	4620      	mov	r0, r4
  203d70:	f7ff fe78 	bl	203a64 <chprintf>
  chprintf(chp, "Port Info:    %s" SHELL_NEWLINE_STR, PORT_INFO);
  203d74:	4a16      	ldr	r2, [pc, #88]	; (203dd0 <cmd_info+0x98>)
  203d76:	4917      	ldr	r1, [pc, #92]	; (203dd4 <cmd_info+0x9c>)
  203d78:	4620      	mov	r0, r4
  203d7a:	f7ff fe73 	bl	203a64 <chprintf>
  chprintf(chp, "Platform:     %s" SHELL_NEWLINE_STR, PLATFORM_NAME);
  203d7e:	4a16      	ldr	r2, [pc, #88]	; (203dd8 <cmd_info+0xa0>)
  203d80:	4916      	ldr	r1, [pc, #88]	; (203ddc <cmd_info+0xa4>)
  203d82:	4620      	mov	r0, r4
  203d84:	f7ff fe6e 	bl	203a64 <chprintf>
  chprintf(chp, "Board:        %s" SHELL_NEWLINE_STR, BOARD_NAME);
  203d88:	4a15      	ldr	r2, [pc, #84]	; (203de0 <cmd_info+0xa8>)
  203d8a:	4916      	ldr	r1, [pc, #88]	; (203de4 <cmd_info+0xac>)
  203d8c:	4620      	mov	r0, r4
  203d8e:	f7ff fe69 	bl	203a64 <chprintf>
  chprintf(chp, "Build time:   %s%s%s" SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
  203d92:	4b15      	ldr	r3, [pc, #84]	; (203de8 <cmd_info+0xb0>)
  203d94:	4a15      	ldr	r2, [pc, #84]	; (203dec <cmd_info+0xb4>)
  203d96:	4620      	mov	r0, r4
  203d98:	9300      	str	r3, [sp, #0]
  203d9a:	4915      	ldr	r1, [pc, #84]	; (203df0 <cmd_info+0xb8>)
  203d9c:	4b15      	ldr	r3, [pc, #84]	; (203df4 <cmd_info+0xbc>)
  203d9e:	f7ff fe61 	bl	203a64 <chprintf>
}
  203da2:	b002      	add	sp, #8
  203da4:	bd10      	pop	{r4, pc}
  203da6:	bf00      	nop
  203da8:	0800dc1e 	.word	0x0800dc1e
  203dac:	0800dc23 	.word	0x0800dc23
  203db0:	0800dc2f 	.word	0x0800dc2f
  203db4:	0800dc35 	.word	0x0800dc35
  203db8:	0800dc48 	.word	0x0800dc48
  203dbc:	0800dc52 	.word	0x0800dc52
  203dc0:	0800dc65 	.word	0x0800dc65
  203dc4:	0800dc6e 	.word	0x0800dc6e
  203dc8:	0800dc81 	.word	0x0800dc81
  203dcc:	0800dc92 	.word	0x0800dc92
  203dd0:	0800dca5 	.word	0x0800dca5
  203dd4:	0800dcba 	.word	0x0800dcba
  203dd8:	0800dccd 	.word	0x0800dccd
  203ddc:	0800dcfe 	.word	0x0800dcfe
  203de0:	0800dd11 	.word	0x0800dd11
  203de4:	0800dd39 	.word	0x0800dd39
  203de8:	0800dd6f 	.word	0x0800dd6f
  203dec:	0800dd4c 	.word	0x0800dd4c
  203df0:	0800dd58 	.word	0x0800dd58
  203df4:	0800e026 	.word	0x0800e026

00203df8 <chThdDequeueNextI.constprop.0>:
  return (bool)(tqp->next != (const thread_t *)tqp);
  203df8:	6803      	ldr	r3, [r0, #0]
  if (queue_notempty(tqp)) {
  203dfa:	4298      	cmp	r0, r3
  203dfc:	d007      	beq.n	203e0e <chThdDequeueNextI.constprop.0+0x16>
  tqp->next             = tp->queue.next;
  203dfe:	681a      	ldr	r2, [r3, #0]
  203e00:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  203e02:	6050      	str	r0, [r2, #4]
  tp->u.rdymsg = msg;
  203e04:	2200      	movs	r2, #0
  (void) chSchReadyI(tp);
  203e06:	4618      	mov	r0, r3
  tp->u.rdymsg = msg;
  203e08:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
  203e0a:	f7fd ba6f 	b.w	2012ec <chSchReadyI>
}
  203e0e:	4770      	bx	lr

00203e10 <trapHandle>:
{
	int i;

	/* Reset the serial port. */

	USART1->ISR = 0xFFFFFFFF;
  203e10:	4b27      	ldr	r3, [pc, #156]	; (203eb0 <trapHandle+0xa0>)
{
  203e12:	4604      	mov	r4, r0
	(void)USART1->ISR;
  203e14:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
{
  203e18:	b507      	push	{r0, r1, r2, lr}
	USART1->ISR = 0xFFFFFFFF;
  203e1a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  203e1e:	61d8      	str	r0, [r3, #28]
	(void)USART1->ISR;
  203e20:	69db      	ldr	r3, [r3, #28]
  203e22:	f3bf 8f4f 	dsb	sy

	for (i = 0; i < 1000; i++)
  203e26:	3d01      	subs	r5, #1
  203e28:	d1fb      	bne.n	203e22 <trapHandle+0x12>
		__DSB();

	_puts ("");
  203e2a:	4822      	ldr	r0, [pc, #136]	; (203eb4 <trapHandle+0xa4>)
  203e2c:	e9cd 1200 	strd	r1, r2, [sp]
  203e30:	f7fc fd38 	bl	2008a4 <_puts>
	_puts ("");
  203e34:	481f      	ldr	r0, [pc, #124]	; (203eb4 <trapHandle+0xa4>)
  203e36:	f7fc fd35 	bl	2008a4 <_puts>
	 * Decoding the stack frame in this case may not
	 * actually yield valid results, but it's wrong
	 * to trigger another fault too.
	 */

	mpuDisable ();
  203e3a:	481f      	ldr	r0, [pc, #124]	; (203eb8 <trapHandle+0xa8>)
  203e3c:	6a43      	ldr	r3, [r0, #36]	; 0x24
  203e3e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  203e42:	6243      	str	r3, [r0, #36]	; 0x24
  203e44:	4b1d      	ldr	r3, [pc, #116]	; (203ebc <trapHandle+0xac>)
  203e46:	e9dd 1200 	ldrd	r1, r2, [sp]
  203e4a:	605d      	str	r5, [r3, #4]

	switch (type) {
  203e4c:	2c03      	cmp	r4, #3
  203e4e:	d82a      	bhi.n	203ea6 <trapHandle+0x96>
  203e50:	e8df f004 	tbb	[pc, r4]
  203e54:	20170e02 	.word	0x20170e02
		case HARD_FAULT:
			_puts ("********** HARD FAULT **********");
  203e58:	4819      	ldr	r0, [pc, #100]	; (203ec0 <trapHandle+0xb0>)
  203e5a:	e9cd 1200 	strd	r1, r2, [sp]
  203e5e:	f7fc fd21 	bl	2008a4 <_puts>
			dumpFrame (type, exc_lr, exc_sp);
  203e62:	2000      	movs	r0, #0
  203e64:	e9dd 1200 	ldrd	r1, r2, [sp]
			break;
		case BUS_FAULT:
			_puts ("********** BUS FAULT **********");
			dumpFrame (type, exc_lr, exc_sp);
  203e68:	f7fd fd62 	bl	201930 <dumpFrame>
			break;
	}

	/* Break into the debugger */

	__asm__ ("bkpt #0");
  203e6c:	be00      	bkpt	0x0000

	while (1) {
	}
  203e6e:	e7fe      	b.n	203e6e <trapHandle+0x5e>
			_puts ("********** BUS FAULT **********");
  203e70:	4814      	ldr	r0, [pc, #80]	; (203ec4 <trapHandle+0xb4>)
  203e72:	e9cd 1200 	strd	r1, r2, [sp]
  203e76:	f7fc fd15 	bl	2008a4 <_puts>
			dumpFrame (type, exc_lr, exc_sp);
  203e7a:	2001      	movs	r0, #1
  203e7c:	e9dd 1200 	ldrd	r1, r2, [sp]
  203e80:	e7f2      	b.n	203e68 <trapHandle+0x58>
			_puts ("********** USAGE FAULT **********");
  203e82:	4811      	ldr	r0, [pc, #68]	; (203ec8 <trapHandle+0xb8>)
  203e84:	e9cd 1200 	strd	r1, r2, [sp]
  203e88:	f7fc fd0c 	bl	2008a4 <_puts>
			dumpFrame (type, exc_lr, exc_sp);
  203e8c:	2002      	movs	r0, #2
  203e8e:	e9dd 1200 	ldrd	r1, r2, [sp]
  203e92:	e7e9      	b.n	203e68 <trapHandle+0x58>
			_puts ("********** MEMMANAGE FAULT **********");
  203e94:	480d      	ldr	r0, [pc, #52]	; (203ecc <trapHandle+0xbc>)
  203e96:	e9cd 1200 	strd	r1, r2, [sp]
  203e9a:	f7fc fd03 	bl	2008a4 <_puts>
			dumpFrame (type, exc_lr, exc_sp);
  203e9e:	2003      	movs	r0, #3
  203ea0:	e9dd 1200 	ldrd	r1, r2, [sp]
  203ea4:	e7e0      	b.n	203e68 <trapHandle+0x58>
			_puts ("********** unknown fault **********");
  203ea6:	480a      	ldr	r0, [pc, #40]	; (203ed0 <trapHandle+0xc0>)
  203ea8:	f7fc fcfc 	bl	2008a4 <_puts>
			break;
  203eac:	e7de      	b.n	203e6c <trapHandle+0x5c>
  203eae:	bf00      	nop
  203eb0:	40011000 	.word	0x40011000
  203eb4:	0800dc16 	.word	0x0800dc16
  203eb8:	e000ed00 	.word	0xe000ed00
  203ebc:	e000ed90 	.word	0xe000ed90
  203ec0:	0800dd78 	.word	0x0800dd78
  203ec4:	0800dd99 	.word	0x0800dd99
  203ec8:	0800ddb9 	.word	0x0800ddb9
  203ecc:	0800dddb 	.word	0x0800dddb
  203ed0:	0800de01 	.word	0x0800de01

00203ed4 <_sbrk>:
}

__attribute__((used))
void *
_sbrk (int incr)
{
  203ed4:	b508      	push	{r3, lr}
	static char * heap_end;
	char *        prev_heap_end;

	if (heap_end == NULL)
  203ed6:	4b0a      	ldr	r3, [pc, #40]	; (203f00 <_sbrk+0x2c>)
{
  203ed8:	4602      	mov	r2, r0
	if (heap_end == NULL)
  203eda:	6819      	ldr	r1, [r3, #0]
  203edc:	b909      	cbnz	r1, 203ee2 <_sbrk+0xe>
		heap_end = HEAP_BASE;
  203ede:	4909      	ldr	r1, [pc, #36]	; (203f04 <_sbrk+0x30>)
  203ee0:	6019      	str	r1, [r3, #0]
    
	if ((heap_end + incr) > HEAP_END) {
  203ee2:	6818      	ldr	r0, [r3, #0]
  203ee4:	4402      	add	r2, r0
  203ee6:	f112 5f7e 	cmn.w	r2, #1065353216	; 0x3f800000
  203eea:	d306      	bcc.n	203efa <_sbrk+0x26>
		errno = ENOMEM;
  203eec:	f005 f9ac 	bl	209248 <__errno>
  203ef0:	230c      	movs	r3, #12
  203ef2:	6003      	str	r3, [r0, #0]
  203ef4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

	prev_heap_end = heap_end;
	heap_end += incr;

	return (void *) prev_heap_end;
}
  203ef8:	bd08      	pop	{r3, pc}
	heap_end += incr;
  203efa:	601a      	str	r2, [r3, #0]
	return (void *) prev_heap_end;
  203efc:	e7fc      	b.n	203ef8 <_sbrk+0x24>
  203efe:	bf00      	nop
  203f00:	20002720 	.word	0x20002720
  203f04:	c003fc00 	.word	0xc003fc00

00203f08 <_isatty>:
}
  203f08:	2802      	cmp	r0, #2
  203f0a:	bf8c      	ite	hi
  203f0c:	2000      	movhi	r0, #0
  203f0e:	2001      	movls	r0, #1
  203f10:	4770      	bx	lr
	...

00203f14 <_fstat>:
{
  203f14:	b508      	push	{r3, lr}
	st->st_blksize = 512;
  203f16:	f44f 7300 	mov.w	r3, #512	; 0x200
	if (desc < 3)
  203f1a:	2802      	cmp	r0, #2
	st->st_blksize = 512;
  203f1c:	644b      	str	r3, [r1, #68]	; 0x44
	st->st_size = 0;
  203f1e:	f04f 0300 	mov.w	r3, #0
  203f22:	610b      	str	r3, [r1, #16]
	st->st_blocks = 0;
  203f24:	648b      	str	r3, [r1, #72]	; 0x48
	if (desc < 3)
  203f26:	dc01      	bgt.n	203f2c <_fstat+0x18>
		return (0);
  203f28:	2000      	movs	r0, #0
}
  203f2a:	bd08      	pop	{r3, pc}
	if (desc > MAX_FILES) {
  203f2c:	2805      	cmp	r0, #5
  203f2e:	dd06      	ble.n	203f3e <_fstat+0x2a>
		errno = EINVAL;
  203f30:	f005 f98a 	bl	209248 <__errno>
  203f34:	2316      	movs	r3, #22
  203f36:	6003      	str	r3, [r0, #0]
  203f38:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  203f3c:	e7f5      	b.n	203f2a <_fstat+0x16>
	i = desc - 3;
  203f3e:	3803      	subs	r0, #3
	if (file_used[i] == 0) {
  203f40:	4b09      	ldr	r3, [pc, #36]	; (203f68 <_fstat+0x54>)
  203f42:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
  203f46:	2b00      	cmp	r3, #0
  203f48:	d0f2      	beq.n	203f30 <_fstat+0x1c>
	st->st_size = f_size (f);
  203f4a:	4b08      	ldr	r3, [pc, #32]	; (203f6c <_fstat+0x58>)
  203f4c:	f44f 720b 	mov.w	r2, #556	; 0x22c
  203f50:	fb02 3000 	mla	r0, r2, r0, r3
  203f54:	68c0      	ldr	r0, [r0, #12]
  203f56:	6108      	str	r0, [r1, #16]
	if (st->st_blocks == 0)
  203f58:	0a40      	lsrs	r0, r0, #9
  203f5a:	d001      	beq.n	203f60 <_fstat+0x4c>
	st->st_blocks = f_size (f) / 512;
  203f5c:	6488      	str	r0, [r1, #72]	; 0x48
  203f5e:	e7e3      	b.n	203f28 <_fstat+0x14>
		st->st_blocks++;
  203f60:	2301      	movs	r3, #1
  203f62:	648b      	str	r3, [r1, #72]	; 0x48
  203f64:	e7e1      	b.n	203f2a <_fstat+0x16>
  203f66:	bf00      	nop
  203f68:	200026d8 	.word	0x200026d8
  203f6c:	20001bfc 	.word	0x20001bfc

00203f70 <_lseek>:
	if (dir == SEEK_END) {
  203f70:	2a02      	cmp	r2, #2
{
  203f72:	b510      	push	{r4, lr}
	if (dir == SEEK_END) {
  203f74:	d106      	bne.n	203f84 <_lseek+0x14>
		errno = EINVAL;
  203f76:	f005 f967 	bl	209248 <__errno>
  203f7a:	2316      	movs	r3, #22
		errno = EIO;
  203f7c:	6003      	str	r3, [r0, #0]
		return (-1);
  203f7e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  203f82:	bd10      	pop	{r4, pc}
	if (file < 3 || file > MAX_FILES) {
  203f84:	3803      	subs	r0, #3
  203f86:	2802      	cmp	r0, #2
  203f88:	d8f5      	bhi.n	203f76 <_lseek+0x6>
	if (file_used[i] == 0) {
  203f8a:	4b0e      	ldr	r3, [pc, #56]	; (203fc4 <_lseek+0x54>)
  203f8c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
  203f90:	2b00      	cmp	r3, #0
  203f92:	d0f0      	beq.n	203f76 <_lseek+0x6>
	f = &file_handles [i];
  203f94:	4b0c      	ldr	r3, [pc, #48]	; (203fc8 <_lseek+0x58>)
  203f96:	f44f 740b 	mov.w	r4, #556	; 0x22c
  203f9a:	fb04 3000 	mla	r0, r4, r0, r3
	if (dir == SEEK_SET)
  203f9e:	b112      	cbz	r2, 203fa6 <_lseek+0x36>
	if (dir == SEEK_CUR)
  203fa0:	2a01      	cmp	r2, #1
  203fa2:	d009      	beq.n	203fb8 <_lseek+0x48>
  203fa4:	2100      	movs	r1, #0
  203fa6:	460c      	mov	r4, r1
	if (f_lseek (f, offset) != FR_OK) {
  203fa8:	4621      	mov	r1, r4
  203faa:	f7fe ff4b 	bl	202e44 <f_lseek>
  203fae:	b130      	cbz	r0, 203fbe <_lseek+0x4e>
		errno = EIO;
  203fb0:	f005 f94a 	bl	209248 <__errno>
  203fb4:	2305      	movs	r3, #5
  203fb6:	e7e1      	b.n	203f7c <_lseek+0xc>
		offset = f_tell (f) + ptr;
  203fb8:	6944      	ldr	r4, [r0, #20]
  203fba:	440c      	add	r4, r1
  203fbc:	e7f4      	b.n	203fa8 <_lseek+0x38>
	return (offset);
  203fbe:	4620      	mov	r0, r4
  203fc0:	e7df      	b.n	203f82 <_lseek+0x12>
  203fc2:	bf00      	nop
  203fc4:	200026d8 	.word	0x200026d8
  203fc8:	20001bfc 	.word	0x20001bfc

00203fcc <_close>:
	if (file < 3 || file > MAX_FILES) {
  203fcc:	3803      	subs	r0, #3
  203fce:	2802      	cmp	r0, #2
{
  203fd0:	b510      	push	{r4, lr}
	if (file < 3 || file > MAX_FILES) {
  203fd2:	d906      	bls.n	203fe2 <_close+0x16>
		errno = EINVAL;
  203fd4:	f005 f938 	bl	209248 <__errno>
  203fd8:	2316      	movs	r3, #22
  203fda:	6003      	str	r3, [r0, #0]
		return (-1);
  203fdc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  203fe0:	bd10      	pop	{r4, pc}
	if (file_used[i] == 0) {
  203fe2:	4b08      	ldr	r3, [pc, #32]	; (204004 <_close+0x38>)
  203fe4:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
  203fe8:	2a00      	cmp	r2, #0
  203fea:	d0f3      	beq.n	203fd4 <_close+0x8>
	file_used[i] = 0;
  203fec:	2400      	movs	r4, #0
	f_close (f);
  203fee:	f44f 720b 	mov.w	r2, #556	; 0x22c
	file_used[i] = 0;
  203ff2:	f843 4020 	str.w	r4, [r3, r0, lsl #2]
	f_close (f);
  203ff6:	4b04      	ldr	r3, [pc, #16]	; (204008 <_close+0x3c>)
  203ff8:	fb02 3000 	mla	r0, r2, r0, r3
  203ffc:	f7fe fc24 	bl	202848 <f_close>
	return (0);
  204000:	4620      	mov	r0, r4
  204002:	e7ed      	b.n	203fe0 <_close+0x14>
  204004:	200026d8 	.word	0x200026d8
  204008:	20001bfc 	.word	0x20001bfc

0020400c <_write>:
{
  20400c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (file == 1 || file == 2) {
  20400e:	1e45      	subs	r5, r0, #1
{
  204010:	4614      	mov	r4, r2
	if (file == 1 || file == 2) {
  204012:	2d01      	cmp	r5, #1
  204014:	d818      	bhi.n	204048 <_write+0x3c>
  204016:	1e4d      	subs	r5, r1, #1
		for (i = 0; i < len; i++) {
  204018:	f1c1 0601 	rsb	r6, r1, #1
  20401c:	4f1a      	ldr	r7, [pc, #104]	; (204088 <_write+0x7c>)
  20401e:	1973      	adds	r3, r6, r5
  204020:	429c      	cmp	r4, r3
  204022:	dc02      	bgt.n	20402a <_write+0x1e>
}
  204024:	4620      	mov	r0, r4
  204026:	b003      	add	sp, #12
  204028:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (ptr[i] == '\n')
  20402a:	786b      	ldrb	r3, [r5, #1]
  20402c:	2b0a      	cmp	r3, #10
  20402e:	d104      	bne.n	20403a <_write+0x2e>
  204030:	6838      	ldr	r0, [r7, #0]
				streamPut (console, '\r');
  204032:	210d      	movs	r1, #13
  204034:	6803      	ldr	r3, [r0, #0]
  204036:	68db      	ldr	r3, [r3, #12]
  204038:	4798      	blx	r3
			streamPut (console, ptr[i]);
  20403a:	6838      	ldr	r0, [r7, #0]
  20403c:	f815 1f01 	ldrb.w	r1, [r5, #1]!
  204040:	6803      	ldr	r3, [r0, #0]
  204042:	68db      	ldr	r3, [r3, #12]
  204044:	4798      	blx	r3
  204046:	e7ea      	b.n	20401e <_write+0x12>
	if (file == 0 || file > MAX_FILES) {
  204048:	b108      	cbz	r0, 20404e <_write+0x42>
  20404a:	2805      	cmp	r0, #5
  20404c:	dd06      	ble.n	20405c <_write+0x50>
		errno = EINVAL;
  20404e:	f005 f8fb 	bl	209248 <__errno>
  204052:	2316      	movs	r3, #22
		return (-1);
  204054:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		errno = EIO;
  204058:	6003      	str	r3, [r0, #0]
		return (-1);
  20405a:	e7e3      	b.n	204024 <_write+0x18>
	i = file - 3;
  20405c:	3803      	subs	r0, #3
	if (file_used[i] == 0) {
  20405e:	4b0b      	ldr	r3, [pc, #44]	; (20408c <_write+0x80>)
  204060:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
  204064:	2b00      	cmp	r3, #0
  204066:	d0f2      	beq.n	20404e <_write+0x42>
	if (f_write (f, ptr, len, &br) != FR_OK) {
  204068:	4c09      	ldr	r4, [pc, #36]	; (204090 <_write+0x84>)
  20406a:	f44f 750b 	mov.w	r5, #556	; 0x22c
  20406e:	ab01      	add	r3, sp, #4
  204070:	fb05 4000 	mla	r0, r5, r0, r4
  204074:	f7fe fffc 	bl	203070 <f_write>
  204078:	b118      	cbz	r0, 204082 <_write+0x76>
		errno = EIO;
  20407a:	f005 f8e5 	bl	209248 <__errno>
  20407e:	2305      	movs	r3, #5
  204080:	e7e8      	b.n	204054 <_write+0x48>
	return (br);
  204082:	9c01      	ldr	r4, [sp, #4]
  204084:	e7ce      	b.n	204024 <_write+0x18>
  204086:	bf00      	nop
  204088:	200018a0 	.word	0x200018a0
  20408c:	200026d8 	.word	0x200026d8
  204090:	20001bfc 	.word	0x20001bfc

00204094 <_read>:
{
  204094:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (file == 0) {
  204096:	b940      	cbnz	r0, 2040aa <_read+0x16>
		streamRead (console, (uint8_t *)&ptr[0], 1);
  204098:	4b14      	ldr	r3, [pc, #80]	; (2040ec <_read+0x58>)
  20409a:	2201      	movs	r2, #1
  20409c:	6818      	ldr	r0, [r3, #0]
  20409e:	6803      	ldr	r3, [r0, #0]
  2040a0:	689b      	ldr	r3, [r3, #8]
  2040a2:	4798      	blx	r3
		return (1);
  2040a4:	2001      	movs	r0, #1
}
  2040a6:	b003      	add	sp, #12
  2040a8:	bd30      	pop	{r4, r5, pc}
	if (file == 1 || file == 2 || file > MAX_FILES) {
  2040aa:	1e43      	subs	r3, r0, #1
  2040ac:	2b01      	cmp	r3, #1
  2040ae:	d901      	bls.n	2040b4 <_read+0x20>
  2040b0:	2805      	cmp	r0, #5
  2040b2:	dd06      	ble.n	2040c2 <_read+0x2e>
		errno = EINVAL;
  2040b4:	f005 f8c8 	bl	209248 <__errno>
  2040b8:	2316      	movs	r3, #22
		errno = EIO;
  2040ba:	6003      	str	r3, [r0, #0]
  2040bc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  2040c0:	e7f1      	b.n	2040a6 <_read+0x12>
	i = file - 3;
  2040c2:	3803      	subs	r0, #3
	if (file_used[i] == 0) {
  2040c4:	4b0a      	ldr	r3, [pc, #40]	; (2040f0 <_read+0x5c>)
  2040c6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
  2040ca:	2b00      	cmp	r3, #0
  2040cc:	d0f2      	beq.n	2040b4 <_read+0x20>
	if (f_read (f, ptr, len, &br) != FR_OK) {
  2040ce:	4c09      	ldr	r4, [pc, #36]	; (2040f4 <_read+0x60>)
  2040d0:	f44f 750b 	mov.w	r5, #556	; 0x22c
  2040d4:	ab01      	add	r3, sp, #4
  2040d6:	fb05 4000 	mla	r0, r5, r0, r4
  2040da:	f7fe faa4 	bl	202626 <f_read>
  2040de:	b118      	cbz	r0, 2040e8 <_read+0x54>
		errno = EIO;
  2040e0:	f005 f8b2 	bl	209248 <__errno>
  2040e4:	2305      	movs	r3, #5
  2040e6:	e7e8      	b.n	2040ba <_read+0x26>
	return (br);
  2040e8:	9801      	ldr	r0, [sp, #4]
  2040ea:	e7dc      	b.n	2040a6 <_read+0x12>
  2040ec:	200018a0 	.word	0x200018a0
  2040f0:	200026d8 	.word	0x200026d8
  2040f4:	20001bfc 	.word	0x20001bfc

002040f8 <port_lock.lto_priv.0.lto_priv.0>:
  __ASM volatile ("cpsid i" : : : "memory");
  2040f8:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2040fa:	2320      	movs	r3, #32
  2040fc:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
  204100:	b662      	cpsie	i
}
  204102:	4770      	bx	lr

00204104 <sof_handler>:
}

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
  204104:	b513      	push	{r0, r1, r4, lr}
 */
void sduSOFHookI(SerialUSBDriver *sdup) {

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
  204106:	4c1e      	ldr	r4, [pc, #120]	; (204180 <sof_handler+0x7c>)
  port_lock();
  204108:	f7ff fff6 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  20410c:	f8d4 348c 	ldr.w	r3, [r4, #1164]	; 0x48c
  204110:	681a      	ldr	r2, [r3, #0]
  204112:	7811      	ldrb	r1, [r2, #0]
  204114:	2904      	cmp	r1, #4
  204116:	d12d      	bne.n	204174 <sof_handler+0x70>
  204118:	7a21      	ldrb	r1, [r4, #8]
  20411a:	2902      	cmp	r1, #2
  20411c:	d12a      	bne.n	204174 <sof_handler+0x70>
    return;
  }

  /* If there is already a transaction ongoing then another one cannot be
     started.*/
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
  20411e:	7919      	ldrb	r1, [r3, #4]
  204120:	2301      	movs	r3, #1
  204122:	8912      	ldrh	r2, [r2, #8]
  204124:	408b      	lsls	r3, r1
  204126:	4213      	tst	r3, r2
  204128:	d124      	bne.n	204174 <sof_handler+0x70>

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
  20412a:	e9d4 3215 	ldrd	r3, r2, [r4, #84]	; 0x54
  20412e:	4293      	cmp	r3, r2
  204130:	d120      	bne.n	204174 <sof_handler+0x70>
  204132:	6d22      	ldr	r2, [r4, #80]	; 0x50
  204134:	b1f2      	cbz	r2, 204174 <sof_handler+0x70>
  204136:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  204138:	b1e2      	cbz	r2, 204174 <sof_handler+0x70>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
  20413a:	3a04      	subs	r2, #4

    if (size > 0U) {
  20413c:	1ad2      	subs	r2, r2, r3
  20413e:	d019      	beq.n	204174 <sof_handler+0x70>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
  204140:	601a      	str	r2, [r3, #0]

  /* Checking if there only a buffer partially filled, if so then it is
     enforced in the queue and transmitted.*/
  if (obqTryFlushI(&sdup->obqueue)) {
    size_t n;
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
  204142:	a901      	add	r1, sp, #4

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
  204144:	6d22      	ldr	r2, [r4, #80]	; 0x50
  204146:	480f      	ldr	r0, [pc, #60]	; (204184 <sof_handler+0x80>)
  204148:	3a01      	subs	r2, #1
  20414a:	6522      	str	r2, [r4, #80]	; 0x50
      obqp->bwrptr += obqp->bsize;
  20414c:	6e22      	ldr	r2, [r4, #96]	; 0x60
  20414e:	4413      	add	r3, r2
      if (obqp->bwrptr >= obqp->btop) {
  204150:	6de2      	ldr	r2, [r4, #92]	; 0x5c
  204152:	4293      	cmp	r3, r2
      obqp->bwrptr += obqp->bsize;
  204154:	6563      	str	r3, [r4, #84]	; 0x54
        obqp->bwrptr = obqp->buffers;
  204156:	bf24      	itt	cs
  204158:	6ea3      	ldrcs	r3, [r4, #104]	; 0x68
  20415a:	6563      	strcs	r3, [r4, #84]	; 0x54
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
  20415c:	2300      	movs	r3, #0
  20415e:	66e3      	str	r3, [r4, #108]	; 0x6c
  204160:	f004 fbde 	bl	208920 <obqGetFullBufferI>

    osalDbgAssert(buf != NULL, "queue is empty");

    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
  204164:	f8d4 448c 	ldr.w	r4, [r4, #1164]	; 0x48c
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
  204168:	4602      	mov	r2, r0
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
  20416a:	9b01      	ldr	r3, [sp, #4]
  20416c:	7921      	ldrb	r1, [r4, #4]
  20416e:	6820      	ldr	r0, [r4, #0]
  204170:	f004 fa34 	bl	2085dc <usbStartTransmitI>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204174:	2300      	movs	r3, #0
  204176:	f383 8811 	msr	BASEPRI, r3
  (void)usbp;

  osalSysLockFromISR();
  sduSOFHookI(&PORTAB_SDU1);
  osalSysUnlockFromISR();
}
  20417a:	b002      	add	sp, #8
  20417c:	bd10      	pop	{r4, pc}
  20417e:	bf00      	nop
  204180:	20000948 	.word	0x20000948
  204184:	2000098c 	.word	0x2000098c

00204188 <cmd_systime>:

#if (SHELL_CMD_SYSTIME_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
  204188:	2900      	cmp	r1, #0
static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {
  20418a:	b510      	push	{r4, lr}
  if (argc > 0) {
  20418c:	dd05      	ble.n	20419a <cmd_systime+0x12>
    shellUsage(chp, "systime");
  20418e:	4a08      	ldr	r2, [pc, #32]	; (2041b0 <cmd_systime+0x28>)
  204190:	4908      	ldr	r1, [pc, #32]	; (2041b4 <cmd_systime+0x2c>)
    return;
  }
  chprintf(chp, "%lu" SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
}
  204192:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chprintf(chp, "%lu" SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
  204196:	f7ff bc65 	b.w	203a64 <chprintf>
 *
 * @special
 */
static inline void chSysLock(void) {

  port_lock();
  20419a:	f7ff ffad 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  return (systime_t)STM32_ST_TIM->CNT;
  20419e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  2041a2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  2041a4:	2300      	movs	r3, #0
  2041a6:	f383 8811 	msr	BASEPRI, r3
  2041aa:	4903      	ldr	r1, [pc, #12]	; (2041b8 <cmd_systime+0x30>)
  2041ac:	e7f1      	b.n	204192 <cmd_systime+0xa>
  2041ae:	bf00      	nop
  2041b0:	0800de25 	.word	0x0800de25
  2041b4:	0800dc23 	.word	0x0800dc23
  2041b8:	0800de2d 	.word	0x0800de2d

002041bc <_port_irq_epilogue>:
#endif

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
  2041bc:	b508      	push	{r3, lr}
  2041be:	f7ff ff9b 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  2041c2:	4b12      	ldr	r3, [pc, #72]	; (20420c <_port_irq_epilogue+0x50>)
  2041c4:	685b      	ldr	r3, [r3, #4]
  2041c6:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  2041ca:	d01b      	beq.n	204204 <_port_irq_epilogue+0x48>
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
  2041cc:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  2041d0:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
  2041d4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  2041d8:	f843 2c4c 	str.w	r2, [r3, #-76]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
  2041dc:	4a0c      	ldr	r2, [pc, #48]	; (204210 <_port_irq_epilogue+0x54>)
  2041de:	68d2      	ldr	r2, [r2, #12]
  2041e0:	f843 2c08 	str.w	r2, [r3, #-8]
    ctxp--;
  2041e4:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  2041e8:	f382 8809 	msr	PSP, r2
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
  2041ec:	4a09      	ldr	r2, [pc, #36]	; (204214 <_port_irq_epilogue+0x58>)
  2041ee:	6811      	ldr	r1, [r2, #0]
  2041f0:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
  2041f2:	6889      	ldr	r1, [r1, #8]
  2041f4:	6892      	ldr	r2, [r2, #8]
  2041f6:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
  2041f8:	bf8c      	ite	hi
  2041fa:	4a07      	ldrhi	r2, [pc, #28]	; (204218 <_port_irq_epilogue+0x5c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
  2041fc:	4a07      	ldrls	r2, [pc, #28]	; (20421c <_port_irq_epilogue+0x60>)
  2041fe:	f843 2c50 	str.w	r2, [r3, #-80]
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
  204202:	bd08      	pop	{r3, pc}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204204:	f383 8811 	msr	BASEPRI, r3
  204208:	e7fb      	b.n	204202 <_port_irq_epilogue+0x46>
  20420a:	bf00      	nop
  20420c:	e000ed00 	.word	0xe000ed00
  204210:	e000ef30 	.word	0xe000ef30
  204214:	20000e8c 	.word	0x20000e8c
  204218:	00200355 	.word	0x00200355
  20421c:	00200358 	.word	0x00200358

00204220 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
  204220:	b538      	push	{r3, r4, r5, lr}
  204222:	4604      	mov	r4, r0
  204224:	f7ff ff68 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
  204228:	4b1b      	ldr	r3, [pc, #108]	; (204298 <chMtxLock+0x78>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
  20422a:	6880      	ldr	r0, [r0, #8]
  thread_t *ctp = currp;
  20422c:	699d      	ldr	r5, [r3, #24]
  if (mp->owner != NULL) {
  20422e:	b968      	cbnz	r0, 20424c <chMtxLock+0x2c>

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
  204230:	6bab      	ldr	r3, [r5, #56]	; 0x38
    mp->owner = ctp;
  204232:	60a5      	str	r5, [r4, #8]
    mp->next = ctp->mtxlist;
  204234:	60e3      	str	r3, [r4, #12]
    ctp->mtxlist = mp;
  204236:	63ac      	str	r4, [r5, #56]	; 0x38
  204238:	e02a      	b.n	204290 <chMtxLock+0x70>
  tp->queue.prev->queue.next = tp->queue.next;
  20423a:	e9d0 3200 	ldrd	r3, r2, [r0]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
  20423e:	6a41      	ldr	r1, [r0, #36]	; 0x24
  204240:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
  204242:	605a      	str	r2, [r3, #4]
  204244:	f7fd f81a 	bl	20127c <queue_prio_insert>
          tp = tp->u.wtmtxp->owner;
  204248:	6a43      	ldr	r3, [r0, #36]	; 0x24
  20424a:	6898      	ldr	r0, [r3, #8]
      while (tp->prio < ctp->prio) {
  20424c:	68ab      	ldr	r3, [r5, #8]
  20424e:	6882      	ldr	r2, [r0, #8]
  204250:	4293      	cmp	r3, r2
  204252:	d915      	bls.n	204280 <chMtxLock+0x60>
        tp->prio = ctp->prio;
  204254:	6083      	str	r3, [r0, #8]
        switch (tp->state) {
  204256:	f890 3020 	ldrb.w	r3, [r0, #32]
  20425a:	2b06      	cmp	r3, #6
  20425c:	d0ed      	beq.n	20423a <chMtxLock+0x1a>
  20425e:	2b07      	cmp	r3, #7
  204260:	d007      	beq.n	204272 <chMtxLock+0x52>
  204262:	b96b      	cbnz	r3, 204280 <chMtxLock+0x60>
  tp->queue.prev->queue.next = tp->queue.next;
  204264:	e9d0 3200 	ldrd	r3, r2, [r0]
  204268:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
  20426a:	605a      	str	r2, [r3, #4]
          (void) chSchReadyI(queue_dequeue(tp));
  20426c:	f7fd f83e 	bl	2012ec <chSchReadyI>
          break;
  204270:	e006      	b.n	204280 <chMtxLock+0x60>
  tp->queue.prev->queue.next = tp->queue.next;
  204272:	e9d0 3200 	ldrd	r3, r2, [r0]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
  204276:	6a41      	ldr	r1, [r0, #36]	; 0x24
  204278:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
  20427a:	605a      	str	r2, [r3, #4]
  20427c:	f7fc fffe 	bl	20127c <queue_prio_insert>
      queue_prio_insert(ctp, &mp->queue);
  204280:	4628      	mov	r0, r5
  204282:	4621      	mov	r1, r4
  204284:	f7fc fffa 	bl	20127c <queue_prio_insert>
      chSchGoSleepS(CH_STATE_WTMTX);
  204288:	2006      	movs	r0, #6
      ctp->u.wtmtxp = mp;
  20428a:	626c      	str	r4, [r5, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
  20428c:	f7fd fa90 	bl	2017b0 <chSchGoSleepS>
  204290:	2300      	movs	r3, #0
  204292:	f383 8811 	msr	BASEPRI, r3
}
  204296:	bd38      	pop	{r3, r4, r5, pc}
  204298:	20000e8c 	.word	0x20000e8c

0020429c <__malloc_lock>:
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
  20429c:	4801      	ldr	r0, [pc, #4]	; (2042a4 <__malloc_lock+0x8>)
  20429e:	f7ff bfbf 	b.w	204220 <chMtxLock>
  2042a2:	bf00      	nop
  2042a4:	20002724 	.word	0x20002724

002042a8 <_ltdc_reload>:
static void _ltdc_reload(void) {
  2042a8:	b573      	push	{r0, r1, r4, r5, r6, lr}
	LTDC->SRCR |= LTDC_SRCR_IMR;
  2042aa:	4d16      	ldr	r5, [pc, #88]	; (204304 <_ltdc_reload+0x5c>)
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
  2042ac:	4c16      	ldr	r4, [pc, #88]	; (204308 <_ltdc_reload+0x60>)
  2042ae:	6a6a      	ldr	r2, [r5, #36]	; 0x24

  /* Placing in ready list behind peers.*/
  otp = chSchReadyI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
  2042b0:	4e16      	ldr	r6, [pc, #88]	; (20430c <_ltdc_reload+0x64>)
  2042b2:	f042 0201 	orr.w	r2, r2, #1
  2042b6:	626a      	str	r2, [r5, #36]	; 0x24
	while (LTDC->SRCR & (LTDC_SRCR_IMR | LTDC_SRCR_VBR))
  2042b8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  2042ba:	079b      	lsls	r3, r3, #30
  2042bc:	d101      	bne.n	2042c2 <_ltdc_reload+0x1a>
}
  2042be:	b002      	add	sp, #8
  2042c0:	bd70      	pop	{r4, r5, r6, pc}
  2042c2:	f7ff ff19 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  2042c6:	6823      	ldr	r3, [r4, #0]
  2042c8:	69a0      	ldr	r0, [r4, #24]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
  2042ca:	6899      	ldr	r1, [r3, #8]
  2042cc:	6882      	ldr	r2, [r0, #8]
  2042ce:	4291      	cmp	r1, r2
  2042d0:	d314      	bcc.n	2042fc <_ltdc_reload+0x54>
  tqp->next             = tp->queue.next;
  2042d2:	681a      	ldr	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  2042d4:	6054      	str	r4, [r2, #4]
  tqp->next             = tp->queue.next;
  2042d6:	6022      	str	r2, [r4, #0]
  currp->state = CH_STATE_CURRENT;
  2042d8:	2201      	movs	r2, #1
  currp = queue_fifo_remove(&ch.rlist.queue);
  2042da:	61a3      	str	r3, [r4, #24]
  currp->state = CH_STATE_CURRENT;
  2042dc:	f883 2020 	strb.w	r2, [r3, #32]
  otp = chSchReadyI(otp);
  2042e0:	f7fd f804 	bl	2012ec <chSchReadyI>
  2042e4:	9001      	str	r0, [sp, #4]
  chSysSwitch(currp, otp);
  2042e6:	f7fd f845 	bl	201374 <_trace_switch.constprop.0>
  2042ea:	9901      	ldr	r1, [sp, #4]
  2042ec:	69a0      	ldr	r0, [r4, #24]
  2042ee:	f7fc f81b 	bl	200328 <_port_switch>
  2042f2:	2307      	movs	r3, #7
  2042f4:	60b3      	str	r3, [r6, #8]
  2042f6:	69a3      	ldr	r3, [r4, #24]
  2042f8:	69db      	ldr	r3, [r3, #28]
  2042fa:	60f3      	str	r3, [r6, #12]
  2042fc:	2300      	movs	r3, #0
  2042fe:	f383 8811 	msr	BASEPRI, r3
  204302:	e7d9      	b.n	2042b8 <_ltdc_reload+0x10>
  204304:	40016800 	.word	0x40016800
  204308:	20000e8c 	.word	0x20000e8c
  20430c:	e000ed90 	.word	0xe000ed90

00204310 <gdisp_lld_init>:
LLDSPEC gBool gdisp_lld_init(GDisplay* g) {
  204310:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  204314:	4606      	mov	r6, r0
	g->priv = 0;
  204316:	2000      	movs	r0, #0
	switch(g->controllerdisplay) {
  204318:	7f73      	ldrb	r3, [r6, #29]
	g->board = 0;
  20431a:	e9c6 0005 	strd	r0, r0, [r6, #20]
	switch(g->controllerdisplay) {
  20431e:	b123      	cbz	r3, 20432a <gdisp_lld_init+0x1a>
  204320:	2b01      	cmp	r3, #1
  204322:	f000 811b 	beq.w	20455c <gdisp_lld_init+0x24c>
}
  204326:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	#else

		//-------------------------------------------
		// Initialise port PE

		RCC->AHB1ENR |= RCC_AHB1ENR_GPIOEEN;
  20432a:	4d91      	ldr	r5, [pc, #580]	; (204570 <gdisp_lld_init+0x260>)
  20432c:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  20432e:	f042 0210 	orr.w	r2, r2, #16
  204332:	632a      	str	r2, [r5, #48]	; 0x30
		GPIOE->MODER |= (
  204334:	4a8f      	ldr	r2, [pc, #572]	; (204574 <gdisp_lld_init+0x264>)
  204336:	6811      	ldr	r1, [r2, #0]
  204338:	f441 7100 	orr.w	r1, r1, #512	; 0x200
  20433c:	6011      	str	r1, [r2, #0]
						  GPIO_MODER_MODER4_1							// PE4:  LCD_B0 - PAL_STM32_OSPEED_HIGHEST, PAL_MODE_ALTERNATE(14)
						);
		GPIOE->MODER &=~ (
  20433e:	6811      	ldr	r1, [r2, #0]
  204340:	f421 7180 	bic.w	r1, r1, #256	; 0x100
  204344:	6011      	str	r1, [r2, #0]
						  GPIO_MODER_MODER4_0
						);
		GPIOE->OTYPER &=~ (
  204346:	6851      	ldr	r1, [r2, #4]
  204348:	f021 0110 	bic.w	r1, r1, #16
  20434c:	6051      	str	r1, [r2, #4]
						  GPIO_OTYPER_OT_4
						);
		GPIOE->OSPEEDR |= (
  20434e:	6891      	ldr	r1, [r2, #8]
  204350:	f441 7140 	orr.w	r1, r1, #768	; 0x300
  204354:	6091      	str	r1, [r2, #8]
						  GPIO_OSPEEDER_OSPEEDR4_0 | GPIO_OSPEEDER_OSPEEDR4_1
						);
		GPIOE->PUPDR &=~ (
  204356:	68d1      	ldr	r1, [r2, #12]
  204358:	f421 7140 	bic.w	r1, r1, #768	; 0x300
  20435c:	60d1      	str	r1, [r2, #12]
						  GPIO_PUPDR_PUPDR4_0  | GPIO_PUPDR_PUPDR4_1
						);
		GPIOE->AFRL |= (
  20435e:	6a11      	ldr	r1, [r2, #32]
  204360:	f441 2160 	orr.w	r1, r1, #917504	; 0xe0000
  204364:	6211      	str	r1, [r2, #32]
						);

		//-------------------------------------------
		// Initialise port PG

		RCC->AHB1ENR |= RCC_AHB1ENR_GPIOGEN;
  204366:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  204368:	f042 0240 	orr.w	r2, r2, #64	; 0x40
  20436c:	632a      	str	r2, [r5, #48]	; 0x30
		GPIOG->MODER |= (
  20436e:	4a82      	ldr	r2, [pc, #520]	; (204578 <gdisp_lld_init+0x268>)
  204370:	6811      	ldr	r1, [r2, #0]
  204372:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
  204376:	6011      	str	r1, [r2, #0]
						  GPIO_MODER_MODER12_1							// PG12:  LCD_B4 - PAL_STM32_OSPEED_HIGHEST, PAL_MODE_ALTERNATE(9)
						);
		GPIOG->MODER &=~ (
  204378:	6811      	ldr	r1, [r2, #0]
  20437a:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
  20437e:	6011      	str	r1, [r2, #0]
						  GPIO_MODER_MODER12_0
						);
		GPIOG->OTYPER &=~ (
  204380:	6851      	ldr	r1, [r2, #4]
  204382:	f421 5180 	bic.w	r1, r1, #4096	; 0x1000
  204386:	6051      	str	r1, [r2, #4]
						  GPIO_OTYPER_OT_12
						);
		GPIOG->OSPEEDR |= (
  204388:	6891      	ldr	r1, [r2, #8]
  20438a:	f041 7140 	orr.w	r1, r1, #50331648	; 0x3000000
  20438e:	6091      	str	r1, [r2, #8]
						  GPIO_OSPEEDER_OSPEEDR12_0 | GPIO_OSPEEDER_OSPEEDR12_1
						);
		GPIOG->PUPDR &=~ (
  204390:	68d1      	ldr	r1, [r2, #12]
  204392:	f021 7140 	bic.w	r1, r1, #50331648	; 0x3000000
  204396:	60d1      	str	r1, [r2, #12]
						  GPIO_PUPDR_PUPDR12_0  | GPIO_PUPDR_PUPDR12_1
						);
		GPIOG->AFRH |= (
  204398:	6a51      	ldr	r1, [r2, #36]	; 0x24
  20439a:	f441 2110 	orr.w	r1, r1, #589824	; 0x90000
  20439e:	6251      	str	r1, [r2, #36]	; 0x24
						);

		//-------------------------------------------
		// Initialise port PI

		RCC->AHB1ENR |= RCC_AHB1ENR_GPIOIEN;
  2043a0:	6b2a      	ldr	r2, [r5, #48]	; 0x30
		GPIOI->MODER |= (
  2043a2:	4976      	ldr	r1, [pc, #472]	; (20457c <gdisp_lld_init+0x26c>)
		RCC->AHB1ENR |= RCC_AHB1ENR_GPIOIEN;
  2043a4:	f442 7280 	orr.w	r2, r2, #256	; 0x100
  2043a8:	632a      	str	r2, [r5, #48]	; 0x30
		GPIOI->MODER |= (
  2043aa:	680a      	ldr	r2, [r1, #0]
  2043ac:	f042 4229 	orr.w	r2, r2, #2835349504	; 0xa9000000
  2043b0:	f442 1220 	orr.w	r2, r2, #2621440	; 0x280000
  2043b4:	600a      	str	r2, [r1, #0]
						| GPIO_MODER_MODER12_0							// PI12: LCD_DISP_PIN - PAL_STM32_OSPEED_HIGHEST, PAL_MODE_OUTPUT_PUSHPULL
						| GPIO_MODER_MODER13_1							// PI13: LCD_INT      - PAL_STM32_OSPEED_HIGHEST, PAL_MODE_ALTERNATE(14)
						| GPIO_MODER_MODER14_1							// PI14: LCD_CLK      - PAL_STM32_OSPEED_HIGHEST, PAL_MODE_ALTERNATE(14)
						| GPIO_MODER_MODER15_1							// PI15: LCD_R0       - PAL_STM32_OSPEED_HIGHEST, PAL_MODE_ALTERNATE(14)
						);
		GPIOI->MODER &=~ (
  2043b6:	680a      	ldr	r2, [r1, #0]
  2043b8:	f022 42ac 	bic.w	r2, r2, #1442840576	; 0x56000000
  2043bc:	f422 12a0 	bic.w	r2, r2, #1310720	; 0x140000
  2043c0:	600a      	str	r2, [r1, #0]
						| GPIO_MODER_MODER12_1
						| GPIO_MODER_MODER13_0
						| GPIO_MODER_MODER14_0
						| GPIO_MODER_MODER15_0
						);
		GPIOI->OTYPER &=~ (
  2043c2:	684a      	ldr	r2, [r1, #4]
  2043c4:	f422 4276 	bic.w	r2, r2, #62976	; 0xf600
  2043c8:	604a      	str	r2, [r1, #4]
						| GPIO_OTYPER_OT_12
						| GPIO_OTYPER_OT_13
						| GPIO_OTYPER_OT_14
						| GPIO_OTYPER_OT_15
						);
		GPIOI->OSPEEDR |= (
  2043ca:	688a      	ldr	r2, [r1, #8]
  2043cc:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
  2043d0:	f442 1270 	orr.w	r2, r2, #3932160	; 0x3c0000
  2043d4:	608a      	str	r2, [r1, #8]
						| GPIO_OSPEEDER_OSPEEDR12_0 | GPIO_OSPEEDER_OSPEEDR12_1
						| GPIO_OSPEEDER_OSPEEDR13_0 | GPIO_OSPEEDER_OSPEEDR13_1
						| GPIO_OSPEEDER_OSPEEDR14_0 | GPIO_OSPEEDER_OSPEEDR14_1
						| GPIO_OSPEEDER_OSPEEDR15_0 | GPIO_OSPEEDER_OSPEEDR15_1
						);
		GPIOI->PUPDR &=~ (
  2043d6:	68ca      	ldr	r2, [r1, #12]
  2043d8:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  2043dc:	f422 1270 	bic.w	r2, r2, #3932160	; 0x3c0000
  2043e0:	60ca      	str	r2, [r1, #12]
						| GPIO_PUPDR_PUPDR12_0 | GPIO_PUPDR_PUPDR12_1
						| GPIO_PUPDR_PUPDR13_0 | GPIO_PUPDR_PUPDR13_1
						| GPIO_PUPDR_PUPDR14_0 | GPIO_PUPDR_PUPDR14_1
						| GPIO_PUPDR_PUPDR15_0 | GPIO_PUPDR_PUPDR15_1
						);
		GPIOI->AFRH |= (
  2043e2:	4a67      	ldr	r2, [pc, #412]	; (204580 <gdisp_lld_init+0x270>)
  2043e4:	6a48      	ldr	r0, [r1, #36]	; 0x24
  2043e6:	4302      	orrs	r2, r0

		//-------------------------------------------
		// Initialise port PJ

		RCC->AHB1ENR |= RCC_AHB1ENR_GPIOJEN;
		GPIOJ->MODER |= (
  2043e8:	4866      	ldr	r0, [pc, #408]	; (204584 <gdisp_lld_init+0x274>)
		GPIOI->AFRH |= (
  2043ea:	624a      	str	r2, [r1, #36]	; 0x24
		RCC->AHB1ENR |= RCC_AHB1ENR_GPIOJEN;
  2043ec:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  2043ee:	f442 7200 	orr.w	r2, r2, #512	; 0x200
  2043f2:	632a      	str	r2, [r5, #48]	; 0x30
		GPIOJ->MODER |= (
  2043f4:	4a64      	ldr	r2, [pc, #400]	; (204588 <gdisp_lld_init+0x278>)
  2043f6:	6814      	ldr	r4, [r2, #0]
  2043f8:	4320      	orrs	r0, r4
  2043fa:	6010      	str	r0, [r2, #0]
						| GPIO_MODER_MODER11_1							// PJ11: LCD_G4 - PAL_STM32_OSPEED_HIGHEST, PAL_MODE_ALTERNATE(14)
						| GPIO_MODER_MODER13_1							// PJ13: LCD_B1 - PAL_STM32_OSPEED_HIGHEST, PAL_MODE_ALTERNATE(14)
						| GPIO_MODER_MODER14_1							// PJ14: LCD_B2 - PAL_STM32_OSPEED_HIGHEST, PAL_MODE_ALTERNATE(14)
						| GPIO_MODER_MODER15_1							// PJ15: LCD_B3 - PAL_STM32_OSPEED_HIGHEST, PAL_MODE_ALTERNATE(14)
						);
		GPIOJ->MODER &=~ (
  2043fc:	4863      	ldr	r0, [pc, #396]	; (20458c <gdisp_lld_init+0x27c>)
  2043fe:	6814      	ldr	r4, [r2, #0]
  204400:	4020      	ands	r0, r4
  204402:	6010      	str	r0, [r2, #0]
						| GPIO_MODER_MODER11_0
						| GPIO_MODER_MODER13_0
						| GPIO_MODER_MODER14_0
						| GPIO_MODER_MODER15_0
						);
		GPIOJ->OTYPER &=~ (
  204404:	6850      	ldr	r0, [r2, #4]
  204406:	f420 406f 	bic.w	r0, r0, #61184	; 0xef00
  20440a:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
  20440e:	6050      	str	r0, [r2, #4]
						| GPIO_OTYPER_OT_11
						| GPIO_OTYPER_OT_13
						| GPIO_OTYPER_OT_14
						| GPIO_OTYPER_OT_15
						);
		GPIOJ->OSPEEDR |= (
  204410:	6890      	ldr	r0, [r2, #8]
  204412:	f060 7040 	orn	r0, r0, #50331648	; 0x3000000
  204416:	6090      	str	r0, [r2, #8]
						| GPIO_OSPEEDER_OSPEEDR11_0 | GPIO_OSPEEDER_OSPEEDR11_1
						| GPIO_OSPEEDER_OSPEEDR13_0 | GPIO_OSPEEDER_OSPEEDR13_1
						| GPIO_OSPEEDER_OSPEEDR14_0 | GPIO_OSPEEDER_OSPEEDR14_1
						| GPIO_OSPEEDER_OSPEEDR15_0 | GPIO_OSPEEDER_OSPEEDR15_1
						);
		GPIOJ->PUPDR &=~ (
  204418:	68d0      	ldr	r0, [r2, #12]
  20441a:	f000 7040 	and.w	r0, r0, #50331648	; 0x3000000
  20441e:	60d0      	str	r0, [r2, #12]
						| GPIO_PUPDR_PUPDR11_0 | GPIO_PUPDR_PUPDR11_1
						| GPIO_PUPDR_PUPDR13_0 | GPIO_PUPDR_PUPDR13_1
						| GPIO_PUPDR_PUPDR14_0 | GPIO_PUPDR_PUPDR14_1
						| GPIO_PUPDR_PUPDR15_0 | GPIO_PUPDR_PUPDR15_1
						);
		GPIOJ->AFRL |= (
  204420:	6a10      	ldr	r0, [r2, #32]
  204422:	f040 30ee 	orr.w	r0, r0, #4008636142	; 0xeeeeeeee
  204426:	6210      	str	r0, [r2, #32]
						| (14U << 4*4)
						| (14U << 4*5)
						| (14U << 4*6)
						| (14U << 4*7)
						);
		GPIOJ->AFRH |= (
  204428:	4859      	ldr	r0, [pc, #356]	; (204590 <gdisp_lld_init+0x280>)
  20442a:	6a54      	ldr	r4, [r2, #36]	; 0x24
  20442c:	4320      	orrs	r0, r4
  20442e:	6250      	str	r0, [r2, #36]	; 0x24
						);

		//-------------------------------------------
		// Initialise port PK

		RCC->AHB1ENR |= RCC_AHB1ENR_GPIOKEN;
  204430:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  204432:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
  204436:	632a      	str	r2, [r5, #48]	; 0x30
		GPIOK->MODER |= (
  204438:	4a56      	ldr	r2, [pc, #344]	; (204594 <gdisp_lld_init+0x284>)
  20443a:	6810      	ldr	r0, [r2, #0]
  20443c:	f440 402a 	orr.w	r0, r0, #43520	; 0xaa00
  204440:	f040 006a 	orr.w	r0, r0, #106	; 0x6a
  204444:	6010      	str	r0, [r2, #0]
						| GPIO_MODER_MODER4_1							// PK4:  LCD_B5      - PAL_STM32_OSPEED_HIGHEST, PAL_MODE_ALTERNATE(14)
						| GPIO_MODER_MODER5_1							// PK5:  LCD_B6      - PAL_STM32_OSPEED_HIGHEST, PAL_MODE_ALTERNATE(14)
						| GPIO_MODER_MODER6_1							// PK6:  LCD_B7      - PAL_STM32_OSPEED_HIGHEST, PAL_MODE_ALTERNATE(14)
						| GPIO_MODER_MODER7_1							// PK7:  LCD_DE      - PAL_STM32_OSPEED_HIGHEST, PAL_MODE_ALTERNATE(14)
						);
		GPIOK->MODER &=~ (
  204446:	6810      	ldr	r0, [r2, #0]
  204448:	f420 40ab 	bic.w	r0, r0, #21888	; 0x5580
  20444c:	f020 0015 	bic.w	r0, r0, #21
  204450:	6010      	str	r0, [r2, #0]
						| GPIO_MODER_MODER4_0
						| GPIO_MODER_MODER5_0
						| GPIO_MODER_MODER6_0
						| GPIO_MODER_MODER7_0
						);
		GPIOK->OTYPER &=~ (
  204452:	6850      	ldr	r0, [r2, #4]
  204454:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
  204458:	6050      	str	r0, [r2, #4]
						| GPIO_OTYPER_OT_4
						| GPIO_OTYPER_OT_5
						| GPIO_OTYPER_OT_6
						| GPIO_OTYPER_OT_7
						);
		GPIOK->OSPEEDR |= (
  20445a:	6890      	ldr	r0, [r2, #8]
  20445c:	ea6f 4010 	mvn.w	r0, r0, lsr #16
  204460:	ea6f 4000 	mvn.w	r0, r0, lsl #16
  204464:	6090      	str	r0, [r2, #8]
						| GPIO_OSPEEDER_OSPEEDR4_0  | GPIO_OSPEEDER_OSPEEDR4_1
						| GPIO_OSPEEDER_OSPEEDR5_0  | GPIO_OSPEEDER_OSPEEDR5_1
						| GPIO_OSPEEDER_OSPEEDR6_0  | GPIO_OSPEEDER_OSPEEDR6_1
						| GPIO_OSPEEDER_OSPEEDR7_0  | GPIO_OSPEEDER_OSPEEDR7_1
						);
		GPIOK->PUPDR &=~ (
  204466:	68d0      	ldr	r0, [r2, #12]
  204468:	0c00      	lsrs	r0, r0, #16
  20446a:	0400      	lsls	r0, r0, #16
  20446c:	60d0      	str	r0, [r2, #12]
						| GPIO_PUPDR_PUPDR4_0  | GPIO_PUPDR_PUPDR4_1
						| GPIO_PUPDR_PUPDR5_0  | GPIO_PUPDR_PUPDR5_1
						| GPIO_PUPDR_PUPDR6_0  | GPIO_PUPDR_PUPDR6_1
						| GPIO_PUPDR_PUPDR7_0  | GPIO_PUPDR_PUPDR7_1
						);
		GPIOK->AFRL |= (
  20446e:	484a      	ldr	r0, [pc, #296]	; (204598 <gdisp_lld_init+0x288>)
  204470:	6a14      	ldr	r4, [r2, #32]
  204472:	4320      	orrs	r0, r4
  204474:	6210      	str	r0, [r2, #32]
	// Enable the display and turn on the backlight
	#if GFX_USE_OS_CHIBIOS && !GFX_LTDC_USE_DIRECTIO
	    palSetPad(GPIOI, GPIOI_LCD_DISP);
	    palSetPad(GPIOK, GPIOK_LCD_BL_CTRL);
	#else
	    GPIOI->ODR |= (1 << 12);  // PowerOn
  204476:	6948      	ldr	r0, [r1, #20]
  204478:	f440 5080 	orr.w	r0, r0, #4096	; 0x1000
  20447c:	6148      	str	r0, [r1, #20]
	    GPIOK->ODR |= (1 << 3);   // Backlight on
  20447e:	6951      	ldr	r1, [r2, #20]
  204480:	f041 0108 	orr.w	r1, r1, #8
  204484:	6151      	str	r1, [r2, #20]
				#define STM32_PLLSAIR_POST                  STM32_SAIR_DIV4
			#else
				#error "LTDC: - Unknown timing set for the STM32F746-Discovery board"
			#endif

			RCC->CR &= ~RCC_CR_PLLSAION;
  204486:	682a      	ldr	r2, [r5, #0]
  204488:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  20448c:	602a      	str	r2, [r5, #0]
			RCC->PLLSAICFGR = ((STM32_PLLSAIP_VALUE/2-1)<<16) | (STM32_PLLSAIN_VALUE << 6) | (STM32_PLLSAIR_VALUE << 28) | (STM32_PLLSAIQ_VALUE << 24);
  20448e:	4a43      	ldr	r2, [pc, #268]	; (20459c <gdisp_lld_init+0x28c>)
  204490:	f8c5 2088 	str.w	r2, [r5, #136]	; 0x88
			RCC->DCKCFGR1 = (RCC->DCKCFGR1 & ~RCC_DCKCFGR1_PLLSAIDIVR) | STM32_PLLSAIR_POST;
  204494:	f8d5 208c 	ldr.w	r2, [r5, #140]	; 0x8c
  204498:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
  20449c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  2044a0:	f8c5 208c 	str.w	r2, [r5, #140]	; 0x8c
			RCC->CR |= RCC_CR_PLLSAION;
  2044a4:	682a      	ldr	r2, [r5, #0]
  2044a6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
  2044aa:	602a      	str	r2, [r5, #0]
			while(!(RCC->CR & RCC_CR_PLLSAIRDY));			// wait for PLLSAI to lock
  2044ac:	682b      	ldr	r3, [r5, #0]
  2044ae:	0099      	lsls	r1, r3, #2
  2044b0:	d5fc      	bpl.n	2044ac <gdisp_lld_init+0x19c>
	RCC->APB2RSTR |= RCC_APB2RSTR_LTDCRST;
  2044b2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	RCC->APB2RSTR = 0;
  2044b4:	2700      	movs	r7, #0
	LTDC->GCR = 0;
  2044b6:	4c3a      	ldr	r4, [pc, #232]	; (2045a0 <gdisp_lld_init+0x290>)
	RCC->APB2RSTR |= RCC_APB2RSTR_LTDCRST;
  2044b8:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
	_ltdc_layer_init(LTDC_Layer1, &driverCfg.bglayer);
  2044bc:	f8df 8108 	ldr.w	r8, [pc, #264]	; 2045c8 <gdisp_lld_init+0x2b8>
	RCC->APB2RSTR |= RCC_APB2RSTR_LTDCRST;
  2044c0:	626b      	str	r3, [r5, #36]	; 0x24
	RCC->APB2RSTR = 0;
  2044c2:	626f      	str	r7, [r5, #36]	; 0x24
			RCC->DCKCFGR1 = (RCC->DCKCFGR1 & ~RCC_DCKCFGR1_PLLSAIDIVR) | (1 << 16);
  2044c4:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
  2044c8:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
  2044cc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  2044d0:	f8c5 308c 	str.w	r3, [r5, #140]	; 0x8c
	RCC->APB2ENR |= RCC_APB2ENR_LTDCEN;
  2044d4:	6c6b      	ldr	r3, [r5, #68]	; 0x44
  2044d6:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
  2044da:	646b      	str	r3, [r5, #68]	; 0x44
	LTDC->GCR = 0;
  2044dc:	61a7      	str	r7, [r4, #24]
	LTDC->IER = 0;
  2044de:	6367      	str	r7, [r4, #52]	; 0x34
	_ltdc_reload();
  2044e0:	f7ff fee2 	bl	2042a8 <_ltdc_reload>
	LTDC->SSCR = ((hacc << 16) & LTDC_SSCR_HSW) | ((vacc <<  0) & LTDC_SSCR_VSH);
  2044e4:	4b2f      	ldr	r3, [pc, #188]	; (2045a4 <gdisp_lld_init+0x294>)
	_ltdc_layer_init(LTDC_Layer1, &driverCfg.bglayer);
  2044e6:	4641      	mov	r1, r8
  2044e8:	482f      	ldr	r0, [pc, #188]	; (2045a8 <gdisp_lld_init+0x298>)
	LTDC->SSCR = ((hacc << 16) & LTDC_SSCR_HSW) | ((vacc <<  0) & LTDC_SSCR_VSH);
  2044ea:	60a3      	str	r3, [r4, #8]
	LTDC->BPCR = ((hacc << 16) & LTDC_BPCR_AHBP) | ((vacc <<  0) & LTDC_BPCR_AVBP);
  2044ec:	4b2f      	ldr	r3, [pc, #188]	; (2045ac <gdisp_lld_init+0x29c>)
  2044ee:	60e3      	str	r3, [r4, #12]
	LTDC->AWCR = ((hacc << 16) & LTDC_AWCR_AAW) | ((vacc <<  0) & LTDC_AWCR_AAH);
  2044f0:	f103 73f0 	add.w	r3, r3, #31457280	; 0x1e00000
  2044f4:	f503 7388 	add.w	r3, r3, #272	; 0x110
  2044f8:	6123      	str	r3, [r4, #16]
	LTDC->TWCR = ((hacc << 16) & LTDC_TWCR_TOTALW) | ((vacc <<  0) & LTDC_TWCR_TOTALH);
  2044fa:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  2044fe:	3302      	adds	r3, #2
  204500:	6163      	str	r3, [r4, #20]
	LTDC->GCR = driverCfg.syncflags & (LTDC_EF_MASK & ~LTDC_EF_ENABLE);
  204502:	61a7      	str	r7, [r4, #24]
	LTDC->BCCR = (LTDC->BCCR & ~0x00FFFFFF) | (driverCfg.bgcolor & 0x00FFFFFF);
  204504:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  204506:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
  20450a:	62e3      	str	r3, [r4, #44]	; 0x2c
	_ltdc_layer_init(LTDC_Layer1, &driverCfg.bglayer);
  20450c:	f7fc fa8c 	bl	200a28 <_ltdc_layer_init>
	_ltdc_layer_init(LTDC_Layer2, &layerOff);
  204510:	4927      	ldr	r1, [pc, #156]	; (2045b0 <gdisp_lld_init+0x2a0>)
  204512:	4828      	ldr	r0, [pc, #160]	; (2045b4 <gdisp_lld_init+0x2a4>)
  204514:	f7fc fa88 	bl	200a28 <_ltdc_layer_init>
	LTDC->IER = 0;
  204518:	6367      	str	r7, [r4, #52]	; 0x34
	_ltdc_reload();
  20451a:	f7ff fec5 	bl	2042a8 <_ltdc_reload>
	LTDC->GCR |= LTDC_GCR_LTDCEN;
  20451e:	69a3      	ldr	r3, [r4, #24]
  204520:	f043 0301 	orr.w	r3, r3, #1
  204524:	61a3      	str	r3, [r4, #24]
	_ltdc_reload();
  204526:	f7ff febf 	bl	2042a8 <_ltdc_reload>
		RCC->AHB1ENR |= RCC_AHB1ENR_DMA2DEN;
  20452a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
			DMA2D->OPFCCR = OPFCCR_RGB565;
  20452c:	2202      	movs	r2, #2
		RCC->AHB1ENR |= RCC_AHB1ENR_DMA2DEN;
  20452e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
  204532:	632b      	str	r3, [r5, #48]	; 0x30
		(void)RCC->AHB1ENR;
  204534:	6b2b      	ldr	r3, [r5, #48]	; 0x30
			DMA2D->OPFCCR = OPFCCR_RGB565;
  204536:	4b20      	ldr	r3, [pc, #128]	; (2045b8 <gdisp_lld_init+0x2a8>)
  204538:	635a      	str	r2, [r3, #52]	; 0x34
			DMA2D->FGPFCCR = FGPFCCR_CM_RGB565;
  20453a:	61da      	str	r2, [r3, #28]
		}
	#else
		if (percent <= 0) {
			GPIOK->ODR &=~ (1 << 3);	// Backlight off
		} else {
			GPIOK->ODR |= (1 << 3);		// Backlight on
  20453c:	4a15      	ldr	r2, [pc, #84]	; (204594 <gdisp_lld_init+0x284>)
		g->priv = (void *)&driverCfg.bglayer;
  20453e:	f8c6 8014 	str.w	r8, [r6, #20]
  204542:	6953      	ldr	r3, [r2, #20]
  204544:	f043 0308 	orr.w	r3, r3, #8
  204548:	6153      	str	r3, [r2, #20]
	g->g.Orientation = gOrientation0;
  20454a:	4b1c      	ldr	r3, [pc, #112]	; (2045bc <gdisp_lld_init+0x2ac>)
	g->g.Contrast = GDISP_INITIAL_CONTRAST;
  20454c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	g->g.Orientation = gOrientation0;
  204550:	4a1b      	ldr	r2, [pc, #108]	; (2045c0 <gdisp_lld_init+0x2b0>)
  204552:	e9c6 2302 	strd	r2, r3, [r6, #8]
	g->g.Contrast = GDISP_INITIAL_CONTRAST;
  204556:	2332      	movs	r3, #50	; 0x32
  204558:	7433      	strb	r3, [r6, #16]
	return gTrue;
  20455a:	e6e4      	b.n	204326 <gdisp_lld_init+0x16>
		_ltdc_layer_init(LTDC_Layer2, &driverCfg.fglayer);
  20455c:	4c19      	ldr	r4, [pc, #100]	; (2045c4 <gdisp_lld_init+0x2b4>)
  20455e:	4815      	ldr	r0, [pc, #84]	; (2045b4 <gdisp_lld_init+0x2a4>)
  204560:	4621      	mov	r1, r4
  204562:	f7fc fa61 	bl	200a28 <_ltdc_layer_init>
		_ltdc_reload();
  204566:	f7ff fe9f 	bl	2042a8 <_ltdc_reload>
		g->priv = (void *)&driverCfg.fglayer;
  20456a:	6174      	str	r4, [r6, #20]
	    post_init_board(g);
  20456c:	e7ed      	b.n	20454a <gdisp_lld_init+0x23a>
  20456e:	bf00      	nop
  204570:	40023800 	.word	0x40023800
  204574:	40021000 	.word	0x40021000
  204578:	40021800 	.word	0x40021800
  20457c:	40022000 	.word	0x40022000
  204580:	eee00ee0 	.word	0xeee00ee0
  204584:	a8aaaaaa 	.word	0xa8aaaaaa
  204588:	40022400 	.word	0x40022400
  20458c:	abaaaaaa 	.word	0xabaaaaaa
  204590:	eee0eeee 	.word	0xeee0eeee
  204594:	40022800 	.word	0x40022800
  204598:	eeee0eee 	.word	0xeeee0eee
  20459c:	54013000 	.word	0x54013000
  2045a0:	40016800 	.word	0x40016800
  2045a4:	00280009 	.word	0x00280009
  2045a8:	40016884 	.word	0x40016884
  2045ac:	0035000b 	.word	0x0035000b
  2045b0:	0800e8c4 	.word	0x0800e8c4
  2045b4:	40016904 	.word	0x40016904
  2045b8:	4002b000 	.word	0x4002b000
  2045bc:	64030000 	.word	0x64030000
  2045c0:	011001e0 	.word	0x011001e0
  2045c4:	0800e640 	.word	0x0800e640
  2045c8:	0800e618 	.word	0x0800e618

002045cc <chThdRelease>:
void chThdRelease(thread_t *tp) {
  2045cc:	b508      	push	{r3, lr}
  2045ce:	f7ff fd93 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  tp->refs--;
  2045d2:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
  2045d6:	3b01      	subs	r3, #1
  2045d8:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
  2045dc:	6a03      	ldr	r3, [r0, #32]
  2045de:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
  2045e2:	2b0f      	cmp	r3, #15
  2045e4:	d117      	bne.n	204616 <chThdRelease+0x4a>
    REG_REMOVE(tp);
  2045e6:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
  2045ea:	611a      	str	r2, [r3, #16]
  2045ec:	6902      	ldr	r2, [r0, #16]
  2045ee:	6153      	str	r3, [r2, #20]
  2045f0:	2200      	movs	r2, #0
  2045f2:	f382 8811 	msr	BASEPRI, r2
    switch (tp->flags & CH_FLAG_MODE_MASK) {
  2045f6:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
  2045fa:	f003 0303 	and.w	r3, r3, #3
  2045fe:	2b02      	cmp	r3, #2
  204600:	d108      	bne.n	204614 <chThdRelease+0x48>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
  204602:	6c01      	ldr	r1, [r0, #64]	; 0x40
  204604:	69c0      	ldr	r0, [r0, #28]
  204606:	f7ff fd77 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  chDbgCheckClassI();
  chDbgCheck((mp != NULL) &&
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
  20460a:	680b      	ldr	r3, [r1, #0]
  20460c:	6003      	str	r3, [r0, #0]
  mp->next = php;
  20460e:	6008      	str	r0, [r1, #0]
  204610:	f382 8811 	msr	BASEPRI, r2
}
  204614:	bd08      	pop	{r3, pc}
  204616:	2300      	movs	r3, #0
  204618:	f383 8811 	msr	BASEPRI, r3
  20461c:	e7fa      	b.n	204614 <chThdRelease+0x48>
	...

00204620 <cmd_threads>:
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
  static const char *states[] = {CH_STATE_NAMES};
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
  204620:	2900      	cmp	r1, #0
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
  204622:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  204626:	4607      	mov	r7, r0
  204628:	b086      	sub	sp, #24
  if (argc > 0) {
  20462a:	dd06      	ble.n	20463a <cmd_threads+0x1a>
    shellUsage(chp, "threads");
  20462c:	4a24      	ldr	r2, [pc, #144]	; (2046c0 <cmd_threads+0xa0>)
  20462e:	4925      	ldr	r1, [pc, #148]	; (2046c4 <cmd_threads+0xa4>)
             stklimit, (uint32_t)tp->ctx.sp, (uint32_t)tp,
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
             tp->name == NULL ? "" : tp->name);
    tp = chRegNextThread(tp);
  } while (tp != NULL);
}
  204630:	b006      	add	sp, #24
  204632:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    shellUsage(chp, "threads");
  204636:	f7ff ba15 	b.w	203a64 <chprintf>
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
  20463a:	4e23      	ldr	r6, [pc, #140]	; (2046c8 <cmd_threads+0xa8>)
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n" SHELL_NEWLINE_STR);
  20463c:	4923      	ldr	r1, [pc, #140]	; (2046cc <cmd_threads+0xac>)
  20463e:	f7ff fa11 	bl	203a64 <chprintf>
  204642:	f7ff fd59 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  204646:	6934      	ldr	r4, [r6, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
  204648:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
  20464c:	3301      	adds	r3, #1
  20464e:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
  204652:	2300      	movs	r3, #0
  204654:	f383 8811 	msr	BASEPRI, r3
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
  204658:	f8df 8074 	ldr.w	r8, [pc, #116]	; 2046d0 <cmd_threads+0xb0>
  20465c:	f8df 9074 	ldr.w	r9, [pc, #116]	; 2046d4 <cmd_threads+0xb4>
  204660:	f8df a074 	ldr.w	sl, [pc, #116]	; 2046d8 <cmd_threads+0xb8>
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
  204664:	f894 5020 	ldrb.w	r5, [r4, #32]
  204668:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
  20466c:	f858 c025 	ldr.w	ip, [r8, r5, lsl #2]
             tp->name == NULL ? "" : tp->name);
  204670:	69a5      	ldr	r5, [r4, #24]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
  204672:	3901      	subs	r1, #1
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
  204674:	68a0      	ldr	r0, [r4, #8]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
  204676:	2d00      	cmp	r5, #0
  204678:	bf08      	it	eq
  20467a:	464d      	moveq	r5, r9
  20467c:	68e3      	ldr	r3, [r4, #12]
    uint32_t stklimit = (uint32_t)tp->wabase;
  20467e:	69e2      	ldr	r2, [r4, #28]
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s" SHELL_NEWLINE_STR,
  204680:	9400      	str	r4, [sp, #0]
  204682:	e9cd c503 	strd	ip, r5, [sp, #12]
  204686:	e9cd 1001 	strd	r1, r0, [sp, #4]
  20468a:	4651      	mov	r1, sl
  20468c:	4638      	mov	r0, r7
  20468e:	f7ff f9e9 	bl	203a64 <chprintf>
  204692:	f7ff fd31 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
  204696:	6925      	ldr	r5, [r4, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  204698:	2200      	movs	r2, #0
  20469a:	42b5      	cmp	r5, r6
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
    ntp->refs++;
  20469c:	bf17      	itett	ne
  20469e:	f895 3022 	ldrbne.w	r3, [r5, #34]	; 0x22
    ntp = NULL;
  2046a2:	4615      	moveq	r5, r2
    ntp->refs++;
  2046a4:	3301      	addne	r3, #1
  2046a6:	f885 3022 	strbne.w	r3, [r5, #34]	; 0x22
  2046aa:	f382 8811 	msr	BASEPRI, r2
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
  2046ae:	4620      	mov	r0, r4
  2046b0:	f7ff ff8c 	bl	2045cc <chThdRelease>
  } while (tp != NULL);
  2046b4:	b915      	cbnz	r5, 2046bc <cmd_threads+0x9c>
}
  2046b6:	b006      	add	sp, #24
  2046b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  } while (tp != NULL);
  2046bc:	462c      	mov	r4, r5
  2046be:	e7d1      	b.n	204664 <cmd_threads+0x44>
  2046c0:	0800de33 	.word	0x0800de33
  2046c4:	0800dc23 	.word	0x0800dc23
  2046c8:	20000e8c 	.word	0x20000e8c
  2046cc:	0800de3b 	.word	0x0800de3b
  2046d0:	0800e924 	.word	0x0800e924
  2046d4:	0800dc16 	.word	0x0800dc16
  2046d8:	0800de7b 	.word	0x0800de7b

002046dc <chThdCreateStatic>:
                            tprio_t prio, tfunc_t pf, void *arg) {
  2046dc:	b538      	push	{r3, r4, r5, lr}
  2046de:	461d      	mov	r5, r3
  2046e0:	f7ff fd0a 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  tp = (thread_t *)((uint8_t *)wsp + size -
  2046e4:	3948      	subs	r1, #72	; 0x48
  2046e6:	1844      	adds	r4, r0, r1
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  2046e8:	f1a4 0364 	sub.w	r3, r4, #100	; 0x64
  2046ec:	f844 5c24 	str.w	r5, [r4, #-36]
  tp->prio      = prio;
  2046f0:	60a2      	str	r2, [r4, #8]
  tp->mtxlist   = NULL;
  2046f2:	2500      	movs	r5, #0
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  2046f4:	60e3      	str	r3, [r4, #12]
  2046f6:	9b04      	ldr	r3, [sp, #16]
  tp->realprio  = prio;
  2046f8:	63e2      	str	r2, [r4, #60]	; 0x3c
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  2046fa:	f844 3c20 	str.w	r3, [r4, #-32]
  2046fe:	4b10      	ldr	r3, [pc, #64]	; (204740 <chThdCreateStatic+0x64>)
  tp->wabase = (stkalign_t *)wsp;
  204700:	61e0      	str	r0, [r4, #28]
  chSchWakeupS(tp, MSG_OK);
  204702:	4620      	mov	r0, r4
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  204704:	f844 3c04 	str.w	r3, [r4, #-4]
  tp->state     = CH_STATE_WTSTART;
  204708:	2302      	movs	r3, #2
  20470a:	8423      	strh	r3, [r4, #32]
  tp->refs      = (trefs_t)1;
  20470c:	2301      	movs	r3, #1
  20470e:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
  tp->name      = name;
  204712:	4b0c      	ldr	r3, [pc, #48]	; (204744 <chThdCreateStatic+0x68>)
  204714:	61a3      	str	r3, [r4, #24]
  REG_INSERT(tp);
  204716:	4b0c      	ldr	r3, [pc, #48]	; (204748 <chThdCreateStatic+0x6c>)
  204718:	6123      	str	r3, [r4, #16]
  20471a:	695a      	ldr	r2, [r3, #20]
  tp->epending  = (eventmask_t)0;
  20471c:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
  REG_INSERT(tp);
  204720:	6162      	str	r2, [r4, #20]
  204722:	6114      	str	r4, [r2, #16]
  204724:	615c      	str	r4, [r3, #20]
  list_init(&tp->waiting);
  204726:	f104 0328 	add.w	r3, r4, #40	; 0x28
  tlp->next = (thread_t *)tlp;
  20472a:	62a3      	str	r3, [r4, #40]	; 0x28
  queue_init(&tp->msgqueue);
  20472c:	f104 032c 	add.w	r3, r4, #44	; 0x2c
  tqp->prev = (thread_t *)tqp;
  204730:	e9c4 330b 	strd	r3, r3, [r4, #44]	; 0x2c
  chSchWakeupS(tp, MSG_OK);
  204734:	f7fd f80c 	bl	201750 <chSchWakeupS.constprop.0>
  204738:	f385 8811 	msr	BASEPRI, r5
}
  20473c:	4620      	mov	r0, r4
  20473e:	bd38      	pop	{r3, r4, r5, pc}
  204740:	00200341 	.word	0x00200341
  204744:	0800dea2 	.word	0x0800dea2
  204748:	20000e8c 	.word	0x20000e8c

0020474c <chSysInit>:
void chSysInit(void) {
  20474c:	b570      	push	{r4, r5, r6, lr}
  tqp->next = (thread_t *)tqp;
  20474e:	4c5d      	ldr	r4, [pc, #372]	; (2048c4 <chSysInit+0x178>)
  ch.rlist.prio = NOPRIO;
  204750:	2600      	movs	r6, #0
  204752:	b086      	sub	sp, #24
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  204754:	f104 031c 	add.w	r3, r4, #28
  204758:	60a6      	str	r6, [r4, #8]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  20475a:	e9c4 3307 	strd	r3, r3, [r4, #28]
  ch.vtlist.delta = (sysinterval_t)-1;
  20475e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  ch.vtlist.lasttime = (systime_t)0;
  204762:	e9c4 3609 	strd	r3, r6, [r4, #36]	; 0x24
  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
  204766:	f503 0301 	add.w	r3, r3, #8454144	; 0x810000
  20476a:	6323      	str	r3, [r4, #48]	; 0x30
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  20476c:	f104 0338 	add.w	r3, r4, #56	; 0x38
  tqp->prev = (thread_t *)tqp;
  204770:	e9c4 4400 	strd	r4, r4, [r4]
  ch.rlist.older = (thread_t *)&ch.rlist;
  204774:	e9c4 4404 	strd	r4, r4, [r4, #16]
  204778:	6363      	str	r3, [r4, #52]	; 0x34
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
  20477a:	1cf3      	adds	r3, r6, #3
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
  20477c:	3601      	adds	r6, #1
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
  20477e:	eb04 1303 	add.w	r3, r4, r3, lsl #4
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
  204782:	2e80      	cmp	r6, #128	; 0x80
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
  204784:	7a1a      	ldrb	r2, [r3, #8]
  204786:	f36f 0202 	bfc	r2, #0, #3
  20478a:	721a      	strb	r2, [r3, #8]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
  20478c:	d1f5      	bne.n	20477a <chSysInit+0x2e>
  ch.tm.offset = (rtcnt_t)0;
  20478e:	2500      	movs	r5, #0
  tmp->best       = (rtcnt_t)-1;
  204790:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  tmp->cumulative = (rttime_t)0;
  204794:	2200      	movs	r2, #0
  chTMStartMeasurementX(&tm);
  204796:	4668      	mov	r0, sp
  ch.tm.offset = (rtcnt_t)0;
  204798:	f8c4 587c 	str.w	r5, [r4, #2172]	; 0x87c
  tmp->worst      = (rtcnt_t)0;
  20479c:	e9cd 3500 	strd	r3, r5, [sp]
  tmp->cumulative = (rttime_t)0;
  2047a0:	2300      	movs	r3, #0
  tmp->n          = (ucnt_t)0;
  2047a2:	e9cd 5502 	strd	r5, r5, [sp, #8]
  tmp->cumulative = (rttime_t)0;
  2047a6:	e9cd 2304 	strd	r2, r3, [sp, #16]
  chTMStartMeasurementX(&tm);
  2047aa:	f7fc fd99 	bl	2012e0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
  2047ae:	4668      	mov	r0, sp
  2047b0:	f7fc fd74 	bl	20129c <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
  2047b4:	9b02      	ldr	r3, [sp, #8]
  REG_INSERT(tp);
  2047b6:	6961      	ldr	r1, [r4, #20]
  tp->refs      = (trefs_t)1;
  2047b8:	2201      	movs	r2, #1
  2047ba:	f8c4 387c 	str.w	r3, [r4, #2172]	; 0x87c
  tp->name      = name;
  2047be:	4b42      	ldr	r3, [pc, #264]	; (2048c8 <chSysInit+0x17c>)
  tp->prio      = prio;
  2047c0:	f8c4 6840 	str.w	r6, [r4, #2112]	; 0x840
  tp->name      = name;
  2047c4:	f8c4 3850 	str.w	r3, [r4, #2128]	; 0x850
  REG_INSERT(tp);
  2047c8:	4b40      	ldr	r3, [pc, #256]	; (2048cc <chSysInit+0x180>)
  tp->realprio  = prio;
  2047ca:	f8c4 6874 	str.w	r6, [r4, #2164]	; 0x874
  tp->flags     = CH_FLAG_MODE_STATIC;
  2047ce:	f884 5859 	strb.w	r5, [r4, #2137]	; 0x859
  tp->epending  = (eventmask_t)0;
  2047d2:	f8c4 586c 	str.w	r5, [r4, #2156]	; 0x86c
  tp->refs      = (trefs_t)1;
  2047d6:	f884 285a 	strb.w	r2, [r4, #2138]	; 0x85a
  REG_INSERT(tp);
  2047da:	f8c4 184c 	str.w	r1, [r4, #2124]	; 0x84c
  tp->mtxlist   = NULL;
  2047de:	f8c4 5870 	str.w	r5, [r4, #2160]	; 0x870
  REG_INSERT(tp);
  2047e2:	f8c4 4848 	str.w	r4, [r4, #2120]	; 0x848
  2047e6:	610b      	str	r3, [r1, #16]
  tlp->next = (thread_t *)tlp;
  2047e8:	f103 0128 	add.w	r1, r3, #40	; 0x28
  2047ec:	6163      	str	r3, [r4, #20]
  2047ee:	f8c4 1860 	str.w	r1, [r4, #2144]	; 0x860
  tqp->next = (thread_t *)tqp;
  2047f2:	f103 012c 	add.w	r1, r3, #44	; 0x2c
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
  2047f6:	61a3      	str	r3, [r4, #24]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  2047f8:	4b35      	ldr	r3, [pc, #212]	; (2048d0 <chSysInit+0x184>)
  currp->state = CH_STATE_CURRENT;
  2047fa:	f884 2858 	strb.w	r2, [r4, #2136]	; 0x858
  2047fe:	68d8      	ldr	r0, [r3, #12]
  204800:	f8c4 1864 	str.w	r1, [r4, #2148]	; 0x864
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  204804:	f420 60e0 	bic.w	r0, r0, #1792	; 0x700
  tqp->prev = (thread_t *)tqp;
  204808:	f8c4 1868 	str.w	r1, [r4, #2152]	; 0x868
  reg_value  =  (reg_value                                   |
  20480c:	4931      	ldr	r1, [pc, #196]	; (2048d4 <chSysInit+0x188>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  20480e:	0400      	lsls	r0, r0, #16
    currp->wabase = &__main_thread_stack_base__;
  204810:	4e31      	ldr	r6, [pc, #196]	; (2048d8 <chSysInit+0x18c>)
  204812:	0c00      	lsrs	r0, r0, #16
  204814:	f8c4 6854 	str.w	r6, [r4, #2132]	; 0x854
  reg_value  =  (reg_value                                   |
  204818:	4301      	orrs	r1, r0
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  20481a:	4830      	ldr	r0, [pc, #192]	; (2048dc <chSysInit+0x190>)
  SCB->AIRCR =  reg_value;
  20481c:	60d9      	str	r1, [r3, #12]
  20481e:	68c1      	ldr	r1, [r0, #12]
  204820:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
  204824:	60c1      	str	r1, [r0, #12]
  DWT->LAR = 0xC5ACCE55U;
  204826:	492e      	ldr	r1, [pc, #184]	; (2048e0 <chSysInit+0x194>)
  204828:	482e      	ldr	r0, [pc, #184]	; (2048e4 <chSysInit+0x198>)
  20482a:	f8c1 0fb0 	str.w	r0, [r1, #4016]	; 0xfb0
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
  20482e:	6808      	ldr	r0, [r1, #0]
  204830:	4310      	orrs	r0, r2
  204832:	6008      	str	r0, [r1, #0]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  204834:	2110      	movs	r1, #16
    mpuConfigureRegion(PORT_USE_MPU_REGION,
  204836:	2007      	movs	r0, #7
  204838:	77d9      	strb	r1, [r3, #31]
  20483a:	2120      	movs	r1, #32
  20483c:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
  204840:	4929      	ldr	r1, [pc, #164]	; (2048e8 <chSysInit+0x19c>)
  204842:	6088      	str	r0, [r1, #8]
  204844:	4829      	ldr	r0, [pc, #164]	; (2048ec <chSysInit+0x1a0>)
  204846:	60ce      	str	r6, [r1, #12]
  204848:	6108      	str	r0, [r1, #16]
    mpuEnable(MPU_CTRL_PRIVDEFENA);
  20484a:	2005      	movs	r0, #5
  20484c:	6048      	str	r0, [r1, #4]
  20484e:	6a59      	ldr	r1, [r3, #36]	; 0x24
  204850:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
  204854:	6259      	str	r1, [r3, #36]	; 0x24
  204856:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
  20485a:	b662      	cpsie	i
  20485c:	f7ff fc4c 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  tp->wabase = tdp->wbase;
  204860:	4b23      	ldr	r3, [pc, #140]	; (2048f0 <chSysInit+0x1a4>)
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  204862:	f103 01d4 	add.w	r1, r3, #212	; 0xd4
  tp->prio      = prio;
  204866:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
  tp->refs      = (trefs_t)1;
  20486a:	f883 215a 	strb.w	r2, [r3, #346]	; 0x15a
  REG_INSERT(tp);
  20486e:	f503 709c 	add.w	r0, r3, #312	; 0x138
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  204872:	f8c3 1144 	str.w	r1, [r3, #324]	; 0x144
  204876:	491f      	ldr	r1, [pc, #124]	; (2048f4 <chSysInit+0x1a8>)
  tp->wabase = tdp->wbase;
  204878:	f8c3 3154 	str.w	r3, [r3, #340]	; 0x154
  tp->epending  = (eventmask_t)0;
  20487c:	f8c3 516c 	str.w	r5, [r3, #364]	; 0x16c
  REG_INSERT(tp);
  204880:	f8c3 4148 	str.w	r4, [r3, #328]	; 0x148
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  204884:	e9c3 1545 	strd	r1, r5, [r3, #276]	; 0x114
  tp->mtxlist   = NULL;
  204888:	e9c3 525c 	strd	r5, r2, [r3, #368]	; 0x170
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  20488c:	491a      	ldr	r1, [pc, #104]	; (2048f8 <chSysInit+0x1ac>)
  tp->name      = name;
  20488e:	4a1b      	ldr	r2, [pc, #108]	; (2048fc <chSysInit+0x1b0>)
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  204890:	f8c3 1134 	str.w	r1, [r3, #308]	; 0x134
  tp->state     = CH_STATE_WTSTART;
  204894:	2102      	movs	r1, #2
  tp->name      = name;
  204896:	f8c3 2150 	str.w	r2, [r3, #336]	; 0x150
  REG_INSERT(tp);
  20489a:	6962      	ldr	r2, [r4, #20]
  tp->state     = CH_STATE_WTSTART;
  20489c:	f8a3 1158 	strh.w	r1, [r3, #344]	; 0x158
  REG_INSERT(tp);
  2048a0:	f8c3 214c 	str.w	r2, [r3, #332]	; 0x14c
  2048a4:	6110      	str	r0, [r2, #16]
  tlp->next = (thread_t *)tlp;
  2048a6:	f503 72b0 	add.w	r2, r3, #352	; 0x160
  2048aa:	6160      	str	r0, [r4, #20]
  2048ac:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
  tqp->next = (thread_t *)tqp;
  2048b0:	f503 72b2 	add.w	r2, r3, #356	; 0x164
  tqp->prev = (thread_t *)tqp;
  2048b4:	e9c3 2259 	strd	r2, r2, [r3, #356]	; 0x164
  chSchWakeupS(tp, MSG_OK);
  2048b8:	f7fc ff4a 	bl	201750 <chSchWakeupS.constprop.0>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2048bc:	f385 8811 	msr	BASEPRI, r5
}
  2048c0:	b006      	add	sp, #24
  2048c2:	bd70      	pop	{r4, r5, r6, pc}
  2048c4:	20000e8c 	.word	0x20000e8c
  2048c8:	0800e5e6 	.word	0x0800e5e6
  2048cc:	200016c4 	.word	0x200016c4
  2048d0:	e000ed00 	.word	0xe000ed00
  2048d4:	05fa0300 	.word	0x05fa0300
  2048d8:	20000400 	.word	0x20000400
  2048dc:	e000edf0 	.word	0xe000edf0
  2048e0:	e0001000 	.word	0xe0001000
  2048e4:	c5acce55 	.word	0xc5acce55
  2048e8:	e000ed90 	.word	0xe000ed90
  2048ec:	00080009 	.word	0x00080009
  2048f0:	20001720 	.word	0x20001720
  2048f4:	002013e9 	.word	0x002013e9
  2048f8:	00200341 	.word	0x00200341
  2048fc:	0800dea9 	.word	0x0800dea9

00204900 <wakeup>:
static void wakeup(void *p) {
  204900:	b508      	push	{r3, lr}
  port_lock();
  204902:	f7ff fbf9 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  switch (tp->state) {
  204906:	f890 2020 	ldrb.w	r2, [r0, #32]
  20490a:	2300      	movs	r3, #0
  20490c:	2a07      	cmp	r2, #7
  20490e:	d807      	bhi.n	204920 <wakeup+0x20>
  204910:	e8df f002 	tbb	[pc, r2]
  204914:	0406060c 	.word	0x0406060c
  204918:	13060f13 	.word	0x13060f13
    *tp->u.wttrp = NULL;
  20491c:	6a42      	ldr	r2, [r0, #36]	; 0x24
  20491e:	6013      	str	r3, [r2, #0]
  tp->u.rdymsg = MSG_TIMEOUT;
  204920:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  204924:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
  204926:	f7fc fce1 	bl	2012ec <chSchReadyI>
  20492a:	2300      	movs	r3, #0
  20492c:	f383 8811 	msr	BASEPRI, r3
}
  204930:	bd08      	pop	{r3, pc}
    chSemFastSignalI(tp->u.wtsemp);
  204932:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
  204934:	6893      	ldr	r3, [r2, #8]
  204936:	3301      	adds	r3, #1
  204938:	6093      	str	r3, [r2, #8]
  tp->queue.prev->queue.next = tp->queue.next;
  20493a:	e9d0 3200 	ldrd	r3, r2, [r0]
  20493e:	6013      	str	r3, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
  204940:	605a      	str	r2, [r3, #4]
  return tp;
  204942:	e7ed      	b.n	204920 <wakeup+0x20>

00204944 <_trace_isr_leave>:
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
  204944:	4a08      	ldr	r2, [pc, #32]	; (204968 <_trace_isr_leave+0x24>)
  204946:	8e13      	ldrh	r3, [r2, #48]	; 0x30
void _trace_isr_leave(const char *isr) {
  204948:	b510      	push	{r4, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
  20494a:	f013 0402 	ands.w	r4, r3, #2
  20494e:	d109      	bne.n	204964 <_trace_isr_leave+0x20>
  204950:	f7ff fbd2 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
  204954:	6b53      	ldr	r3, [r2, #52]	; 0x34
  204956:	2203      	movs	r2, #3
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
  204958:	6098      	str	r0, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
  20495a:	701a      	strb	r2, [r3, #0]
    trace_next();
  20495c:	f7fc fcf0 	bl	201340 <trace_next>
  204960:	f384 8811 	msr	BASEPRI, r4
}
  204964:	bd10      	pop	{r4, pc}
  204966:	bf00      	nop
  204968:	20000e8c 	.word	0x20000e8c

0020496c <_trace_isr_enter>:
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
  20496c:	4a08      	ldr	r2, [pc, #32]	; (204990 <_trace_isr_enter+0x24>)
  20496e:	8e13      	ldrh	r3, [r2, #48]	; 0x30
void _trace_isr_enter(const char *isr) {
  204970:	b510      	push	{r4, lr}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
  204972:	f013 0402 	ands.w	r4, r3, #2
  204976:	d109      	bne.n	20498c <_trace_isr_enter+0x20>
  204978:	f7ff fbbe 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
  20497c:	6b53      	ldr	r3, [r2, #52]	; 0x34
  20497e:	2202      	movs	r2, #2
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
  204980:	6098      	str	r0, [r3, #8]
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
  204982:	701a      	strb	r2, [r3, #0]
    trace_next();
  204984:	f7fc fcdc 	bl	201340 <trace_next>
  204988:	f384 8811 	msr	BASEPRI, r4
}
  20498c:	bd10      	pop	{r4, pc}
  20498e:	bf00      	nop
  204990:	20000e8c 	.word	0x20000e8c

00204994 <Vector184>:
{
  204994:	b508      	push	{r3, lr}
	OSAL_IRQ_PROLOGUE();
  204996:	480a      	ldr	r0, [pc, #40]	; (2049c0 <Vector184+0x2c>)
  204998:	f7ff ffe8 	bl	20496c <_trace_isr_enter>
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
  20499c:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  2049a0:	f3ef 8209 	mrs	r2, PSP
	exc->exc_FPSCR &= ~(FPU_EXCEPTION_MASK);
  2049a4:	6e13      	ldr	r3, [r2, #96]	; 0x60
  2049a6:	f023 039f 	bic.w	r3, r3, #159	; 0x9f
  2049aa:	6613      	str	r3, [r2, #96]	; 0x60
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
  2049ac:	eee1 3a10 	vmsr	fpscr, r3
	OSAL_IRQ_EPILOGUE();
  2049b0:	4803      	ldr	r0, [pc, #12]	; (2049c0 <Vector184+0x2c>)
  2049b2:	f7ff ffc7 	bl	204944 <_trace_isr_leave>
}
  2049b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	OSAL_IRQ_EPILOGUE();
  2049ba:	f7ff bbff 	b.w	2041bc <_port_irq_epilogue>
  2049be:	bf00      	nop
  2049c0:	0800e51a 	.word	0x0800e51a

002049c4 <spi_lld_serve_rx_interrupt>:
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
  2049c4:	f011 0f0c 	tst.w	r1, #12
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
  2049c8:	b538      	push	{r3, r4, r5, lr}
  2049ca:	4604      	mov	r4, r0
  2049cc:	460d      	mov	r5, r1
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
  2049ce:	d001      	beq.n	2049d4 <spi_lld_serve_rx_interrupt+0x10>
  chSysHalt(reason);
  2049d0:	f7fc fce4 	bl	20139c <chSysHalt.constprop.0>
  if (spip->config->circular) {
  2049d4:	6843      	ldr	r3, [r0, #4]
  2049d6:	781a      	ldrb	r2, [r3, #0]
  2049d8:	b19a      	cbz	r2, 204a02 <spi_lld_serve_rx_interrupt+0x3e>
    if ((flags & STM32_DMA_ISR_HTIF) != 0U) {
  2049da:	06ca      	lsls	r2, r1, #27
  2049dc:	d502      	bpl.n	2049e4 <spi_lld_serve_rx_interrupt+0x20>
      _spi_isr_half_code(spip);
  2049de:	685b      	ldr	r3, [r3, #4]
  2049e0:	b103      	cbz	r3, 2049e4 <spi_lld_serve_rx_interrupt+0x20>
  2049e2:	4798      	blx	r3
    if ((flags & STM32_DMA_ISR_TCIF) != 0U) {
  2049e4:	06ab      	lsls	r3, r5, #26
  2049e6:	d50b      	bpl.n	204a00 <spi_lld_serve_rx_interrupt+0x3c>
      _spi_isr_full_code(spip);
  2049e8:	6863      	ldr	r3, [r4, #4]
  2049ea:	685b      	ldr	r3, [r3, #4]
  2049ec:	b143      	cbz	r3, 204a00 <spi_lld_serve_rx_interrupt+0x3c>
  2049ee:	2204      	movs	r2, #4
  2049f0:	4620      	mov	r0, r4
  2049f2:	7022      	strb	r2, [r4, #0]
  2049f4:	4798      	blx	r3
  2049f6:	7823      	ldrb	r3, [r4, #0]
  2049f8:	2b04      	cmp	r3, #4
  2049fa:	d101      	bne.n	204a00 <spi_lld_serve_rx_interrupt+0x3c>
  2049fc:	2303      	movs	r3, #3
  2049fe:	7023      	strb	r3, [r4, #0]
}
  204a00:	bd38      	pop	{r3, r4, r5, pc}
    dmaStreamDisable(spip->dmatx);
  204a02:	6a42      	ldr	r2, [r0, #36]	; 0x24
  204a04:	6811      	ldr	r1, [r2, #0]
  204a06:	6808      	ldr	r0, [r1, #0]
  204a08:	f020 001f 	bic.w	r0, r0, #31
  204a0c:	6008      	str	r0, [r1, #0]
  204a0e:	6808      	ldr	r0, [r1, #0]
  204a10:	07c5      	lsls	r5, r0, #31
  204a12:	d4fc      	bmi.n	204a0e <spi_lld_serve_rx_interrupt+0x4a>
  204a14:	7a50      	ldrb	r0, [r2, #9]
  204a16:	6851      	ldr	r1, [r2, #4]
  204a18:	223d      	movs	r2, #61	; 0x3d
  204a1a:	4082      	lsls	r2, r0
  204a1c:	600a      	str	r2, [r1, #0]
    dmaStreamDisable(spip->dmarx);
  204a1e:	6a22      	ldr	r2, [r4, #32]
  204a20:	6811      	ldr	r1, [r2, #0]
  204a22:	6808      	ldr	r0, [r1, #0]
  204a24:	f020 001f 	bic.w	r0, r0, #31
  204a28:	6008      	str	r0, [r1, #0]
  204a2a:	6808      	ldr	r0, [r1, #0]
  204a2c:	07c0      	lsls	r0, r0, #31
  204a2e:	d4fc      	bmi.n	204a2a <spi_lld_serve_rx_interrupt+0x66>
  204a30:	7a50      	ldrb	r0, [r2, #9]
  204a32:	6851      	ldr	r1, [r2, #4]
  204a34:	223d      	movs	r2, #61	; 0x3d
    _spi_isr_code(spip);
  204a36:	685b      	ldr	r3, [r3, #4]
    dmaStreamDisable(spip->dmarx);
  204a38:	4082      	lsls	r2, r0
  204a3a:	600a      	str	r2, [r1, #0]
    _spi_isr_code(spip);
  204a3c:	b133      	cbz	r3, 204a4c <spi_lld_serve_rx_interrupt+0x88>
  204a3e:	2204      	movs	r2, #4
  204a40:	4620      	mov	r0, r4
  204a42:	7022      	strb	r2, [r4, #0]
  204a44:	4798      	blx	r3
  204a46:	7823      	ldrb	r3, [r4, #0]
  204a48:	2b04      	cmp	r3, #4
  204a4a:	d101      	bne.n	204a50 <spi_lld_serve_rx_interrupt+0x8c>
  204a4c:	2302      	movs	r3, #2
  204a4e:	7023      	strb	r3, [r4, #0]
  204a50:	f7ff fb52 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  chThdResumeI(trp, msg);
  204a54:	2100      	movs	r1, #0
  204a56:	f104 0008 	add.w	r0, r4, #8
  204a5a:	f7fc fc68 	bl	20132e <chThdResumeI>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  204a5e:	2300      	movs	r3, #0
  204a60:	f383 8811 	msr	BASEPRI, r3
  204a64:	e7cc      	b.n	204a00 <spi_lld_serve_rx_interrupt+0x3c>

00204a66 <i2c_lld_serve_error_interrupt>:
  i2cp->i2c->CR1 &= ~(I2C_CR1_TXIE | I2C_CR1_RXIE);
  204a66:	6b02      	ldr	r2, [r0, #48]	; 0x30
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint32_t isr) {
  204a68:	b508      	push	{r3, lr}
  i2cp->i2c->CR1 &= ~(I2C_CR1_TXIE | I2C_CR1_RXIE);
  204a6a:	6813      	ldr	r3, [r2, #0]
  204a6c:	f023 0306 	bic.w	r3, r3, #6
  204a70:	6013      	str	r3, [r2, #0]
  if (isr & I2C_ISR_BERR)
  204a72:	05cb      	lsls	r3, r1, #23
    i2cp->errors |= I2C_BUS_ERROR;
  204a74:	bf42      	ittt	mi
  204a76:	6883      	ldrmi	r3, [r0, #8]
  204a78:	f043 0301 	orrmi.w	r3, r3, #1
  204a7c:	6083      	strmi	r3, [r0, #8]
  if (isr & I2C_ISR_ARLO)
  204a7e:	058a      	lsls	r2, r1, #22
    i2cp->errors |= I2C_ARBITRATION_LOST;
  204a80:	bf42      	ittt	mi
  204a82:	6883      	ldrmi	r3, [r0, #8]
  204a84:	f043 0302 	orrmi.w	r3, r3, #2
  204a88:	6083      	strmi	r3, [r0, #8]
  if (isr & I2C_ISR_OVR)
  204a8a:	054b      	lsls	r3, r1, #21
    i2cp->errors |= I2C_OVERRUN;
  204a8c:	bf42      	ittt	mi
  204a8e:	6883      	ldrmi	r3, [r0, #8]
  204a90:	f043 0308 	orrmi.w	r3, r3, #8
  204a94:	6083      	strmi	r3, [r0, #8]
  if (isr & I2C_ISR_TIMEOUT)
  204a96:	04ca      	lsls	r2, r1, #19
  204a98:	6883      	ldr	r3, [r0, #8]
  204a9a:	d50d      	bpl.n	204ab8 <i2c_lld_serve_error_interrupt+0x52>
    i2cp->errors |= I2C_TIMEOUT;
  204a9c:	f043 0320 	orr.w	r3, r3, #32
  204aa0:	6083      	str	r3, [r0, #8]
  204aa2:	f7ff fb29 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  204aa6:	f06f 0101 	mvn.w	r1, #1
  204aaa:	301c      	adds	r0, #28
  204aac:	f7fc fc3f 	bl	20132e <chThdResumeI>
  204ab0:	2300      	movs	r3, #0
  204ab2:	f383 8811 	msr	BASEPRI, r3
  204ab6:	e001      	b.n	204abc <i2c_lld_serve_error_interrupt+0x56>
  if (i2cp->errors != I2C_NO_ERROR)
  204ab8:	2b00      	cmp	r3, #0
  204aba:	d1f2      	bne.n	204aa2 <i2c_lld_serve_error_interrupt+0x3c>
}
  204abc:	bd08      	pop	{r3, pc}

00204abe <i2c_lld_serve_interrupt>:
  if ((isr & I2C_ISR_NACKF) != 0U) {
  204abe:	06cb      	lsls	r3, r1, #27
static void i2c_lld_serve_interrupt(I2CDriver *i2cp, uint32_t isr) {
  204ac0:	b510      	push	{r4, lr}
  I2C_TypeDef *dp = i2cp->i2c;
  204ac2:	6b04      	ldr	r4, [r0, #48]	; 0x30
  if ((isr & I2C_ISR_NACKF) != 0U) {
  204ac4:	d516      	bpl.n	204af4 <i2c_lld_serve_interrupt+0x36>
    i2cp->errors |= I2C_ACK_FAILURE;
  204ac6:	6883      	ldr	r3, [r0, #8]
  204ac8:	f043 0304 	orr.w	r3, r3, #4
  204acc:	6083      	str	r3, [r0, #8]
    dp->CR2 |= I2C_CR2_STOP;
  204ace:	6863      	ldr	r3, [r4, #4]
  204ad0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  204ad4:	6063      	str	r3, [r4, #4]
    dp->CR1 &= ~(I2C_CR1_TCIE | I2C_CR1_TXIE | I2C_CR1_RXIE);
  204ad6:	6823      	ldr	r3, [r4, #0]
  204ad8:	f023 0346 	bic.w	r3, r3, #70	; 0x46
  204adc:	6023      	str	r3, [r4, #0]
  204ade:	f7ff fb0b 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  204ae2:	f06f 0101 	mvn.w	r1, #1
  204ae6:	301c      	adds	r0, #28
  204ae8:	f7fc fc21 	bl	20132e <chThdResumeI>
  204aec:	2300      	movs	r3, #0
  204aee:	f383 8811 	msr	BASEPRI, r3
  204af2:	e047      	b.n	204b84 <i2c_lld_serve_interrupt+0xc6>
    if (i2cp->state == I2C_ACTIVE_TX) {
  204af4:	7802      	ldrb	r2, [r0, #0]
    uint32_t cr1 = dp->CR1;
  204af6:	6823      	ldr	r3, [r4, #0]
    if (i2cp->state == I2C_ACTIVE_TX) {
  204af8:	2a03      	cmp	r2, #3
  204afa:	d119      	bne.n	204b30 <i2c_lld_serve_interrupt+0x72>
      if (((cr1 &I2C_CR1_TXIE) != 0U) && ((isr & I2C_ISR_TXIS) != 0U)) {
  204afc:	079a      	lsls	r2, r3, #30
  204afe:	d50e      	bpl.n	204b1e <i2c_lld_serve_interrupt+0x60>
  204b00:	078b      	lsls	r3, r1, #30
  204b02:	d50c      	bpl.n	204b1e <i2c_lld_serve_interrupt+0x60>
        dp->TXDR = (uint32_t)*i2cp->txptr;
  204b04:	6a03      	ldr	r3, [r0, #32]
  204b06:	f813 2b01 	ldrb.w	r2, [r3], #1
  204b0a:	62a2      	str	r2, [r4, #40]	; 0x28
        i2cp->txptr++;
  204b0c:	6203      	str	r3, [r0, #32]
        i2cp->txbytes--;
  204b0e:	6a43      	ldr	r3, [r0, #36]	; 0x24
  204b10:	3b01      	subs	r3, #1
  204b12:	6243      	str	r3, [r0, #36]	; 0x24
        if (i2cp->txbytes == 0U) {
  204b14:	b91b      	cbnz	r3, 204b1e <i2c_lld_serve_interrupt+0x60>
          dp->CR1 &= ~I2C_CR1_TXIE;
  204b16:	6823      	ldr	r3, [r4, #0]
  204b18:	f023 0302 	bic.w	r3, r3, #2
          dp->CR1 &= ~I2C_CR1_RXIE;
  204b1c:	6023      	str	r3, [r4, #0]
  if ((isr & I2C_ISR_TCR) != 0U) {
  204b1e:	060a      	lsls	r2, r1, #24
  204b20:	d51d      	bpl.n	204b5e <i2c_lld_serve_interrupt+0xa0>
    if (i2cp->state == I2C_ACTIVE_TX) {
  204b22:	7803      	ldrb	r3, [r0, #0]
  204b24:	2b03      	cmp	r3, #3
  204b26:	d116      	bne.n	204b56 <i2c_lld_serve_interrupt+0x98>
}
  204b28:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      i2c_lld_setup_tx_transfer(i2cp);
  204b2c:	f7fc bd14 	b.w	201558 <i2c_lld_setup_tx_transfer>
      if (((cr1 & I2C_CR1_RXIE) != 0U) && ((isr & I2C_ISR_RXNE) != 0U)) {
  204b30:	075a      	lsls	r2, r3, #29
  204b32:	d5f4      	bpl.n	204b1e <i2c_lld_serve_interrupt+0x60>
  204b34:	074b      	lsls	r3, r1, #29
  204b36:	d5f2      	bpl.n	204b1e <i2c_lld_serve_interrupt+0x60>
        *i2cp->rxptr = (uint8_t)dp->RXDR;
  204b38:	6a62      	ldr	r2, [r4, #36]	; 0x24
  204b3a:	6a83      	ldr	r3, [r0, #40]	; 0x28
  204b3c:	701a      	strb	r2, [r3, #0]
        i2cp->rxptr++;
  204b3e:	6a83      	ldr	r3, [r0, #40]	; 0x28
  204b40:	3301      	adds	r3, #1
  204b42:	6283      	str	r3, [r0, #40]	; 0x28
        i2cp->rxbytes--;
  204b44:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  204b46:	3b01      	subs	r3, #1
  204b48:	62c3      	str	r3, [r0, #44]	; 0x2c
        if (i2cp->rxbytes == 0U) {
  204b4a:	2b00      	cmp	r3, #0
  204b4c:	d1e7      	bne.n	204b1e <i2c_lld_serve_interrupt+0x60>
          dp->CR1 &= ~I2C_CR1_RXIE;
  204b4e:	6823      	ldr	r3, [r4, #0]
  204b50:	f023 0304 	bic.w	r3, r3, #4
  204b54:	e7e2      	b.n	204b1c <i2c_lld_serve_interrupt+0x5e>
}
  204b56:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      i2c_lld_setup_rx_transfer(i2cp);
  204b5a:	f7fc bd15 	b.w	201588 <i2c_lld_setup_rx_transfer>
  if ((isr & I2C_ISR_TC) != 0U) {
  204b5e:	064b      	lsls	r3, r1, #25
  204b60:	d510      	bpl.n	204b84 <i2c_lld_serve_interrupt+0xc6>
    if (i2cp->state == I2C_ACTIVE_TX) {
  204b62:	7803      	ldrb	r3, [r0, #0]
  204b64:	2b03      	cmp	r3, #3
  204b66:	d10e      	bne.n	204b86 <i2c_lld_serve_interrupt+0xc8>
      if (i2c_lld_get_rxbytes(i2cp) > 0U) {
  204b68:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  204b6a:	b163      	cbz	r3, 204b86 <i2c_lld_serve_interrupt+0xc8>
        i2c_lld_setup_rx_transfer(i2cp);
  204b6c:	f7fc fd0c 	bl	201588 <i2c_lld_setup_rx_transfer>
        dp->CR1 |= I2C_CR1_RXIE;
  204b70:	6823      	ldr	r3, [r4, #0]
  204b72:	f043 0304 	orr.w	r3, r3, #4
  204b76:	6023      	str	r3, [r4, #0]
        dp->CR2 |= I2C_CR2_START;
  204b78:	6863      	ldr	r3, [r4, #4]
  204b7a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  204b7e:	6063      	str	r3, [r4, #4]
        i2cp->state = I2C_ACTIVE_RX;
  204b80:	2304      	movs	r3, #4
  204b82:	7003      	strb	r3, [r0, #0]
}
  204b84:	bd10      	pop	{r4, pc}
    dp->CR2 |= I2C_CR2_STOP;
  204b86:	6863      	ldr	r3, [r4, #4]
  204b88:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  204b8c:	6063      	str	r3, [r4, #4]
    dp->CR1 &= ~I2C_CR1_TCIE;
  204b8e:	6823      	ldr	r3, [r4, #0]
  204b90:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  204b94:	6023      	str	r3, [r4, #0]
  204b96:	f7ff faaf 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  204b9a:	2100      	movs	r1, #0
  204b9c:	e7a3      	b.n	204ae6 <i2c_lld_serve_interrupt+0x28>

00204b9e <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
  204b9e:	b510      	push	{r4, lr}

  (void)ep;
  switch (usbp->ep0state) {
  204ba0:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
  204ba4:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
  204ba6:	2b14      	cmp	r3, #20
  204ba8:	d02d      	beq.n	204c06 <_usb_ep0out+0x68>
  204baa:	d81c      	bhi.n	204be6 <_usb_ep0out+0x48>
  204bac:	2b06      	cmp	r3, #6
  204bae:	d005      	beq.n	204bbc <_usb_ep0out+0x1e>
  204bb0:	d801      	bhi.n	204bb6 <_usb_ep0out+0x18>
  204bb2:	b11b      	cbz	r3, 204bbc <_usb_ep0out+0x1e>
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
  204bb4:	bd10      	pop	{r4, pc}
  switch (usbp->ep0state) {
  204bb6:	3b09      	subs	r3, #9
  204bb8:	2b02      	cmp	r3, #2
  204bba:	d8fb      	bhi.n	204bb4 <_usb_ep0out+0x16>
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
  204bbc:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
  204bbe:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
  204bc2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  204bc6:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
  204bca:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
  204bce:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  204bd2:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
  204bd6:	6863      	ldr	r3, [r4, #4]
  204bd8:	681b      	ldr	r3, [r3, #0]
  204bda:	b113      	cbz	r3, 204be2 <_usb_ep0out+0x44>
  204bdc:	2106      	movs	r1, #6
  204bde:	4620      	mov	r0, r4
  204be0:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
  204be2:	2306      	movs	r3, #6
  204be4:	e018      	b.n	204c18 <_usb_ep0out+0x7a>
  switch (usbp->ep0state) {
  204be6:	2b15      	cmp	r3, #21
  204be8:	d1e4      	bne.n	204bb4 <_usb_ep0out+0x16>
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
  204bea:	230b      	movs	r3, #11
  204bec:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
  204bf0:	f7ff fa82 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
    usbStartTransmitI(usbp, 0, NULL, 0);
  204bf4:	2300      	movs	r3, #0
  204bf6:	461a      	mov	r2, r3
  204bf8:	4619      	mov	r1, r3
  204bfa:	f003 fcef 	bl	2085dc <usbStartTransmitI>
  204bfe:	2300      	movs	r3, #0
  204c00:	f383 8811 	msr	BASEPRI, r3
  204c04:	e7d6      	b.n	204bb4 <_usb_ep0out+0x16>
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
  204c06:	68c3      	ldr	r3, [r0, #12]
  204c08:	699b      	ldr	r3, [r3, #24]
  204c0a:	685b      	ldr	r3, [r3, #4]
  204c0c:	2b00      	cmp	r3, #0
  204c0e:	d1d1      	bne.n	204bb4 <_usb_ep0out+0x16>
    if (usbp->ep0endcb != NULL) {
  204c10:	6d83      	ldr	r3, [r0, #88]	; 0x58
  204c12:	b103      	cbz	r3, 204c16 <_usb_ep0out+0x78>
      usbp->ep0endcb(usbp);
  204c14:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
  204c16:	2300      	movs	r3, #0
    usbp->ep0state = USB_EP0_ERROR;
  204c18:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
    return;
  204c1c:	e7ca      	b.n	204bb4 <_usb_ep0out+0x16>

00204c1e <_usb_ep0in>:
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
  204c1e:	b538      	push	{r3, r4, r5, lr}
  switch (usbp->ep0state) {
  204c20:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
  204c24:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
  204c26:	2b00      	cmp	r3, #0
  204c28:	d040      	beq.n	204cac <_usb_ep0in+0x8e>
  204c2a:	3b06      	subs	r3, #6
  204c2c:	b2da      	uxtb	r2, r3
  204c2e:	2a0f      	cmp	r2, #15
  204c30:	d836      	bhi.n	204ca0 <_usb_ep0in+0x82>
  204c32:	2b0f      	cmp	r3, #15
  204c34:	d834      	bhi.n	204ca0 <_usb_ep0in+0x82>
  204c36:	e8df f003 	tbb	[pc, r3]
  204c3a:	3339      	.short	0x3339
  204c3c:	34250833 	.word	0x34250833
  204c40:	33333333 	.word	0x33333333
  204c44:	33333333 	.word	0x33333333
  204c48:	3939      	.short	0x3939
  hw |= (uint16_t)*p << 8U;
  204c4a:	f890 1063 	ldrb.w	r1, [r0, #99]	; 0x63
  204c4e:	f890 2062 	ldrb.w	r2, [r0, #98]	; 0x62
    if ((usbp->ep0n < max) &&
  204c52:	6d43      	ldr	r3, [r0, #84]	; 0x54
    max = (size_t)get_hword(&usbp->setup[6]);
  204c54:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    if ((usbp->ep0n < max) &&
  204c58:	4293      	cmp	r3, r2
  204c5a:	d213      	bcs.n	204c84 <_usb_ep0in+0x66>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
  204c5c:	68c2      	ldr	r2, [r0, #12]
  204c5e:	8a12      	ldrh	r2, [r2, #16]
  204c60:	fbb3 f5f2 	udiv	r5, r3, r2
  204c64:	fb02 3515 	mls	r5, r2, r5, r3
    if ((usbp->ep0n < max) &&
  204c68:	b965      	cbnz	r5, 204c84 <_usb_ep0in+0x66>
  204c6a:	f7ff fa45 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
      usbStartTransmitI(usbp, 0, NULL, 0);
  204c6e:	462b      	mov	r3, r5
  204c70:	462a      	mov	r2, r5
  204c72:	4629      	mov	r1, r5
  204c74:	f003 fcb2 	bl	2085dc <usbStartTransmitI>
  204c78:	f385 8811 	msr	BASEPRI, r5
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
  204c7c:	230a      	movs	r3, #10
    usbp->ep0state = USB_EP0_ERROR;
  204c7e:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
    return;
  204c82:	e00d      	b.n	204ca0 <_usb_ep0in+0x82>
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
  204c84:	2314      	movs	r3, #20
  204c86:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
  204c8a:	f7ff fa35 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
    usbStartReceiveI(usbp, 0, NULL, 0);
  204c8e:	2300      	movs	r3, #0
  204c90:	4620      	mov	r0, r4
  204c92:	461a      	mov	r2, r3
  204c94:	4619      	mov	r1, r3
  204c96:	f003 fcb2 	bl	2085fe <usbStartReceiveI>
  204c9a:	2300      	movs	r3, #0
  204c9c:	f383 8811 	msr	BASEPRI, r3
}
  204ca0:	bd38      	pop	{r3, r4, r5, pc}
    if (usbp->ep0endcb != NULL) {
  204ca2:	6d83      	ldr	r3, [r0, #88]	; 0x58
  204ca4:	b103      	cbz	r3, 204ca8 <_usb_ep0in+0x8a>
      usbp->ep0endcb(usbp);
  204ca6:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
  204ca8:	2300      	movs	r3, #0
  204caa:	e7e8      	b.n	204c7e <_usb_ep0in+0x60>
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
  204cac:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
  204cae:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
  204cb2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  204cb6:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
  204cba:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
  204cbe:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  204cc2:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
  204cc6:	6863      	ldr	r3, [r4, #4]
  204cc8:	681b      	ldr	r3, [r3, #0]
  204cca:	b113      	cbz	r3, 204cd2 <_usb_ep0in+0xb4>
  204ccc:	2106      	movs	r1, #6
  204cce:	4620      	mov	r0, r4
  204cd0:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
  204cd2:	2306      	movs	r3, #6
  204cd4:	e7d3      	b.n	204c7e <_usb_ep0in+0x60>
	...

00204cd8 <_usb_ep0setup>:
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
  204cd8:	b570      	push	{r4, r5, r6, lr}
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
  204cda:	f890 304c 	ldrb.w	r3, [r0, #76]	; 0x4c
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
  204cde:	4604      	mov	r4, r0
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
  204ce0:	b113      	cbz	r3, 204ce8 <_usb_ep0setup+0x10>
    usbp->ep0state = USB_EP0_STP_WAITING;
  204ce2:	2300      	movs	r3, #0
  204ce4:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
  204ce8:	eb04 0181 	add.w	r1, r4, r1, lsl #2
  204cec:	68cb      	ldr	r3, [r1, #12]
  204cee:	6a1a      	ldr	r2, [r3, #32]
  204cf0:	6813      	ldr	r3, [r2, #0]
  204cf2:	65e3      	str	r3, [r4, #92]	; 0x5c
  204cf4:	6853      	ldr	r3, [r2, #4]
  204cf6:	6623      	str	r3, [r4, #96]	; 0x60
  if ((usbp->config->requests_hook_cb == NULL) ||
  204cf8:	6863      	ldr	r3, [r4, #4]
  204cfa:	689b      	ldr	r3, [r3, #8]
  204cfc:	b9db      	cbnz	r3, 204d36 <_usb_ep0setup+0x5e>
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
  204cfe:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
  204d02:	f013 0560 	ands.w	r5, r3, #96	; 0x60
  204d06:	d03c      	beq.n	204d82 <_usb_ep0setup+0xaa>
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
  204d08:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
  204d0a:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
  204d0e:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  204d12:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
  204d16:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
  204d1a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  204d1e:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
  204d22:	6863      	ldr	r3, [r4, #4]
  204d24:	681b      	ldr	r3, [r3, #0]
  204d26:	b113      	cbz	r3, 204d2e <_usb_ep0setup+0x56>
  204d28:	2106      	movs	r1, #6
  204d2a:	4620      	mov	r0, r4
  204d2c:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
  204d2e:	2306      	movs	r3, #6
  204d30:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
}
  204d34:	bd70      	pop	{r4, r5, r6, pc}
      !(usbp->config->requests_hook_cb(usbp))) {
  204d36:	4620      	mov	r0, r4
  204d38:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
  204d3a:	2800      	cmp	r0, #0
  204d3c:	d0df      	beq.n	204cfe <_usb_ep0setup+0x26>
  hw |= (uint16_t)*p << 8U;
  204d3e:	f894 2063 	ldrb.w	r2, [r4, #99]	; 0x63
  204d42:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
  max = (size_t)get_hword(&usbp->setup[6]);
  204d46:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  if (usbp->ep0n > max) {
  204d4a:	6d62      	ldr	r2, [r4, #84]	; 0x54
  204d4c:	429a      	cmp	r2, r3
    usbp->ep0n = max;
  204d4e:	bf88      	it	hi
  204d50:	6563      	strhi	r3, [r4, #84]	; 0x54
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
  204d52:	f994 305c 	ldrsb.w	r3, [r4, #92]	; 0x5c
  204d56:	6d65      	ldr	r5, [r4, #84]	; 0x54
  204d58:	2b00      	cmp	r3, #0
  204d5a:	f280 812c 	bge.w	204fb6 <_usb_ep0setup+0x2de>
    if (usbp->ep0n != 0U) {
  204d5e:	2d00      	cmp	r5, #0
  204d60:	f000 811b 	beq.w	204f9a <_usb_ep0setup+0x2c2>
      usbp->ep0state = USB_EP0_IN_TX;
  204d64:	2309      	movs	r3, #9
  204d66:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
  204d6a:	f7ff f9c5 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
  204d6e:	2100      	movs	r1, #0
  204d70:	4620      	mov	r0, r4
  204d72:	e9d4 2314 	ldrd	r2, r3, [r4, #80]	; 0x50
  204d76:	f003 fc31 	bl	2085dc <usbStartTransmitI>
  204d7a:	2300      	movs	r3, #0
  204d7c:	f383 8811 	msr	BASEPRI, r3
  204d80:	e7d8      	b.n	204d34 <_usb_ep0setup+0x5c>
           ((uint32_t)usbp->setup[1] << 8U))) {
  204d82:	f894 205d 	ldrb.w	r2, [r4, #93]	; 0x5d
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  204d86:	f003 037f 	and.w	r3, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
  204d8a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  204d8e:	f240 3202 	movw	r2, #770	; 0x302
  204d92:	4293      	cmp	r3, r2
  204d94:	f000 80e6 	beq.w	204f64 <_usb_ep0setup+0x28c>
  204d98:	d821      	bhi.n	204dde <_usb_ep0setup+0x106>
  204d9a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  204d9e:	d04d      	beq.n	204e3c <_usb_ep0setup+0x164>
  204da0:	d80d      	bhi.n	204dbe <_usb_ep0setup+0xe6>
  204da2:	2b01      	cmp	r3, #1
  204da4:	d044      	beq.n	204e30 <_usb_ep0setup+0x158>
  204da6:	2b02      	cmp	r3, #2
  204da8:	f000 80a9 	beq.w	204efe <_usb_ep0setup+0x226>
  204dac:	2b00      	cmp	r3, #0
  204dae:	d1ab      	bne.n	204d08 <_usb_ep0setup+0x30>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
  204db0:	f104 0264 	add.w	r2, r4, #100	; 0x64
  204db4:	6522      	str	r2, [r4, #80]	; 0x50
  204db6:	2202      	movs	r2, #2
  204db8:	6562      	str	r2, [r4, #84]	; 0x54
    usbSetupTransfer(usbp, NULL, 0, NULL);
  204dba:	65a3      	str	r3, [r4, #88]	; 0x58
    return true;
  204dbc:	e7bf      	b.n	204d3e <_usb_ep0setup+0x66>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  204dbe:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
  204dc2:	f000 80b0 	beq.w	204f26 <_usb_ep0setup+0x24e>
  204dc6:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
  204dca:	d19d      	bne.n	204d08 <_usb_ep0setup+0x30>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
  204dcc:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
  204dd0:	2b01      	cmp	r3, #1
  204dd2:	d199      	bne.n	204d08 <_usb_ep0setup+0x30>
      usbp->status |= 2U;
  204dd4:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
  204dd8:	f043 0302 	orr.w	r3, r3, #2
  204ddc:	e037      	b.n	204e4e <_usb_ep0setup+0x176>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  204dde:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
  204de2:	d058      	beq.n	204e96 <_usb_ep0setup+0x1be>
  204de4:	d81c      	bhi.n	204e20 <_usb_ep0setup+0x148>
  204de6:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
  204dea:	d036      	beq.n	204e5a <_usb_ep0setup+0x182>
  204dec:	f5a3 63c0 	sub.w	r3, r3, #1536	; 0x600
  204df0:	2b01      	cmp	r3, #1
  204df2:	d889      	bhi.n	204d08 <_usb_ep0setup+0x30>
  hw |= (uint16_t)*p << 8U;
  204df4:	f894 2061 	ldrb.w	r2, [r4, #97]	; 0x61
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
  204df8:	4620      	mov	r0, r4
  204dfa:	6861      	ldr	r1, [r4, #4]
  hw |= (uint16_t)*p << 8U;
  204dfc:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
  204e00:	684e      	ldr	r6, [r1, #4]
  204e02:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  204e06:	f894 105f 	ldrb.w	r1, [r4, #95]	; 0x5f
  204e0a:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
  204e0e:	47b0      	blx	r6
    if (dp == NULL) {
  204e10:	2800      	cmp	r0, #0
  204e12:	f43f af79 	beq.w	204d08 <_usb_ep0setup+0x30>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
  204e16:	6843      	ldr	r3, [r0, #4]
  204e18:	6523      	str	r3, [r4, #80]	; 0x50
  204e1a:	6803      	ldr	r3, [r0, #0]
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
  204e1c:	6563      	str	r3, [r4, #84]	; 0x54
  204e1e:	e01a      	b.n	204e56 <_usb_ep0setup+0x17e>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
  204e20:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
  204e24:	d03c      	beq.n	204ea0 <_usb_ep0setup+0x1c8>
  204e26:	f640 4202 	movw	r2, #3074	; 0xc02
  204e2a:	4293      	cmp	r3, r2
  204e2c:	f47f af6c 	bne.w	204d08 <_usb_ep0setup+0x30>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
  204e30:	4b6d      	ldr	r3, [pc, #436]	; (204fe8 <_usb_ep0setup+0x310>)
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
  204e32:	6523      	str	r3, [r4, #80]	; 0x50
  204e34:	2302      	movs	r3, #2
  204e36:	6563      	str	r3, [r4, #84]	; 0x54
  204e38:	2300      	movs	r3, #0
  204e3a:	e7be      	b.n	204dba <_usb_ep0setup+0xe2>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
  204e3c:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
  204e40:	2b01      	cmp	r3, #1
  204e42:	f47f af61 	bne.w	204d08 <_usb_ep0setup+0x30>
      usbp->status &= ~2U;
  204e46:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
  204e4a:	f023 0302 	bic.w	r3, r3, #2
      usbp->status |= 2U;
  204e4e:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
  204e52:	e9c4 5514 	strd	r5, r5, [r4, #80]	; 0x50
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
  204e56:	65a5      	str	r5, [r4, #88]	; 0x58
    return true;
  204e58:	e771      	b.n	204d3e <_usb_ep0setup+0x66>
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
  204e5a:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
  204e5e:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
  204e62:	d114      	bne.n	204e8e <_usb_ep0setup+0x1b6>
  usbp->address = usbp->setup[2];
  204e64:	f894 105e 	ldrb.w	r1, [r4, #94]	; 0x5e
  stm32_otg_t *otgp = usbp->otg;
  204e68:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  204e6a:	f884 1066 	strb.w	r1, [r4, #102]	; 0x66
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
  204e6e:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
  204e72:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
  204e76:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
  204e7a:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
  204e7e:	6863      	ldr	r3, [r4, #4]
  204e80:	681b      	ldr	r3, [r3, #0]
  204e82:	b113      	cbz	r3, 204e8a <_usb_ep0setup+0x1b2>
  204e84:	2101      	movs	r1, #1
  204e86:	4620      	mov	r0, r4
  204e88:	4798      	blx	r3
  usbp->state = USB_SELECTED;
  204e8a:	2303      	movs	r3, #3
  204e8c:	7023      	strb	r3, [r4, #0]
    usbSetupTransfer(usbp, NULL, 0, NULL);
  204e8e:	2300      	movs	r3, #0
  204e90:	e9c4 3314 	strd	r3, r3, [r4, #80]	; 0x50
  204e94:	e791      	b.n	204dba <_usb_ep0setup+0xe2>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
  204e96:	f104 0367 	add.w	r3, r4, #103	; 0x67
  204e9a:	6523      	str	r3, [r4, #80]	; 0x50
  204e9c:	2301      	movs	r3, #1
  204e9e:	e7bd      	b.n	204e1c <_usb_ep0setup+0x144>
      if (usbp->state == USB_ACTIVE) {
  204ea0:	7823      	ldrb	r3, [r4, #0]
  204ea2:	2b04      	cmp	r3, #4
  204ea4:	d11b      	bne.n	204ede <_usb_ep0setup+0x206>
  204ea6:	f7ff f927 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  usbp->transmitting &= 1U;
  204eaa:	68a3      	ldr	r3, [r4, #8]
  otg_disable_ep(usbp);
  204eac:	4620      	mov	r0, r4
    usbp->epc[i] = NULL;
  204eae:	6225      	str	r5, [r4, #32]
  usbp->transmitting &= 1U;
  204eb0:	f003 1301 	and.w	r3, r3, #65537	; 0x10001
  204eb4:	60a3      	str	r3, [r4, #8]
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
  204eb6:	6f23      	ldr	r3, [r4, #112]	; 0x70
  204eb8:	681b      	ldr	r3, [r3, #0]
    usbp->epc[i] = NULL;
  204eba:	e9c4 5504 	strd	r5, r5, [r4, #16]
  204ebe:	e9c4 5506 	strd	r5, r5, [r4, #24]
  204ec2:	6763      	str	r3, [r4, #116]	; 0x74
  otg_disable_ep(usbp);
  204ec4:	f7fc fac2 	bl	20144c <otg_disable_ep>
  204ec8:	f385 8811 	msr	BASEPRI, r5
        usbp->state = USB_SELECTED;
  204ecc:	2103      	movs	r1, #3
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
  204ece:	6863      	ldr	r3, [r4, #4]
        usbp->configuration = 0U;
  204ed0:	f884 5067 	strb.w	r5, [r4, #103]	; 0x67
        usbp->state = USB_SELECTED;
  204ed4:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
  204ed6:	681b      	ldr	r3, [r3, #0]
  204ed8:	b10b      	cbz	r3, 204ede <_usb_ep0setup+0x206>
  204eda:	4620      	mov	r0, r4
  204edc:	4798      	blx	r3
      if (usbp->setup[2] != 0U) {
  204ede:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
  204ee2:	2b00      	cmp	r3, #0
  204ee4:	d0d3      	beq.n	204e8e <_usb_ep0setup+0x1b6>
        usbp->configuration = usbp->setup[2];
  204ee6:	f884 3067 	strb.w	r3, [r4, #103]	; 0x67
        usbp->state = USB_ACTIVE;
  204eea:	2304      	movs	r3, #4
  204eec:	7023      	strb	r3, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
  204eee:	6863      	ldr	r3, [r4, #4]
  204ef0:	681b      	ldr	r3, [r3, #0]
  204ef2:	2b00      	cmp	r3, #0
  204ef4:	d0cb      	beq.n	204e8e <_usb_ep0setup+0x1b6>
  204ef6:	2102      	movs	r1, #2
  204ef8:	4620      	mov	r0, r4
  204efa:	4798      	blx	r3
  204efc:	e7c7      	b.n	204e8e <_usb_ep0setup+0x1b6>
    if ((usbp->setup[4] & 0x80U) != 0U) {
  204efe:	f894 1060 	ldrb.w	r1, [r4, #96]	; 0x60
  204f02:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  204f04:	0608      	lsls	r0, r1, #24
  204f06:	f001 030f 	and.w	r3, r1, #15
  204f0a:	d50a      	bpl.n	204f22 <_usb_ep0setup+0x24a>
  ctl = usbp->otg->ie[ep].DIEPCTL;
  204f0c:	3348      	adds	r3, #72	; 0x48
  ctl = usbp->otg->oe[ep].DOEPCTL;
  204f0e:	015b      	lsls	r3, r3, #5
  204f10:	58d3      	ldr	r3, [r2, r3]
  if (!(ctl & DOEPCTL_USBAEP))
  204f12:	041a      	lsls	r2, r3, #16
  204f14:	f57f aef8 	bpl.w	204d08 <_usb_ep0setup+0x30>
  if (ctl & DIEPCTL_STALL)
  204f18:	0299      	lsls	r1, r3, #10
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
  204f1a:	bf4c      	ite	mi
  204f1c:	4b33      	ldrmi	r3, [pc, #204]	; (204fec <_usb_ep0setup+0x314>)
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
  204f1e:	4b34      	ldrpl	r3, [pc, #208]	; (204ff0 <_usb_ep0setup+0x318>)
  204f20:	e787      	b.n	204e32 <_usb_ep0setup+0x15a>
  ctl = usbp->otg->oe[ep].DOEPCTL;
  204f22:	3358      	adds	r3, #88	; 0x58
  204f24:	e7f3      	b.n	204f0e <_usb_ep0setup+0x236>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
  204f26:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
  204f2a:	2b00      	cmp	r3, #0
  204f2c:	f47f aeec 	bne.w	204d08 <_usb_ep0setup+0x30>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
  204f30:	f894 1060 	ldrb.w	r1, [r4, #96]	; 0x60
  204f34:	f011 020f 	ands.w	r2, r1, #15
  204f38:	d0a9      	beq.n	204e8e <_usb_ep0setup+0x1b6>
      if ((usbp->setup[4] & 0x80U) != 0U) {
  204f3a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
  204f3c:	b212      	sxth	r2, r2
  204f3e:	f011 0f80 	tst.w	r1, #128	; 0x80
  204f42:	eb03 1342 	add.w	r3, r3, r2, lsl #5
  204f46:	d006      	beq.n	204f56 <_usb_ep0setup+0x27e>
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
  204f48:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
  204f4c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
  204f50:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  204f54:	e79b      	b.n	204e8e <_usb_ep0setup+0x1b6>
  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
  204f56:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
  204f5a:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
  204f5e:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
  204f62:	e794      	b.n	204e8e <_usb_ep0setup+0x1b6>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
  204f64:	f894 305e 	ldrb.w	r3, [r4, #94]	; 0x5e
  204f68:	2b00      	cmp	r3, #0
  204f6a:	f47f aecd 	bne.w	204d08 <_usb_ep0setup+0x30>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
  204f6e:	f894 1060 	ldrb.w	r1, [r4, #96]	; 0x60
  204f72:	f011 020f 	ands.w	r2, r1, #15
  204f76:	d08a      	beq.n	204e8e <_usb_ep0setup+0x1b6>
      if ((usbp->setup[4] & 0x80U) != 0U) {
  204f78:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
  204f7a:	b212      	sxth	r2, r2
  204f7c:	f011 0f80 	tst.w	r1, #128	; 0x80
  204f80:	eb03 1342 	add.w	r3, r3, r2, lsl #5
  204f84:	d004      	beq.n	204f90 <_usb_ep0setup+0x2b8>
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
  204f86:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
  204f8a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  204f8e:	e7df      	b.n	204f50 <_usb_ep0setup+0x278>
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
  204f90:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
  204f94:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  204f98:	e7e1      	b.n	204f5e <_usb_ep0setup+0x286>
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
  204f9a:	2314      	movs	r3, #20
  204f9c:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
  204fa0:	f7ff f8aa 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
      usbStartReceiveI(usbp, 0, NULL, 0);
  204fa4:	462b      	mov	r3, r5
  204fa6:	462a      	mov	r2, r5
  204fa8:	4629      	mov	r1, r5
  204faa:	4620      	mov	r0, r4
  204fac:	f003 fb27 	bl	2085fe <usbStartReceiveI>
  204fb0:	f385 8811 	msr	BASEPRI, r5
  204fb4:	e6be      	b.n	204d34 <_usb_ep0setup+0x5c>
    if (usbp->ep0n != 0U) {
  204fb6:	b15d      	cbz	r5, 204fd0 <_usb_ep0setup+0x2f8>
      usbp->ep0state = USB_EP0_OUT_RX;
  204fb8:	2315      	movs	r3, #21
  204fba:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
  204fbe:	f7ff f89b 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
  204fc2:	2100      	movs	r1, #0
  204fc4:	4620      	mov	r0, r4
  204fc6:	e9d4 2314 	ldrd	r2, r3, [r4, #80]	; 0x50
  204fca:	f003 fb18 	bl	2085fe <usbStartReceiveI>
  204fce:	e6d4      	b.n	204d7a <_usb_ep0setup+0xa2>
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
  204fd0:	230b      	movs	r3, #11
  204fd2:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
  204fd6:	f7ff f88f 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
      usbStartTransmitI(usbp, 0, NULL, 0);
  204fda:	462b      	mov	r3, r5
  204fdc:	462a      	mov	r2, r5
  204fde:	4629      	mov	r1, r5
  204fe0:	4620      	mov	r0, r4
  204fe2:	f003 fafb 	bl	2085dc <usbStartTransmitI>
  204fe6:	e7e3      	b.n	204fb0 <_usb_ep0setup+0x2d8>
  204fe8:	0800ea8c 	.word	0x0800ea8c
  204fec:	0800e8a0 	.word	0x0800e8a0
  204ff0:	0800e5e4 	.word	0x0800e5e4

00204ff4 <sdc_lld_is_write_protected>:
bool sdc_lld_sync(SDCDriver *sdcp) {

  /* TODO: Implement.*/
  (void)sdcp;
  return HAL_SUCCESS;
}
  204ff4:	2000      	movs	r0, #0
  204ff6:	4770      	bx	lr

00204ff8 <_port_set_region>:
  mpuSetRegionAddress(PORT_USE_MPU_REGION,
  204ff8:	4b03      	ldr	r3, [pc, #12]	; (205008 <_port_set_region+0x10>)
  204ffa:	2207      	movs	r2, #7
  204ffc:	609a      	str	r2, [r3, #8]
  return ch.rlist.current;
  204ffe:	4a03      	ldr	r2, [pc, #12]	; (20500c <_port_set_region+0x14>)
  205000:	6992      	ldr	r2, [r2, #24]
  205002:	69d2      	ldr	r2, [r2, #28]
  205004:	60da      	str	r2, [r3, #12]
}
  205006:	4770      	bx	lr
  205008:	e000ed90 	.word	0xe000ed90
  20500c:	20000e8c 	.word	0x20000e8c

00205010 <SVC_Handler>:
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
  205010:	4a06      	ldr	r2, [pc, #24]	; (20502c <SVC_Handler+0x1c>)
  205012:	6853      	ldr	r3, [r2, #4]
  205014:	f023 0301 	bic.w	r3, r3, #1
  205018:	6053      	str	r3, [r2, #4]
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  20501a:	f3ef 8309 	mrs	r3, PSP
  ctxp++;
  20501e:	3368      	adds	r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  205020:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205024:	2300      	movs	r3, #0
  205026:	f383 8811 	msr	BASEPRI, r3
}
  20502a:	4770      	bx	lr
  20502c:	e000ef30 	.word	0xe000ef30

00205030 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
  205030:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  205032:	4606      	mov	r6, r0
  205034:	460d      	mov	r5, r1
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  205036:	6804      	ldr	r4, [r0, #0]
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
  205038:	2700      	movs	r7, #0
  while (elp != (event_listener_t *)esp) {
  20503a:	42b4      	cmp	r4, r6
  20503c:	d100      	bne.n	205040 <chEvtBroadcastFlagsI+0x10>
}
  20503e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    elp->flags |= flags;
  205040:	68e3      	ldr	r3, [r4, #12]
  205042:	432b      	orrs	r3, r5
  205044:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
  205046:	b115      	cbz	r5, 20504e <chEvtBroadcastFlagsI+0x1e>
        ((flags & elp->wflags) != (eventflags_t)0)) {
  205048:	6923      	ldr	r3, [r4, #16]
    if ((flags == (eventflags_t)0) ||
  20504a:	421d      	tst	r5, r3
  20504c:	d00b      	beq.n	205066 <chEvtBroadcastFlagsI+0x36>
  tp->epending |= events;
  20504e:	e9d4 0301 	ldrd	r0, r3, [r4, #4]
  205052:	6b42      	ldr	r2, [r0, #52]	; 0x34
  205054:	4313      	orrs	r3, r2
  if (((tp->state == CH_STATE_WTOREVT) &&
  205056:	f890 2020 	ldrb.w	r2, [r0, #32]
  20505a:	2a0a      	cmp	r2, #10
  tp->epending |= events;
  20505c:	6343      	str	r3, [r0, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
  20505e:	d104      	bne.n	20506a <chEvtBroadcastFlagsI+0x3a>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  205060:	6a42      	ldr	r2, [r0, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
  205062:	4213      	tst	r3, r2
  205064:	d107      	bne.n	205076 <chEvtBroadcastFlagsI+0x46>
    elp = elp->next;
  205066:	6824      	ldr	r4, [r4, #0]
  205068:	e7e7      	b.n	20503a <chEvtBroadcastFlagsI+0xa>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  20506a:	2a0b      	cmp	r2, #11
  20506c:	d1fb      	bne.n	205066 <chEvtBroadcastFlagsI+0x36>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
  20506e:	6a42      	ldr	r2, [r0, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
  205070:	ea32 0303 	bics.w	r3, r2, r3
  205074:	d1f7      	bne.n	205066 <chEvtBroadcastFlagsI+0x36>
    tp->u.rdymsg = MSG_OK;
  205076:	6247      	str	r7, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
  205078:	f7fc f938 	bl	2012ec <chSchReadyI>
  20507c:	e7f3      	b.n	205066 <chEvtBroadcastFlagsI+0x36>
	...

00205080 <shellExit.constprop.0>:
 *
 * @param[in] msg       shell exit code
 *
 * @api
 */
void shellExit(msg_t msg) {
  205080:	b508      	push	{r3, lr}
  205082:	f7ff f839 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
  205086:	4804      	ldr	r0, [pc, #16]	; (205098 <shellExit.constprop.0+0x18>)
  205088:	2100      	movs	r1, #0
  20508a:	f7ff ffd1 	bl	205030 <chEvtBroadcastFlagsI>

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
  chEvtBroadcastI(&shell_terminated);
  chThdExitS(msg);
  20508e:	2000      	movs	r0, #0
}
  205090:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  chThdExitS(msg);
  205094:	f7fc bc2c 	b.w	2018f0 <chThdExitS>
  205098:	2000294c 	.word	0x2000294c

0020509c <cmd_exit>:
  if (argc > 0) {
  20509c:	2900      	cmp	r1, #0
  20509e:	dd03      	ble.n	2050a8 <cmd_exit+0xc>
    shellUsage(chp, "exit");
  2050a0:	4a02      	ldr	r2, [pc, #8]	; (2050ac <cmd_exit+0x10>)
  2050a2:	4903      	ldr	r1, [pc, #12]	; (2050b0 <cmd_exit+0x14>)
  2050a4:	f7fe bcde 	b.w	203a64 <chprintf>
  shellExit(MSG_OK);
  2050a8:	f7ff bfea 	b.w	205080 <shellExit.constprop.0>
  2050ac:	0800deae 	.word	0x0800deae
  2050b0:	0800dc23 	.word	0x0800dc23

002050b4 <shellThread>:
THD_FUNCTION(shellThread, p) {
  2050b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  const ShellCommand *scp = scfg->sc_commands;
  2050b8:	e9d0 4800 	ldrd	r4, r8, [r0]
THD_FUNCTION(shellThread, p) {
  2050bc:	b099      	sub	sp, #100	; 0x64
  chprintf(chp, SHELL_NEWLINE_STR);
  2050be:	4970      	ldr	r1, [pc, #448]	; (205280 <shellThread+0x1cc>)
THD_FUNCTION(shellThread, p) {
  2050c0:	4607      	mov	r7, r0
  2050c2:	f8df b1f0 	ldr.w	fp, [pc, #496]	; 2052b4 <shellThread+0x200>
  chprintf(chp, SHELL_NEWLINE_STR);
  2050c6:	4620      	mov	r0, r4
        p--;
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, SHELL_NEWLINE_STR);
  2050c8:	f8df 91b4 	ldr.w	r9, [pc, #436]	; 205280 <shellThread+0x1cc>
  chprintf(chp, SHELL_NEWLINE_STR);
  2050cc:	f7fe fcca 	bl	203a64 <chprintf>
  chprintf(chp, "ChibiOS/RT Shell" SHELL_NEWLINE_STR);
  2050d0:	496c      	ldr	r1, [pc, #432]	; (205284 <shellThread+0x1d0>)
  2050d2:	4620      	mov	r0, r4
  2050d4:	f7fe fcc6 	bl	203a64 <chprintf>
  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
  2050d8:	f8db 3018 	ldr.w	r3, [fp, #24]
  while (!chThdShouldTerminateX()) {
  2050dc:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  2050e0:	075b      	lsls	r3, r3, #29
  2050e2:	d41e      	bmi.n	205122 <shellThread+0x6e>
  char *p = line;
  2050e4:	ad08      	add	r5, sp, #32
    chprintf(chp, SHELL_PROMPT_STR);
  2050e6:	4968      	ldr	r1, [pc, #416]	; (205288 <shellThread+0x1d4>)
  2050e8:	4620      	mov	r0, r4
  2050ea:	f7fe fcbb 	bl	203a64 <chprintf>
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
  2050ee:	46aa      	mov	sl, r5
  BaseSequentialStream *chp = scfg->sc_channel;
  2050f0:	683e      	ldr	r6, [r7, #0]
    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
  2050f2:	6833      	ldr	r3, [r6, #0]
  2050f4:	2201      	movs	r2, #1
  2050f6:	f10d 0107 	add.w	r1, sp, #7
  2050fa:	4630      	mov	r0, r6
  2050fc:	689b      	ldr	r3, [r3, #8]
  2050fe:	4798      	blx	r3
  205100:	b138      	cbz	r0, 205112 <shellThread+0x5e>
    if (c == 4) {
  205102:	f89d 1007 	ldrb.w	r1, [sp, #7]
  205106:	2904      	cmp	r1, #4
  205108:	d110      	bne.n	20512c <shellThread+0x78>
      chprintf(chp, "^D");
  20510a:	4960      	ldr	r1, [pc, #384]	; (20528c <shellThread+0x1d8>)
  20510c:	4630      	mov	r0, r6
  20510e:	f7fe fca9 	bl	203a64 <chprintf>
      chprintf(chp, SHELL_NEWLINE_STR);
  205112:	495b      	ldr	r1, [pc, #364]	; (205280 <shellThread+0x1cc>)
  205114:	4620      	mov	r0, r4
  205116:	f7fe fca5 	bl	203a64 <chprintf>
      chprintf(chp, "logout");
  20511a:	495d      	ldr	r1, [pc, #372]	; (205290 <shellThread+0x1dc>)
  20511c:	4620      	mov	r0, r4
  20511e:	f7fe fca1 	bl	203a64 <chprintf>
  shellExit(MSG_OK);
  205122:	f7ff ffad 	bl	205080 <shellExit.constprop.0>
}
  205126:	b019      	add	sp, #100	; 0x64
  205128:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if ((c == 8) || (c == 127)) {
  20512c:	2908      	cmp	r1, #8
  20512e:	d001      	beq.n	205134 <shellThread+0x80>
  205130:	297f      	cmp	r1, #127	; 0x7f
  205132:	d112      	bne.n	20515a <shellThread+0xa6>
      if (p != line) {
  205134:	4555      	cmp	r5, sl
  205136:	d0dc      	beq.n	2050f2 <shellThread+0x3e>
        streamPut(chp, 0x08);
  205138:	6833      	ldr	r3, [r6, #0]
  20513a:	2108      	movs	r1, #8
  20513c:	4630      	mov	r0, r6
        p--;
  20513e:	3d01      	subs	r5, #1
        streamPut(chp, 0x08);
  205140:	68db      	ldr	r3, [r3, #12]
  205142:	4798      	blx	r3
        streamPut(chp, 0x20);
  205144:	6833      	ldr	r3, [r6, #0]
  205146:	2120      	movs	r1, #32
  205148:	4630      	mov	r0, r6
  20514a:	68db      	ldr	r3, [r3, #12]
  20514c:	4798      	blx	r3
        streamPut(chp, 0x08);
  20514e:	6833      	ldr	r3, [r6, #0]
  205150:	2108      	movs	r1, #8
  205152:	4630      	mov	r0, r6
  205154:	68db      	ldr	r3, [r3, #12]
  205156:	4798      	blx	r3
  205158:	e7cb      	b.n	2050f2 <shellThread+0x3e>
    if (c == '\r') {
  20515a:	290d      	cmp	r1, #13
  20515c:	d127      	bne.n	2051ae <shellThread+0xfa>
      chprintf(chp, SHELL_NEWLINE_STR);
  20515e:	4649      	mov	r1, r9
  205160:	4630      	mov	r0, r6
  205162:	f7fe fc7f 	bl	203a64 <chprintf>
#if SHELL_USE_HISTORY == TRUE
      save_history(shp, line, p - line);
#endif
      *p = 0;
  205166:	2300      	movs	r3, #0
    lp = parse_arguments(line, &tokp);
  205168:	4650      	mov	r0, sl
  20516a:	a902      	add	r1, sp, #8
      *p = 0;
  20516c:	702b      	strb	r3, [r5, #0]
      args[n++] = lp;
  20516e:	f10d 0a0c 	add.w	sl, sp, #12
    lp = parse_arguments(line, &tokp);
  205172:	f7fe fc51 	bl	203a18 <parse_arguments>
  205176:	2300      	movs	r3, #0
  205178:	4606      	mov	r6, r0
  20517a:	461d      	mov	r5, r3
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
  20517c:	a902      	add	r1, sp, #8
  20517e:	2000      	movs	r0, #0
  205180:	f7fe fc4a 	bl	203a18 <parse_arguments>
  205184:	bb10      	cbnz	r0, 2051cc <shellThread+0x118>
    args[n] = NULL;
  205186:	ab18      	add	r3, sp, #96	; 0x60
  205188:	eb03 0385 	add.w	r3, r3, r5, lsl #2
  20518c:	f843 0c54 	str.w	r0, [r3, #-84]
    if (cmd != NULL) {
  205190:	2e00      	cmp	r6, #0
  205192:	d0a1      	beq.n	2050d8 <shellThread+0x24>
      if (strcmp(cmd, "help") == 0) {
  205194:	493f      	ldr	r1, [pc, #252]	; (205294 <shellThread+0x1e0>)
  205196:	4630      	mov	r0, r6
  205198:	f7fb f95a 	bl	200450 <strcmp>
  20519c:	2800      	cmp	r0, #0
  20519e:	d163      	bne.n	205268 <shellThread+0x1b4>
        if (n > 0) {
  2051a0:	b30d      	cbz	r5, 2051e6 <shellThread+0x132>
          shellUsage(chp, "help");
  2051a2:	4a3c      	ldr	r2, [pc, #240]	; (205294 <shellThread+0x1e0>)
  2051a4:	4620      	mov	r0, r4
  2051a6:	493c      	ldr	r1, [pc, #240]	; (205298 <shellThread+0x1e4>)
  2051a8:	f7fe fc5c 	bl	203a64 <chprintf>
          continue;
  2051ac:	e794      	b.n	2050d8 <shellThread+0x24>
        p = line + len;
      }
      continue;
    }
#endif
    if (c < 0x20)
  2051ae:	291f      	cmp	r1, #31
  2051b0:	d99f      	bls.n	2050f2 <shellThread+0x3e>
      continue;
    if (p < line + size - 1) {
  2051b2:	f10d 035f 	add.w	r3, sp, #95	; 0x5f
  2051b6:	429d      	cmp	r5, r3
  2051b8:	d29b      	bcs.n	2050f2 <shellThread+0x3e>
      streamPut(chp, c);
  2051ba:	6833      	ldr	r3, [r6, #0]
  2051bc:	4630      	mov	r0, r6
  2051be:	68db      	ldr	r3, [r3, #12]
  2051c0:	4798      	blx	r3
      *p++ = (char)c;
  2051c2:	f89d 3007 	ldrb.w	r3, [sp, #7]
  2051c6:	f805 3b01 	strb.w	r3, [r5], #1
  2051ca:	e792      	b.n	2050f2 <shellThread+0x3e>
      if (n >= SHELL_MAX_ARGUMENTS) {
  2051cc:	2d04      	cmp	r5, #4
  2051ce:	d106      	bne.n	2051de <shellThread+0x12a>
        chprintf(chp, "too many arguments" SHELL_NEWLINE_STR);
  2051d0:	4932      	ldr	r1, [pc, #200]	; (20529c <shellThread+0x1e8>)
  2051d2:	4620      	mov	r0, r4
  2051d4:	f7fe fc46 	bl	203a64 <chprintf>
    args[n] = NULL;
  2051d8:	2300      	movs	r3, #0
  2051da:	9307      	str	r3, [sp, #28]
    if (cmd != NULL) {
  2051dc:	e77c      	b.n	2050d8 <shellThread+0x24>
      args[n++] = lp;
  2051de:	f84a 0025 	str.w	r0, [sl, r5, lsl #2]
  2051e2:	3501      	adds	r5, #1
  2051e4:	e7ca      	b.n	20517c <shellThread+0xc8>
        chprintf(chp, "Commands: help ");
  2051e6:	4d2e      	ldr	r5, [pc, #184]	; (2052a0 <shellThread+0x1ec>)
  2051e8:	4620      	mov	r0, r4
    chprintf(chp, "%s ", scp->sc_name);
  2051ea:	4e2e      	ldr	r6, [pc, #184]	; (2052a4 <shellThread+0x1f0>)
        chprintf(chp, "Commands: help ");
  2051ec:	492e      	ldr	r1, [pc, #184]	; (2052a8 <shellThread+0x1f4>)
  2051ee:	f7fe fc39 	bl	203a64 <chprintf>
  while (scp->sc_name != NULL) {
  2051f2:	682a      	ldr	r2, [r5, #0]
  2051f4:	b972      	cbnz	r2, 205214 <shellThread+0x160>
        if (scp != NULL)
  2051f6:	f1b8 0f00 	cmp.w	r8, #0
  2051fa:	d006      	beq.n	20520a <shellThread+0x156>
  2051fc:	f108 0508 	add.w	r5, r8, #8
    chprintf(chp, "%s ", scp->sc_name);
  205200:	4e28      	ldr	r6, [pc, #160]	; (2052a4 <shellThread+0x1f0>)
  while (scp->sc_name != NULL) {
  205202:	f855 2c08 	ldr.w	r2, [r5, #-8]
  205206:	3508      	adds	r5, #8
  205208:	b952      	cbnz	r2, 205220 <shellThread+0x16c>
        chprintf(chp, SHELL_NEWLINE_STR);
  20520a:	4649      	mov	r1, r9
        chprintf(chp, " ?" SHELL_NEWLINE_STR);
  20520c:	4620      	mov	r0, r4
  20520e:	f7fe fc29 	bl	203a64 <chprintf>
  205212:	e761      	b.n	2050d8 <shellThread+0x24>
    chprintf(chp, "%s ", scp->sc_name);
  205214:	4631      	mov	r1, r6
  205216:	4620      	mov	r0, r4
    scp++;
  205218:	3508      	adds	r5, #8
    chprintf(chp, "%s ", scp->sc_name);
  20521a:	f7fe fc23 	bl	203a64 <chprintf>
    scp++;
  20521e:	e7e8      	b.n	2051f2 <shellThread+0x13e>
    chprintf(chp, "%s ", scp->sc_name);
  205220:	4631      	mov	r1, r6
  205222:	4620      	mov	r0, r4
  205224:	f7fe fc1e 	bl	203a64 <chprintf>
    scp++;
  205228:	e7eb      	b.n	205202 <shellThread+0x14e>
    if (strcmp(scp->sc_name, name) == 0) {
  20522a:	4631      	mov	r1, r6
  20522c:	f7fb f910 	bl	200450 <strcmp>
  205230:	b930      	cbnz	r0, 205240 <shellThread+0x18c>
      scp->sc_function(chp, argc, argv);
  205232:	f8da 3004 	ldr.w	r3, [sl, #4]
  205236:	aa03      	add	r2, sp, #12
  205238:	4629      	mov	r1, r5
  20523a:	4620      	mov	r0, r4
  20523c:	4798      	blx	r3
      return false;
  20523e:	e74b      	b.n	2050d8 <shellThread+0x24>
    scp++;
  205240:	f10a 0a08 	add.w	sl, sl, #8
  while (scp->sc_name != NULL) {
  205244:	f8da 0000 	ldr.w	r0, [sl]
  205248:	2800      	cmp	r0, #0
  20524a:	d1ee      	bne.n	20522a <shellThread+0x176>
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
  20524c:	f1b8 0f00 	cmp.w	r8, #0
  205250:	d003      	beq.n	20525a <shellThread+0x1a6>
  205252:	46c2      	mov	sl, r8
  while (scp->sc_name != NULL) {
  205254:	f8da 0000 	ldr.w	r0, [sl]
  205258:	b948      	cbnz	r0, 20526e <shellThread+0x1ba>
        chprintf(chp, "%s", cmd);
  20525a:	4914      	ldr	r1, [pc, #80]	; (2052ac <shellThread+0x1f8>)
  20525c:	4632      	mov	r2, r6
  20525e:	4620      	mov	r0, r4
  205260:	f7fe fc00 	bl	203a64 <chprintf>
        chprintf(chp, " ?" SHELL_NEWLINE_STR);
  205264:	4912      	ldr	r1, [pc, #72]	; (2052b0 <shellThread+0x1fc>)
  205266:	e7d1      	b.n	20520c <shellThread+0x158>
      if (strcmp(cmd, "help") == 0) {
  205268:	f8df a034 	ldr.w	sl, [pc, #52]	; 2052a0 <shellThread+0x1ec>
  20526c:	e7ea      	b.n	205244 <shellThread+0x190>
    if (strcmp(scp->sc_name, name) == 0) {
  20526e:	4631      	mov	r1, r6
  205270:	f7fb f8ee 	bl	200450 <strcmp>
  205274:	2800      	cmp	r0, #0
  205276:	d0dc      	beq.n	205232 <shellThread+0x17e>
    scp++;
  205278:	f10a 0a08 	add.w	sl, sl, #8
  20527c:	e7ea      	b.n	205254 <shellThread+0x1a0>
  20527e:	bf00      	nop
  205280:	0800de78 	.word	0x0800de78
  205284:	0800deb3 	.word	0x0800deb3
  205288:	0800dec6 	.word	0x0800dec6
  20528c:	0800dece 	.word	0x0800dece
  205290:	0800ded1 	.word	0x0800ded1
  205294:	0800deed 	.word	0x0800deed
  205298:	0800dc23 	.word	0x0800dc23
  20529c:	0800ded8 	.word	0x0800ded8
  2052a0:	0800e8fc 	.word	0x0800e8fc
  2052a4:	0800df02 	.word	0x0800df02
  2052a8:	0800def2 	.word	0x0800def2
  2052ac:	0800df06 	.word	0x0800df06
  2052b0:	0800df09 	.word	0x0800df09
  2052b4:	20000e8c 	.word	0x20000e8c

002052b8 <shellSdThreadStub>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
  2052b8:	4b02      	ldr	r3, [pc, #8]	; (2052c4 <shellSdThreadStub+0xc>)
  2052ba:	4a03      	ldr	r2, [pc, #12]	; (2052c8 <shellSdThreadStub+0x10>)
  2052bc:	699b      	ldr	r3, [r3, #24]
  2052be:	619a      	str	r2, [r3, #24]
}

THD_FUNCTION(shellSdThreadStub, p)
{
	chRegSetThreadName ("UartShell");
	shellThread (p);
  2052c0:	f7ff bef8 	b.w	2050b4 <shellThread>
  2052c4:	20000e8c 	.word	0x20000e8c
  2052c8:	0800df0e 	.word	0x0800df0e

002052cc <shellUsbThreadStub>:
  2052cc:	4b12      	ldr	r3, [pc, #72]	; (205318 <shellUsbThreadStub+0x4c>)
  2052ce:	4a13      	ldr	r2, [pc, #76]	; (20531c <shellUsbThreadStub+0x50>)
  2052d0:	699b      	ldr	r3, [r3, #24]
}

THD_FUNCTION(shellUsbThreadStub, p)
{
  2052d2:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uint8_t c;

	chRegSetThreadName ("UsbShell");

	if (SDU1.config->usbp->state != USB_ACTIVE) {
  2052d4:	4c12      	ldr	r4, [pc, #72]	; (205320 <shellUsbThreadStub+0x54>)
{
  2052d6:	4605      	mov	r5, r0
  2052d8:	619a      	str	r2, [r3, #24]
	if (SDU1.config->usbp->state != USB_ACTIVE) {
  2052da:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
  2052de:	4626      	mov	r6, r4
  2052e0:	6812      	ldr	r2, [r2, #0]
  2052e2:	7812      	ldrb	r2, [r2, #0]
  2052e4:	2a04      	cmp	r2, #4
  2052e6:	d011      	beq.n	20530c <shellUsbThreadStub+0x40>
  *trp = tp;
  2052e8:	4a0e      	ldr	r2, [pc, #56]	; (205324 <shellUsbThreadStub+0x58>)
    chSchGoSleepS(newstate);
  2052ea:	2003      	movs	r0, #3
  tp->u.wttrp = trp;
  2052ec:	625a      	str	r2, [r3, #36]	; 0x24
  *trp = tp;
  2052ee:	6013      	str	r3, [r2, #0]
  2052f0:	f7fc fa5e 	bl	2017b0 <chSchGoSleepS>
		osalThreadSuspendS (&shell_ref_usb);
		if (streamRead ((BaseSequentialStream *)&SDU1, &c, 1) == 0) {
  2052f4:	6823      	ldr	r3, [r4, #0]
  2052f6:	2201      	movs	r2, #1
  2052f8:	f10d 0107 	add.w	r1, sp, #7
  2052fc:	4620      	mov	r0, r4
  2052fe:	689b      	ldr	r3, [r3, #8]
  205300:	4798      	blx	r3
  205302:	b918      	cbnz	r0, 20530c <shellUsbThreadStub+0x40>
			shellExit (MSG_OK);
  205304:	f7ff febc 	bl	205080 <shellExit.constprop.0>
	}

	console = (BaseSequentialStream *)&SDU1;

	shellThread (p);
}
  205308:	b002      	add	sp, #8
  20530a:	bd70      	pop	{r4, r5, r6, pc}
	console = (BaseSequentialStream *)&SDU1;
  20530c:	4b06      	ldr	r3, [pc, #24]	; (205328 <shellUsbThreadStub+0x5c>)
	shellThread (p);
  20530e:	4628      	mov	r0, r5
	console = (BaseSequentialStream *)&SDU1;
  205310:	601e      	str	r6, [r3, #0]
	shellThread (p);
  205312:	f7ff fecf 	bl	2050b4 <shellThread>
  205316:	e7f7      	b.n	205308 <shellUsbThreadStub+0x3c>
  205318:	20000e8c 	.word	0x20000e8c
  20531c:	0800df18 	.word	0x0800df18
  205320:	20000948 	.word	0x20000948
  205324:	20002948 	.word	0x20002948
  205328:	200018a0 	.word	0x200018a0

0020532c <usb_event>:
static void usb_event(USBDriver *usbp, usbevent_t event) {
  20532c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  20532e:	2905      	cmp	r1, #5
  205330:	d838      	bhi.n	2053a4 <usb_event+0x78>
  205332:	e8df f001 	tbb	[pc, r1]
  205336:	3739      	.short	0x3739
  205338:	53393903 	.word	0x53393903
  ibqp->bcounter  = 0;
  20533c:	4c2d      	ldr	r4, [pc, #180]	; (2053f4 <usb_event+0xc8>)
  20533e:	2500      	movs	r5, #0
  205340:	9001      	str	r0, [sp, #4]
  205342:	f7fe fed9 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
    usbInitEndpointI(usbp, USB1_DATA_REQUEST_EP, &ep1config);
  205346:	9801      	ldr	r0, [sp, #4]
  205348:	2101      	movs	r1, #1
  20534a:	4a2b      	ldr	r2, [pc, #172]	; (2053f8 <usb_event+0xcc>)
  20534c:	f003 f968 	bl	208620 <usbInitEndpointI>
    usbInitEndpointI(usbp, USB1_INTERRUPT_REQUEST_EP, &ep2config);
  205350:	4a2a      	ldr	r2, [pc, #168]	; (2053fc <usb_event+0xd0>)
  205352:	2102      	movs	r1, #2
  205354:	9801      	ldr	r0, [sp, #4]
  205356:	f003 f963 	bl	208620 <usbInitEndpointI>
  ibqp->brdptr    = ibqp->buffers;
  20535a:	6b23      	ldr	r3, [r4, #48]	; 0x30
  chThdDequeueAllI(tqp, msg);
  20535c:	f104 000c 	add.w	r0, r4, #12
  ibqp->bcounter  = 0;
  205360:	61a5      	str	r5, [r4, #24]
  ibqp->bwrptr    = ibqp->buffers;
  205362:	e9c4 3307 	strd	r3, r3, [r4, #28]
  ibqp->top       = NULL;
  205366:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
  20536a:	f7fb ffd1 	bl	201310 <chThdDequeueAllI.constprop.0>
  obqp->bcounter  = bqSizeX(obqp);
  20536e:	6e63      	ldr	r3, [r4, #100]	; 0x64
  205370:	f104 0044 	add.w	r0, r4, #68	; 0x44
  bqResumeX(&sdup->ibqueue);
  205374:	7525      	strb	r5, [r4, #20]
  205376:	6523      	str	r3, [r4, #80]	; 0x50
  obqp->brdptr    = obqp->buffers;
  205378:	6ea3      	ldr	r3, [r4, #104]	; 0x68
  obqp->top       = NULL;
  20537a:	e9c4 551b 	strd	r5, r5, [r4, #108]	; 0x6c
  obqp->bwrptr    = obqp->buffers;
  20537e:	e9c4 3315 	strd	r3, r3, [r4, #84]	; 0x54
  205382:	f7fb ffc5 	bl	201310 <chThdDequeueAllI.constprop.0>
  chEvtBroadcastFlagsI(esp, flags);
  205386:	2101      	movs	r1, #1
  205388:	1d20      	adds	r0, r4, #4
  bqResumeX(&sdup->obqueue);
  20538a:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
  20538e:	f7ff fe4f 	bl	205030 <chEvtBroadcastFlagsI>
  (void) sdu_start_receive(sdup);
  205392:	4620      	mov	r0, r4
  205394:	f003 f9e2 	bl	20875c <sdu_start_receive.lto_priv.0>
  chThdResumeI(trp, msg);
  205398:	4629      	mov	r1, r5
  20539a:	4819      	ldr	r0, [pc, #100]	; (205400 <usb_event+0xd4>)
  20539c:	f7fb ffc7 	bl	20132e <chThdResumeI>
  2053a0:	f385 8811 	msr	BASEPRI, r5
}
  2053a4:	b003      	add	sp, #12
  2053a6:	bd30      	pop	{r4, r5, pc}
  if(bqIsSuspendedX(&sdup->ibqueue) && bqIsSuspendedX(&sdup->obqueue)) {
  2053a8:	4c12      	ldr	r4, [pc, #72]	; (2053f4 <usb_event+0xc8>)
  2053aa:	f7fe fea5 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  2053ae:	7d23      	ldrb	r3, [r4, #20]
  2053b0:	b113      	cbz	r3, 2053b8 <usb_event+0x8c>
  2053b2:	f894 304c 	ldrb.w	r3, [r4, #76]	; 0x4c
  2053b6:	b96b      	cbnz	r3, 2053d4 <usb_event+0xa8>
  chEvtBroadcastFlagsI(esp, flags);
  2053b8:	2102      	movs	r1, #2
  2053ba:	4812      	ldr	r0, [pc, #72]	; (205404 <usb_event+0xd8>)
  bqSuspendI(&sdup->ibqueue);
  2053bc:	2501      	movs	r5, #1
  2053be:	f7ff fe37 	bl	205030 <chEvtBroadcastFlagsI>
  chThdDequeueAllI(tqp, msg);
  2053c2:	4811      	ldr	r0, [pc, #68]	; (205408 <usb_event+0xdc>)
  2053c4:	7525      	strb	r5, [r4, #20]
  2053c6:	f7fb ffa3 	bl	201310 <chThdDequeueAllI.constprop.0>
  2053ca:	4810      	ldr	r0, [pc, #64]	; (20540c <usb_event+0xe0>)
  bqSuspendI(&sdup->obqueue);
  2053cc:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
  2053d0:	f7fb ff9e 	bl	201310 <chThdDequeueAllI.constprop.0>
  2053d4:	2300      	movs	r3, #0
  2053d6:	f383 8811 	msr	BASEPRI, r3
  2053da:	e7e3      	b.n	2053a4 <usb_event+0x78>
  chEvtBroadcastFlagsI(esp, flags);
  2053dc:	4c05      	ldr	r4, [pc, #20]	; (2053f4 <usb_event+0xc8>)
  2053de:	f7fe fe8b 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  2053e2:	2101      	movs	r1, #1
  2053e4:	1d20      	adds	r0, r4, #4
  2053e6:	f7ff fe23 	bl	205030 <chEvtBroadcastFlagsI>
  bqResumeX(&sdup->ibqueue);
  2053ea:	2300      	movs	r3, #0
  2053ec:	7523      	strb	r3, [r4, #20]
  bqResumeX(&sdup->obqueue);
  2053ee:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
  2053f2:	e7f0      	b.n	2053d6 <usb_event+0xaa>
  2053f4:	20000948 	.word	0x20000948
  2053f8:	0800e68c 	.word	0x0800e68c
  2053fc:	0800e6b0 	.word	0x0800e6b0
  205400:	20002948 	.word	0x20002948
  205404:	2000094c 	.word	0x2000094c
  205408:	20000954 	.word	0x20000954
  20540c:	2000098c 	.word	0x2000098c

00205410 <chThdEnqueueTimeoutS>:
  if (TIME_IMMEDIATE == timeout) {
  205410:	b149      	cbz	r1, 205426 <chThdEnqueueTimeoutS+0x16>
  queue_insert(currp, tqp);
  205412:	4b06      	ldr	r3, [pc, #24]	; (20542c <chThdEnqueueTimeoutS+0x1c>)
  tp->queue.prev             = tqp->prev;
  205414:	6842      	ldr	r2, [r0, #4]
  205416:	699b      	ldr	r3, [r3, #24]
  tp->queue.next             = (thread_t *)tqp;
  205418:	6018      	str	r0, [r3, #0]
  tp->queue.prev             = tqp->prev;
  20541a:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
  20541c:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
  20541e:	6043      	str	r3, [r0, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  205420:	2004      	movs	r0, #4
  205422:	f7fc b9e7 	b.w	2017f4 <chSchGoSleepTimeoutS>
}
  205426:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  20542a:	4770      	bx	lr
  20542c:	20000e8c 	.word	0x20000e8c

00205430 <chThdSleep>:
void chThdSleep(sysinterval_t time) {
  205430:	b508      	push	{r3, lr}
  205432:	4601      	mov	r1, r0
  205434:	f7fe fe60 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
  205438:	2008      	movs	r0, #8
  20543a:	f7fc f9db 	bl	2017f4 <chSchGoSleepTimeoutS>
  20543e:	2300      	movs	r3, #0
  205440:	f383 8811 	msr	BASEPRI, r3
}
  205444:	bd08      	pop	{r3, pc}
	...

00205448 <Thread1>:
{
  205448:	b508      	push	{r3, lr}
		palSetLine (LINE_ARD_D13);
  20544a:	2502      	movs	r5, #2
  20544c:	4b08      	ldr	r3, [pc, #32]	; (205470 <Thread1+0x28>)
  20544e:	4a09      	ldr	r2, [pc, #36]	; (205474 <Thread1+0x2c>)
  205450:	699b      	ldr	r3, [r3, #24]
  205452:	462e      	mov	r6, r5
  205454:	4c08      	ldr	r4, [pc, #32]	; (205478 <Thread1+0x30>)
  205456:	619a      	str	r2, [r3, #24]
		chThdSleepMilliseconds (500);
  205458:	f241 3088 	movw	r0, #5000	; 0x1388
		palSetLine (LINE_ARD_D13);
  20545c:	8326      	strh	r6, [r4, #24]
		chThdSleepMilliseconds (500);
  20545e:	f7ff ffe7 	bl	205430 <chThdSleep>
		chThdSleepMilliseconds (500);
  205462:	f241 3088 	movw	r0, #5000	; 0x1388
		palClearLine (LINE_ARD_D13);
  205466:	8365      	strh	r5, [r4, #26]
		chThdSleepMilliseconds (500);
  205468:	f7ff ffe2 	bl	205430 <chThdSleep>
  20546c:	e7f4      	b.n	205458 <Thread1+0x10>
  20546e:	bf00      	nop
  205470:	20000e8c 	.word	0x20000e8c
  205474:	0800df21 	.word	0x0800df21
  205478:	40022000 	.word	0x40022000

0020547c <main>:
/*
 * Application entry point.
 */
int
main (void)
{
  20547c:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  205480:	b08f      	sub	sp, #60	; 0x3c
	 *   device drivers and performs the board-specific initializations.
	 * - Kernel initialization, the main() function becomes a thread and
	 *   the RTOS is active.
	 */

	halInit();
  205482:	f003 fa7b 	bl	20897c <halInit>
	chSysInit();
  205486:	f7ff f961 	bl	20474c <chSysInit>
  __ASM volatile ("cpsid i" : : : "memory");
  20548a:	b672      	cpsid	i
	/*
	 * ChibiOS will use MPU region 0 for stack guards. We arbitrarily
	 * choose region 6 for null pointer protection.
	 */

	mpuConfigureRegion (MPU_REGION_6, 0x0, MPU_RASR_ATTR_AP_NA_NA |
  20548c:	4bb8      	ldr	r3, [pc, #736]	; (205770 <main+0x2f4>)
  20548e:	2206      	movs	r2, #6
  205490:	609a      	str	r2, [r3, #8]
  205492:	2200      	movs	r2, #0
  205494:	60da      	str	r2, [r3, #12]
  205496:	4ab7      	ldr	r2, [pc, #732]	; (205774 <main+0x2f8>)
  205498:	611a      	str	r2, [r3, #16]
  __ASM volatile ("cpsie i" : : : "memory");
  20549a:	b662      	cpsie	i
	 * Enable division by 0 traps. We don't enable unaligned access
	 * traps because there are some pieces of code in the OS that trigger
	 * unaligned accesses.
	 */
    
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk /*| SCB_CCR_UNALIGN_TRP_Msk*/;
  20549c:	f853 2c7c 	ldr.w	r2, [r3, #-124]
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  2054a0:	f5a3 6349 	sub.w	r3, r3, #3216	; 0xc90
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
  2054a4:	4fb4      	ldr	r7, [pc, #720]	; (205778 <main+0x2fc>)
  2054a6:	f042 0210 	orr.w	r2, r2, #16
  2054aa:	f8c3 2c14 	str.w	r2, [r3, #3092]	; 0xc14
	 * we don't always end up diverting through the hard fault handler.
	 * Note: the memory management fault only applies if the MPU is
	 * enabled, which it currently is (for stack guard pages).
	 */

	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk |
  2054ae:	f8d3 2c24 	ldr.w	r2, [r3, #3108]	; 0xc24
  2054b2:	f442 22e0 	orr.w	r2, r2, #458752	; 0x70000
  2054b6:	f8c3 2c24 	str.w	r2, [r3, #3108]	; 0xc24
  2054ba:	2260      	movs	r2, #96	; 0x60
  2054bc:	f883 2351 	strb.w	r2, [r3, #849]	; 0x351
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  2054c0:	f44f 3200 	mov.w	r2, #131072	; 0x20000
  2054c4:	609a      	str	r2, [r3, #8]
  2054c6:	f7fe fe17 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  2054ca:	7a3b      	ldrb	r3, [r7, #8]
  2054cc:	2b01      	cmp	r3, #1
  2054ce:	d109      	bne.n	2054e4 <main+0x68>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
      rccEnableUSART1(true);
  2054d0:	4baa      	ldr	r3, [pc, #680]	; (20577c <main+0x300>)
  2054d2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  2054d4:	f042 0210 	orr.w	r2, r2, #16
  2054d8:	645a      	str	r2, [r3, #68]	; 0x44
  2054da:	6e5a      	ldr	r2, [r3, #100]	; 0x64
  2054dc:	f042 0210 	orr.w	r2, r2, #16
  2054e0:	665a      	str	r2, [r3, #100]	; 0x64
  2054e2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    fck = (uint32_t)(sdp->clock / config->speed);
  2054e4:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
  2054e8:	e9d7 3215 	ldrd	r3, r2, [r7, #84]	; 0x54
  2054ec:	fbb2 f2f1 	udiv	r2, r2, r1
  u->BRR = fck;
  2054f0:	60da      	str	r2, [r3, #12]
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  2054f2:	2240      	movs	r2, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
  2054f4:	2101      	movs	r1, #1
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  2054f6:	605a      	str	r2, [r3, #4]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
  2054f8:	f240 122d 	movw	r2, #301	; 0x12d
  u->CR3 = config->cr3 | USART_CR3_EIE;
  2054fc:	6099      	str	r1, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
  2054fe:	601a      	str	r2, [r3, #0]
  u->ICR = 0xFFFFFFFFU;
  205500:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  205504:	621a      	str	r2, [r3, #32]

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
  205506:	2302      	movs	r3, #2
    sdp->rxmask = 0xFF;
  205508:	f887 205c 	strb.w	r2, [r7, #92]	; 0x5c
  20550c:	723b      	strb	r3, [r7, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20550e:	2300      	movs	r3, #0
  205510:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
void fsmc_init(void) {

  if (FSMCD1.state == FSMC_UNINIT) {
  205514:	4a9a      	ldr	r2, [pc, #616]	; (205780 <main+0x304>)
	 * Activates the serial driver 1 using the driver default
	 * configuration.
	 */

	sdStart (&SD1, NULL);
	console = (BaseSequentialStream *)&SD1;
  205516:	4b9b      	ldr	r3, [pc, #620]	; (205784 <main+0x308>)
  205518:	7810      	ldrb	r0, [r2, #0]
  20551a:	601f      	str	r7, [r3, #0]
  20551c:	9304      	str	r3, [sp, #16]
  20551e:	b910      	cbnz	r0, 205526 <main+0xaa>
     defined(STM32F745xx) || defined(STM32F746xx) || \
     defined(STM32F756xx) || defined(STM32F767xx) || \
     defined(STM32F769xx) || defined(STM32F777xx) || \
     defined(STM32F779xx))
  #if STM32_USE_FSMC_SDRAM
    FSMCD1.sdram = (FSMC_SDRAM_TypeDef *)FSMC_Bank5_6_R_BASE;
  205520:	4b99      	ldr	r3, [pc, #612]	; (205788 <main+0x30c>)
    FSMCD1.state  = FSMC_STOP;
  205522:	7011      	strb	r1, [r2, #0]
    FSMCD1.sdram = (FSMC_SDRAM_TypeDef *)FSMC_Bank5_6_R_BASE;
  205524:	6053      	str	r3, [r2, #4]
 */
void fsmcSdramInit(void) {

  fsmc_init();

  SDRAMD.sdram = FSMCD1.sdram;
  205526:	4c99      	ldr	r4, [pc, #612]	; (20578c <main+0x310>)
  SDRAMD.state = SDRAM_STOP;
  205528:	2301      	movs	r3, #1
  SDRAMD.sdram = FSMCD1.sdram;
  20552a:	6851      	ldr	r1, [r2, #4]
  SDRAMD.state = SDRAM_STOP;
  20552c:	7023      	strb	r3, [r4, #0]
 * @param[in] sdramp        pointer to the @p SDRAMDriver object
 * @param[in] cfgp          pointer to the @p SDRAMConfig object
 */
void fsmcSdramStart(SDRAMDriver *sdramp, const SDRAMConfig *cfgp) {

  if (FSMCD1.state == FSMC_STOP)
  20552e:	7813      	ldrb	r3, [r2, #0]
  SDRAMD.sdram = FSMCD1.sdram;
  205530:	6061      	str	r1, [r4, #4]
  if (FSMCD1.state == FSMC_STOP)
  205532:	2b01      	cmp	r3, #1
  205534:	d114      	bne.n	205560 <main+0xe4>
  if (fsmcp->state == FSMC_STOP) {
    /* Enables the peripheral.*/
#if STM32_FSMC_USE_FSMC1
    if (&FSMCD1 == fsmcp) {
#ifdef rccResetFSMC
      rccResetFSMC();
  205536:	4b91      	ldr	r3, [pc, #580]	; (20577c <main+0x300>)
  205538:	6998      	ldr	r0, [r3, #24]
  20553a:	f040 0001 	orr.w	r0, r0, #1
  20553e:	6198      	str	r0, [r3, #24]
  205540:	6998      	ldr	r0, [r3, #24]
  205542:	f020 0001 	bic.w	r0, r0, #1
  205546:	6198      	str	r0, [r3, #24]
  205548:	6998      	ldr	r0, [r3, #24]
#endif
      rccEnableFSMC(TRUE);
  20554a:	6b98      	ldr	r0, [r3, #56]	; 0x38
  20554c:	f040 0001 	orr.w	r0, r0, #1
  205550:	6398      	str	r0, [r3, #56]	; 0x38
  205552:	6d98      	ldr	r0, [r3, #88]	; 0x58
  205554:	f040 0001 	orr.w	r0, r0, #1
  205558:	6598      	str	r0, [r3, #88]	; 0x58
  20555a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
      nvicEnableVector(STM32_FSMC_NUMBER, STM32_FSMC_FSMC1_IRQ_PRIORITY);
#endif
    }
#endif /* STM32_FSMC_USE_FSMC1 */

    fsmcp->state = FSMC_READY;
  20555c:	2302      	movs	r3, #2
  20555e:	7013      	strb	r3, [r2, #0]
  if (sdramp->state == SDRAM_STOP) {

    /* Even if you need only bank2 you must properly set up SDCR and SDTR
       regitsters for bank1 too. Both banks will be tuned equally assuming
       connected memory ICs are equal.*/
    sdramp->sdram->SDCR1 = cfgp->sdcr;
  205560:	f641 1254 	movw	r2, #6484	; 0x1954
    sdramp->sdram->SDTR1 = cfgp->sdtr;
  205564:	4b8a      	ldr	r3, [pc, #552]	; (205790 <main+0x314>)
    sdramp->sdram->SDCR2 = cfgp->sdcr;
    sdramp->sdram->SDTR2 = cfgp->sdtr;

    _sdram_init_sequence(cfgp);

    sdramp->state = SDRAM_READY;
  205566:	2502      	movs	r5, #2
  osalDbgCheck((gptp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
              "invalid state");
  gptp->config = config;
  205568:	4e8a      	ldr	r6, [pc, #552]	; (205794 <main+0x318>)
    sdramp->sdram->SDCR1 = cfgp->sdcr;
  20556a:	600a      	str	r2, [r1, #0]
    sdramp->sdram->SDTR1 = cfgp->sdtr;
  20556c:	608b      	str	r3, [r1, #8]
    sdramp->sdram->SDCR2 = cfgp->sdcr;
  20556e:	604a      	str	r2, [r1, #4]
    sdramp->sdram->SDTR2 = cfgp->sdtr;
  205570:	60cb      	str	r3, [r1, #12]
  _sdram_wait_ready();
  205572:	f7fb ff5b 	bl	20142c <_sdram_wait_ready>
  SDRAMD.sdram->SDCMR = FMCCM_CLK_ENABLED | command_target;
  205576:	6863      	ldr	r3, [r4, #4]
  205578:	2211      	movs	r2, #17
  chThdSleep(delay);
  20557a:	200a      	movs	r0, #10
  20557c:	611a      	str	r2, [r3, #16]
  20557e:	f7ff ff57 	bl	205430 <chThdSleep>
  _sdram_wait_ready();
  205582:	f7fb ff53 	bl	20142c <_sdram_wait_ready>
  SDRAMD.sdram->SDCMR = FMCCM_PALL | command_target;
  205586:	2212      	movs	r2, #18
  205588:	6863      	ldr	r3, [r4, #4]
  20558a:	611a      	str	r2, [r3, #16]
  _sdram_wait_ready();
  20558c:	f7fb ff4e 	bl	20142c <_sdram_wait_ready>
  SDRAMD.sdram->SDCMR = FMCCM_AUTO_REFRESH | command_target |
  205590:	21f3      	movs	r1, #243	; 0xf3
  205592:	6863      	ldr	r3, [r4, #4]
  205594:	6119      	str	r1, [r3, #16]
  _sdram_wait_ready();
  205596:	f7fb ff49 	bl	20142c <_sdram_wait_ready>
  SDRAMD.sdram->SDCMR = FMCCM_AUTO_REFRESH | command_target |
  20559a:	6863      	ldr	r3, [r4, #4]
  20559c:	6119      	str	r1, [r3, #16]
  _sdram_wait_ready();
  20559e:	f7fb ff45 	bl	20142c <_sdram_wait_ready>
  SDRAMD.sdram->SDCMR = FMCCM_LOAD_MODE | command_target |
  2055a2:	6863      	ldr	r3, [r4, #4]
  2055a4:	4a7c      	ldr	r2, [pc, #496]	; (205798 <main+0x31c>)
  2055a6:	611a      	str	r2, [r3, #16]
  _sdram_wait_ready();
  2055a8:	f7fb ff40 	bl	20142c <_sdram_wait_ready>
  SDRAMD.sdram->SDRTR = cfgp->sdrtr & FMC_SDRTR_COUNT;
  2055ac:	6863      	ldr	r3, [r4, #4]
  2055ae:	f640 4206 	movw	r2, #3078	; 0xc06
  2055b2:	615a      	str	r2, [r3, #20]
  _sdram_wait_ready();
  2055b4:	f7fb ff3a 	bl	20142c <_sdram_wait_ready>
  tqp->next = (thread_t *)tqp;
  2055b8:	4b78      	ldr	r3, [pc, #480]	; (20579c <main+0x320>)
  mp->owner = NULL;
  2055ba:	2200      	movs	r2, #0

	newlibStart ();

	/* Safe to use printf() from here on. */

	printf ("\n\nUntitled Ides of DEF CON 28 Badge Game\n\n");
  2055bc:	4878      	ldr	r0, [pc, #480]	; (2057a0 <main+0x324>)
    sdramp->state = SDRAM_READY;
  2055be:	7025      	strb	r5, [r4, #0]
  2055c0:	609a      	str	r2, [r3, #8]
  tqp->prev = (thread_t *)tqp;
  2055c2:	e9c3 3300 	strd	r3, r3, [r3]
  2055c6:	f008 f8ff 	bl	20d7c8 <puts>

	/*
	 * ARD_D13 is programmed as output (board LED).
	 */

	palClearLine (LINE_ARD_D13);
  2055ca:	4876      	ldr	r0, [pc, #472]	; (2057a4 <main+0x328>)
	palSetLineMode (LINE_ARD_D13, PAL_MODE_OUTPUT_PUSHPULL);
  2055cc:	2201      	movs	r2, #1
  2055ce:	4629      	mov	r1, r5
	palClearLine (LINE_ARD_D13);
  2055d0:	8345      	strh	r5, [r0, #26]
	palSetLineMode (LINE_ARD_D13, PAL_MODE_OUTPUT_PUSHPULL);
  2055d2:	f7fb fff2 	bl	2015ba <_pal_lld_setgroupmode>
  2055d6:	f7fe fd8f 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  2055da:	4b73      	ldr	r3, [pc, #460]	; (2057a8 <main+0x32c>)
  2055dc:	6073      	str	r3, [r6, #4]
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
  2055de:	7833      	ldrb	r3, [r6, #0]
  2055e0:	2b01      	cmp	r3, #1
  2055e2:	d11d      	bne.n	205620 <main+0x1a4>
    }
#endif

#if STM32_GPT_USE_TIM5
    if (&GPTD5 == gptp) {
      rccEnableTIM5(true);
  2055e4:	4b65      	ldr	r3, [pc, #404]	; (20577c <main+0x300>)
  2055e6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  2055e8:	f042 0208 	orr.w	r2, r2, #8
  2055ec:	641a      	str	r2, [r3, #64]	; 0x40
  2055ee:	6e1a      	ldr	r2, [r3, #96]	; 0x60
  2055f0:	f042 0208 	orr.w	r2, r2, #8
  2055f4:	661a      	str	r2, [r3, #96]	; 0x60
  2055f6:	6e1a      	ldr	r2, [r3, #96]	; 0x60
      rccResetTIM5();
  2055f8:	6a1a      	ldr	r2, [r3, #32]
  2055fa:	f042 0208 	orr.w	r2, r2, #8
  2055fe:	621a      	str	r2, [r3, #32]
  205600:	6a1a      	ldr	r2, [r3, #32]
  205602:	f022 0208 	bic.w	r2, r2, #8
  205606:	621a      	str	r2, [r3, #32]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  205608:	2270      	movs	r2, #112	; 0x70
  20560a:	6a1b      	ldr	r3, [r3, #32]
  20560c:	4b67      	ldr	r3, [pc, #412]	; (2057ac <main+0x330>)
  20560e:	f883 2332 	strb.w	r2, [r3, #818]	; 0x332
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  205612:	f44f 2280 	mov.w	r2, #262144	; 0x40000
  205616:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20561a:	605a      	str	r2, [r3, #4]
      nvicEnableVector(STM32_TIM5_NUMBER, STM32_GPT_TIM5_IRQ_PRIORITY);
#endif
#if defined(STM32_TIM5CLK)
      gptp->clock = STM32_TIM5CLK;
#else
      gptp->clock = STM32_TIMCLK1;
  20561c:	4b64      	ldr	r3, [pc, #400]	; (2057b0 <main+0x334>)
  20561e:	60b3      	str	r3, [r6, #8]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
  205620:	68b3      	ldr	r3, [r6, #8]
  gpt_lld_start(gptp);
  gptp->state = GPT_READY;
  205622:	2402      	movs	r4, #2
  205624:	4a63      	ldr	r2, [pc, #396]	; (2057b4 <main+0x338>)
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
  205626:	68f1      	ldr	r1, [r6, #12]
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
  205628:	fbb3 f3f2 	udiv	r3, r3, r2
  20562c:	3b01      	subs	r3, #1
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
  20562e:	2200      	movs	r2, #0
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
  205630:	b29b      	uxth	r3, r3
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
  205632:	600a      	str	r2, [r1, #0]
  gptp->tim->CR2  = gptp->config->cr2;
  205634:	604a      	str	r2, [r1, #4]
  205636:	7034      	strb	r4, [r6, #0]
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
  205638:	628b      	str	r3, [r1, #40]	; 0x28
  gptp->tim->SR   = 0;                          /* Clear pending IRQs.      */
  20563a:	610a      	str	r2, [r1, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
  20563c:	60ca      	str	r2, [r1, #12]
  20563e:	f382 8811 	msr	BASEPRI, r2

	/* Enable timer */

	gptStart (&GPTD5, &gptcfg);

	printf ("Timer TMI5 enabled\n");
  205642:	485d      	ldr	r0, [pc, #372]	; (2057b8 <main+0x33c>)
  205644:	f008 f8c0 	bl	20d7c8 <puts>

	/* Enable SPI */

	palSetPadMode (GPIOI, GPIOI_ARD_D13,
  205648:	4621      	mov	r1, r4
  20564a:	f240 229a 	movw	r2, #666	; 0x29a
  20564e:	4855      	ldr	r0, [pc, #340]	; (2057a4 <main+0x328>)
  205650:	f7fb ffb3 	bl	2015ba <_pal_lld_setgroupmode>
	    PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);
	palSetPadMode (GPIOB, GPIOB_ARD_D12,
  205654:	f240 229a 	movw	r2, #666	; 0x29a
  205658:	f44f 4180 	mov.w	r1, #16384	; 0x4000
  20565c:	4857      	ldr	r0, [pc, #348]	; (2057bc <main+0x340>)
  20565e:	f7fb ffac 	bl	2015ba <_pal_lld_setgroupmode>
	    PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);
	palSetPadMode (GPIOB, GPIOB_ARD_D11,
  205662:	f240 229a 	movw	r2, #666	; 0x29a
  205666:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  20566a:	4854      	ldr	r0, [pc, #336]	; (2057bc <main+0x340>)
  20566c:	f7fb ffa5 	bl	2015ba <_pal_lld_setgroupmode>
	    PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);

	palSetLineMode (LINE_ARD_D11, PAL_MODE_OUTPUT_PUSHPULL);
  205670:	2201      	movs	r2, #1
  205672:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  205676:	4851      	ldr	r0, [pc, #324]	; (2057bc <main+0x340>)
  205678:	f7fb ff9f 	bl	2015ba <_pal_lld_setgroupmode>
	palSetLineMode (LINE_ARD_D12, PAL_MODE_OUTPUT_PUSHPULL);
  20567c:	2201      	movs	r2, #1
  20567e:	f44f 4180 	mov.w	r1, #16384	; 0x4000
  205682:	484e      	ldr	r0, [pc, #312]	; (2057bc <main+0x340>)
  205684:	f7fb ff99 	bl	2015ba <_pal_lld_setgroupmode>
	palSetLineMode (LINE_ARD_D13, PAL_MODE_OUTPUT_PUSHPULL);
  205688:	4621      	mov	r1, r4
  20568a:	2201      	movs	r2, #1
  20568c:	4845      	ldr	r0, [pc, #276]	; (2057a4 <main+0x328>)
  20568e:	f7fb ff94 	bl	2015ba <_pal_lld_setgroupmode>
  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
  205692:	4c4b      	ldr	r4, [pc, #300]	; (2057c0 <main+0x344>)
  205694:	f7fe fd30 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  205698:	4b4a      	ldr	r3, [pc, #296]	; (2057c4 <main+0x348>)
  20569a:	6063      	str	r3, [r4, #4]
 */
void spi_lld_start(SPIDriver *spip) {
  uint32_t ds;

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
  20569c:	7823      	ldrb	r3, [r4, #0]
  20569e:	2b01      	cmp	r3, #1
  2056a0:	f000 828e 	beq.w	205bc0 <main+0x744>
  /* Configuration-specific DMA setup.*/
  ds = spip->config->cr2 & SPI_CR2_DS;
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  2056a4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  2056a6:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
  2056aa:	62a3      	str	r3, [r4, #40]	; 0x28
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  2056ac:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  2056ae:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }

  if (spip->config->circular) {
  2056b2:	6861      	ldr	r1, [r4, #4]
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
  2056b4:	62e3      	str	r3, [r4, #44]	; 0x2c
  if (spip->config->circular) {
  2056b6:	7808      	ldrb	r0, [r1, #0]
  2056b8:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	; 0x28
  2056bc:	2800      	cmp	r0, #0
  2056be:	f000 82b2 	beq.w	205c26 <main+0x7aa>
    spip->rxdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
  2056c2:	f442 7284 	orr.w	r2, r2, #264	; 0x108
    spip->txdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
  2056c6:	f443 7384 	orr.w	r3, r3, #264	; 0x108
    spip->rxdmamode |= (STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
  2056ca:	62a2      	str	r2, [r4, #40]	; 0x28
  }
  else {
    spip->rxdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
    spip->txdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
  2056cc:	62e3      	str	r3, [r4, #44]	; 0x2c
  spi_lld_start(spip);
  spip->state = SPI_READY;
  2056ce:	f04f 0902 	mov.w	r9, #2
  }

  /* SPI setup and enable.*/
  spip->spi->CR1 &= ~SPI_CR1_SPE;
  2056d2:	69e3      	ldr	r3, [r4, #28]
  2056d4:	2500      	movs	r5, #0
  2056d6:	681a      	ldr	r2, [r3, #0]
  2056d8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  2056dc:	601a      	str	r2, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR;
  2056de:	8a0a      	ldrh	r2, [r1, #16]
  2056e0:	f042 0204 	orr.w	r2, r2, #4
  2056e4:	601a      	str	r2, [r3, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_FRXTH | SPI_CR2_SSOE |
                    SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
  2056e6:	8a4a      	ldrh	r2, [r1, #18]
  2056e8:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
  2056ec:	f042 0207 	orr.w	r2, r2, #7
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_FRXTH | SPI_CR2_SSOE |
  2056f0:	605a      	str	r2, [r3, #4]
  spip->spi->CR1 |= SPI_CR1_SPE;
  2056f2:	681a      	ldr	r2, [r3, #0]
  2056f4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
  2056f8:	601a      	str	r2, [r3, #0]
  2056fa:	f884 9000 	strb.w	r9, [r4]
  2056fe:	f385 8811 	msr	BASEPRI, r5

	spiStart(&SPID2, &hs_spicfg);

	printf ("SPI bus 2 enabled\n");
  205702:	4831      	ldr	r0, [pc, #196]	; (2057c8 <main+0x34c>)
  205704:	f008 f860 	bl	20d7c8 <puts>

	/* Enable I2C instance 1 (arduino pins) */

	palSetPadMode (GPIOB, GPIOB_ARD_D14, PAL_MODE_ALTERNATE(4));
  205708:	f240 2202 	movw	r2, #514	; 0x202
  20570c:	f44f 7100 	mov.w	r1, #512	; 0x200
  205710:	482a      	ldr	r0, [pc, #168]	; (2057bc <main+0x340>)
  205712:	f7fb ff52 	bl	2015ba <_pal_lld_setgroupmode>
	palSetPadMode (GPIOB, GPIOB_ARD_D15, PAL_MODE_ALTERNATE(4));
  205716:	f240 2202 	movw	r2, #514	; 0x202
  20571a:	f44f 7180 	mov.w	r1, #256	; 0x100
  20571e:	4827      	ldr	r0, [pc, #156]	; (2057bc <main+0x340>)
  205720:	f7fb ff4b 	bl	2015ba <_pal_lld_setgroupmode>
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
  205724:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 2057e4 <main+0x368>
  205728:	f7fe fce6 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  20572c:	4827      	ldr	r0, [pc, #156]	; (2057cc <main+0x350>)
  20572e:	f8c0 a004 	str.w	sl, [r0, #4]
  i2c_lld_start(i2cp);
  205732:	f7fb fea9 	bl	201488 <i2c_lld_start>
  i2cp->state = I2C_READY;
  205736:	f880 9000 	strb.w	r9, [r0]
  20573a:	f385 8811 	msr	BASEPRI, r5
  i2cp->config = config;
  20573e:	4c24      	ldr	r4, [pc, #144]	; (2057d0 <main+0x354>)

	i2cStart (&I2CD1, &i2cconfig);

	printf ("I2C bus 1 enabled\n");
  205740:	4824      	ldr	r0, [pc, #144]	; (2057d4 <main+0x358>)
  205742:	f008 f841 	bl	20d7c8 <puts>
  205746:	f7fe fcd7 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  i2c_lld_start(i2cp);
  20574a:	4620      	mov	r0, r4
  i2cp->config = config;
  20574c:	f8c4 a004 	str.w	sl, [r4, #4]
  i2c_lld_start(i2cp);
  205750:	f7fb fe9a 	bl	201488 <i2c_lld_start>
  i2cp->state = I2C_READY;
  205754:	f884 9000 	strb.w	r9, [r4]
  205758:	f385 8811 	msr	BASEPRI, r5
	 * Note: GPIO pins are already configured in board.c/board.h
	 */

	i2cStart (&I2CD3, &i2cconfig);

	printf ("I2C bus 3 enabled\n");
  20575c:	481e      	ldr	r0, [pc, #120]	; (2057d8 <main+0x35c>)
  20575e:	46a1      	mov	r9, r4
  205760:	f008 f832 	bl	20d7c8 <puts>
  205764:	f7fe fcc8 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
 */
void trng_lld_start(TRNGDriver *trngp) {

  /* There is no real configuration but setting up a valid pointer anyway.*/
  if (trngp->config == NULL) {
    trngp->config = &default_cfg;
  205768:	491c      	ldr	r1, [pc, #112]	; (2057dc <main+0x360>)
  20576a:	4a1d      	ldr	r2, [pc, #116]	; (2057e0 <main+0x364>)
  20576c:	604a      	str	r2, [r1, #4]
  20576e:	e03b      	b.n	2057e8 <main+0x36c>
  205770:	e000ed90 	.word	0xe000ed90
  205774:	00080013 	.word	0x00080013
  205778:	2000088c 	.word	0x2000088c
  20577c:	40023800 	.word	0x40023800
  205780:	20000800 	.word	0x20000800
  205784:	200018a0 	.word	0x200018a0
  205788:	a0000140 	.word	0xa0000140
  20578c:	20000940 	.word	0x20000940
  205790:	01116361 	.word	0x01116361
  205794:	20000814 	.word	0x20000814
  205798:	00044014 	.word	0x00044014
  20579c:	20002724 	.word	0x20002724
  2057a0:	0800df2c 	.word	0x0800df2c
  2057a4:	40022000 	.word	0x40022000
  2057a8:	0800e890 	.word	0x0800e890
  2057ac:	e000e100 	.word	0xe000e100
  2057b0:	066ff300 	.word	0x066ff300
  2057b4:	003d0900 	.word	0x003d0900
  2057b8:	0800df56 	.word	0x0800df56
  2057bc:	40020400 	.word	0x40020400
  2057c0:	20000dd8 	.word	0x20000dd8
  2057c4:	0800e8a4 	.word	0x0800e8a4
  2057c8:	0800df69 	.word	0x0800df69
  2057cc:	20000824 	.word	0x20000824
  2057d0:	20000858 	.word	0x20000858
  2057d4:	0800df7b 	.word	0x0800df7b
  2057d8:	0800df8d 	.word	0x0800df8d
  2057dc:	20000e08 	.word	0x20000e08
  2057e0:	0800e5fc 	.word	0x0800e5fc
  2057e4:	0800e8b8 	.word	0x0800e8b8
  }

  if (trngp->state == TRNG_STOP) {
  2057e8:	780a      	ldrb	r2, [r1, #0]
  2057ea:	2a01      	cmp	r2, #1
  2057ec:	d109      	bne.n	205802 <main+0x386>
    /* Enables the peripheral.*/
#if STM32_TRNG_USE_RNG1 == TRUE
    if (&TRNGD1 == trngp) {
      rccEnableRNG(false);
  2057ee:	4bb6      	ldr	r3, [pc, #728]	; (205ac8 <main+0x64c>)
  2057f0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  2057f2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
  2057f6:	635a      	str	r2, [r3, #52]	; 0x34
  2057f8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  2057fa:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  2057fe:	655a      	str	r2, [r3, #84]	; 0x54
  205800:	6d5b      	ldr	r3, [r3, #84]	; 0x54
    }
#endif
  }
  /* Configures the peripheral.*/
  trngp->rng->CR |= RNG_CR_RNGEN;
  205802:	688a      	ldr	r2, [r1, #8]
  osalSysLock();
  osalDbgAssert((trngp->state == TRNG_STOP) || (trngp->state == TRNG_READY),
              "invalid state");
  trngp->config = config;
  trng_lld_start(trngp);
  trngp->state = TRNG_READY;
  205804:	2502      	movs	r5, #2
  205806:	f04f 0a00 	mov.w	sl, #0
  20580a:	6813      	ldr	r3, [r2, #0]
  20580c:	f043 0304 	orr.w	r3, r3, #4
  205810:	6013      	str	r3, [r2, #0]
  205812:	700d      	strb	r5, [r1, #0]
  205814:	f38a 8811 	msr	BASEPRI, sl

	/* Enable random number generator */

	trngStart (&TRNGD1, NULL);

	printf ("Random number generator enabled\n");
  205818:	48ac      	ldr	r0, [pc, #688]	; (205acc <main+0x650>)
  ibqp->bsize     = size + sizeof (size_t);
  20581a:	f44f 7482 	mov.w	r4, #260	; 0x104
  20581e:	f007 ffd3 	bl	20d7c8 <puts>
  sdup->vmt = &vmt;
  205822:	4aab      	ldr	r2, [pc, #684]	; (205ad0 <main+0x654>)
  205824:	49ab      	ldr	r1, [pc, #684]	; (205ad4 <main+0x658>)
  205826:	4613      	mov	r3, r2
  ibqp->brdptr    = bp;
  205828:	f102 007c 	add.w	r0, r2, #124	; 0x7c
  ibqp->bcounter  = 0;
  20582c:	f8c2 a018 	str.w	sl, [r2, #24]
  205830:	f843 1b04 	str.w	r1, [r3], #4
  sdup->state = SDU_STOP;
  205834:	2101      	movs	r1, #1
  esp->next = (event_listener_t *)esp;
  205836:	6053      	str	r3, [r2, #4]
  tqp->next = (thread_t *)tqp;
  205838:	f102 030c 	add.w	r3, r2, #12
  20583c:	7211      	strb	r1, [r2, #8]
  ibqp->suspended = suspended;
  20583e:	7511      	strb	r1, [r2, #20]
  obqp->suspended = suspended;
  205840:	f882 104c 	strb.w	r1, [r2, #76]	; 0x4c
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
  205844:	f202 418c 	addw	r1, r2, #1164	; 0x48c
  ibqp->top       = NULL;
  205848:	f8c2 a038 	str.w	sl, [r2, #56]	; 0x38
  obqp->bcounter  = n;
  20584c:	6515      	str	r5, [r2, #80]	; 0x50
  tqp->prev = (thread_t *)tqp;
  20584e:	e9c2 3303 	strd	r3, r3, [r2, #12]
  ibqp->bwrptr    = bp;
  205852:	e9c2 0007 	strd	r0, r0, [r2, #28]
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  205856:	f502 7321 	add.w	r3, r2, #644	; 0x284
  ibqp->ptr       = NULL;
  20585a:	e9c2 0a0c 	strd	r0, sl, [r2, #48]	; 0x30
  ibqp->notify    = infy;
  20585e:	489e      	ldr	r0, [pc, #632]	; (205ad8 <main+0x65c>)
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  205860:	6253      	str	r3, [r2, #36]	; 0x24
  ibqp->link      = link;
  205862:	e9c2 020f 	strd	r0, r2, [r2, #60]	; 0x3c
  obqp->bwrptr    = bp;
  205866:	e9c2 3315 	strd	r3, r3, [r2, #84]	; 0x54
  tqp->next = (thread_t *)tqp;
  20586a:	f102 0044 	add.w	r0, r2, #68	; 0x44
  obqp->buffers   = bp;
  20586e:	e9c2 5319 	strd	r5, r3, [r2, #100]	; 0x64
  obqp->notify    = onfy;
  205872:	4b9a      	ldr	r3, [pc, #616]	; (205adc <main+0x660>)
  ibqp->bn        = n;
  205874:	e9c2 450a 	strd	r4, r5, [r2, #40]	; 0x28
  obqp->bsize     = size + sizeof (size_t);
  205878:	e9c2 1417 	strd	r1, r4, [r2, #92]	; 0x5c
  obqp->link      = link;
  20587c:	e9c2 321d 	strd	r3, r2, [r2, #116]	; 0x74
  tqp->prev = (thread_t *)tqp;
  205880:	e9c2 0011 	strd	r0, r0, [r2, #68]	; 0x44
  obqp->top       = NULL;
  205884:	e9c2 aa1b 	strd	sl, sl, [r2, #108]	; 0x6c
  205888:	f7fe fc36 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  usbp->in_params[config->bulk_in - 1U]   = sdup;
  20588c:	4c94      	ldr	r4, [pc, #592]	; (205ae0 <main+0x664>)
  sdup->config = config;
  20588e:	4b95      	ldr	r3, [pc, #596]	; (205ae4 <main+0x668>)
  usbp->in_params[config->bulk_in - 1U]   = sdup;
  205890:	6262      	str	r2, [r4, #36]	; 0x24
  usbp->out_params[config->bulk_out - 1U] = sdup;
  205892:	63a2      	str	r2, [r4, #56]	; 0x38
    usbp->in_params[config->int_in - 1U]  = sdup;
  205894:	62a2      	str	r2, [r4, #40]	; 0x28
  sdup->config = config;
  205896:	f8c2 348c 	str.w	r3, [r2, #1164]	; 0x48c
  sdup->state = SDU_READY;
  20589a:	7215      	strb	r5, [r2, #8]
  20589c:	f38a 8811 	msr	BASEPRI, sl
	 */

	sduObjectInit (&PORTAB_SDU1);
	sduStart (&PORTAB_SDU1, &serusbcfg);

	printf ("USB CDC enabled\n");
  2058a0:	4891      	ldr	r0, [pc, #580]	; (205ae8 <main+0x66c>)
  2058a2:	f007 ff91 	bl	20d7c8 <puts>

	/*
	 * Activates the USB driver and then the USB bus pull-up on D+.
	 */

	usbDisconnectBus (serusbcfg.usbp);
  2058a6:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  2058a8:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
  2058ac:	432b      	orrs	r3, r5
  2058ae:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
  2058b2:	f7fe fc21 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  usbp->config = config;
  2058b6:	4b8d      	ldr	r3, [pc, #564]	; (205aec <main+0x670>)
  2058b8:	6063      	str	r3, [r4, #4]
  if (usbp->state == USB_STOP) {
  2058ba:	7823      	ldrb	r3, [r4, #0]
  2058bc:	2b01      	cmp	r3, #1
    usbp->epc[i] = NULL;
  2058be:	e9c4 aa03 	strd	sl, sl, [r4, #12]
  2058c2:	e9c4 aa05 	strd	sl, sl, [r4, #20]
  2058c6:	e9c4 aa07 	strd	sl, sl, [r4, #28]
  2058ca:	d153      	bne.n	205974 <main+0x4f8>
      rccEnableOTG_FS(true);
  2058cc:	4b7e      	ldr	r3, [pc, #504]	; (205ac8 <main+0x64c>)
  stm32_otg_t *otgp = usbp->otg;
  2058ce:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
      rccEnableOTG_FS(true);
  2058d0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  2058d2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  2058d6:	635a      	str	r2, [r3, #52]	; 0x34
  2058d8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  2058da:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  2058de:	655a      	str	r2, [r3, #84]	; 0x54
  2058e0:	6d5a      	ldr	r2, [r3, #84]	; 0x54
      rccResetOTG_FS();
  2058e2:	695a      	ldr	r2, [r3, #20]
  2058e4:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  2058e8:	615a      	str	r2, [r3, #20]
  2058ea:	695a      	ldr	r2, [r3, #20]
  2058ec:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  2058f0:	615a      	str	r2, [r3, #20]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2058f2:	22e0      	movs	r2, #224	; 0xe0
  2058f4:	695b      	ldr	r3, [r3, #20]
  2058f6:	4b7e      	ldr	r3, [pc, #504]	; (205af0 <main+0x674>)
  2058f8:	f883 2343 	strb.w	r2, [r3, #835]	; 0x343
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2058fc:	2208      	movs	r2, #8
  2058fe:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  205902:	609a      	str	r2, [r3, #8]
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
  205904:	4b7b      	ldr	r3, [pc, #492]	; (205af4 <main+0x678>)
  205906:	60eb      	str	r3, [r5, #12]
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
  205908:	4b7b      	ldr	r3, [pc, #492]	; (205af8 <main+0x67c>)
  20590a:	f8c5 3800 	str.w	r3, [r5, #2048]	; 0x800
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
  20590e:	23c0      	movs	r3, #192	; 0xc0
    otgp->PCGCCTL = 0;
  205910:	f8c5 ae00 	str.w	sl, [r5, #3584]	; 0xe00
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
  205914:	602b      	str	r3, [r5, #0]
      otgp->GCCFG = GCCFG_INIT_VALUE;
  205916:	f44f 1304 	mov.w	r3, #2162688	; 0x210000
  20591a:	63ab      	str	r3, [r5, #56]	; 0x38
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
  20591c:	692b      	ldr	r3, [r5, #16]
  20591e:	2b00      	cmp	r3, #0
  205920:	dafc      	bge.n	20591c <main+0x4a0>
  otgp->GRSTCTL = GRSTCTL_CSRST;
  205922:	2301      	movs	r3, #1
  chSysPolledDelayX(cycles);
  205924:	200c      	movs	r0, #12
  205926:	612b      	str	r3, [r5, #16]
  205928:	f7fb fd54 	bl	2013d4 <chSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
  20592c:	692b      	ldr	r3, [r5, #16]
  20592e:	07d9      	lsls	r1, r3, #31
  205930:	d4fc      	bmi.n	20592c <main+0x4b0>
  205932:	2012      	movs	r0, #18
  205934:	f7fb fd4e 	bl	2013d4 <chSysPolledDelayX>
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
  205938:	692b      	ldr	r3, [r5, #16]
  20593a:	2b00      	cmp	r3, #0
  20593c:	dafc      	bge.n	205938 <main+0x4bc>
    otgp->GAHBCFG = 0;
  20593e:	f04f 0a00 	mov.w	sl, #0
    otg_disable_ep(usbp);
  205942:	4867      	ldr	r0, [pc, #412]	; (205ae0 <main+0x664>)
    otgp->GAHBCFG = 0;
  205944:	f8c5 a008 	str.w	sl, [r5, #8]
    otg_disable_ep(usbp);
  205948:	f7fb fd80 	bl	20144c <otg_disable_ep>
    if (usbp->config->sof_cb == NULL)
  20594c:	6863      	ldr	r3, [r4, #4]
    otgp->DIEPMSK  = 0;
  20594e:	f8c5 a810 	str.w	sl, [r5, #2064]	; 0x810
    if (usbp->config->sof_cb == NULL)
  205952:	68db      	ldr	r3, [r3, #12]
    otgp->DOEPMSK  = 0;
  205954:	f8c5 a814 	str.w	sl, [r5, #2068]	; 0x814
    otgp->DAINTMSK = 0;
  205958:	f8c5 a81c 	str.w	sl, [r5, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
  20595c:	2b00      	cmp	r3, #0
  20595e:	f040 8168 	bne.w	205c32 <main+0x7b6>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
  205962:	4b66      	ldr	r3, [pc, #408]	; (205afc <main+0x680>)
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
  205964:	61ab      	str	r3, [r5, #24]
    otgp->GINTSTS  = 0xFFFFFFFF;
  205966:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  20596a:	616b      	str	r3, [r5, #20]
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
  20596c:	68ab      	ldr	r3, [r5, #8]
  20596e:	f043 0301 	orr.w	r3, r3, #1
  205972:	60ab      	str	r3, [r5, #8]
  usbp->state = USB_READY;
  205974:	2302      	movs	r3, #2
  205976:	2500      	movs	r5, #0
  205978:	7023      	strb	r3, [r4, #0]
  20597a:	f385 8811 	msr	BASEPRI, r5
	usbStart (serusbcfg.usbp, &usbcfg);
	usbConnectBus (serusbcfg.usbp);
  20597e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c

	printf ("USB controller enabled\n");
  205980:	485f      	ldr	r0, [pc, #380]	; (205b00 <main+0x684>)
	usbConnectBus (serusbcfg.usbp);
  205982:	f8d3 2804 	ldr.w	r2, [r3, #2052]	; 0x804
  osalDbgCheck(sdcp != NULL);

  osalSysLock();
  osalDbgAssert((sdcp->state == BLK_STOP) || (sdcp->state == BLK_ACTIVE),
                "invalid state");
  sdcp->config = config;
  205986:	4c5f      	ldr	r4, [pc, #380]	; (205b04 <main+0x688>)
  205988:	f022 0202 	bic.w	r2, r2, #2
  20598c:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
	printf ("USB controller enabled\n");
  205990:	f007 ff1a 	bl	20d7c8 <puts>
  205994:	f7fe fbb0 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  205998:	4b5b      	ldr	r3, [pc, #364]	; (205b08 <main+0x68c>)
  20599a:	62e3      	str	r3, [r4, #44]	; 0x2c
  sdcp->dmamode |= STM32_DMA_CR_PFCTRL |
  20599c:	4b5b      	ldr	r3, [pc, #364]	; (205b0c <main+0x690>)
  20599e:	64a3      	str	r3, [r4, #72]	; 0x48
  if (sdcp->state == BLK_STOP) {
  2059a0:	7923      	ldrb	r3, [r4, #4]
  2059a2:	2b01      	cmp	r3, #1
  2059a4:	d11c      	bne.n	2059e0 <main+0x564>
  if (id < STM32_DMA_STREAMS) {
  2059a6:	462b      	mov	r3, r5
  2059a8:	462a      	mov	r2, r5
  2059aa:	2109      	movs	r1, #9
  2059ac:	200b      	movs	r0, #11
  2059ae:	f7fb fe69 	bl	201684 <dmaStreamAllocI.part.0>
      sdcp->dmamode |= STM32_DMA_CR_CHSEL(SDMMC1_DMA_CHANNEL) |
  2059b2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
      dmaStreamSetPeripheral(sdcp->dma, &sdcp->sdmmc->FIFO);
  2059b4:	6802      	ldr	r2, [r0, #0]
      sdcp->dmamode |= STM32_DMA_CR_CHSEL(SDMMC1_DMA_CHANNEL) |
  2059b6:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
      sdcp->dma = dmaStreamAllocI(STM32_SDC_SDMMC1_DMA_STREAM,
  2059ba:	64e0      	str	r0, [r4, #76]	; 0x4c
      sdcp->dmamode |= STM32_DMA_CR_CHSEL(SDMMC1_DMA_CHANNEL) |
  2059bc:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
  2059c0:	64a3      	str	r3, [r4, #72]	; 0x48
      dmaStreamSetPeripheral(sdcp->dma, &sdcp->sdmmc->FIFO);
  2059c2:	6d23      	ldr	r3, [r4, #80]	; 0x50
  2059c4:	3380      	adds	r3, #128	; 0x80
  2059c6:	6093      	str	r3, [r2, #8]
      dmaStreamSetFIFO(sdcp->dma, STM32_DMA_FCR_DMDIS |
  2059c8:	2307      	movs	r3, #7
  2059ca:	6153      	str	r3, [r2, #20]
      rccEnableSDMMC1(true);
  2059cc:	4b3e      	ldr	r3, [pc, #248]	; (205ac8 <main+0x64c>)
  2059ce:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  2059d0:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
  2059d4:	645a      	str	r2, [r3, #68]	; 0x44
  2059d6:	6e5a      	ldr	r2, [r3, #100]	; 0x64
  2059d8:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
  2059dc:	665a      	str	r2, [r3, #100]	; 0x64
  2059de:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  sdcp->sdmmc->POWER  = 0;
  2059e0:	6d22      	ldr	r2, [r4, #80]	; 0x50
  2059e2:	2300      	movs	r3, #0
  2059e4:	6013      	str	r3, [r2, #0]
  sdcp->sdmmc->CLKCR  = 0;
  2059e6:	6053      	str	r3, [r2, #4]
  sdcp->sdmmc->DCTRL  = 0;
  2059e8:	62d3      	str	r3, [r2, #44]	; 0x2c
  sdcp->sdmmc->DTIMER = 0;
  2059ea:	6253      	str	r3, [r2, #36]	; 0x24
  sdc_lld_start(sdcp);
  sdcp->state = BLK_ACTIVE;
  2059ec:	2202      	movs	r2, #2
  2059ee:	7122      	strb	r2, [r4, #4]
  2059f0:	f383 8811 	msr	BASEPRI, r3
	 * Initializes the SDIO drivers.
	 */

	sdcStart(&SDCD1, &sdccfg);

	printf ("SD card controller enabled\n");
  2059f4:	4846      	ldr	r0, [pc, #280]	; (205b10 <main+0x694>)
  2059f6:	f007 fee7 	bl	20d7c8 <puts>

	if (!blkIsInserted (&SDCD1))
  2059fa:	6823      	ldr	r3, [r4, #0]
  2059fc:	4841      	ldr	r0, [pc, #260]	; (205b04 <main+0x688>)
  2059fe:	685b      	ldr	r3, [r3, #4]
  205a00:	4798      	blx	r3
  205a02:	2800      	cmp	r0, #0
  205a04:	f040 8117 	bne.w	205c36 <main+0x7ba>
		printf ("SD card not present.\n");
  205a08:	4842      	ldr	r0, [pc, #264]	; (205b14 <main+0x698>)
  205a0a:	f007 fedd 	bl	20d7c8 <puts>
#endif

void gfxInit(void)
{
	/* Ensure we only initialise once */
	if (gfxInitDone)
  205a0e:	4b42      	ldr	r3, [pc, #264]	; (205b18 <main+0x69c>)
  205a10:	4d42      	ldr	r5, [pc, #264]	; (205b1c <main+0x6a0>)
  205a12:	f993 2000 	ldrsb.w	r2, [r3]
  205a16:	bb62      	cbnz	r2, 205a72 <main+0x5f6>
		return;
	gfxInitDone = gTrue;
  205a18:	22ff      	movs	r2, #255	; 0xff
  205a1a:	701a      	strb	r2, [r3, #0]
			if (!chThdSelf()) {
				halInit();
				chSysInit();
			}
		#else
			if (!chThdGetSelfX()) {
  205a1c:	69ab      	ldr	r3, [r5, #24]
  205a1e:	b91b      	cbnz	r3, 205a28 <main+0x5ac>
				halInit();
  205a20:	f002 ffac 	bl	20897c <halInit>
				chSysInit();
  205a24:	f7fe fe92 	bl	20474c <chSysInit>
	for(pd = dhead; pd; pd = pd->driverchain) {
  205a28:	4a3d      	ldr	r2, [pc, #244]	; (205b20 <main+0x6a4>)
	dinstance = sinstance = 0;
  205a2a:	2300      	movs	r3, #0
		if (pd->vmt == vmt)
  205a2c:	483d      	ldr	r0, [pc, #244]	; (205b24 <main+0x6a8>)
	for(pd = dhead; pd; pd = pd->driverchain) {
  205a2e:	f8d2 8000 	ldr.w	r8, [r2]
	dinstance = sinstance = 0;
  205a32:	469b      	mov	fp, r3
  205a34:	4692      	mov	sl, r2
	for(pd = dhead; pd; pd = pd->driverchain) {
  205a36:	f1b8 0f00 	cmp.w	r8, #0
  205a3a:	f040 8108 	bne.w	205c4e <main+0x7d2>
	pd = gfxAlloc(vmt->objsize);
  205a3e:	f44f 70a8 	mov.w	r0, #336	; 0x150
  205a42:	9305      	str	r3, [sp, #20]
  205a44:	f006 fbe6 	bl	20c214 <malloc>
	if (!pd)
  205a48:	4604      	mov	r4, r0
  205a4a:	b190      	cbz	r0, 205a72 <main+0x5f6>
    memset(pd, 0, vmt->objsize);
  205a4c:	f44f 72a8 	mov.w	r2, #336	; 0x150
  205a50:	4641      	mov	r1, r8
  205a52:	f006 fc0e 	bl	20c272 <memset>
	pd->vmt = vmt;
  205a56:	4a33      	ldr	r2, [pc, #204]	; (205b24 <main+0x6a8>)
	if (vmt->init && !vmt->init(pd, param, dinstance, sinstance)) {
  205a58:	9b05      	ldr	r3, [sp, #20]
  205a5a:	4641      	mov	r1, r8
	pd->vmt = vmt;
  205a5c:	6062      	str	r2, [r4, #4]
	if (vmt->init && !vmt->init(pd, param, dinstance, sinstance)) {
  205a5e:	4620      	mov	r0, r4
  205a60:	465a      	mov	r2, fp
  205a62:	f001 fa17 	bl	206e94 <_gdispInitDriver>
  205a66:	2800      	cmp	r0, #0
  205a68:	f040 80ff 	bne.w	205c6a <main+0x7ee>
		gfxFree(pd);
  205a6c:	4620      	mov	r0, r4
  205a6e:	f006 fbd9 	bl	20c224 <free>

	/* Initialize uGFX subsystem */

	gfxInit ();

	printf ("Main screen turn on\n");
  205a72:	482d      	ldr	r0, [pc, #180]	; (205b28 <main+0x6ac>)
  205a74:	f007 fea8 	bl	20d7c8 <puts>
gBool gfileMount(char fs, const char* drive) {
	const GFILEVMT * const *p;

	// Find the correct VMT
	for(p = FsArray; p < &FsArray[sizeof(FsArray)/sizeof(FsArray[0])]; p++) {
		if (p[0]->prefix == fs) {
  205a78:	4a2c      	ldr	r2, [pc, #176]	; (205b2c <main+0x6b0>)
  205a7a:	6813      	ldr	r3, [r2, #0]
  205a7c:	4692      	mov	sl, r2
  205a7e:	7859      	ldrb	r1, [r3, #1]
  205a80:	2946      	cmp	r1, #70	; 0x46
  205a82:	f000 8100 	beq.w	205c86 <main+0x80a>

	if (gfileMount ('F', "0:") == FALSE)
		printf ("Mounting filesystem failed.\n");
  205a86:	482a      	ldr	r0, [pc, #168]	; (205b30 <main+0x6b4>)

	/*
	 * Create blinker thread.
	 */

	chThdCreateStatic (waThread1, sizeof(waThread1),
  205a88:	2400      	movs	r4, #0
		printf ("Filesystem mounted OK.\n");
  205a8a:	f007 fe9d 	bl	20d7c8 <puts>
	chThdCreateStatic (waThread1, sizeof(waThread1),
  205a8e:	4b29      	ldr	r3, [pc, #164]	; (205b34 <main+0x6b8>)
  205a90:	f44f 71f8 	mov.w	r1, #496	; 0x1f0
  205a94:	2281      	movs	r2, #129	; 0x81
  205a96:	9400      	str	r4, [sp, #0]
  205a98:	4827      	ldr	r0, [pc, #156]	; (205b38 <main+0x6bc>)
  205a9a:	f7fe fe1f 	bl	2046dc <chThdCreateStatic>
  205a9e:	4a27      	ldr	r2, [pc, #156]	; (205b3c <main+0x6c0>)
  205aa0:	6012      	str	r2, [r2, #0]
  205aa2:	f7fe fb29 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  elp->next     = esp->next;
  205aa6:	4b26      	ldr	r3, [pc, #152]	; (205b40 <main+0x6c4>)
  205aa8:	6811      	ldr	r1, [r2, #0]
  esp->next     = elp;
  205aaa:	6013      	str	r3, [r2, #0]
  elp->listener = currp;
  205aac:	69aa      	ldr	r2, [r5, #24]
  elp->next     = esp->next;
  205aae:	6019      	str	r1, [r3, #0]
  elp->listener = currp;
  205ab0:	605a      	str	r2, [r3, #4]
  elp->events   = events;
  205ab2:	2201      	movs	r2, #1
  elp->flags    = (eventflags_t)0;
  205ab4:	e9c3 2402 	strd	r2, r4, [r3, #8]
  elp->wflags   = wflags;
  205ab8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  205abc:	611a      	str	r2, [r3, #16]
  205abe:	f384 8811 	msr	BASEPRI, r4
  205ac2:	2303      	movs	r3, #3
	for (f = gfileArr; f < &gfileArr[GFILE_MAX_GFILES]; f++) {
  205ac4:	4c1f      	ldr	r4, [pc, #124]	; (205b44 <main+0x6c8>)
  205ac6:	e03f      	b.n	205b48 <main+0x6cc>
  205ac8:	40023800 	.word	0x40023800
  205acc:	0800df9f 	.word	0x0800df9f
  205ad0:	20000948 	.word	0x20000948
  205ad4:	0800ea64 	.word	0x0800ea64
  205ad8:	002087a5 	.word	0x002087a5
  205adc:	0020893b 	.word	0x0020893b
  205ae0:	20000e14 	.word	0x20000e14
  205ae4:	0800e8f4 	.word	0x0800e8f4
  205ae8:	0800dfbf 	.word	0x0800dfbf
  205aec:	0800e964 	.word	0x0800e964
  205af0:	e000e100 	.word	0xe000e100
  205af4:	40001440 	.word	0x40001440
  205af8:	02200003 	.word	0x02200003
  205afc:	c0303c00 	.word	0xc0303c00
  205b00:	0800dfcf 	.word	0x0800dfcf
  205b04:	200008ec 	.word	0x200008ec
  205b08:	0800e8ec 	.word	0x0800e8ec
  205b0c:	00a05420 	.word	0x00a05420
  205b10:	0800dfe6 	.word	0x0800dfe6
  205b14:	0800e001 	.word	0x0800e001
  205b18:	2000271c 	.word	0x2000271c
  205b1c:	20000e8c 	.word	0x20000e8c
  205b20:	200018a4 	.word	0x200018a4
  205b24:	0800e3a8 	.word	0x0800e3a8
  205b28:	0800e03c 	.word	0x0800e03c
  205b2c:	20010000 	.word	0x20010000
  205b30:	0800e050 	.word	0x0800e050
  205b34:	00205449 	.word	0x00205449
  205b38:	20003c60 	.word	0x20003c60
  205b3c:	2000294c 	.word	0x2000294c
  205b40:	20002934 	.word	0x20002934
  205b44:	200026ec 	.word	0x200026ec
		if (!(f->flags & GFILEFLG_OPEN)) {
  205b48:	88a2      	ldrh	r2, [r4, #4]
  205b4a:	07d2      	lsls	r2, r2, #31
  205b4c:	f100 80b2 	bmi.w	205cb4 <main+0x838>
				f->flags = GFILEFLG_READ|GFILEFLG_MUSTEXIST;
  205b50:	f44f 7381 	mov.w	r3, #258	; 0x102
  205b54:	498c      	ldr	r1, [pc, #560]	; (205d88 <main+0x90c>)
  205b56:	80a3      	strh	r3, [r4, #4]
				while (*++mode) {
  205b58:	f811 2f01 	ldrb.w	r2, [r1, #1]!
  205b5c:	88a3      	ldrh	r3, [r4, #4]
  205b5e:	2a00      	cmp	r2, #0
  205b60:	f040 809c 	bne.w	205c9c <main+0x820>
	if ((f->flags & GFILEFLG_WRITE) && !(p->flags & GFSFLG_WRITEABLE))
  205b64:	075b      	lsls	r3, r3, #29
		if (testopen(p[0], f, fname))
  205b66:	f8da a000 	ldr.w	sl, [sl]
	if ((f->flags & GFILEFLG_WRITE) && !(p->flags & GFSFLG_WRITEABLE))
  205b6a:	d504      	bpl.n	205b76 <main+0x6fa>
  205b6c:	f89a 3000 	ldrb.w	r3, [sl]
  205b70:	07d9      	lsls	r1, r3, #31
  205b72:	f140 80a4 	bpl.w	205cbe <main+0x842>
	if (!p->open || !p->open(f, fname))
  205b76:	f8da 3014 	ldr.w	r3, [sl, #20]
  205b7a:	2b00      	cmp	r3, #0
  205b7c:	f000 809f 	beq.w	205cbe <main+0x842>
  205b80:	4982      	ldr	r1, [pc, #520]	; (205d8c <main+0x910>)
  205b82:	4620      	mov	r0, r4
  205b84:	4798      	blx	r3
  205b86:	2800      	cmp	r0, #0
  205b88:	f000 8099 	beq.w	205cbe <main+0x842>
	f->pos = 0;
  205b8c:	2300      	movs	r3, #0
	f->vmt = p;
  205b8e:	f8c4 a000 	str.w	sl, [r4]
	f->pos = 0;
  205b92:	60e3      	str	r3, [r4, #12]
	f->flags |= GFILEFLG_OPEN;
  205b94:	88a3      	ldrh	r3, [r4, #4]
  205b96:	f043 0201 	orr.w	r2, r3, #1
  205b9a:	80a2      	strh	r2, [r4, #4]
	if (p->flags & GFSFLG_SEEKABLE)
  205b9c:	f89a 2000 	ldrb.w	r2, [sl]
  205ba0:	0750      	lsls	r0, r2, #29
  205ba2:	d502      	bpl.n	205baa <main+0x72e>
		f->flags |= GFILEFLG_CANSEEK;
  205ba4:	f043 0341 	orr.w	r3, r3, #65	; 0x41
  205ba8:	80a3      	strh	r3, [r4, #4]
	img->bgcolor = GFX_WHITE;
  205baa:	f64f 73ff 	movw	r3, #65535	; 0xffff
	img->f = f;
  205bae:	940b      	str	r4, [sp, #44]	; 0x2c
	for(img->fns = ImageHandlers; img->fns < ImageHandlers+sizeof(ImageHandlers)/sizeof(ImageHandlers[0]); img->fns++) {
  205bb0:	4c77      	ldr	r4, [pc, #476]	; (205d90 <main+0x914>)
		if (err != GDISP_IMAGE_ERR_BADFORMAT) {
  205bb2:	f248 0a01 	movw	sl, #32769	; 0x8001
	img->bgcolor = GFX_WHITE;
  205bb6:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	for(img->fns = ImageHandlers; img->fns < ImageHandlers+sizeof(ImageHandlers)/sizeof(ImageHandlers[0]); img->fns++) {
  205bba:	940c      	str	r4, [sp, #48]	; 0x30
  205bbc:	3440      	adds	r4, #64	; 0x40
  205bbe:	e0bd      	b.n	205d3c <main+0x8c0>
  205bc0:	4623      	mov	r3, r4
  205bc2:	4a74      	ldr	r2, [pc, #464]	; (205d94 <main+0x918>)
  205bc4:	210a      	movs	r1, #10
  205bc6:	2003      	movs	r0, #3
  205bc8:	f7fb fd5c 	bl	201684 <dmaStreamAllocI.part.0>
  205bcc:	4623      	mov	r3, r4
  205bce:	4a72      	ldr	r2, [pc, #456]	; (205d98 <main+0x91c>)
  205bd0:	210a      	movs	r1, #10
      spip->dmarx = dmaStreamAllocI(STM32_SPI_SPI2_RX_DMA_STREAM,
  205bd2:	6220      	str	r0, [r4, #32]
  205bd4:	2004      	movs	r0, #4
  205bd6:	f7fb fd55 	bl	201684 <dmaStreamAllocI.part.0>
      rccEnableSPI2(true);
  205bda:	4b70      	ldr	r3, [pc, #448]	; (205d9c <main+0x920>)
      spip->dmatx = dmaStreamAllocI(STM32_SPI_SPI2_TX_DMA_STREAM,
  205bdc:	6260      	str	r0, [r4, #36]	; 0x24
      rccEnableSPI2(true);
  205bde:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  205be0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
  205be4:	641a      	str	r2, [r3, #64]	; 0x40
  205be6:	6e1a      	ldr	r2, [r3, #96]	; 0x60
  205be8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
  205bec:	661a      	str	r2, [r3, #96]	; 0x60
  205bee:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
  205bf0:	6a23      	ldr	r3, [r4, #32]
  205bf2:	681a      	ldr	r2, [r3, #0]
  205bf4:	69e3      	ldr	r3, [r4, #28]
  205bf6:	330c      	adds	r3, #12
  205bf8:	6093      	str	r3, [r2, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
  205bfa:	6802      	ldr	r2, [r0, #0]
  205bfc:	6093      	str	r3, [r2, #8]
  ds = spip->config->cr2 & SPI_CR2_DS;
  205bfe:	6863      	ldr	r3, [r4, #4]
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
  205c00:	8a5b      	ldrh	r3, [r3, #18]
  205c02:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
  205c06:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
  205c0a:	f67f ad4b 	bls.w	2056a4 <main+0x228>
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
  205c0e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  205c10:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  205c14:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
  205c18:	62a3      	str	r3, [r4, #40]	; 0x28
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
  205c1a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  205c1c:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  205c20:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
  205c24:	e545      	b.n	2056b2 <main+0x236>
    spip->rxdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
  205c26:	f422 7284 	bic.w	r2, r2, #264	; 0x108
    spip->txdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
  205c2a:	f423 7384 	bic.w	r3, r3, #264	; 0x108
    spip->rxdmamode &= ~(STM32_DMA_CR_CIRC | STM32_DMA_CR_HTIE);
  205c2e:	62a2      	str	r2, [r4, #40]	; 0x28
  205c30:	e54c      	b.n	2056cc <main+0x250>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
  205c32:	4b5b      	ldr	r3, [pc, #364]	; (205da0 <main+0x924>)
  205c34:	e696      	b.n	205964 <main+0x4e8>
		printf ("SD card inserted - ");
  205c36:	485b      	ldr	r0, [pc, #364]	; (205da4 <main+0x928>)
  205c38:	f007 fd52 	bl	20d6e0 <iprintf>
		sdcConnect (&SDCD1);
  205c3c:	485a      	ldr	r0, [pc, #360]	; (205da8 <main+0x92c>)
  205c3e:	f002 fac5 	bl	2081cc <sdcConnect>
		printf("Capacity: %ldMB\r\n", SDCD1.capacity / 2048);
  205c42:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  205c44:	4859      	ldr	r0, [pc, #356]	; (205dac <main+0x930>)
  205c46:	0ac9      	lsrs	r1, r1, #11
  205c48:	f007 fd4a 	bl	20d6e0 <iprintf>
  205c4c:	e6df      	b.n	205a0e <main+0x592>
		if (pd->vmt == vmt)
  205c4e:	f8d8 2004 	ldr.w	r2, [r8, #4]
  205c52:	4282      	cmp	r2, r0
  205c54:	d103      	bne.n	205c5e <main+0x7e2>
			dinstance++;
  205c56:	f10b 0b01 	add.w	fp, fp, #1
			sinstance++;
  205c5a:	3301      	adds	r3, #1
  205c5c:	e002      	b.n	205c64 <main+0x7e8>
		if (pd->vmt->type == vmt->type)
  205c5e:	8812      	ldrh	r2, [r2, #0]
  205c60:	2a67      	cmp	r2, #103	; 0x67
  205c62:	d0fa      	beq.n	205c5a <main+0x7de>
	for(pd = dhead; pd; pd = pd->driverchain) {
  205c64:	f8d8 8000 	ldr.w	r8, [r8]
  205c68:	e6e5      	b.n	205a36 <main+0x5ba>
	if (dhead)
  205c6a:	f8da 2000 	ldr.w	r2, [sl]
  205c6e:	4b50      	ldr	r3, [pc, #320]	; (205db0 <main+0x934>)
  205c70:	b132      	cbz	r2, 205c80 <main+0x804>
		dtail->driverchain = pd;
  205c72:	681a      	ldr	r2, [r3, #0]
  205c74:	6014      	str	r4, [r2, #0]
		vmt->postinit(pd);
  205c76:	4620      	mov	r0, r4
	dtail = pd;
  205c78:	601c      	str	r4, [r3, #0]
		vmt->postinit(pd);
  205c7a:	f001 f8c9 	bl	206e10 <_gdispPostInitDriver>
  205c7e:	e6f8      	b.n	205a72 <main+0x5f6>
		dhead = pd;
  205c80:	f8ca 4000 	str.w	r4, [sl]
  205c84:	e7f7      	b.n	205c76 <main+0x7fa>
			if (!p[0]->mount)
  205c86:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  205c88:	2b00      	cmp	r3, #0
  205c8a:	f43f aefc 	beq.w	205a86 <main+0x60a>
				return gFalse;
			return p[0]->mount(drive);
  205c8e:	4849      	ldr	r0, [pc, #292]	; (205db4 <main+0x938>)
  205c90:	4798      	blx	r3
	if (gfileMount ('F', "0:") == FALSE)
  205c92:	2800      	cmp	r0, #0
  205c94:	f43f aef7 	beq.w	205a86 <main+0x60a>
		printf ("Filesystem mounted OK.\n");
  205c98:	4847      	ldr	r0, [pc, #284]	; (205db8 <main+0x93c>)
  205c9a:	e6f5      	b.n	205a88 <main+0x60c>
  205c9c:	2a2b      	cmp	r2, #43	; 0x2b
  205c9e:	d005      	beq.n	205cac <main+0x830>
  205ca0:	2a62      	cmp	r2, #98	; 0x62
  205ca2:	f47f af59 	bne.w	205b58 <main+0x6dc>
					case 'b':	f->flags |= GFILEFLG_BINARY;		break;
  205ca6:	f043 0310 	orr.w	r3, r3, #16
  205caa:	e001      	b.n	205cb0 <main+0x834>
					case '+':	f->flags |= GFILEFLG_WRITE;			break;
  205cac:	f043 0304 	orr.w	r3, r3, #4
					case 'b':	f->flags |= GFILEFLG_BINARY;		break;
  205cb0:	80a3      	strh	r3, [r4, #4]
  205cb2:	e751      	b.n	205b58 <main+0x6dc>
	for (f = gfileArr; f < &gfileArr[GFILE_MAX_GFILES]; f++) {
  205cb4:	3b01      	subs	r3, #1
  205cb6:	f104 0410 	add.w	r4, r4, #16
  205cba:	f47f af45 	bne.w	205b48 <main+0x6cc>
	uint16_t tx;
	uint16_t rx;
	msg_t r;

	tx = __builtin_bswap16(0x0002);
	rx = 0x0000;
  205cbe:	2200      	movs	r2, #0
	tx = __builtin_bswap16(0x0002);
  205cc0:	f44f 7300 	mov.w	r3, #512	; 0x200
	rx = 0x0000;
  205cc4:	f8ad 201e 	strh.w	r2, [sp, #30]
	tx = __builtin_bswap16(0x0002);
  205cc8:	f8ad 3020 	strh.w	r3, [sp, #32]
  205ccc:	f7fe fa14 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
  205cd0:	2303      	movs	r3, #3
  i2cp->errors = I2C_NO_ERROR;
  205cd2:	f8c9 2008 	str.w	r2, [r9, #8]
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      sysinterval_t timeout) {
  msg_t msg;
  I2C_TypeDef *dp = i2cp->i2c;
  205cd6:	f8d9 4030 	ldr.w	r4, [r9, #48]	; 0x30
  i2cp->state = I2C_ACTIVE_TX;
  205cda:	f889 3000 	strb.w	r3, [r9]
  205cde:	f382 8811 	msr	BASEPRI, r2
  /* RX DMA setup, note, rxbytes can be zero but we write the value anyway.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
#else
  i2cp->txptr   = txbuf;
  205ce2:	ab08      	add	r3, sp, #32
  i2cp->txbytes = txbytes;
  i2cp->rxptr   = rxbuf;
  205ce4:	f10d 011e 	add.w	r1, sp, #30
  i2cp->txptr   = txbuf;
  205ce8:	f8c9 3020 	str.w	r3, [r9, #32]
  i2cp->txbytes = txbytes;
  205cec:	2302      	movs	r3, #2
  205cee:	f8c9 3024 	str.w	r3, [r9, #36]	; 0x24
  i2cp->rxbytes = rxbytes;
  205cf2:	e9c9 130a 	strd	r1, r3, [r9, #40]	; 0x28
  205cf6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  205cfa:	6a59      	ldr	r1, [r3, #36]	; 0x24
  205cfc:	4618      	mov	r0, r3
  205cfe:	f7fe f9fb 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if ((dp->ISR & I2C_ISR_BUSY) == 0)
  205d02:	69a3      	ldr	r3, [r4, #24]
  205d04:	041b      	lsls	r3, r3, #16
  205d06:	d55b      	bpl.n	205dc0 <main+0x944>
  205d08:	6a43      	ldr	r3, [r0, #36]	; 0x24
 */
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {

  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
  205d0a:	1a5b      	subs	r3, r3, r1
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end)) {
  205d0c:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
  205d10:	d27c      	bcs.n	205e0c <main+0x990>
  205d12:	f382 8811 	msr	BASEPRI, r2
  205d16:	e7f2      	b.n	205cfe <main+0x882>
		err = img->fns->open(img);
  205d18:	681b      	ldr	r3, [r3, #0]
  205d1a:	a808      	add	r0, sp, #32
  205d1c:	4798      	blx	r3
		if (err != GDISP_IMAGE_ERR_BADFORMAT) {
  205d1e:	4550      	cmp	r0, sl
  205d20:	d005      	beq.n	205d2e <main+0x8b2>
			if ((err & GDISP_IMAGE_ERR_UNRECOVERABLE))
  205d22:	0402      	lsls	r2, r0, #16
  205d24:	d511      	bpl.n	205d4a <main+0x8ce>
	gfileClose(img->f);
  205d26:	980b      	ldr	r0, [sp, #44]	; 0x2c
  205d28:	f7fa ff38 	bl	200b9c <gfileClose>
	img->priv = 0;
  205d2c:	e7c7      	b.n	205cbe <main+0x842>
		gfileSetPos(img->f, 0);
  205d2e:	2100      	movs	r1, #0
  205d30:	980b      	ldr	r0, [sp, #44]	; 0x2c
  205d32:	f7fa ff01 	bl	200b38 <gfileSetPos>
	for(img->fns = ImageHandlers; img->fns < ImageHandlers+sizeof(ImageHandlers)/sizeof(ImageHandlers[0]); img->fns++) {
  205d36:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  205d38:	3320      	adds	r3, #32
  205d3a:	930c      	str	r3, [sp, #48]	; 0x30
  205d3c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  205d3e:	42a3      	cmp	r3, r4
  205d40:	d3ea      	bcc.n	205d18 <main+0x89c>
	img->type = GDISP_IMAGE_TYPE_UNKNOWN;
  205d42:	2300      	movs	r3, #0
  205d44:	f8ad 3020 	strh.w	r3, [sp, #32]
  205d48:	e7ed      	b.n	205d26 <main+0x8aa>
    if (gdispImageOpenFile (&myImage,
  205d4a:	2800      	cmp	r0, #0
  205d4c:	d1b7      	bne.n	205cbe <main+0x842>
	if (!img->fns) return GDISP_IMAGE_ERR_BADFORMAT;
  205d4e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
      gdispImageDraw (&myImage,
  205d50:	f9bd 2026 	ldrsh.w	r2, [sp, #38]	; 0x26
  205d54:	b183      	cbz	r3, 205d78 <main+0x8fc>
	if (cx <= 0 || cy <= 0) return GDISP_IMAGE_ERR_OK;
  205d56:	2a00      	cmp	r2, #0
  205d58:	dd0e      	ble.n	205d78 <main+0x8fc>
  205d5a:	f9bd 1028 	ldrsh.w	r1, [sp, #40]	; 0x28
  205d5e:	2900      	cmp	r1, #0
  205d60:	dd0a      	ble.n	205d78 <main+0x8fc>
	return img->fns->draw(g, img, x, y, cx, cy, sx, sy);
  205d62:	e9cd 2100 	strd	r2, r1, [sp]
  205d66:	e9cd 0002 	strd	r0, r0, [sp, #8]
  205d6a:	4602      	mov	r2, r0
  205d6c:	68dc      	ldr	r4, [r3, #12]
  205d6e:	4603      	mov	r3, r0
  205d70:	4812      	ldr	r0, [pc, #72]	; (205dbc <main+0x940>)
  205d72:	a908      	add	r1, sp, #32
  205d74:	6800      	ldr	r0, [r0, #0]
  205d76:	47a0      	blx	r4
	if (img->fns)
  205d78:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  205d7a:	2b00      	cmp	r3, #0
  205d7c:	d0d3      	beq.n	205d26 <main+0x8aa>
		img->fns->close(img);
  205d7e:	685b      	ldr	r3, [r3, #4]
  205d80:	a808      	add	r0, sp, #32
  205d82:	4798      	blx	r3
  205d84:	e7cf      	b.n	205d26 <main+0x8aa>
  205d86:	bf00      	nop
  205d88:	0800df29 	.word	0x0800df29
  205d8c:	0800e086 	.word	0x0800e086
  205d90:	20010004 	.word	0x20010004
  205d94:	002049c5 	.word	0x002049c5
  205d98:	002013c5 	.word	0x002013c5
  205d9c:	40023800 	.word	0x40023800
  205da0:	c0303c08 	.word	0xc0303c08
  205da4:	0800e016 	.word	0x0800e016
  205da8:	200008ec 	.word	0x200008ec
  205dac:	0800e02a 	.word	0x0800e02a
  205db0:	2000192c 	.word	0x2000192c
  205db4:	0800e06c 	.word	0x0800e06c
  205db8:	0800e06f 	.word	0x0800e06f
  205dbc:	20000810 	.word	0x20000810
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
  205dc0:	f8d9 2004 	ldr.w	r2, [r9, #4]
  I2C_TypeDef *dp = i2cp->i2c;
  205dc4:	f8d9 3030 	ldr.w	r3, [r9, #48]	; 0x30
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
  205dc8:	6892      	ldr	r2, [r2, #8]

  /* Setting up the slave address.*/
  i2c_lld_set_address(i2cp, addr);

  /* Preparing the transfer.*/
  i2c_lld_setup_tx_transfer(i2cp);
  205dca:	485e      	ldr	r0, [pc, #376]	; (205f44 <main+0xac8>)
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
  205dcc:	0511      	lsls	r1, r2, #20
    dp->CR2 = (uint32_t)addr << 1U;
  205dce:	bf54      	ite	pl
  205dd0:	2234      	movpl	r2, #52	; 0x34
    dp->CR2 = (uint32_t)addr;
  205dd2:	221a      	movmi	r2, #26
  205dd4:	605a      	str	r2, [r3, #4]
  i2c_lld_setup_tx_transfer(i2cp);
  205dd6:	f7fb fbbf 	bl	201558 <i2c_lld_setup_tx_transfer>

  /* Transfer complete interrupt enabled.*/
  dp->CR1 |= I2C_CR1_TCIE;
#else
  /* Transfer complete and TX interrupts enabled.*/
  dp->CR1 |= I2C_CR1_TCIE | I2C_CR1_TXIE;
  205dda:	6823      	ldr	r3, [r4, #0]
  tp->u.wttrp = trp;
  205ddc:	4a5a      	ldr	r2, [pc, #360]	; (205f48 <main+0xacc>)
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
  205dde:	2164      	movs	r1, #100	; 0x64
  205de0:	f043 0342 	orr.w	r3, r3, #66	; 0x42
  205de4:	2003      	movs	r0, #3
  205de6:	6023      	str	r3, [r4, #0]
#endif

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_START;
  205de8:	6863      	ldr	r3, [r4, #4]
  205dea:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  205dee:	6063      	str	r3, [r4, #4]
  return ch.rlist.current;
  205df0:	69ab      	ldr	r3, [r5, #24]
  tp->u.wttrp = trp;
  205df2:	625a      	str	r2, [r3, #36]	; 0x24
  *trp = tp;
  205df4:	f8c9 301c 	str.w	r3, [r9, #28]
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
  205df8:	f7fb fcfc 	bl	2017f4 <chSchGoSleepTimeoutS>
  /* Waits for the operation completion or a timeout.*/
  msg = osalThreadSuspendTimeoutS(&i2cp->thread, timeout);

  /* In case of a software timeout a STOP is sent as an extreme attempt
     to release the bus.*/
  if (msg == MSG_TIMEOUT) {
  205dfc:	1c42      	adds	r2, r0, #1
  205dfe:	4601      	mov	r1, r0
  205e00:	f040 809c 	bne.w	205f3c <main+0xac0>
    dp->CR2 |= I2C_CR2_STOP;
  205e04:	6863      	ldr	r3, [r4, #4]
  205e06:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  205e0a:	6063      	str	r3, [r4, #4]
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
  205e0c:	2305      	movs	r3, #5
  205e0e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  205e12:	f889 3000 	strb.w	r3, [r9]
  205e16:	2400      	movs	r4, #0
  205e18:	f384 8811 	msr	BASEPRI, r4

	r = i2cMasterTransmitTimeout (&I2CD3, 0x34 >> 1,
	    (uint8_t *)&tx, 2, (uint8_t *)&rx, 2, 100);

	rx = __builtin_bswap16(rx);
  205e1c:	f8bd 301e 	ldrh.w	r3, [sp, #30]

	printf ("R: %ld ", r);
  205e20:	484a      	ldr	r0, [pc, #296]	; (205f4c <main+0xad0>)
	rx = __builtin_bswap16(rx);
  205e22:	ba5b      	rev16	r3, r3
  205e24:	f8ad 301e 	strh.w	r3, [sp, #30]
	printf ("R: %ld ", r);
  205e28:	f007 fc5a 	bl	20d6e0 <iprintf>
	printf ("REG: %x\n", rx);
  205e2c:	f8bd 101e 	ldrh.w	r1, [sp, #30]
  205e30:	4847      	ldr	r0, [pc, #284]	; (205f50 <main+0xad4>)
  205e32:	f007 fc55 	bl	20d6e0 <iprintf>
  205e36:	f7fe f95f 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  osalDbgCheckClassI();
  osalDbgCheck(gptp != NULL);
  osalDbgAssert(gptp->state == GPT_READY,
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
  205e3a:	2303      	movs	r3, #3
 *
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {

  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
  205e3c:	4a45      	ldr	r2, [pc, #276]	; (205f54 <main+0xad8>)
  205e3e:	7033      	strb	r3, [r6, #0]
  205e40:	68f3      	ldr	r3, [r6, #12]
  205e42:	62da      	str	r2, [r3, #44]	; 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
  205e44:	2201      	movs	r2, #1
  205e46:	615a      	str	r2, [r3, #20]

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is why the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  if (NULL != gptp->config->callback)
  205e48:	6872      	ldr	r2, [r6, #4]
  gptp->tim->CNT = 0;                           /* Reset counter.           */
  205e4a:	625c      	str	r4, [r3, #36]	; 0x24
  if (NULL != gptp->config->callback)
  205e4c:	6852      	ldr	r2, [r2, #4]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  205e4e:	611c      	str	r4, [r3, #16]
  if (NULL != gptp->config->callback)
  205e50:	b11a      	cbz	r2, 205e5a <main+0x9de>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
  205e52:	68da      	ldr	r2, [r3, #12]
  205e54:	f042 0201 	orr.w	r2, r2, #1
  205e58:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
  205e5a:	2285      	movs	r2, #133	; 0x85
  205e5c:	601a      	str	r2, [r3, #0]
  205e5e:	2300      	movs	r3, #0
  205e60:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("dsb 0xF":::"memory");
  205e64:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  205e68:	f3bf 8f6f 	isb	sy
	uint32_t t2;

        gptStartContinuous (&GPTD5, 0x7FFFFFFF);
__DSB();
__ISB();
	t1 = gptGetCounterX (&GPTD5);
  205e6c:	68f3      	ldr	r3, [r6, #12]
  205e6e:	6a59      	ldr	r1, [r3, #36]	; 0x24
  205e70:	9105      	str	r1, [sp, #20]
  __ASM volatile ("dsb 0xF":::"memory");
  205e72:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  205e76:	f3bf 8f6f 	isb	sy
__DSB();
__ISB();
	chThdSleepMilliseconds (10);
  205e7a:	2064      	movs	r0, #100	; 0x64
  205e7c:	f7ff fad8 	bl	205430 <chThdSleep>
  __ASM volatile ("dsb 0xF":::"memory");
  205e80:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  205e84:	f3bf 8f6f 	isb	sy
__DSB();
__ISB();
	t2 = gptGetCounterX (&GPTD5);
  205e88:	68f3      	ldr	r3, [r6, #12]
  205e8a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
  205e8c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  205e90:	f3bf 8f6f 	isb	sy
	 * Normal main() thread activity. Start and monitor
	 * shell threads.
	 */

	while (true) {
		if (shell_tp_sd == NULL) {
  205e94:	4e30      	ldr	r6, [pc, #192]	; (205f58 <main+0xadc>)
			shell_tp_sd = chThdCreateStatic (shell_wa_sd,
  205e96:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 205f78 <main+0xafc>
  205e9a:	46b1      	mov	r9, r6
	printf ("T1: %lu T2: %lu\n", t1, t2);
  205e9c:	9905      	ldr	r1, [sp, #20]
  205e9e:	482f      	ldr	r0, [pc, #188]	; (205f5c <main+0xae0>)
  205ea0:	f007 fc1e 	bl	20d6e0 <iprintf>
		if (shell_tp_sd == NULL) {
  205ea4:	6833      	ldr	r3, [r6, #0]
  205ea6:	b94b      	cbnz	r3, 205ebc <main+0xa40>
			shell_tp_sd = chThdCreateStatic (shell_wa_sd,
  205ea8:	4b2d      	ldr	r3, [pc, #180]	; (205f60 <main+0xae4>)
  205eaa:	2285      	movs	r2, #133	; 0x85
  205eac:	f44f 6117 	mov.w	r1, #2416	; 0x970
  205eb0:	482c      	ldr	r0, [pc, #176]	; (205f64 <main+0xae8>)
  205eb2:	f8cd a000 	str.w	sl, [sp]
  205eb6:	f7fe fc11 	bl	2046dc <chThdCreateStatic>
  205eba:	6030      	str	r0, [r6, #0]
			    sizeof(shell_wa_sd), NORMALPRIO + 5,
 			    shellSdThreadStub, (void *)&shell_cfg_sd);
		}

		if (shell_tp_usb == NULL) {
  205ebc:	4c2a      	ldr	r4, [pc, #168]	; (205f68 <main+0xaec>)
  205ebe:	6823      	ldr	r3, [r4, #0]
  205ec0:	b94b      	cbnz	r3, 205ed6 <main+0xa5a>
			shell_tp_usb = chThdCreateStatic (shell_wa_usb,
  205ec2:	4b2a      	ldr	r3, [pc, #168]	; (205f6c <main+0xaf0>)
  205ec4:	2285      	movs	r2, #133	; 0x85
  205ec6:	f44f 6117 	mov.w	r1, #2416	; 0x970
  205eca:	4829      	ldr	r0, [pc, #164]	; (205f70 <main+0xaf4>)
  205ecc:	9300      	str	r3, [sp, #0]
  205ece:	4b29      	ldr	r3, [pc, #164]	; (205f74 <main+0xaf8>)
  205ed0:	f7fe fc04 	bl	2046dc <chThdCreateStatic>
  205ed4:	6020      	str	r0, [r4, #0]
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
  thread_t *ctp = currp;
  205ed6:	f8d5 b018 	ldr.w	fp, [r5, #24]
  205eda:	f7fe f90d 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  205ede:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
  if (m == (eventmask_t)0) {
  205ee2:	f013 0301 	ands.w	r3, r3, #1
  205ee6:	d109      	bne.n	205efc <main+0xa80>
    ctp->u.ewmask = events;
  205ee8:	2301      	movs	r3, #1
    chSchGoSleepS(CH_STATE_WTOREVT);
  205eea:	200a      	movs	r0, #10
    ctp->u.ewmask = events;
  205eec:	f8cb 3024 	str.w	r3, [fp, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
  205ef0:	f7fb fc5e 	bl	2017b0 <chSchGoSleepS>
    m = ctp->epending & events;
  205ef4:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
  205ef8:	f003 0301 	and.w	r3, r3, #1
  }
  ctp->epending &= ~m;
  205efc:	f8db 2034 	ldr.w	r2, [fp, #52]	; 0x34
  205f00:	ea22 0303 	bic.w	r3, r2, r3
  205f04:	f8cb 3034 	str.w	r3, [fp, #52]	; 0x34
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  205f08:	f04f 0b00 	mov.w	fp, #0
  205f0c:	f38b 8811 	msr	BASEPRI, fp
 			    shellUsbThreadStub, (void *)&shell_cfg_usb);
		}

		chEvtWaitAny (EVENT_MASK(0));

		if (chThdTerminatedX (shell_tp_sd)) {
  205f10:	f8d9 0000 	ldr.w	r0, [r9]
  205f14:	f890 3020 	ldrb.w	r3, [r0, #32]
  205f18:	2b0f      	cmp	r3, #15
  205f1a:	d103      	bne.n	205f24 <main+0xaa8>
			chThdRelease (shell_tp_sd);
  205f1c:	f7fe fb56 	bl	2045cc <chThdRelease>
			shell_tp_sd = NULL;
  205f20:	f8c9 b000 	str.w	fp, [r9]
		}

		if (chThdTerminatedX (shell_tp_usb)) {
  205f24:	6820      	ldr	r0, [r4, #0]
  205f26:	f890 3020 	ldrb.w	r3, [r0, #32]
  205f2a:	2b0f      	cmp	r3, #15
  205f2c:	d1ba      	bne.n	205ea4 <main+0xa28>
			chThdRelease (shell_tp_usb);
  205f2e:	f7fe fb4d 	bl	2045cc <chThdRelease>
			shell_tp_usb = NULL;
  205f32:	2300      	movs	r3, #0
  205f34:	6023      	str	r3, [r4, #0]
			console = (BaseSequentialStream *)&SD1;
  205f36:	9b04      	ldr	r3, [sp, #16]
  205f38:	601f      	str	r7, [r3, #0]
  205f3a:	e7b3      	b.n	205ea4 <main+0xa28>
  }
  else {
    i2cp->state = I2C_READY;
  205f3c:	2302      	movs	r3, #2
  205f3e:	f889 3000 	strb.w	r3, [r9]
  205f42:	e768      	b.n	205e16 <main+0x99a>
  205f44:	20000858 	.word	0x20000858
  205f48:	20000874 	.word	0x20000874
  205f4c:	0800e090 	.word	0x0800e090
  205f50:	0800e098 	.word	0x0800e098
  205f54:	7ffffffe 	.word	0x7ffffffe
  205f58:	20002950 	.word	0x20002950
  205f5c:	0800e0a1 	.word	0x0800e0a1
  205f60:	002052b9 	.word	0x002052b9
  205f64:	20002960 	.word	0x20002960
  205f68:	20002954 	.word	0x20002954
  205f6c:	20010050 	.word	0x20010050
  205f70:	200032e0 	.word	0x200032e0
  205f74:	002052cd 	.word	0x002052cd
  205f78:	20010048 	.word	0x20010048

00205f7c <chThdExit>:
void chThdExit(msg_t msg) {
  205f7c:	b508      	push	{r3, lr}
  205f7e:	f7fe f8bb 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
}
  205f82:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  chThdExitS(msg);
  205f86:	f7fb bcb3 	b.w	2018f0 <chThdExitS>
	...

00205f8c <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
  205f8c:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
  205f8e:	4b13      	ldr	r3, [pc, #76]	; (205fdc <chSchDoReschedule+0x50>)
  thread_t *tp = tqp->next;
  205f90:	681a      	ldr	r2, [r3, #0]
  205f92:	461d      	mov	r5, r3
  205f94:	699c      	ldr	r4, [r3, #24]
  tqp->next             = tp->queue.next;
  205f96:	6811      	ldr	r1, [r2, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  205f98:	604b      	str	r3, [r1, #4]
  tqp->next             = tp->queue.next;
  205f9a:	6019      	str	r1, [r3, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
  205f9c:	2101      	movs	r1, #1
  currp = queue_fifo_remove(&ch.rlist.queue);
  205f9e:	619a      	str	r2, [r3, #24]
  currp->state = CH_STATE_CURRENT;
  205fa0:	f882 1020 	strb.w	r1, [r2, #32]
  tp->state = CH_STATE_READY;
  205fa4:	2200      	movs	r2, #0
  205fa6:	f884 2020 	strb.w	r2, [r4, #32]
  } while (cp->prio > tp->prio);
  205faa:	68a2      	ldr	r2, [r4, #8]
    cp = cp->queue.next;
  205fac:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
  205fae:	6899      	ldr	r1, [r3, #8]
  205fb0:	4291      	cmp	r1, r2
  205fb2:	d8fb      	bhi.n	205fac <chSchDoReschedule+0x20>
  tp->queue.prev             = cp->queue.prev;
  205fb4:	685a      	ldr	r2, [r3, #4]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
  205fb6:	4620      	mov	r0, r4
  tp->queue.next             = cp;
  205fb8:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  205fba:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  205fbc:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
  205fbe:	605c      	str	r4, [r3, #4]
  chSysSwitch(currp, otp);
  205fc0:	f7fb f9d8 	bl	201374 <_trace_switch.constprop.0>
  205fc4:	4621      	mov	r1, r4
  205fc6:	69a8      	ldr	r0, [r5, #24]
  205fc8:	f7fa f9ae 	bl	200328 <_port_switch>
  205fcc:	4b04      	ldr	r3, [pc, #16]	; (205fe0 <chSchDoReschedule+0x54>)
  205fce:	2207      	movs	r2, #7
  205fd0:	609a      	str	r2, [r3, #8]
  205fd2:	69aa      	ldr	r2, [r5, #24]
  205fd4:	69d2      	ldr	r2, [r2, #28]
  205fd6:	60da      	str	r2, [r3, #12]
}
  205fd8:	bd38      	pop	{r3, r4, r5, pc}
  205fda:	bf00      	nop
  205fdc:	20000e8c 	.word	0x20000e8c
  205fe0:	e000ed90 	.word	0xe000ed90

00205fe4 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  205fe4:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
  205fe6:	4c17      	ldr	r4, [pc, #92]	; (206044 <chMtxUnlock+0x60>)
  205fe8:	69a1      	ldr	r1, [r4, #24]
  205fea:	f7fe f885 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  return (bool)(tqp->next != (const thread_t *)tqp);
  205fee:	6803      	ldr	r3, [r0, #0]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
  205ff0:	68c2      	ldr	r2, [r0, #12]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
  205ff2:	4283      	cmp	r3, r0
    ctp->mtxlist = mp->next;
  205ff4:	638a      	str	r2, [r1, #56]	; 0x38
    if (chMtxQueueNotEmptyS(mp)) {
  205ff6:	d021      	beq.n	20603c <chMtxUnlock+0x58>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
  205ff8:	6bcd      	ldr	r5, [r1, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
  205ffa:	b9b2      	cbnz	r2, 20602a <chMtxUnlock+0x46>
  tqp->next             = tp->queue.next;
  205ffc:	681a      	ldr	r2, [r3, #0]
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
  205ffe:	608d      	str	r5, [r1, #8]
  206000:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  206002:	6050      	str	r0, [r2, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
  206004:	6b9a      	ldr	r2, [r3, #56]	; 0x38
      mp->owner = tp;
  206006:	6083      	str	r3, [r0, #8]
      mp->next = tp->mtxlist;
  206008:	60c2      	str	r2, [r0, #12]
      tp->mtxlist = mp;
  20600a:	6398      	str	r0, [r3, #56]	; 0x38

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
  20600c:	4618      	mov	r0, r3
  20600e:	f7fb f96d 	bl	2012ec <chSchReadyI>
  return firstprio(&ch.rlist.queue) > currp->prio;
  206012:	6822      	ldr	r2, [r4, #0]
  206014:	69a3      	ldr	r3, [r4, #24]
  if (chSchIsRescRequiredI()) {
  206016:	6892      	ldr	r2, [r2, #8]
  206018:	689b      	ldr	r3, [r3, #8]
  20601a:	429a      	cmp	r2, r3
  20601c:	d901      	bls.n	206022 <chMtxUnlock+0x3e>
    chSchDoRescheduleAhead();
  20601e:	f7ff ffb5 	bl	205f8c <chSchDoReschedule>
  206022:	2300      	movs	r3, #0
  206024:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
  206028:	bd70      	pop	{r4, r5, r6, pc}
  return (bool)(tqp->next != (const thread_t *)tqp);
  20602a:	6816      	ldr	r6, [r2, #0]
        if (chMtxQueueNotEmptyS(lmp) &&
  20602c:	42b2      	cmp	r2, r6
  20602e:	d003      	beq.n	206038 <chMtxUnlock+0x54>
  206030:	68b6      	ldr	r6, [r6, #8]
  206032:	42b5      	cmp	r5, r6
  206034:	bf38      	it	cc
  206036:	4635      	movcc	r5, r6
        lmp = lmp->next;
  206038:	68d2      	ldr	r2, [r2, #12]
  20603a:	e7de      	b.n	205ffa <chMtxUnlock+0x16>
      mp->owner = NULL;
  20603c:	2200      	movs	r2, #0
  20603e:	609a      	str	r2, [r3, #8]
  206040:	e7ef      	b.n	206022 <chMtxUnlock+0x3e>
  206042:	bf00      	nop
  206044:	20000e8c 	.word	0x20000e8c

00206048 <__malloc_unlock>:
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
  206048:	4801      	ldr	r0, [pc, #4]	; (206050 <__malloc_unlock+0x8>)
  20604a:	f7ff bfcb 	b.w	205fe4 <chMtxUnlock>
  20604e:	bf00      	nop
  206050:	20002724 	.word	0x20002724

00206054 <gdispGBlitArea>:
	}
	autoflush_stopdone(g);
	MUTEX_EXIT(g);
}

void gdispGBlitArea(GDisplay *g, gCoord x, gCoord y, gCoord cx, gCoord cy, gCoord srcx, gCoord srcy, gCoord srccx, const gPixel *buffer) {
  206054:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	MUTEX_ENTER(g);
  206058:	f100 0a20 	add.w	sl, r0, #32
void gdispGBlitArea(GDisplay *g, gCoord x, gCoord y, gCoord cx, gCoord cy, gCoord srcx, gCoord srcy, gCoord srccx, const gPixel *buffer) {
  20605c:	4604      	mov	r4, r0
  20605e:	460f      	mov	r7, r1
  206060:	461d      	mov	r5, r3
  206062:	f9bd 1038 	ldrsh.w	r1, [sp, #56]	; 0x38
	MUTEX_ENTER(g);
  206066:	4650      	mov	r0, sl
void gdispGBlitArea(GDisplay *g, gCoord x, gCoord y, gCoord cx, gCoord cy, gCoord srcx, gCoord srcy, gCoord srccx, const gPixel *buffer) {
  206068:	9b10      	ldr	r3, [sp, #64]	; 0x40
  20606a:	4616      	mov	r6, r2
  20606c:	9101      	str	r1, [sp, #4]
  20606e:	f9bd 8030 	ldrsh.w	r8, [sp, #48]	; 0x30
  206072:	f9bd 9034 	ldrsh.w	r9, [sp, #52]	; 0x34
  206076:	f9bd b03c 	ldrsh.w	fp, [sp, #60]	; 0x3c
  20607a:	9300      	str	r3, [sp, #0]
	MUTEX_ENTER(g);
  20607c:	f7fe f8d0 	bl	204220 <chMtxLock>
		#if GDISP_HARDWARE_CLIP == HARDWARE_AUTODETECT
			if (!gvmt(g)->setclip)
		#endif
		{
			// This is a different clipping to fillarea(g) as it needs to take into account srcx,srcy
			if (x < g->clipx0) { cx -= g->clipx0 - x; srcx += g->clipx0 - x; x = g->clipx0; }
  206080:	f9b4 0030 	ldrsh.w	r0, [r4, #48]	; 0x30
  206084:	9901      	ldr	r1, [sp, #4]
  206086:	42b8      	cmp	r0, r7
  206088:	dd0c      	ble.n	2060a4 <gdispGBlitArea+0x50>
  20608a:	fa1f fc87 	uxth.w	ip, r7
  20608e:	fa15 f587 	uxtah	r5, r5, r7
  206092:	b282      	uxth	r2, r0
  206094:	4607      	mov	r7, r0
  206096:	eba9 090c 	sub.w	r9, r9, ip
  20609a:	1aad      	subs	r5, r5, r2
  20609c:	4491      	add	r9, r2
  20609e:	b22d      	sxth	r5, r5
  2060a0:	fa0f f989 	sxth.w	r9, r9
			if (y < g->clipy0) { cy -= g->clipy0 - y; srcy += g->clipy0 - x; y = g->clipy0; }
  2060a4:	f9b4 0032 	ldrsh.w	r0, [r4, #50]	; 0x32
  2060a8:	42b0      	cmp	r0, r6
  2060aa:	dd09      	ble.n	2060c0 <gdispGBlitArea+0x6c>
  2060ac:	b283      	uxth	r3, r0
  2060ae:	44b0      	add	r8, r6
  2060b0:	4606      	mov	r6, r0
  2060b2:	eba8 0803 	sub.w	r8, r8, r3
  2060b6:	440b      	add	r3, r1
  2060b8:	1bdb      	subs	r3, r3, r7
  2060ba:	fa0f f888 	sxth.w	r8, r8
  2060be:	b219      	sxth	r1, r3
			if (x+cx > g->clipx1)	cx = g->clipx1 - x;
  2060c0:	197a      	adds	r2, r7, r5
  2060c2:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
  2060c6:	429a      	cmp	r2, r3
			if (y+cy > g->clipy1)	cy = g->clipy1 - y;
  2060c8:	eb06 0208 	add.w	r2, r6, r8
			if (x+cx > g->clipx1)	cx = g->clipx1 - x;
  2060cc:	bfc4      	itt	gt
  2060ce:	1bdb      	subgt	r3, r3, r7
  2060d0:	b21d      	sxthgt	r5, r3
			if (y+cy > g->clipy1)	cy = g->clipy1 - y;
  2060d2:	f9b4 3036 	ldrsh.w	r3, [r4, #54]	; 0x36
  2060d6:	429a      	cmp	r2, r3
  2060d8:	bfc8      	it	gt
  2060da:	eba3 0806 	subgt.w	r8, r3, r6
			if (srcx+cx > srccx) cx = srccx - srcx;
  2060de:	eb09 0305 	add.w	r3, r9, r5
			if (y+cy > g->clipy1)	cy = g->clipy1 - y;
  2060e2:	bfc8      	it	gt
  2060e4:	fa0f f888 	sxthgt.w	r8, r8
			if (srcx+cx > srccx) cx = srccx - srcx;
  2060e8:	455b      	cmp	r3, fp
  2060ea:	bfc4      	itt	gt
  2060ec:	ebab 0509 	subgt.w	r5, fp, r9
  2060f0:	b22d      	sxthgt	r5, r5
			if (cx <= 0 || cy <= 0) { MUTEX_EXIT(g); return; }
  2060f2:	2d00      	cmp	r5, #0
  2060f4:	dd02      	ble.n	2060fc <gdispGBlitArea+0xa8>
  2060f6:	f1b8 0f00 	cmp.w	r8, #0
  2060fa:	dc05      	bgt.n	206108 <gdispGBlitArea+0xb4>
			g->p.y1 = srcy;
			g->p.x2 = srccx;
			g->p.ptr = (void *)buffer;
			gdisp_lld_blit_area(g);
			autoflush_stopdone(g);
			MUTEX_EXIT(g);
  2060fc:	4650      	mov	r0, sl
			autoflush_stopdone(g);
			MUTEX_EXIT(g);
			return;
		}
	#endif
}
  2060fe:	b003      	add	sp, #12
  206100:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			MUTEX_EXIT(g);
  206104:	f7ff bf6e 	b.w	205fe4 <chMtxUnlock>
			g->p.ptr = (void *)buffer;
  206108:	9b00      	ldr	r3, [sp, #0]
			gdisp_lld_blit_area(g);
  20610a:	4620      	mov	r0, r4
			g->p.x = x;
  20610c:	8727      	strh	r7, [r4, #56]	; 0x38
			g->p.y = y;
  20610e:	8766      	strh	r6, [r4, #58]	; 0x3a
			g->p.cx = cx;
  206110:	87a5      	strh	r5, [r4, #60]	; 0x3c
			g->p.cy = cy;
  206112:	f8a4 803e 	strh.w	r8, [r4, #62]	; 0x3e
			g->p.x1 = srcx;
  206116:	f8a4 9040 	strh.w	r9, [r4, #64]	; 0x40
			g->p.y1 = srcy;
  20611a:	f8a4 1042 	strh.w	r1, [r4, #66]	; 0x42
			g->p.x2 = srccx;
  20611e:	f8a4 b044 	strh.w	fp, [r4, #68]	; 0x44
			g->p.ptr = (void *)buffer;
  206122:	64e3      	str	r3, [r4, #76]	; 0x4c
			gdisp_lld_blit_area(g);
  206124:	f7fa fbe8 	bl	2008f8 <gdisp_lld_blit_area>
  206128:	e7e8      	b.n	2060fc <gdispGBlitArea+0xa8>

0020612a <gdispGImageDraw_NATIVE>:
gdispImageError gdispGImageDraw_NATIVE(GDisplay *g, gdispImage *img, gCoord x, gCoord y, gCoord cx, gCoord cy, gCoord sx, gCoord sy) {
  20612a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  20612e:	b08b      	sub	sp, #44	; 0x2c
  206130:	4681      	mov	r9, r0
  206132:	4692      	mov	sl, r2
	if (sx >= img->width || sy >= img->height) return GDISP_IMAGE_ERR_OK;
  206134:	f9b1 0006 	ldrsh.w	r0, [r1, #6]
gdispImageError gdispGImageDraw_NATIVE(GDisplay *g, gdispImage *img, gCoord x, gCoord y, gCoord cx, gCoord cy, gCoord sx, gCoord sy) {
  206138:	f9bd 2058 	ldrsh.w	r2, [sp, #88]	; 0x58
  20613c:	461d      	mov	r5, r3
  20613e:	460e      	mov	r6, r1
  206140:	f9bd 8050 	ldrsh.w	r8, [sp, #80]	; 0x50
	if (sx >= img->width || sy >= img->height) return GDISP_IMAGE_ERR_OK;
  206144:	4290      	cmp	r0, r2
gdispImageError gdispGImageDraw_NATIVE(GDisplay *g, gdispImage *img, gCoord x, gCoord y, gCoord cx, gCoord cy, gCoord sx, gCoord sy) {
  206146:	f9bd 3054 	ldrsh.w	r3, [sp, #84]	; 0x54
  20614a:	f9bd 405c 	ldrsh.w	r4, [sp, #92]	; 0x5c
	if (sx >= img->width || sy >= img->height) return GDISP_IMAGE_ERR_OK;
  20614e:	dc03      	bgt.n	206158 <gdispGImageDraw_NATIVE+0x2e>
		return GDISP_IMAGE_ERR_OK;
  206150:	2000      	movs	r0, #0
}
  206152:	b00b      	add	sp, #44	; 0x2c
  206154:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (sx >= img->width || sy >= img->height) return GDISP_IMAGE_ERR_OK;
  206158:	f9b1 1008 	ldrsh.w	r1, [r1, #8]
  20615c:	42a1      	cmp	r1, r4
  20615e:	ddf7      	ble.n	206150 <gdispGImageDraw_NATIVE+0x26>
	if (sx + cx > img->width) cx = img->width - sx;
  206160:	eb02 0708 	add.w	r7, r2, r8
  206164:	4287      	cmp	r7, r0
	if (sy + cy > img->height) cy = img->height - sy;
  206166:	eb04 0703 	add.w	r7, r4, r3
	if (sx + cx > img->width) cx = img->width - sx;
  20616a:	bfc4      	itt	gt
  20616c:	eba0 0802 	subgt.w	r8, r0, r2
  206170:	fa0f f888 	sxthgt.w	r8, r8
	if (sy + cy > img->height) cy = img->height - sy;
  206174:	428f      	cmp	r7, r1
  206176:	bfc8      	it	gt
  206178:	1b0b      	subgt	r3, r1, r4
	priv = (gdispImagePrivate_NATIVE *)img->priv;
  20617a:	6971      	ldr	r1, [r6, #20]
	if (priv->frame0cache) {
  20617c:	680f      	ldr	r7, [r1, #0]
	if (sy + cy > img->height) cy = img->height - sy;
  20617e:	bfc8      	it	gt
  206180:	b21b      	sxthgt	r3, r3
	if (priv->frame0cache) {
  206182:	b15f      	cbz	r7, 20619c <gdispGImageDraw_NATIVE+0x72>
		gdispGBlitArea(g, x, y, cx, cy, sx, sy, img->width, priv->frame0cache);
  206184:	9300      	str	r3, [sp, #0]
  206186:	4651      	mov	r1, sl
  206188:	4643      	mov	r3, r8
  20618a:	e9cd 0703 	strd	r0, r7, [sp, #12]
  20618e:	e9cd 2401 	strd	r2, r4, [sp, #4]
  206192:	4648      	mov	r0, r9
  206194:	462a      	mov	r2, r5
  206196:	f7ff ff5d 	bl	206054 <gdispGBlitArea>
  20619a:	e7d9      	b.n	206150 <gdispGImageDraw_NATIVE+0x26>
	pos = FRAME0POS_NATIVE + (img->width * sy + sx) * sizeof(gPixel);
  20619c:	fb00 2404 	mla	r4, r0, r4, r2
  2061a0:	442b      	add	r3, r5
  2061a2:	3404      	adds	r4, #4
  2061a4:	b21b      	sxth	r3, r3
  2061a6:	0064      	lsls	r4, r4, #1
	for(;cy;cy--, y++) {
  2061a8:	9309      	str	r3, [sp, #36]	; 0x24
						priv->buf,
  2061aa:	1d0b      	adds	r3, r1, #4
  2061ac:	9308      	str	r3, [sp, #32]
	for(;cy;cy--, y++) {
  2061ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
  2061b0:	429d      	cmp	r5, r3
  2061b2:	d0cd      	beq.n	206150 <gdispGImageDraw_NATIVE+0x26>
		for(mx = x, mcx = cx; mcx > 0; mcx -= len, mx += len) {
  2061b4:	4647      	mov	r7, r8
  2061b6:	46d3      	mov	fp, sl
		gfileSetPos(img->f, pos);
  2061b8:	4621      	mov	r1, r4
  2061ba:	68f0      	ldr	r0, [r6, #12]
  2061bc:	f7fa fcbc 	bl	200b38 <gfileSetPos>
		for(mx = x, mcx = cx; mcx > 0; mcx -= len, mx += len) {
  2061c0:	2f00      	cmp	r7, #0
  2061c2:	dc06      	bgt.n	2061d2 <gdispGImageDraw_NATIVE+0xa8>
		pos += img->width*sizeof(gPixel);
  2061c4:	f9b6 3006 	ldrsh.w	r3, [r6, #6]
  2061c8:	3501      	adds	r5, #1
  2061ca:	eb04 0443 	add.w	r4, r4, r3, lsl #1
  2061ce:	b22d      	sxth	r5, r5
  2061d0:	e7ed      	b.n	2061ae <gdispGImageDraw_NATIVE+0x84>
			len = gfileRead(img->f,
  2061d2:	2f20      	cmp	r7, #32
  2061d4:	68f0      	ldr	r0, [r6, #12]
  2061d6:	9908      	ldr	r1, [sp, #32]
  2061d8:	bfd4      	ite	le
  2061da:	007a      	lslle	r2, r7, #1
  2061dc:	2240      	movgt	r2, #64	; 0x40
  2061de:	f7fa fcc8 	bl	200b72 <gfileRead>
			if (!len)
  2061e2:	2801      	cmp	r0, #1
			len = gfileRead(img->f,
  2061e4:	ea4f 0350 	mov.w	r3, r0, lsr #1
  2061e8:	9307      	str	r3, [sp, #28]
			if (!len)
  2061ea:	d916      	bls.n	20621a <gdispGImageDraw_NATIVE+0xf0>
			gdispGBlitArea(g, mx, y, len, 1, 0, 0, len, priv->buf);
  2061ec:	f9bd 301c 	ldrsh.w	r3, [sp, #28]
  2061f0:	4659      	mov	r1, fp
  2061f2:	9a08      	ldr	r2, [sp, #32]
  2061f4:	4648      	mov	r0, r9
  2061f6:	e9cd 3203 	strd	r3, r2, [sp, #12]
  2061fa:	2200      	movs	r2, #0
  2061fc:	e9cd 2201 	strd	r2, r2, [sp, #4]
  206200:	2201      	movs	r2, #1
  206202:	9200      	str	r2, [sp, #0]
  206204:	462a      	mov	r2, r5
  206206:	f7ff ff25 	bl	206054 <gdispGBlitArea>
		for(mx = x, mcx = cx; mcx > 0; mcx -= len, mx += len) {
  20620a:	f8bd 301c 	ldrh.w	r3, [sp, #28]
  20620e:	1aff      	subs	r7, r7, r3
  206210:	449b      	add	fp, r3
  206212:	b23f      	sxth	r7, r7
  206214:	fa0f fb8b 	sxth.w	fp, fp
  206218:	e7d2      	b.n	2061c0 <gdispGImageDraw_NATIVE+0x96>
				return GDISP_IMAGE_ERR_BADDATA;
  20621a:	f248 0002 	movw	r0, #32770	; 0x8002
  20621e:	e798      	b.n	206152 <gdispGImageDraw_NATIVE+0x28>

00206220 <gdispGFillArea>:
void gdispGFillArea(GDisplay *g, gCoord x, gCoord y, gCoord cx, gCoord cy, gColor color) {
  206220:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	MUTEX_ENTER(g);
  206224:	f100 0820 	add.w	r8, r0, #32
void gdispGFillArea(GDisplay *g, gCoord x, gCoord y, gCoord cx, gCoord cy, gColor color) {
  206228:	4604      	mov	r4, r0
  20622a:	460d      	mov	r5, r1
  20622c:	4617      	mov	r7, r2
	MUTEX_ENTER(g);
  20622e:	4640      	mov	r0, r8
void gdispGFillArea(GDisplay *g, gCoord x, gCoord y, gCoord cx, gCoord cy, gColor color) {
  206230:	f9bd 6020 	ldrsh.w	r6, [sp, #32]
  206234:	4699      	mov	r9, r3
  206236:	f8bd a024 	ldrh.w	sl, [sp, #36]	; 0x24
	MUTEX_ENTER(g);
  20623a:	f7fd fff1 	bl	204220 <chMtxLock>
	TEST_CLIP_AREA(g) {
  20623e:	f9b4 2030 	ldrsh.w	r2, [r4, #48]	; 0x30
	g->p.x = x;
  206242:	8725      	strh	r5, [r4, #56]	; 0x38
	TEST_CLIP_AREA(g) {
  206244:	42aa      	cmp	r2, r5
	g->p.cx = cx;
  206246:	f8a4 903c 	strh.w	r9, [r4, #60]	; 0x3c
	g->p.cy = cy;
  20624a:	87e6      	strh	r6, [r4, #62]	; 0x3e
	TEST_CLIP_AREA(g) {
  20624c:	bfc4      	itt	gt
  20624e:	eb05 0309 	addgt.w	r3, r5, r9
  206252:	8722      	strhgt	r2, [r4, #56]	; 0x38
  206254:	f9b4 1038 	ldrsh.w	r1, [r4, #56]	; 0x38
  206258:	bfc8      	it	gt
  20625a:	1a9d      	subgt	r5, r3, r2
  20625c:	f9b4 3032 	ldrsh.w	r3, [r4, #50]	; 0x32
	g->p.y = y;
  206260:	8767      	strh	r7, [r4, #58]	; 0x3a
	TEST_CLIP_AREA(g) {
  206262:	bfc8      	it	gt
  206264:	87a5      	strhgt	r5, [r4, #60]	; 0x3c
  206266:	42bb      	cmp	r3, r7
  206268:	f9b4 203c 	ldrsh.w	r2, [r4, #60]	; 0x3c
  20626c:	bfc4      	itt	gt
  20626e:	19f6      	addgt	r6, r6, r7
  206270:	8763      	strhgt	r3, [r4, #58]	; 0x3a
  206272:	440a      	add	r2, r1
	g->p.color = color;
  206274:	f8a4 a048 	strh.w	sl, [r4, #72]	; 0x48
	TEST_CLIP_AREA(g) {
  206278:	bfc8      	it	gt
  20627a:	1af6      	subgt	r6, r6, r3
  20627c:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
  206280:	bfc8      	it	gt
  206282:	87e6      	strhgt	r6, [r4, #62]	; 0x3e
  206284:	429a      	cmp	r2, r3
  206286:	f9b4 203e 	ldrsh.w	r2, [r4, #62]	; 0x3e
  20628a:	bfc8      	it	gt
  20628c:	1a5b      	subgt	r3, r3, r1
  20628e:	f9b4 103a 	ldrsh.w	r1, [r4, #58]	; 0x3a
  206292:	bfc8      	it	gt
  206294:	87a3      	strhgt	r3, [r4, #60]	; 0x3c
  206296:	440a      	add	r2, r1
  206298:	f9b4 3036 	ldrsh.w	r3, [r4, #54]	; 0x36
  20629c:	429a      	cmp	r2, r3
  20629e:	bfc4      	itt	gt
  2062a0:	1a5b      	subgt	r3, r3, r1
  2062a2:	87e3      	strhgt	r3, [r4, #62]	; 0x3e
  2062a4:	f9b4 303c 	ldrsh.w	r3, [r4, #60]	; 0x3c
  2062a8:	2b00      	cmp	r3, #0
  2062aa:	dd06      	ble.n	2062ba <gdispGFillArea+0x9a>
  2062ac:	f9b4 303e 	ldrsh.w	r3, [r4, #62]	; 0x3e
  2062b0:	2b00      	cmp	r3, #0
  2062b2:	dd02      	ble.n	2062ba <gdispGFillArea+0x9a>
			gdisp_lld_fill_area(g);
  2062b4:	4620      	mov	r0, r4
  2062b6:	f7fa fb6b 	bl	200990 <gdisp_lld_fill_area>
	MUTEX_EXIT(g);
  2062ba:	4640      	mov	r0, r8
}
  2062bc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	MUTEX_EXIT(g);
  2062c0:	f7ff be90 	b.w	205fe4 <chMtxUnlock>

002062c4 <gdispGDrawPixel>:
void gdispGDrawPixel(GDisplay *g, gCoord x, gCoord y, gColor color) {
  2062c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	MUTEX_ENTER(g);
  2062c8:	f100 0820 	add.w	r8, r0, #32
void gdispGDrawPixel(GDisplay *g, gCoord x, gCoord y, gColor color) {
  2062cc:	4604      	mov	r4, r0
  2062ce:	460e      	mov	r6, r1
  2062d0:	461f      	mov	r7, r3
	MUTEX_ENTER(g);
  2062d2:	4640      	mov	r0, r8
void gdispGDrawPixel(GDisplay *g, gCoord x, gCoord y, gColor color) {
  2062d4:	4615      	mov	r5, r2
	MUTEX_ENTER(g);
  2062d6:	f7fd ffa3 	bl	204220 <chMtxLock>
			if (g->p.x < g->clipx0 || g->p.x >= g->clipx1 || g->p.y < g->clipy0 || g->p.y >= g->clipy1)
  2062da:	f9b4 3030 	ldrsh.w	r3, [r4, #48]	; 0x30
	g->p.x		= x;
  2062de:	8726      	strh	r6, [r4, #56]	; 0x38
			if (g->p.x < g->clipx0 || g->p.x >= g->clipx1 || g->p.y < g->clipy0 || g->p.y >= g->clipy1)
  2062e0:	42b3      	cmp	r3, r6
	g->p.y		= y;
  2062e2:	8765      	strh	r5, [r4, #58]	; 0x3a
	g->p.color	= color;
  2062e4:	f8a4 7048 	strh.w	r7, [r4, #72]	; 0x48
			if (g->p.x < g->clipx0 || g->p.x >= g->clipx1 || g->p.y < g->clipy0 || g->p.y >= g->clipy1)
  2062e8:	dc0e      	bgt.n	206308 <gdispGDrawPixel+0x44>
  2062ea:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
  2062ee:	42b3      	cmp	r3, r6
  2062f0:	dd0a      	ble.n	206308 <gdispGDrawPixel+0x44>
  2062f2:	f9b4 3032 	ldrsh.w	r3, [r4, #50]	; 0x32
  2062f6:	42ab      	cmp	r3, r5
  2062f8:	dc06      	bgt.n	206308 <gdispGDrawPixel+0x44>
  2062fa:	f9b4 3036 	ldrsh.w	r3, [r4, #54]	; 0x36
  2062fe:	42ab      	cmp	r3, r5
  206300:	dd02      	ble.n	206308 <gdispGDrawPixel+0x44>
			gdisp_lld_draw_pixel(g);
  206302:	4620      	mov	r0, r4
  206304:	f7fa fb7c 	bl	200a00 <gdisp_lld_draw_pixel>
	MUTEX_EXIT(g);
  206308:	4640      	mov	r0, r8
}
  20630a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	MUTEX_EXIT(g);
  20630e:	f7ff be69 	b.w	205fe4 <chMtxUnlock>

00206312 <gdispGImageDraw_GIF>:
gdispImageError gdispGImageDraw_GIF(GDisplay *g, gdispImage *img, gCoord x, gCoord y, gCoord cx, gCoord cy, gCoord sx, gCoord sy) {
  206312:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	priv = (gdispImagePrivate_GIF *)img->priv;
  206316:	694c      	ldr	r4, [r1, #20]
gdispImageError gdispGImageDraw_GIF(GDisplay *g, gdispImage *img, gCoord x, gCoord y, gCoord cx, gCoord cy, gCoord sx, gCoord sy) {
  206318:	4605      	mov	r5, r0
  20631a:	461e      	mov	r6, r3
  20631c:	ed2d 8b02 	vpush	{d8}
	if (priv->dispose.flags & (GIFL_DISPOSECLEAR|GIFL_DISPOSEREST)) {
  206320:	f894 c03c 	ldrb.w	ip, [r4, #60]	; 0x3c
gdispImageError gdispGImageDraw_GIF(GDisplay *g, gdispImage *img, gCoord x, gCoord y, gCoord cx, gCoord cy, gCoord sx, gCoord sy) {
  206324:	b09b      	sub	sp, #108	; 0x6c
  206326:	ee08 1a10 	vmov	s16, r1
	if (priv->dispose.flags & (GIFL_DISPOSECLEAR|GIFL_DISPOSEREST)) {
  20632a:	f01c 0f06 	tst.w	ip, #6
gdispImageError gdispGImageDraw_GIF(GDisplay *g, gdispImage *img, gCoord x, gCoord y, gCoord cx, gCoord cy, gCoord sx, gCoord sy) {
  20632e:	f9bd b098 	ldrsh.w	fp, [sp, #152]	; 0x98
  206332:	f9bd 909c 	ldrsh.w	r9, [sp, #156]	; 0x9c
  206336:	f9bd 80a0 	ldrsh.w	r8, [sp, #160]	; 0xa0
  20633a:	f9bd 70a4 	ldrsh.w	r7, [sp, #164]	; 0xa4
  20633e:	920a      	str	r2, [sp, #40]	; 0x28
	if (priv->dispose.flags & (GIFL_DISPOSECLEAR|GIFL_DISPOSEREST)) {
  206340:	d047      	beq.n	2063d2 <gdispGImageDraw_GIF+0xc0>
		mx = priv->dispose.x;
  206342:	f9b4 a03e 	ldrsh.w	sl, [r4, #62]	; 0x3e
		fy = priv->dispose.y+priv->dispose.height;
  206346:	f8b4 0044 	ldrh.w	r0, [r4, #68]	; 0x44
		my = priv->dispose.y;
  20634a:	f9b4 e040 	ldrsh.w	lr, [r4, #64]	; 0x40
		fx = priv->dispose.x+priv->dispose.width;
  20634e:	45c2      	cmp	sl, r8
  206350:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
		fy = priv->dispose.y+priv->dispose.height;
  206354:	eb0e 0200 	add.w	r2, lr, r0
		fx = priv->dispose.x+priv->dispose.width;
  206358:	4453      	add	r3, sl
  20635a:	bfb8      	it	lt
  20635c:	46c2      	movlt	sl, r8
		fy = priv->dispose.y+priv->dispose.height;
  20635e:	b210      	sxth	r0, r2
		if (sx+cx <= fx) fx = sx+cx;
  206360:	eb08 020b 	add.w	r2, r8, fp
		fx = priv->dispose.x+priv->dispose.width;
  206364:	b21b      	sxth	r3, r3
		if (sx+cx <= fx) fx = sx+cx;
  206366:	429a      	cmp	r2, r3
  206368:	bfd8      	it	le
  20636a:	b213      	sxthle	r3, r2
		if (sy+cy <= fy) fy = sy+cy;
  20636c:	eb07 0209 	add.w	r2, r7, r9
  206370:	4282      	cmp	r2, r0
  206372:	bfd8      	it	le
  206374:	b210      	sxthle	r0, r2
		if (fx > mx && fy > my) {
  206376:	459a      	cmp	sl, r3
  206378:	da2b      	bge.n	2063d2 <gdispGImageDraw_GIF+0xc0>
  20637a:	45be      	cmp	lr, r7
  20637c:	bfb8      	it	lt
  20637e:	46be      	movlt	lr, r7
  206380:	4586      	cmp	lr, r0
  206382:	da26      	bge.n	2063d2 <gdispGImageDraw_GIF+0xc0>
			if (((priv->dispose.flags & GIFL_TRANSPARENT) /*&& priv->dispose.paltrans == priv->bgcolor*/) || priv->bgcolor >= priv->palsize)
  206384:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  206386:	eba3 030a 	sub.w	r3, r3, sl
  20638a:	eba0 000e 	sub.w	r0, r0, lr
  20638e:	f01c 0f01 	tst.w	ip, #1
  206392:	eba2 0108 	sub.w	r1, r2, r8
  206396:	eba6 0207 	sub.w	r2, r6, r7
  20639a:	b21b      	sxth	r3, r3
  20639c:	fa11 f18a 	uxtah	r1, r1, sl
  2063a0:	fa12 f28e 	uxtah	r2, r2, lr
  2063a4:	ee07 3a90 	vmov	s15, r3
  2063a8:	b200      	sxth	r0, r0
  2063aa:	b209      	sxth	r1, r1
  2063ac:	b212      	sxth	r2, r2
  2063ae:	d105      	bne.n	2063bc <gdispGImageDraw_GIF+0xaa>
  2063b0:	f894 c001 	ldrb.w	ip, [r4, #1]
  2063b4:	f8b4 a004 	ldrh.w	sl, [r4, #4]
  2063b8:	45e2      	cmp	sl, ip
  2063ba:	d81e      	bhi.n	2063fa <gdispGImageDraw_GIF+0xe8>
				gdispGFillArea(g, x+mx-sx, y+my-sy, fx-mx, fy-my, img->bgcolor);
  2063bc:	ee18 3a10 	vmov	r3, s16
  2063c0:	f8b3 c004 	ldrh.w	ip, [r3, #4]
				gdispGFillArea(g, x+mx-sx, y+my-sy, fx-mx, fy-my, priv->palette[priv->bgcolor]);
  2063c4:	ee17 3a90 	vmov	r3, s15
  2063c8:	e9cd 0c00 	strd	r0, ip, [sp]
  2063cc:	4628      	mov	r0, r5
  2063ce:	f7ff ff27 	bl	206220 <gdispGFillArea>
	fx = priv->frame.x+priv->frame.width;
  2063d2:	8ba2      	ldrh	r2, [r4, #28]
  2063d4:	f9b4 c020 	ldrsh.w	ip, [r4, #32]
  2063d8:	f9b4 301c 	ldrsh.w	r3, [r4, #28]
  2063dc:	eb02 000c 	add.w	r0, r2, ip
  2063e0:	9208      	str	r2, [sp, #32]
  2063e2:	fa1f fa80 	uxth.w	sl, r0
  2063e6:	b200      	sxth	r0, r0
	if (sx >= fx || sy >= fy || sx+cx < priv->frame.x || sy+cy < priv->frame.y) return GDISP_IMAGE_ERR_OK;
  2063e8:	4580      	cmp	r8, r0
  2063ea:	db0a      	blt.n	206402 <gdispGImageDraw_GIF+0xf0>
  2063ec:	2700      	movs	r7, #0
}
  2063ee:	4638      	mov	r0, r7
  2063f0:	b01b      	add	sp, #108	; 0x6c
  2063f2:	ecbd 8b02 	vpop	{d8}
  2063f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				gdispGFillArea(g, x+mx-sx, y+my-sy, fx-mx, fy-my, priv->palette[priv->bgcolor]);
  2063fa:	68a3      	ldr	r3, [r4, #8]
  2063fc:	f833 c01c 	ldrh.w	ip, [r3, ip, lsl #1]
  206400:	e7e0      	b.n	2063c4 <gdispGImageDraw_GIF+0xb2>
	fy = priv->frame.y+priv->frame.height;
  206402:	8be2      	ldrh	r2, [r4, #30]
  206404:	8c61      	ldrh	r1, [r4, #34]	; 0x22
  206406:	920b      	str	r2, [sp, #44]	; 0x2c
  206408:	4411      	add	r1, r2
  20640a:	f9b4 e01e 	ldrsh.w	lr, [r4, #30]
  20640e:	b28a      	uxth	r2, r1
  206410:	920c      	str	r2, [sp, #48]	; 0x30
  206412:	b20a      	sxth	r2, r1
	if (sx >= fx || sy >= fy || sx+cx < priv->frame.x || sy+cy < priv->frame.y) return GDISP_IMAGE_ERR_OK;
  206414:	4297      	cmp	r7, r2
	fy = priv->frame.y+priv->frame.height;
  206416:	9207      	str	r2, [sp, #28]
	if (sx >= fx || sy >= fy || sx+cx < priv->frame.x || sy+cy < priv->frame.y) return GDISP_IMAGE_ERR_OK;
  206418:	dae8      	bge.n	2063ec <gdispGImageDraw_GIF+0xda>
  20641a:	eb08 020b 	add.w	r2, r8, fp
  20641e:	429a      	cmp	r2, r3
  206420:	dbe4      	blt.n	2063ec <gdispGImageDraw_GIF+0xda>
  206422:	eb07 0209 	add.w	r2, r7, r9
  206426:	4572      	cmp	r2, lr
  206428:	dbe0      	blt.n	2063ec <gdispGImageDraw_GIF+0xda>
	if (sx < priv->frame.x) { mx = priv->frame.x - sx; x += mx; cx -= mx; sx = priv->frame.x; }
  20642a:	4543      	cmp	r3, r8
  20642c:	dd10      	ble.n	206450 <gdispGImageDraw_GIF+0x13e>
  20642e:	fa1f f888 	uxth.w	r8, r8
  206432:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  206434:	eba2 0208 	sub.w	r2, r2, r8
  206438:	44d8      	add	r8, fp
  20643a:	4611      	mov	r1, r2
  20643c:	9a08      	ldr	r2, [sp, #32]
  20643e:	4411      	add	r1, r2
  206440:	b20a      	sxth	r2, r1
  206442:	920a      	str	r2, [sp, #40]	; 0x28
  206444:	9a08      	ldr	r2, [sp, #32]
  206446:	eba8 0802 	sub.w	r8, r8, r2
  20644a:	fa0f fb88 	sxth.w	fp, r8
  20644e:	4698      	mov	r8, r3
	if (sy < priv->frame.y) { my = priv->frame.y - sy; y += my; cy -= my; sy = priv->frame.y; }
  206450:	45be      	cmp	lr, r7
  206452:	dd0a      	ble.n	20646a <gdispGImageDraw_GIF+0x158>
  206454:	b2bf      	uxth	r7, r7
  206456:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  206458:	1bf6      	subs	r6, r6, r7
  20645a:	44b9      	add	r9, r7
  20645c:	4677      	mov	r7, lr
  20645e:	441e      	add	r6, r3
  206460:	eba9 0903 	sub.w	r9, r9, r3
  206464:	b236      	sxth	r6, r6
  206466:	fa0f f989 	sxth.w	r9, r9
	if (sx+cx > fx) cx = fx-sx;
  20646a:	fa1f f388 	uxth.w	r3, r8
  20646e:	44d8      	add	r8, fp
	sx -= priv->frame.x; sy -= priv->frame.y;
  206470:	990b      	ldr	r1, [sp, #44]	; 0x2c
	if (sx+cx > fx) cx = fx-sx;
  206472:	4580      	cmp	r8, r0
  206474:	9309      	str	r3, [sp, #36]	; 0x24
  206476:	bfc8      	it	gt
  206478:	ebaa 0a03 	subgt.w	sl, sl, r3
  20647c:	b2bb      	uxth	r3, r7
	if (sy+cy > fy) cy = fy-sy;
  20647e:	444f      	add	r7, r9
  206480:	930f      	str	r3, [sp, #60]	; 0x3c
	if (sx+cx > fx) cx = fx-sx;
  206482:	bfc8      	it	gt
  206484:	fa0f fb8a 	sxthgt.w	fp, sl
	if (sy+cy > fy) cy = fy-sy;
  206488:	9b07      	ldr	r3, [sp, #28]
	if (priv->curcache) {
  20648a:	f8d4 a014 	ldr.w	sl, [r4, #20]
	if (sy+cy > fy) cy = fy-sy;
  20648e:	429f      	cmp	r7, r3
  206490:	bfc2      	ittt	gt
  206492:	9b0c      	ldrgt	r3, [sp, #48]	; 0x30
  206494:	9a0f      	ldrgt	r2, [sp, #60]	; 0x3c
  206496:	eba3 0902 	subgt.w	r9, r3, r2
	sx -= priv->frame.x; sy -= priv->frame.y;
  20649a:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
	if (sy+cy > fy) cy = fy-sy;
  20649e:	bfc8      	it	gt
  2064a0:	fa0f f989 	sxthgt.w	r9, r9
	sx -= priv->frame.x; sy -= priv->frame.y;
  2064a4:	1a9b      	subs	r3, r3, r2
  2064a6:	b21a      	sxth	r2, r3
	fx = sx + cx;
  2064a8:	fa1b f383 	uxtah	r3, fp, r3
	sx -= priv->frame.x; sy -= priv->frame.y;
  2064ac:	920d      	str	r2, [sp, #52]	; 0x34
  2064ae:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  2064b0:	1a52      	subs	r2, r2, r1
  2064b2:	b211      	sxth	r1, r2
	fy = sy + cy;
  2064b4:	fa19 f982 	uxtah	r9, r9, r2
	sx -= priv->frame.x; sy -= priv->frame.y;
  2064b8:	910c      	str	r1, [sp, #48]	; 0x30
	fx = sx + cx;
  2064ba:	b299      	uxth	r1, r3
  2064bc:	b21b      	sxth	r3, r3
  2064be:	9111      	str	r1, [sp, #68]	; 0x44
  2064c0:	930e      	str	r3, [sp, #56]	; 0x38
	fy = sy + cy;
  2064c2:	fa0f f389 	sxth.w	r3, r9
  2064c6:	9310      	str	r3, [sp, #64]	; 0x40
	if (priv->curcache) {
  2064c8:	f1ba 0f00 	cmp.w	sl, #0
  2064cc:	f000 80a9 	beq.w	206622 <gdispGImageDraw_GIF+0x310>
		q = cache->imagebits+priv->frame.width*sy+sx;
  2064d0:	b2b6      	uxth	r6, r6
  2064d2:	e9dd 320c 	ldrd	r3, r2, [sp, #48]	; 0x30
  2064d6:	fb0c 2c03 	mla	ip, ip, r3, r2
  2064da:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
  2064de:	9a08      	ldr	r2, [sp, #32]
  2064e0:	4463      	add	r3, ip
  2064e2:	9307      	str	r3, [sp, #28]
		for(my=sy; my < fy; my++, q += priv->frame.width - cx) {
  2064e4:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
  2064e8:	930f      	str	r3, [sp, #60]	; 0x3c
  2064ea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  2064ec:	fa12 f283 	uxtah	r2, r2, r3
  2064f0:	b293      	uxth	r3, r2
  2064f2:	9312      	str	r3, [sp, #72]	; 0x48
  2064f4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  2064f6:	9a10      	ldr	r2, [sp, #64]	; 0x40
  2064f8:	4293      	cmp	r3, r2
  2064fa:	f6bf af77 	bge.w	2063ec <gdispGImageDraw_GIF+0xda>
  2064fe:	9b07      	ldr	r3, [sp, #28]
			for(gcnt=0, mx=sx, cnt=0; mx < fx; mx++) {
  206500:	2100      	movs	r1, #0
		for(my=sy; my < fy; my++, q += priv->frame.width - cx) {
  206502:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
					gdispGBlitArea(g, x+mx-sx-gcnt+1, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);
  206504:	b232      	sxth	r2, r6
		for(my=sy; my < fy; my++, q += priv->frame.width - cx) {
  206506:	930a      	str	r3, [sp, #40]	; 0x28
					gdispGBlitArea(g, x+mx-sx-gcnt+1, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);
  206508:	f104 0346 	add.w	r3, r4, #70	; 0x46
			for(gcnt=0, mx=sx, cnt=0; mx < fx; mx++) {
  20650c:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
					gdispGBlitArea(g, x+mx-sx-gcnt+1, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);
  206510:	4689      	mov	r9, r1
  206512:	930b      	str	r3, [sp, #44]	; 0x2c
  206514:	e01e      	b.n	206554 <gdispGImageDraw_GIF+0x242>
				col = *q++;
  206516:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  206518:	f813 cb01 	ldrb.w	ip, [r3], #1
  20651c:	930a      	str	r3, [sp, #40]	; 0x28
				if ((priv->frame.flags & GIFL_TRANSPARENT) && col == priv->frame.paltrans) {
  20651e:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
  206522:	07d8      	lsls	r0, r3, #31
  206524:	d555      	bpl.n	2065d2 <gdispGImageDraw_GIF+0x2c0>
  206526:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
  20652a:	4563      	cmp	r3, ip
  20652c:	d151      	bne.n	2065d2 <gdispGImageDraw_GIF+0x2c0>
					switch(gcnt) {
  20652e:	b159      	cbz	r1, 206548 <gdispGImageDraw_GIF+0x236>
  206530:	2901      	cmp	r1, #1
  206532:	d13f      	bne.n	2065b4 <gdispGImageDraw_GIF+0x2a2>
					case 1:		gdispGDrawPixel(g, x+mx-sx-gcnt, y+my-sy, priv->buf[0]); gcnt = 0;					break;
  206534:	1e79      	subs	r1, r7, #1
  206536:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
  20653a:	4628      	mov	r0, r5
  20653c:	9213      	str	r2, [sp, #76]	; 0x4c
  20653e:	b209      	sxth	r1, r1
  206540:	f7ff fec0 	bl	2062c4 <gdispGDrawPixel>
					gcnt = 0;
  206544:	2100      	movs	r1, #0
  206546:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  206548:	f108 0801 	add.w	r8, r8, #1
  20654c:	3701      	adds	r7, #1
  20654e:	fa0f f888 	sxth.w	r8, r8
  206552:	b2bf      	uxth	r7, r7
			for(gcnt=0, mx=sx, cnt=0; mx < fx; mx++) {
  206554:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  206556:	4598      	cmp	r8, r3
  206558:	dbdd      	blt.n	206516 <gdispGImageDraw_GIF+0x204>
  20655a:	e9dd 3208 	ldrd	r3, r2, [sp, #32]
  20655e:	1a9f      	subs	r7, r3, r2
  206560:	9b11      	ldr	r3, [sp, #68]	; 0x44
  206562:	441f      	add	r7, r3
  206564:	e9dd 320d 	ldrd	r3, r2, [sp, #52]	; 0x34
  206568:	b2bf      	uxth	r7, r7
  20656a:	4293      	cmp	r3, r2
  20656c:	bfc8      	it	gt
  20656e:	2700      	movgt	r7, #0
  206570:	19d8      	adds	r0, r3, r7
  206572:	b200      	sxth	r0, r0
			switch(gcnt) {
  206574:	b179      	cbz	r1, 206596 <gdispGImageDraw_GIF+0x284>
  206576:	2901      	cmp	r1, #1
  206578:	b232      	sxth	r2, r6
  20657a:	d13a      	bne.n	2065f2 <gdispGImageDraw_GIF+0x2e0>
			case 1:		gdispGDrawPixel(g, x+mx-sx-gcnt, y+my-sy, priv->buf[0]);					break;
  20657c:	9b08      	ldr	r3, [sp, #32]
  20657e:	1e59      	subs	r1, r3, #1
  206580:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  206582:	4419      	add	r1, r3
  206584:	9b09      	ldr	r3, [sp, #36]	; 0x24
  206586:	1ac9      	subs	r1, r1, r3
  206588:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
  20658c:	4401      	add	r1, r0
  20658e:	4628      	mov	r0, r5
  206590:	b209      	sxth	r1, r1
  206592:	f7ff fe97 	bl	2062c4 <gdispGDrawPixel>
  206596:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  206598:	3601      	adds	r6, #1
  20659a:	3301      	adds	r3, #1
  20659c:	b2b6      	uxth	r6, r6
  20659e:	b21b      	sxth	r3, r3
  2065a0:	930c      	str	r3, [sp, #48]	; 0x30
		for(my=sy; my < fy; my++, q += priv->frame.width - cx) {
  2065a2:	f9b4 3020 	ldrsh.w	r3, [r4, #32]
  2065a6:	eba3 030b 	sub.w	r3, r3, fp
  2065aa:	441f      	add	r7, r3
  2065ac:	9b07      	ldr	r3, [sp, #28]
  2065ae:	443b      	add	r3, r7
  2065b0:	9307      	str	r3, [sp, #28]
  2065b2:	e79f      	b.n	2064f4 <gdispGImageDraw_GIF+0x1e2>
					default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  2065b4:	b20b      	sxth	r3, r1
					gdispGBlitArea(g, x+mx-sx-gcnt+1, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);
  2065b6:	980b      	ldr	r0, [sp, #44]	; 0x2c
  2065b8:	1a79      	subs	r1, r7, r1
  2065ba:	9213      	str	r2, [sp, #76]	; 0x4c
  2065bc:	b209      	sxth	r1, r1
  2065be:	e9cd 3003 	strd	r3, r0, [sp, #12]
  2065c2:	2001      	movs	r0, #1
  2065c4:	e9cd 9901 	strd	r9, r9, [sp, #4]
  2065c8:	9000      	str	r0, [sp, #0]
  2065ca:	4628      	mov	r0, r5
  2065cc:	f7ff fd42 	bl	206054 <gdispGBlitArea>
  2065d0:	e7b8      	b.n	206544 <gdispGImageDraw_GIF+0x232>
				priv->buf[gcnt++] = cache->palette[col];
  2065d2:	1c4b      	adds	r3, r1, #1
  2065d4:	f8da 0020 	ldr.w	r0, [sl, #32]
  2065d8:	b29b      	uxth	r3, r3
  2065da:	f830 c01c 	ldrh.w	ip, [r0, ip, lsl #1]
  2065de:	eb04 0041 	add.w	r0, r4, r1, lsl #1
				if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  2065e2:	2b1f      	cmp	r3, #31
				priv->buf[gcnt++] = cache->palette[col];
  2065e4:	f8a0 c046 	strh.w	ip, [r0, #70]	; 0x46
				if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  2065e8:	d901      	bls.n	2065ee <gdispGImageDraw_GIF+0x2dc>
					gdispGBlitArea(g, x+mx-sx-gcnt+1, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);
  2065ea:	b21b      	sxth	r3, r3
  2065ec:	e7e3      	b.n	2065b6 <gdispGImageDraw_GIF+0x2a4>
				if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  2065ee:	4619      	mov	r1, r3
  2065f0:	e7aa      	b.n	206548 <gdispGImageDraw_GIF+0x236>
			default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);	break;
  2065f2:	9b12      	ldr	r3, [sp, #72]	; 0x48
  2065f4:	fa0f fe81 	sxth.w	lr, r1
  2065f8:	469c      	mov	ip, r3
  2065fa:	9b09      	ldr	r3, [sp, #36]	; 0x24
  2065fc:	ebac 0c03 	sub.w	ip, ip, r3
  206600:	4673      	mov	r3, lr
  206602:	4460      	add	r0, ip
  206604:	1a41      	subs	r1, r0, r1
  206606:	f104 0046 	add.w	r0, r4, #70	; 0x46
  20660a:	e9cd e003 	strd	lr, r0, [sp, #12]
  20660e:	2000      	movs	r0, #0
  206610:	b209      	sxth	r1, r1
  206612:	e9cd 0001 	strd	r0, r0, [sp, #4]
  206616:	2001      	movs	r0, #1
  206618:	9000      	str	r0, [sp, #0]
  20661a:	4628      	mov	r0, r5
  20661c:	f7ff fd1a 	bl	206054 <gdispGBlitArea>
  206620:	e7b9      	b.n	206596 <gdispGImageDraw_GIF+0x284>
	switch(startDecodeGif(img)) {
  206622:	ee18 0a10 	vmov	r0, s16
  206626:	f7fb fc38 	bl	201e9a <startDecodeGif>
  20662a:	b140      	cbz	r0, 20663e <gdispGImageDraw_GIF+0x32c>
  20662c:	f248 0304 	movw	r3, #32772	; 0x8004
  206630:	f248 0202 	movw	r2, #32770	; 0x8002
  206634:	4298      	cmp	r0, r3
  206636:	bf0c      	ite	eq
  206638:	461f      	moveq	r7, r3
  20663a:	4617      	movne	r7, r2
  20663c:	e6d7      	b.n	2063ee <gdispGImageDraw_GIF+0xdc>
	if (priv->frame.flags & GIFL_INTERLACE) {
  20663e:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
	decode = priv->decode;
  206642:	f8d4 b018 	ldr.w	fp, [r4, #24]
	if (priv->frame.flags & GIFL_INTERLACE) {
  206646:	071a      	lsls	r2, r3, #28
  206648:	d429      	bmi.n	20669e <gdispGImageDraw_GIF+0x38c>
  20664a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	cnt = 0;
  20664c:	4657      	mov	r7, sl
  20664e:	9a08      	ldr	r2, [sp, #32]
  206650:	4433      	add	r3, r6
	if (priv->frame.flags & GIFL_INTERLACE) {
  206652:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
  206656:	461e      	mov	r6, r3
  206658:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  20665a:	1af6      	subs	r6, r6, r3
  20665c:	b2b3      	uxth	r3, r6
  20665e:	9307      	str	r3, [sp, #28]
  206660:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
  206664:	9312      	str	r3, [sp, #72]	; 0x48
  206666:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  206668:	fa12 f283 	uxtah	r2, r2, r3
  20666c:	9b09      	ldr	r3, [sp, #36]	; 0x24
  20666e:	1ad3      	subs	r3, r2, r3
  206670:	9313      	str	r3, [sp, #76]	; 0x4c
  206672:	f9bd 302c 	ldrsh.w	r3, [sp, #44]	; 0x2c
  206676:	930a      	str	r3, [sp, #40]	; 0x28
		for(my=0; my < priv->frame.height; my++) {
  206678:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  20667a:	f9b4 3022 	ldrsh.w	r3, [r4, #34]	; 0x22
  20667e:	4293      	cmp	r3, r2
  206680:	f340 83ab 	ble.w	206dda <gdispGImageDraw_GIF+0xac8>
  206684:	f8bd 304c 	ldrh.w	r3, [sp, #76]	; 0x4c
			for(gcnt=0, mx=0; mx < priv->frame.width; mx++, q++, cnt--) {
  206688:	2100      	movs	r1, #0
  20668a:	f9bd 201c 	ldrsh.w	r2, [sp, #28]
		for(my=0; my < priv->frame.height; my++) {
  20668e:	461e      	mov	r6, r3
  206690:	9311      	str	r3, [sp, #68]	; 0x44
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  206692:	f104 0346 	add.w	r3, r4, #70	; 0x46
		for(my=0; my < priv->frame.height; my++) {
  206696:	4689      	mov	r9, r1
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  206698:	4688      	mov	r8, r1
  20669a:	930f      	str	r3, [sp, #60]	; 0x3c
  20669c:	e332      	b.n	206d04 <gdispGImageDraw_GIF+0x9f2>
  20669e:	b2b3      	uxth	r3, r6
  2066a0:	9a08      	ldr	r2, [sp, #32]
		for(my=0; my < priv->frame.height; my+=8) {
  2066a2:	4657      	mov	r7, sl
	cnt = 0;
  2066a4:	f8cd a01c 	str.w	sl, [sp, #28]
  2066a8:	9312      	str	r3, [sp, #72]	; 0x48
  2066aa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  2066ac:	fa13 f686 	uxtah	r6, r3, r6
  2066b0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  2066b2:	1af6      	subs	r6, r6, r3
  2066b4:	b2b3      	uxth	r3, r6
  2066b6:	9311      	str	r3, [sp, #68]	; 0x44
  2066b8:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
  2066bc:	9315      	str	r3, [sp, #84]	; 0x54
  2066be:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  2066c0:	fa12 f383 	uxtah	r3, r2, r3
  2066c4:	9a09      	ldr	r2, [sp, #36]	; 0x24
  2066c6:	1a9b      	subs	r3, r3, r2
  2066c8:	9316      	str	r3, [sp, #88]	; 0x58
		for(my=0; my < priv->frame.height; my+=8) {
  2066ca:	f9b4 3022 	ldrsh.w	r3, [r4, #34]	; 0x22
  2066ce:	42bb      	cmp	r3, r7
  2066d0:	f340 80a8 	ble.w	206824 <gdispGImageDraw_GIF+0x512>
  2066d4:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
			for(gcnt=0, mx=0; mx < priv->frame.width; mx++, q++, cnt--) {
  2066d8:	2100      	movs	r1, #0
  2066da:	f9bd 2044 	ldrsh.w	r2, [sp, #68]	; 0x44
		for(my=0; my < priv->frame.height; my+=8) {
  2066de:	461e      	mov	r6, r3
  2066e0:	9314      	str	r3, [sp, #80]	; 0x50
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  2066e2:	f104 0346 	add.w	r3, r4, #70	; 0x46
		for(my=0; my < priv->frame.height; my+=8) {
  2066e6:	4689      	mov	r9, r1
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  2066e8:	4688      	mov	r8, r1
  2066ea:	9313      	str	r3, [sp, #76]	; 0x4c
  2066ec:	e02e      	b.n	20674c <gdispGImageDraw_GIF+0x43a>
					q = decode->buf;
  2066ee:	f10b 0a1c 	add.w	sl, fp, #28
				if (my >= sy && my < fy && mx >= sx && mx < fx) {
  2066f2:	980c      	ldr	r0, [sp, #48]	; 0x30
  2066f4:	4287      	cmp	r7, r0
  2066f6:	db12      	blt.n	20671e <gdispGImageDraw_GIF+0x40c>
  2066f8:	9810      	ldr	r0, [sp, #64]	; 0x40
  2066fa:	4287      	cmp	r7, r0
  2066fc:	da0f      	bge.n	20671e <gdispGImageDraw_GIF+0x40c>
  2066fe:	980d      	ldr	r0, [sp, #52]	; 0x34
  206700:	4298      	cmp	r0, r3
  206702:	dc0c      	bgt.n	20671e <gdispGImageDraw_GIF+0x40c>
  206704:	980e      	ldr	r0, [sp, #56]	; 0x38
  206706:	4298      	cmp	r0, r3
  206708:	dd09      	ble.n	20671e <gdispGImageDraw_GIF+0x40c>
					if ((priv->frame.flags & GIFL_TRANSPARENT) && col == priv->frame.paltrans) {
  20670a:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
					col = *q;
  20670e:	f89a c000 	ldrb.w	ip, [sl]
					if ((priv->frame.flags & GIFL_TRANSPARENT) && col == priv->frame.paltrans) {
  206712:	07db      	lsls	r3, r3, #31
  206714:	d554      	bpl.n	2067c0 <gdispGImageDraw_GIF+0x4ae>
  206716:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
  20671a:	4563      	cmp	r3, ip
  20671c:	d150      	bne.n	2067c0 <gdispGImageDraw_GIF+0x4ae>
				switch(gcnt) {
  20671e:	b159      	cbz	r1, 206738 <gdispGImageDraw_GIF+0x426>
  206720:	2901      	cmp	r1, #1
  206722:	d168      	bne.n	2067f6 <gdispGImageDraw_GIF+0x4e4>
				case 1:		gdispGDrawPixel(g, x+mx-sx-gcnt, y+my-sy, priv->buf[0]); gcnt = 0;					break;
  206724:	1e71      	subs	r1, r6, #1
  206726:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
  20672a:	4628      	mov	r0, r5
  20672c:	9217      	str	r2, [sp, #92]	; 0x5c
  20672e:	b209      	sxth	r1, r1
  206730:	f7ff fdc8 	bl	2062c4 <gdispGDrawPixel>
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  206734:	2100      	movs	r1, #0
  206736:	9a17      	ldr	r2, [sp, #92]	; 0x5c
			for(gcnt=0, mx=0; mx < priv->frame.width; mx++, q++, cnt--) {
  206738:	9b07      	ldr	r3, [sp, #28]
  20673a:	3601      	adds	r6, #1
  20673c:	f10a 0a01 	add.w	sl, sl, #1
  206740:	f109 0901 	add.w	r9, r9, #1
  206744:	1e58      	subs	r0, r3, #1
  206746:	b2b6      	uxth	r6, r6
  206748:	b283      	uxth	r3, r0
  20674a:	9307      	str	r3, [sp, #28]
  20674c:	fa0f f389 	sxth.w	r3, r9
  206750:	f9b4 0020 	ldrsh.w	r0, [r4, #32]
  206754:	4298      	cmp	r0, r3
  206756:	dd1a      	ble.n	20678e <gdispGImageDraw_GIF+0x47c>
				if (!cnt) {
  206758:	9807      	ldr	r0, [sp, #28]
  20675a:	2800      	cmp	r0, #0
  20675c:	d1c9      	bne.n	2066f2 <gdispGImageDraw_GIF+0x3e0>
					if (!(cnt = getBytesGif(img))) {
  20675e:	ee18 0a10 	vmov	r0, s16
  206762:	9317      	str	r3, [sp, #92]	; 0x5c
  206764:	e9cd 1218 	strd	r1, r2, [sp, #96]	; 0x60
  206768:	f7fa fbc4 	bl	200ef4 <getBytesGif>
  20676c:	9a19      	ldr	r2, [sp, #100]	; 0x64
  20676e:	9007      	str	r0, [sp, #28]
  206770:	e9dd 3117 	ldrd	r3, r1, [sp, #92]	; 0x5c
  206774:	2800      	cmp	r0, #0
  206776:	d1ba      	bne.n	2066ee <gdispGImageDraw_GIF+0x3dc>
						if (decode->code_last != decode->code_eof)
  206778:	f8bb 2010 	ldrh.w	r2, [fp, #16]
  20677c:	f8bb 300c 	ldrh.w	r3, [fp, #12]
  206780:	429a      	cmp	r2, r3
  206782:	f040 833d 	bne.w	206e00 <gdispGImageDraw_GIF+0xaee>
						mx++;
  206786:	f109 0901 	add.w	r9, r9, #1
  20678a:	fa0f f389 	sxth.w	r3, r9
			switch(gcnt) {
  20678e:	b181      	cbz	r1, 2067b2 <gdispGImageDraw_GIF+0x4a0>
  206790:	2901      	cmp	r1, #1
  206792:	f9bd 2044 	ldrsh.w	r2, [sp, #68]	; 0x44
  206796:	d132      	bne.n	2067fe <gdispGImageDraw_GIF+0x4ec>
			case 1:		gdispGDrawPixel(g, x+mx-sx-gcnt, y+my-sy, priv->buf[0]);					break;
  206798:	9908      	ldr	r1, [sp, #32]
  20679a:	9815      	ldr	r0, [sp, #84]	; 0x54
  20679c:	3901      	subs	r1, #1
  20679e:	4401      	add	r1, r0
  2067a0:	9809      	ldr	r0, [sp, #36]	; 0x24
  2067a2:	1a09      	subs	r1, r1, r0
  2067a4:	4628      	mov	r0, r5
  2067a6:	4419      	add	r1, r3
  2067a8:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
  2067ac:	b209      	sxth	r1, r1
  2067ae:	f7ff fd89 	bl	2062c4 <gdispGDrawPixel>
  2067b2:	9e11      	ldr	r6, [sp, #68]	; 0x44
  2067b4:	3708      	adds	r7, #8
  2067b6:	3608      	adds	r6, #8
  2067b8:	b23f      	sxth	r7, r7
  2067ba:	b2b3      	uxth	r3, r6
  2067bc:	9311      	str	r3, [sp, #68]	; 0x44
  2067be:	e784      	b.n	2066ca <gdispGImageDraw_GIF+0x3b8>
					priv->buf[gcnt++] = decode->palette[col];
  2067c0:	1c4b      	adds	r3, r1, #1
  2067c2:	f8db 0018 	ldr.w	r0, [fp, #24]
  2067c6:	b29b      	uxth	r3, r3
  2067c8:	f830 c01c 	ldrh.w	ip, [r0, ip, lsl #1]
  2067cc:	eb04 0041 	add.w	r0, r4, r1, lsl #1
					if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  2067d0:	2b1f      	cmp	r3, #31
					priv->buf[gcnt++] = decode->palette[col];
  2067d2:	f8a0 c046 	strh.w	ip, [r0, #70]	; 0x46
					if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  2067d6:	d910      	bls.n	2067fa <gdispGImageDraw_GIF+0x4e8>
						gdispGBlitArea(g, x+mx-sx-gcnt+1, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);
  2067d8:	b21b      	sxth	r3, r3
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  2067da:	9813      	ldr	r0, [sp, #76]	; 0x4c
  2067dc:	1a71      	subs	r1, r6, r1
  2067de:	9217      	str	r2, [sp, #92]	; 0x5c
  2067e0:	b209      	sxth	r1, r1
  2067e2:	e9cd 3003 	strd	r3, r0, [sp, #12]
  2067e6:	2001      	movs	r0, #1
  2067e8:	e9cd 8801 	strd	r8, r8, [sp, #4]
  2067ec:	9000      	str	r0, [sp, #0]
  2067ee:	4628      	mov	r0, r5
  2067f0:	f7ff fc30 	bl	206054 <gdispGBlitArea>
  2067f4:	e79e      	b.n	206734 <gdispGImageDraw_GIF+0x422>
  2067f6:	b20b      	sxth	r3, r1
  2067f8:	e7ef      	b.n	2067da <gdispGImageDraw_GIF+0x4c8>
					if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  2067fa:	4619      	mov	r1, r3
  2067fc:	e79c      	b.n	206738 <gdispGImageDraw_GIF+0x426>
			default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);	break;
  2067fe:	9814      	ldr	r0, [sp, #80]	; 0x50
  206800:	b20e      	sxth	r6, r1
  206802:	4418      	add	r0, r3
  206804:	f104 0346 	add.w	r3, r4, #70	; 0x46
  206808:	1a41      	subs	r1, r0, r1
  20680a:	2000      	movs	r0, #0
  20680c:	e9cd 6303 	strd	r6, r3, [sp, #12]
  206810:	2301      	movs	r3, #1
  206812:	b209      	sxth	r1, r1
  206814:	e9cd 0001 	strd	r0, r0, [sp, #4]
  206818:	9300      	str	r3, [sp, #0]
  20681a:	4628      	mov	r0, r5
  20681c:	4633      	mov	r3, r6
  20681e:	f7ff fc19 	bl	206054 <gdispGBlitArea>
  206822:	e7c6      	b.n	2067b2 <gdispGImageDraw_GIF+0x4a0>
  206824:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		for(my=4; my < priv->frame.height; my+=8) {
  206826:	2704      	movs	r7, #4
  206828:	9a12      	ldr	r2, [sp, #72]	; 0x48
  20682a:	3304      	adds	r3, #4
  20682c:	4413      	add	r3, r2
  20682e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  206830:	1a9b      	subs	r3, r3, r2
  206832:	9a08      	ldr	r2, [sp, #32]
  206834:	b29b      	uxth	r3, r3
  206836:	9311      	str	r3, [sp, #68]	; 0x44
  206838:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
  20683c:	9315      	str	r3, [sp, #84]	; 0x54
  20683e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  206840:	fa12 f383 	uxtah	r3, r2, r3
  206844:	9a09      	ldr	r2, [sp, #36]	; 0x24
  206846:	1a9b      	subs	r3, r3, r2
  206848:	9316      	str	r3, [sp, #88]	; 0x58
  20684a:	f9b4 3022 	ldrsh.w	r3, [r4, #34]	; 0x22
  20684e:	42bb      	cmp	r3, r7
  206850:	f340 80a8 	ble.w	2069a4 <gdispGImageDraw_GIF+0x692>
  206854:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
			for(gcnt=0, mx=0; mx < priv->frame.width; mx++, q++, cnt--) {
  206858:	2100      	movs	r1, #0
  20685a:	f9bd 2044 	ldrsh.w	r2, [sp, #68]	; 0x44
		for(my=4; my < priv->frame.height; my+=8) {
  20685e:	461e      	mov	r6, r3
  206860:	9314      	str	r3, [sp, #80]	; 0x50
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  206862:	f104 0346 	add.w	r3, r4, #70	; 0x46
		for(my=4; my < priv->frame.height; my+=8) {
  206866:	4689      	mov	r9, r1
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  206868:	4688      	mov	r8, r1
  20686a:	9313      	str	r3, [sp, #76]	; 0x4c
  20686c:	e02e      	b.n	2068cc <gdispGImageDraw_GIF+0x5ba>
					q = decode->buf;
  20686e:	f10b 0a1c 	add.w	sl, fp, #28
				if (my >= sy && my < fy && mx >= sx && mx < fx) {
  206872:	980c      	ldr	r0, [sp, #48]	; 0x30
  206874:	4287      	cmp	r7, r0
  206876:	db12      	blt.n	20689e <gdispGImageDraw_GIF+0x58c>
  206878:	9810      	ldr	r0, [sp, #64]	; 0x40
  20687a:	4287      	cmp	r7, r0
  20687c:	da0f      	bge.n	20689e <gdispGImageDraw_GIF+0x58c>
  20687e:	980d      	ldr	r0, [sp, #52]	; 0x34
  206880:	4298      	cmp	r0, r3
  206882:	dc0c      	bgt.n	20689e <gdispGImageDraw_GIF+0x58c>
  206884:	980e      	ldr	r0, [sp, #56]	; 0x38
  206886:	4298      	cmp	r0, r3
  206888:	dd09      	ble.n	20689e <gdispGImageDraw_GIF+0x58c>
					if ((priv->frame.flags & GIFL_TRANSPARENT) && col == priv->frame.paltrans) {
  20688a:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
					col = *q;
  20688e:	f89a c000 	ldrb.w	ip, [sl]
					if ((priv->frame.flags & GIFL_TRANSPARENT) && col == priv->frame.paltrans) {
  206892:	07d8      	lsls	r0, r3, #31
  206894:	d554      	bpl.n	206940 <gdispGImageDraw_GIF+0x62e>
  206896:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
  20689a:	4563      	cmp	r3, ip
  20689c:	d150      	bne.n	206940 <gdispGImageDraw_GIF+0x62e>
				switch(gcnt) {
  20689e:	b159      	cbz	r1, 2068b8 <gdispGImageDraw_GIF+0x5a6>
  2068a0:	2901      	cmp	r1, #1
  2068a2:	d168      	bne.n	206976 <gdispGImageDraw_GIF+0x664>
				case 1:		gdispGDrawPixel(g, x+mx-sx-gcnt, y+my-sy, priv->buf[0]); gcnt = 0;					break;
  2068a4:	1e71      	subs	r1, r6, #1
  2068a6:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
  2068aa:	4628      	mov	r0, r5
  2068ac:	9217      	str	r2, [sp, #92]	; 0x5c
  2068ae:	b209      	sxth	r1, r1
  2068b0:	f7ff fd08 	bl	2062c4 <gdispGDrawPixel>
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  2068b4:	2100      	movs	r1, #0
  2068b6:	9a17      	ldr	r2, [sp, #92]	; 0x5c
			for(gcnt=0, mx=0; mx < priv->frame.width; mx++, q++, cnt--) {
  2068b8:	9b07      	ldr	r3, [sp, #28]
  2068ba:	3601      	adds	r6, #1
  2068bc:	f10a 0a01 	add.w	sl, sl, #1
  2068c0:	f109 0901 	add.w	r9, r9, #1
  2068c4:	1e58      	subs	r0, r3, #1
  2068c6:	b2b6      	uxth	r6, r6
  2068c8:	b283      	uxth	r3, r0
  2068ca:	9307      	str	r3, [sp, #28]
  2068cc:	fa0f f389 	sxth.w	r3, r9
  2068d0:	f9b4 0020 	ldrsh.w	r0, [r4, #32]
  2068d4:	4298      	cmp	r0, r3
  2068d6:	dd1a      	ble.n	20690e <gdispGImageDraw_GIF+0x5fc>
				if (!cnt) {
  2068d8:	9807      	ldr	r0, [sp, #28]
  2068da:	2800      	cmp	r0, #0
  2068dc:	d1c9      	bne.n	206872 <gdispGImageDraw_GIF+0x560>
					if (!(cnt = getBytesGif(img))) {
  2068de:	ee18 0a10 	vmov	r0, s16
  2068e2:	9317      	str	r3, [sp, #92]	; 0x5c
  2068e4:	e9cd 1218 	strd	r1, r2, [sp, #96]	; 0x60
  2068e8:	f7fa fb04 	bl	200ef4 <getBytesGif>
  2068ec:	9a19      	ldr	r2, [sp, #100]	; 0x64
  2068ee:	9007      	str	r0, [sp, #28]
  2068f0:	e9dd 3117 	ldrd	r3, r1, [sp, #92]	; 0x5c
  2068f4:	2800      	cmp	r0, #0
  2068f6:	d1ba      	bne.n	20686e <gdispGImageDraw_GIF+0x55c>
						if (decode->code_last != decode->code_eof)
  2068f8:	f8bb 2010 	ldrh.w	r2, [fp, #16]
  2068fc:	f8bb 300c 	ldrh.w	r3, [fp, #12]
  206900:	429a      	cmp	r2, r3
  206902:	f040 827d 	bne.w	206e00 <gdispGImageDraw_GIF+0xaee>
						mx++;
  206906:	f109 0901 	add.w	r9, r9, #1
  20690a:	fa0f f389 	sxth.w	r3, r9
			switch(gcnt) {
  20690e:	b181      	cbz	r1, 206932 <gdispGImageDraw_GIF+0x620>
  206910:	2901      	cmp	r1, #1
  206912:	f9bd 2044 	ldrsh.w	r2, [sp, #68]	; 0x44
  206916:	d132      	bne.n	20697e <gdispGImageDraw_GIF+0x66c>
			case 1:		gdispGDrawPixel(g, x+mx-sx-gcnt, y+my-sy, priv->buf[0]);					break;
  206918:	9908      	ldr	r1, [sp, #32]
  20691a:	9815      	ldr	r0, [sp, #84]	; 0x54
  20691c:	3901      	subs	r1, #1
  20691e:	4401      	add	r1, r0
  206920:	9809      	ldr	r0, [sp, #36]	; 0x24
  206922:	1a09      	subs	r1, r1, r0
  206924:	4628      	mov	r0, r5
  206926:	4419      	add	r1, r3
  206928:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
  20692c:	b209      	sxth	r1, r1
  20692e:	f7ff fcc9 	bl	2062c4 <gdispGDrawPixel>
  206932:	9b11      	ldr	r3, [sp, #68]	; 0x44
  206934:	3708      	adds	r7, #8
  206936:	3308      	adds	r3, #8
  206938:	b23f      	sxth	r7, r7
  20693a:	b29b      	uxth	r3, r3
  20693c:	9311      	str	r3, [sp, #68]	; 0x44
  20693e:	e784      	b.n	20684a <gdispGImageDraw_GIF+0x538>
					priv->buf[gcnt++] = decode->palette[col];
  206940:	1c4b      	adds	r3, r1, #1
  206942:	f8db 0018 	ldr.w	r0, [fp, #24]
  206946:	b29b      	uxth	r3, r3
  206948:	f830 c01c 	ldrh.w	ip, [r0, ip, lsl #1]
  20694c:	eb04 0041 	add.w	r0, r4, r1, lsl #1
					if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  206950:	2b1f      	cmp	r3, #31
					priv->buf[gcnt++] = decode->palette[col];
  206952:	f8a0 c046 	strh.w	ip, [r0, #70]	; 0x46
					if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  206956:	d910      	bls.n	20697a <gdispGImageDraw_GIF+0x668>
						gdispGBlitArea(g, x+mx-sx-gcnt+1, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);
  206958:	b21b      	sxth	r3, r3
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  20695a:	9813      	ldr	r0, [sp, #76]	; 0x4c
  20695c:	1a71      	subs	r1, r6, r1
  20695e:	9217      	str	r2, [sp, #92]	; 0x5c
  206960:	b209      	sxth	r1, r1
  206962:	e9cd 3003 	strd	r3, r0, [sp, #12]
  206966:	2001      	movs	r0, #1
  206968:	e9cd 8801 	strd	r8, r8, [sp, #4]
  20696c:	9000      	str	r0, [sp, #0]
  20696e:	4628      	mov	r0, r5
  206970:	f7ff fb70 	bl	206054 <gdispGBlitArea>
  206974:	e79e      	b.n	2068b4 <gdispGImageDraw_GIF+0x5a2>
  206976:	b20b      	sxth	r3, r1
  206978:	e7ef      	b.n	20695a <gdispGImageDraw_GIF+0x648>
					if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  20697a:	4619      	mov	r1, r3
  20697c:	e79c      	b.n	2068b8 <gdispGImageDraw_GIF+0x5a6>
			default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);	break;
  20697e:	9814      	ldr	r0, [sp, #80]	; 0x50
  206980:	b20e      	sxth	r6, r1
  206982:	4418      	add	r0, r3
  206984:	f104 0346 	add.w	r3, r4, #70	; 0x46
  206988:	1a41      	subs	r1, r0, r1
  20698a:	2000      	movs	r0, #0
  20698c:	e9cd 6303 	strd	r6, r3, [sp, #12]
  206990:	2301      	movs	r3, #1
  206992:	b209      	sxth	r1, r1
  206994:	e9cd 0001 	strd	r0, r0, [sp, #4]
  206998:	9300      	str	r3, [sp, #0]
  20699a:	4628      	mov	r0, r5
  20699c:	4633      	mov	r3, r6
  20699e:	f7ff fb59 	bl	206054 <gdispGBlitArea>
  2069a2:	e7c6      	b.n	206932 <gdispGImageDraw_GIF+0x620>
  2069a4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		for(my=2; my < priv->frame.height; my+=4) {
  2069a6:	2702      	movs	r7, #2
  2069a8:	9a12      	ldr	r2, [sp, #72]	; 0x48
  2069aa:	3302      	adds	r3, #2
  2069ac:	4413      	add	r3, r2
  2069ae:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  2069b0:	1a9b      	subs	r3, r3, r2
  2069b2:	9a08      	ldr	r2, [sp, #32]
  2069b4:	b29b      	uxth	r3, r3
  2069b6:	9311      	str	r3, [sp, #68]	; 0x44
  2069b8:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
  2069bc:	9315      	str	r3, [sp, #84]	; 0x54
  2069be:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  2069c0:	fa12 f383 	uxtah	r3, r2, r3
  2069c4:	9a09      	ldr	r2, [sp, #36]	; 0x24
  2069c6:	1a9b      	subs	r3, r3, r2
  2069c8:	9316      	str	r3, [sp, #88]	; 0x58
  2069ca:	f9b4 3022 	ldrsh.w	r3, [r4, #34]	; 0x22
  2069ce:	42bb      	cmp	r3, r7
  2069d0:	f340 80a8 	ble.w	206b24 <gdispGImageDraw_GIF+0x812>
  2069d4:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
			for(gcnt=0, mx=0; mx < priv->frame.width; mx++, q++, cnt--) {
  2069d8:	2100      	movs	r1, #0
  2069da:	f9bd 2044 	ldrsh.w	r2, [sp, #68]	; 0x44
		for(my=2; my < priv->frame.height; my+=4) {
  2069de:	461e      	mov	r6, r3
  2069e0:	9314      	str	r3, [sp, #80]	; 0x50
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  2069e2:	f104 0346 	add.w	r3, r4, #70	; 0x46
		for(my=2; my < priv->frame.height; my+=4) {
  2069e6:	4689      	mov	r9, r1
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  2069e8:	4688      	mov	r8, r1
  2069ea:	9313      	str	r3, [sp, #76]	; 0x4c
  2069ec:	e02e      	b.n	206a4c <gdispGImageDraw_GIF+0x73a>
					q = decode->buf;
  2069ee:	f10b 0a1c 	add.w	sl, fp, #28
				if (my >= sy && my < fy && mx >= sx && mx < fx) {
  2069f2:	980c      	ldr	r0, [sp, #48]	; 0x30
  2069f4:	4287      	cmp	r7, r0
  2069f6:	db12      	blt.n	206a1e <gdispGImageDraw_GIF+0x70c>
  2069f8:	9810      	ldr	r0, [sp, #64]	; 0x40
  2069fa:	4287      	cmp	r7, r0
  2069fc:	da0f      	bge.n	206a1e <gdispGImageDraw_GIF+0x70c>
  2069fe:	980d      	ldr	r0, [sp, #52]	; 0x34
  206a00:	4283      	cmp	r3, r0
  206a02:	db0c      	blt.n	206a1e <gdispGImageDraw_GIF+0x70c>
  206a04:	980e      	ldr	r0, [sp, #56]	; 0x38
  206a06:	4283      	cmp	r3, r0
  206a08:	da09      	bge.n	206a1e <gdispGImageDraw_GIF+0x70c>
					if ((priv->frame.flags & GIFL_TRANSPARENT) && col == priv->frame.paltrans) {
  206a0a:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
					col = *q;
  206a0e:	f89a c000 	ldrb.w	ip, [sl]
					if ((priv->frame.flags & GIFL_TRANSPARENT) && col == priv->frame.paltrans) {
  206a12:	07db      	lsls	r3, r3, #31
  206a14:	d554      	bpl.n	206ac0 <gdispGImageDraw_GIF+0x7ae>
  206a16:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
  206a1a:	4563      	cmp	r3, ip
  206a1c:	d150      	bne.n	206ac0 <gdispGImageDraw_GIF+0x7ae>
				switch(gcnt) {
  206a1e:	b159      	cbz	r1, 206a38 <gdispGImageDraw_GIF+0x726>
  206a20:	2901      	cmp	r1, #1
  206a22:	d168      	bne.n	206af6 <gdispGImageDraw_GIF+0x7e4>
				case 1:		gdispGDrawPixel(g, x+mx-sx-gcnt, y+my-sy, priv->buf[0]); gcnt = 0;					break;
  206a24:	1e71      	subs	r1, r6, #1
  206a26:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
  206a2a:	4628      	mov	r0, r5
  206a2c:	9217      	str	r2, [sp, #92]	; 0x5c
  206a2e:	b209      	sxth	r1, r1
  206a30:	f7ff fc48 	bl	2062c4 <gdispGDrawPixel>
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  206a34:	2100      	movs	r1, #0
  206a36:	9a17      	ldr	r2, [sp, #92]	; 0x5c
			for(gcnt=0, mx=0; mx < priv->frame.width; mx++, q++, cnt--) {
  206a38:	9b07      	ldr	r3, [sp, #28]
  206a3a:	3601      	adds	r6, #1
  206a3c:	f10a 0a01 	add.w	sl, sl, #1
  206a40:	f109 0901 	add.w	r9, r9, #1
  206a44:	1e58      	subs	r0, r3, #1
  206a46:	b2b6      	uxth	r6, r6
  206a48:	b283      	uxth	r3, r0
  206a4a:	9307      	str	r3, [sp, #28]
  206a4c:	fa0f f389 	sxth.w	r3, r9
  206a50:	f9b4 0020 	ldrsh.w	r0, [r4, #32]
  206a54:	4298      	cmp	r0, r3
  206a56:	dd1a      	ble.n	206a8e <gdispGImageDraw_GIF+0x77c>
				if (!cnt) {
  206a58:	9807      	ldr	r0, [sp, #28]
  206a5a:	2800      	cmp	r0, #0
  206a5c:	d1c9      	bne.n	2069f2 <gdispGImageDraw_GIF+0x6e0>
					if (!(cnt = getBytesGif(img))) {
  206a5e:	ee18 0a10 	vmov	r0, s16
  206a62:	9317      	str	r3, [sp, #92]	; 0x5c
  206a64:	e9cd 1218 	strd	r1, r2, [sp, #96]	; 0x60
  206a68:	f7fa fa44 	bl	200ef4 <getBytesGif>
  206a6c:	9a19      	ldr	r2, [sp, #100]	; 0x64
  206a6e:	9007      	str	r0, [sp, #28]
  206a70:	e9dd 3117 	ldrd	r3, r1, [sp, #92]	; 0x5c
  206a74:	2800      	cmp	r0, #0
  206a76:	d1ba      	bne.n	2069ee <gdispGImageDraw_GIF+0x6dc>
						if (decode->code_last != decode->code_eof)
  206a78:	f8bb 2010 	ldrh.w	r2, [fp, #16]
  206a7c:	f8bb 300c 	ldrh.w	r3, [fp, #12]
  206a80:	429a      	cmp	r2, r3
  206a82:	f040 81bd 	bne.w	206e00 <gdispGImageDraw_GIF+0xaee>
						mx++;
  206a86:	f109 0901 	add.w	r9, r9, #1
  206a8a:	fa0f f389 	sxth.w	r3, r9
			switch(gcnt) {
  206a8e:	b181      	cbz	r1, 206ab2 <gdispGImageDraw_GIF+0x7a0>
  206a90:	2901      	cmp	r1, #1
  206a92:	f9bd 2044 	ldrsh.w	r2, [sp, #68]	; 0x44
  206a96:	d132      	bne.n	206afe <gdispGImageDraw_GIF+0x7ec>
			case 1:		gdispGDrawPixel(g, x+mx-sx-gcnt, y+my-sy, priv->buf[0]);					break;
  206a98:	9908      	ldr	r1, [sp, #32]
  206a9a:	9815      	ldr	r0, [sp, #84]	; 0x54
  206a9c:	3901      	subs	r1, #1
  206a9e:	4401      	add	r1, r0
  206aa0:	9809      	ldr	r0, [sp, #36]	; 0x24
  206aa2:	1a09      	subs	r1, r1, r0
  206aa4:	4628      	mov	r0, r5
  206aa6:	4419      	add	r1, r3
  206aa8:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
  206aac:	b209      	sxth	r1, r1
  206aae:	f7ff fc09 	bl	2062c4 <gdispGDrawPixel>
  206ab2:	9b11      	ldr	r3, [sp, #68]	; 0x44
  206ab4:	3704      	adds	r7, #4
  206ab6:	3304      	adds	r3, #4
  206ab8:	b23f      	sxth	r7, r7
  206aba:	b29b      	uxth	r3, r3
  206abc:	9311      	str	r3, [sp, #68]	; 0x44
  206abe:	e784      	b.n	2069ca <gdispGImageDraw_GIF+0x6b8>
					priv->buf[gcnt++] = decode->palette[col];
  206ac0:	1c4b      	adds	r3, r1, #1
  206ac2:	f8db 0018 	ldr.w	r0, [fp, #24]
  206ac6:	b29b      	uxth	r3, r3
  206ac8:	f830 c01c 	ldrh.w	ip, [r0, ip, lsl #1]
  206acc:	eb04 0041 	add.w	r0, r4, r1, lsl #1
					if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  206ad0:	2b1f      	cmp	r3, #31
					priv->buf[gcnt++] = decode->palette[col];
  206ad2:	f8a0 c046 	strh.w	ip, [r0, #70]	; 0x46
					if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  206ad6:	d910      	bls.n	206afa <gdispGImageDraw_GIF+0x7e8>
						gdispGBlitArea(g, x+mx-sx-gcnt+1, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);
  206ad8:	b21b      	sxth	r3, r3
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  206ada:	9813      	ldr	r0, [sp, #76]	; 0x4c
  206adc:	1a71      	subs	r1, r6, r1
  206ade:	9217      	str	r2, [sp, #92]	; 0x5c
  206ae0:	b209      	sxth	r1, r1
  206ae2:	e9cd 3003 	strd	r3, r0, [sp, #12]
  206ae6:	2001      	movs	r0, #1
  206ae8:	e9cd 8801 	strd	r8, r8, [sp, #4]
  206aec:	9000      	str	r0, [sp, #0]
  206aee:	4628      	mov	r0, r5
  206af0:	f7ff fab0 	bl	206054 <gdispGBlitArea>
  206af4:	e79e      	b.n	206a34 <gdispGImageDraw_GIF+0x722>
  206af6:	b20b      	sxth	r3, r1
  206af8:	e7ef      	b.n	206ada <gdispGImageDraw_GIF+0x7c8>
					if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  206afa:	4619      	mov	r1, r3
  206afc:	e79c      	b.n	206a38 <gdispGImageDraw_GIF+0x726>
			default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);	break;
  206afe:	9814      	ldr	r0, [sp, #80]	; 0x50
  206b00:	b20e      	sxth	r6, r1
  206b02:	4418      	add	r0, r3
  206b04:	f104 0346 	add.w	r3, r4, #70	; 0x46
  206b08:	1a41      	subs	r1, r0, r1
  206b0a:	2000      	movs	r0, #0
  206b0c:	e9cd 6303 	strd	r6, r3, [sp, #12]
  206b10:	2301      	movs	r3, #1
  206b12:	b209      	sxth	r1, r1
  206b14:	e9cd 0001 	strd	r0, r0, [sp, #4]
  206b18:	9300      	str	r3, [sp, #0]
  206b1a:	4628      	mov	r0, r5
  206b1c:	4633      	mov	r3, r6
  206b1e:	f7ff fa99 	bl	206054 <gdispGBlitArea>
  206b22:	e7c6      	b.n	206ab2 <gdispGImageDraw_GIF+0x7a0>
  206b24:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
		for(my=1; my < priv->frame.height; my+=2) {
  206b26:	2701      	movs	r7, #1
  206b28:	9b12      	ldr	r3, [sp, #72]	; 0x48
  206b2a:	3601      	adds	r6, #1
  206b2c:	9a08      	ldr	r2, [sp, #32]
  206b2e:	4433      	add	r3, r6
  206b30:	461e      	mov	r6, r3
  206b32:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  206b34:	1af6      	subs	r6, r6, r3
  206b36:	b2b3      	uxth	r3, r6
  206b38:	930b      	str	r3, [sp, #44]	; 0x2c
  206b3a:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
  206b3e:	9311      	str	r3, [sp, #68]	; 0x44
  206b40:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  206b42:	fa12 f283 	uxtah	r2, r2, r3
  206b46:	9b09      	ldr	r3, [sp, #36]	; 0x24
  206b48:	1ad3      	subs	r3, r2, r3
  206b4a:	9312      	str	r3, [sp, #72]	; 0x48
  206b4c:	f9b4 3022 	ldrsh.w	r3, [r4, #34]	; 0x22
  206b50:	42bb      	cmp	r3, r7
  206b52:	f340 8142 	ble.w	206dda <gdispGImageDraw_GIF+0xac8>
  206b56:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
			for(gcnt=0, mx=0; mx < priv->frame.width; mx++, q++, cnt--) {
  206b5a:	2100      	movs	r1, #0
  206b5c:	f9bd 202c 	ldrsh.w	r2, [sp, #44]	; 0x2c
		for(my=1; my < priv->frame.height; my+=2) {
  206b60:	461e      	mov	r6, r3
  206b62:	930f      	str	r3, [sp, #60]	; 0x3c
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  206b64:	f104 0346 	add.w	r3, r4, #70	; 0x46
		for(my=1; my < priv->frame.height; my+=2) {
  206b68:	4689      	mov	r9, r1
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  206b6a:	4688      	mov	r8, r1
  206b6c:	930a      	str	r3, [sp, #40]	; 0x28
  206b6e:	e02e      	b.n	206bce <gdispGImageDraw_GIF+0x8bc>
					q = decode->buf;
  206b70:	f10b 0a1c 	add.w	sl, fp, #28
				if (my >= sy && my < fy && mx >= sx && mx < fx) {
  206b74:	980c      	ldr	r0, [sp, #48]	; 0x30
  206b76:	4287      	cmp	r7, r0
  206b78:	db12      	blt.n	206ba0 <gdispGImageDraw_GIF+0x88e>
  206b7a:	9810      	ldr	r0, [sp, #64]	; 0x40
  206b7c:	4287      	cmp	r7, r0
  206b7e:	da0f      	bge.n	206ba0 <gdispGImageDraw_GIF+0x88e>
  206b80:	980d      	ldr	r0, [sp, #52]	; 0x34
  206b82:	4283      	cmp	r3, r0
  206b84:	db0c      	blt.n	206ba0 <gdispGImageDraw_GIF+0x88e>
  206b86:	980e      	ldr	r0, [sp, #56]	; 0x38
  206b88:	4283      	cmp	r3, r0
  206b8a:	da09      	bge.n	206ba0 <gdispGImageDraw_GIF+0x88e>
					if ((priv->frame.flags & GIFL_TRANSPARENT) && col == priv->frame.paltrans) {
  206b8c:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
					col = *q;
  206b90:	f89a c000 	ldrb.w	ip, [sl]
					if ((priv->frame.flags & GIFL_TRANSPARENT) && col == priv->frame.paltrans) {
  206b94:	07d8      	lsls	r0, r3, #31
  206b96:	d554      	bpl.n	206c42 <gdispGImageDraw_GIF+0x930>
  206b98:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
  206b9c:	4563      	cmp	r3, ip
  206b9e:	d150      	bne.n	206c42 <gdispGImageDraw_GIF+0x930>
				switch(gcnt) {
  206ba0:	b159      	cbz	r1, 206bba <gdispGImageDraw_GIF+0x8a8>
  206ba2:	2901      	cmp	r1, #1
  206ba4:	d168      	bne.n	206c78 <gdispGImageDraw_GIF+0x966>
				case 1:		gdispGDrawPixel(g, x+mx-sx-gcnt, y+my-sy, priv->buf[0]); gcnt = 0;					break;
  206ba6:	1e71      	subs	r1, r6, #1
  206ba8:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
  206bac:	4628      	mov	r0, r5
  206bae:	9213      	str	r2, [sp, #76]	; 0x4c
  206bb0:	b209      	sxth	r1, r1
  206bb2:	f7ff fb87 	bl	2062c4 <gdispGDrawPixel>
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  206bb6:	2100      	movs	r1, #0
  206bb8:	9a13      	ldr	r2, [sp, #76]	; 0x4c
			for(gcnt=0, mx=0; mx < priv->frame.width; mx++, q++, cnt--) {
  206bba:	9b07      	ldr	r3, [sp, #28]
  206bbc:	3601      	adds	r6, #1
  206bbe:	f10a 0a01 	add.w	sl, sl, #1
  206bc2:	f109 0901 	add.w	r9, r9, #1
  206bc6:	1e58      	subs	r0, r3, #1
  206bc8:	b2b6      	uxth	r6, r6
  206bca:	b283      	uxth	r3, r0
  206bcc:	9307      	str	r3, [sp, #28]
  206bce:	fa0f f389 	sxth.w	r3, r9
  206bd2:	f9b4 0020 	ldrsh.w	r0, [r4, #32]
  206bd6:	4298      	cmp	r0, r3
  206bd8:	dd1a      	ble.n	206c10 <gdispGImageDraw_GIF+0x8fe>
				if (!cnt) {
  206bda:	9807      	ldr	r0, [sp, #28]
  206bdc:	2800      	cmp	r0, #0
  206bde:	d1c9      	bne.n	206b74 <gdispGImageDraw_GIF+0x862>
					if (!(cnt = getBytesGif(img))) {
  206be0:	ee18 0a10 	vmov	r0, s16
  206be4:	9313      	str	r3, [sp, #76]	; 0x4c
  206be6:	e9cd 1214 	strd	r1, r2, [sp, #80]	; 0x50
  206bea:	f7fa f983 	bl	200ef4 <getBytesGif>
  206bee:	9a15      	ldr	r2, [sp, #84]	; 0x54
  206bf0:	9007      	str	r0, [sp, #28]
  206bf2:	e9dd 3113 	ldrd	r3, r1, [sp, #76]	; 0x4c
  206bf6:	2800      	cmp	r0, #0
  206bf8:	d1ba      	bne.n	206b70 <gdispGImageDraw_GIF+0x85e>
						if (decode->code_last != decode->code_eof)
  206bfa:	f8bb 2010 	ldrh.w	r2, [fp, #16]
  206bfe:	f8bb 300c 	ldrh.w	r3, [fp, #12]
  206c02:	429a      	cmp	r2, r3
  206c04:	f040 80fc 	bne.w	206e00 <gdispGImageDraw_GIF+0xaee>
						mx++;
  206c08:	f109 0901 	add.w	r9, r9, #1
  206c0c:	fa0f f389 	sxth.w	r3, r9
			switch(gcnt) {
  206c10:	b181      	cbz	r1, 206c34 <gdispGImageDraw_GIF+0x922>
  206c12:	2901      	cmp	r1, #1
  206c14:	f9bd 202c 	ldrsh.w	r2, [sp, #44]	; 0x2c
  206c18:	d132      	bne.n	206c80 <gdispGImageDraw_GIF+0x96e>
			case 1:		gdispGDrawPixel(g, x+mx-sx-gcnt, y+my-sy, priv->buf[0]);					break;
  206c1a:	9908      	ldr	r1, [sp, #32]
  206c1c:	9811      	ldr	r0, [sp, #68]	; 0x44
  206c1e:	3901      	subs	r1, #1
  206c20:	4401      	add	r1, r0
  206c22:	9809      	ldr	r0, [sp, #36]	; 0x24
  206c24:	1a09      	subs	r1, r1, r0
  206c26:	4628      	mov	r0, r5
  206c28:	4419      	add	r1, r3
  206c2a:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
  206c2e:	b209      	sxth	r1, r1
  206c30:	f7ff fb48 	bl	2062c4 <gdispGDrawPixel>
  206c34:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  206c36:	3702      	adds	r7, #2
  206c38:	3302      	adds	r3, #2
  206c3a:	b23f      	sxth	r7, r7
  206c3c:	b29b      	uxth	r3, r3
  206c3e:	930b      	str	r3, [sp, #44]	; 0x2c
  206c40:	e784      	b.n	206b4c <gdispGImageDraw_GIF+0x83a>
					priv->buf[gcnt++] = decode->palette[col];
  206c42:	1c4b      	adds	r3, r1, #1
  206c44:	f8db 0018 	ldr.w	r0, [fp, #24]
  206c48:	b29b      	uxth	r3, r3
  206c4a:	f830 c01c 	ldrh.w	ip, [r0, ip, lsl #1]
  206c4e:	eb04 0041 	add.w	r0, r4, r1, lsl #1
					if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  206c52:	2b1f      	cmp	r3, #31
					priv->buf[gcnt++] = decode->palette[col];
  206c54:	f8a0 c046 	strh.w	ip, [r0, #70]	; 0x46
					if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  206c58:	d910      	bls.n	206c7c <gdispGImageDraw_GIF+0x96a>
						gdispGBlitArea(g, x+mx-sx-gcnt+1, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);
  206c5a:	b21b      	sxth	r3, r3
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  206c5c:	980a      	ldr	r0, [sp, #40]	; 0x28
  206c5e:	1a71      	subs	r1, r6, r1
  206c60:	9213      	str	r2, [sp, #76]	; 0x4c
  206c62:	b209      	sxth	r1, r1
  206c64:	e9cd 3003 	strd	r3, r0, [sp, #12]
  206c68:	2001      	movs	r0, #1
  206c6a:	e9cd 8801 	strd	r8, r8, [sp, #4]
  206c6e:	9000      	str	r0, [sp, #0]
  206c70:	4628      	mov	r0, r5
  206c72:	f7ff f9ef 	bl	206054 <gdispGBlitArea>
  206c76:	e79e      	b.n	206bb6 <gdispGImageDraw_GIF+0x8a4>
  206c78:	b20b      	sxth	r3, r1
  206c7a:	e7ef      	b.n	206c5c <gdispGImageDraw_GIF+0x94a>
					if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  206c7c:	4619      	mov	r1, r3
  206c7e:	e79c      	b.n	206bba <gdispGImageDraw_GIF+0x8a8>
			default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);	break;
  206c80:	980f      	ldr	r0, [sp, #60]	; 0x3c
  206c82:	b20e      	sxth	r6, r1
  206c84:	4418      	add	r0, r3
  206c86:	f104 0346 	add.w	r3, r4, #70	; 0x46
  206c8a:	1a41      	subs	r1, r0, r1
  206c8c:	2000      	movs	r0, #0
  206c8e:	e9cd 6303 	strd	r6, r3, [sp, #12]
  206c92:	2301      	movs	r3, #1
  206c94:	b209      	sxth	r1, r1
  206c96:	e9cd 0001 	strd	r0, r0, [sp, #4]
  206c9a:	9300      	str	r3, [sp, #0]
  206c9c:	4628      	mov	r0, r5
  206c9e:	4633      	mov	r3, r6
  206ca0:	f7ff f9d8 	bl	206054 <gdispGBlitArea>
  206ca4:	e7c6      	b.n	206c34 <gdispGImageDraw_GIF+0x922>
					q = decode->buf;
  206ca6:	f10b 0a1c 	add.w	sl, fp, #28
				if (my >= sy && my < fy && mx >= sx && mx < fx) {
  206caa:	980a      	ldr	r0, [sp, #40]	; 0x28
  206cac:	4684      	mov	ip, r0
  206cae:	980c      	ldr	r0, [sp, #48]	; 0x30
  206cb0:	4584      	cmp	ip, r0
  206cb2:	db12      	blt.n	206cda <gdispGImageDraw_GIF+0x9c8>
  206cb4:	9810      	ldr	r0, [sp, #64]	; 0x40
  206cb6:	4584      	cmp	ip, r0
  206cb8:	da0f      	bge.n	206cda <gdispGImageDraw_GIF+0x9c8>
  206cba:	980d      	ldr	r0, [sp, #52]	; 0x34
  206cbc:	4283      	cmp	r3, r0
  206cbe:	db0c      	blt.n	206cda <gdispGImageDraw_GIF+0x9c8>
  206cc0:	980e      	ldr	r0, [sp, #56]	; 0x38
  206cc2:	4283      	cmp	r3, r0
  206cc4:	da09      	bge.n	206cda <gdispGImageDraw_GIF+0x9c8>
					if ((priv->frame.flags & GIFL_TRANSPARENT) && col == priv->frame.paltrans) {
  206cc6:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
					col = *q;
  206cca:	f89a c000 	ldrb.w	ip, [sl]
					if ((priv->frame.flags & GIFL_TRANSPARENT) && col == priv->frame.paltrans) {
  206cce:	07db      	lsls	r3, r3, #31
  206cd0:	d551      	bpl.n	206d76 <gdispGImageDraw_GIF+0xa64>
  206cd2:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
  206cd6:	4563      	cmp	r3, ip
  206cd8:	d14d      	bne.n	206d76 <gdispGImageDraw_GIF+0xa64>
				switch(gcnt) {
  206cda:	b159      	cbz	r1, 206cf4 <gdispGImageDraw_GIF+0x9e2>
  206cdc:	2901      	cmp	r1, #1
  206cde:	d165      	bne.n	206dac <gdispGImageDraw_GIF+0xa9a>
				case 1:		gdispGDrawPixel(g, x+mx-sx-gcnt, y+my-sy, priv->buf[0]); gcnt = 0;					break;
  206ce0:	1e71      	subs	r1, r6, #1
  206ce2:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
  206ce6:	4628      	mov	r0, r5
  206ce8:	9214      	str	r2, [sp, #80]	; 0x50
  206cea:	b209      	sxth	r1, r1
  206cec:	f7ff faea 	bl	2062c4 <gdispGDrawPixel>
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  206cf0:	2100      	movs	r1, #0
  206cf2:	9a14      	ldr	r2, [sp, #80]	; 0x50
			for(gcnt=0, mx=0; mx < priv->frame.width; mx++, q++, cnt--) {
  206cf4:	3f01      	subs	r7, #1
  206cf6:	3601      	adds	r6, #1
  206cf8:	f10a 0a01 	add.w	sl, sl, #1
  206cfc:	f109 0901 	add.w	r9, r9, #1
  206d00:	b2bf      	uxth	r7, r7
  206d02:	b2b6      	uxth	r6, r6
  206d04:	fa0f f389 	sxth.w	r3, r9
  206d08:	f9b4 0020 	ldrsh.w	r0, [r4, #32]
  206d0c:	4298      	cmp	r0, r3
  206d0e:	dd18      	ble.n	206d42 <gdispGImageDraw_GIF+0xa30>
				if (!cnt) {
  206d10:	2f00      	cmp	r7, #0
  206d12:	d1ca      	bne.n	206caa <gdispGImageDraw_GIF+0x998>
					if (!(cnt = getBytesGif(img))) {
  206d14:	ee18 0a10 	vmov	r0, s16
  206d18:	9314      	str	r3, [sp, #80]	; 0x50
  206d1a:	e9cd 1215 	strd	r1, r2, [sp, #84]	; 0x54
  206d1e:	f7fa f8e9 	bl	200ef4 <getBytesGif>
  206d22:	9a16      	ldr	r2, [sp, #88]	; 0x58
  206d24:	4607      	mov	r7, r0
  206d26:	e9dd 3114 	ldrd	r3, r1, [sp, #80]	; 0x50
  206d2a:	2800      	cmp	r0, #0
  206d2c:	d1bb      	bne.n	206ca6 <gdispGImageDraw_GIF+0x994>
						if (decode->code_last != decode->code_eof)
  206d2e:	f8bb 2010 	ldrh.w	r2, [fp, #16]
  206d32:	f8bb 300c 	ldrh.w	r3, [fp, #12]
  206d36:	429a      	cmp	r2, r3
  206d38:	d162      	bne.n	206e00 <gdispGImageDraw_GIF+0xaee>
						mx++;
  206d3a:	f109 0901 	add.w	r9, r9, #1
  206d3e:	fa0f f389 	sxth.w	r3, r9
			switch(gcnt) {
  206d42:	b181      	cbz	r1, 206d66 <gdispGImageDraw_GIF+0xa54>
  206d44:	2901      	cmp	r1, #1
  206d46:	f9bd 201c 	ldrsh.w	r2, [sp, #28]
  206d4a:	d133      	bne.n	206db4 <gdispGImageDraw_GIF+0xaa2>
			case 1:		gdispGDrawPixel(g, x+mx-sx-gcnt, y+my-sy, priv->buf[0]);					break;
  206d4c:	9908      	ldr	r1, [sp, #32]
  206d4e:	9812      	ldr	r0, [sp, #72]	; 0x48
  206d50:	3901      	subs	r1, #1
  206d52:	4401      	add	r1, r0
  206d54:	9809      	ldr	r0, [sp, #36]	; 0x24
  206d56:	1a09      	subs	r1, r1, r0
  206d58:	4628      	mov	r0, r5
  206d5a:	4419      	add	r1, r3
  206d5c:	f8b4 3046 	ldrh.w	r3, [r4, #70]	; 0x46
  206d60:	b209      	sxth	r1, r1
  206d62:	f7ff faaf 	bl	2062c4 <gdispGDrawPixel>
  206d66:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  206d68:	9e07      	ldr	r6, [sp, #28]
  206d6a:	3301      	adds	r3, #1
  206d6c:	3601      	adds	r6, #1
  206d6e:	930b      	str	r3, [sp, #44]	; 0x2c
  206d70:	b2b3      	uxth	r3, r6
  206d72:	9307      	str	r3, [sp, #28]
  206d74:	e47d      	b.n	206672 <gdispGImageDraw_GIF+0x360>
					priv->buf[gcnt++] = decode->palette[col];
  206d76:	1c4b      	adds	r3, r1, #1
  206d78:	f8db 0018 	ldr.w	r0, [fp, #24]
  206d7c:	b29b      	uxth	r3, r3
  206d7e:	f830 c01c 	ldrh.w	ip, [r0, ip, lsl #1]
  206d82:	eb04 0041 	add.w	r0, r4, r1, lsl #1
					if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  206d86:	2b1f      	cmp	r3, #31
					priv->buf[gcnt++] = decode->palette[col];
  206d88:	f8a0 c046 	strh.w	ip, [r0, #70]	; 0x46
					if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  206d8c:	d910      	bls.n	206db0 <gdispGImageDraw_GIF+0xa9e>
						gdispGBlitArea(g, x+mx-sx-gcnt+1, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);
  206d8e:	b21b      	sxth	r3, r3
				default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf); gcnt = 0;	break;
  206d90:	980f      	ldr	r0, [sp, #60]	; 0x3c
  206d92:	1a71      	subs	r1, r6, r1
  206d94:	9214      	str	r2, [sp, #80]	; 0x50
  206d96:	b209      	sxth	r1, r1
  206d98:	e9cd 3003 	strd	r3, r0, [sp, #12]
  206d9c:	2001      	movs	r0, #1
  206d9e:	e9cd 8801 	strd	r8, r8, [sp, #4]
  206da2:	9000      	str	r0, [sp, #0]
  206da4:	4628      	mov	r0, r5
  206da6:	f7ff f955 	bl	206054 <gdispGBlitArea>
  206daa:	e7a1      	b.n	206cf0 <gdispGImageDraw_GIF+0x9de>
  206dac:	b20b      	sxth	r3, r1
  206dae:	e7ef      	b.n	206d90 <gdispGImageDraw_GIF+0xa7e>
					if (gcnt >= GDISP_IMAGE_GIF_BLIT_BUFFER_SIZE) {
  206db0:	4619      	mov	r1, r3
  206db2:	e79f      	b.n	206cf4 <gdispGImageDraw_GIF+0x9e2>
			default:	gdispGBlitArea(g, x+mx-sx-gcnt, y+my-sy, gcnt, 1, 0, 0, gcnt, priv->buf);	break;
  206db4:	9811      	ldr	r0, [sp, #68]	; 0x44
  206db6:	b20e      	sxth	r6, r1
  206db8:	4418      	add	r0, r3
  206dba:	f104 0346 	add.w	r3, r4, #70	; 0x46
  206dbe:	1a41      	subs	r1, r0, r1
  206dc0:	2000      	movs	r0, #0
  206dc2:	e9cd 6303 	strd	r6, r3, [sp, #12]
  206dc6:	2301      	movs	r3, #1
  206dc8:	b209      	sxth	r1, r1
  206dca:	e9cd 0001 	strd	r0, r0, [sp, #4]
  206dce:	9300      	str	r3, [sp, #0]
  206dd0:	4628      	mov	r0, r5
  206dd2:	4633      	mov	r3, r6
  206dd4:	f7ff f93e 	bl	206054 <gdispGBlitArea>
  206dd8:	e7c5      	b.n	206d66 <gdispGImageDraw_GIF+0xa54>
	while (getBytesGif(img));
  206dda:	ee18 0a10 	vmov	r0, s16
  206dde:	f7fa f889 	bl	200ef4 <getBytesGif>
  206de2:	4607      	mov	r7, r0
  206de4:	2800      	cmp	r0, #0
  206de6:	d1f8      	bne.n	206dda <gdispGImageDraw_GIF+0xac8>
	priv->frame.posend = gfileGetPos(img->f);
  206de8:	ee18 3a10 	vmov	r3, s16
  206dec:	68d8      	ldr	r0, [r3, #12]
  206dee:	f7f9 feb7 	bl	200b60 <gfileGetPos>
  206df2:	63a0      	str	r0, [r4, #56]	; 0x38
	stopDecodeGif(img);
  206df4:	ee18 0a10 	vmov	r0, s16
  206df8:	f7fb f846 	bl	201e88 <stopDecodeGif>
	return GDISP_IMAGE_ERR_OK;
  206dfc:	f7ff baf7 	b.w	2063ee <gdispGImageDraw_GIF+0xdc>
	stopDecodeGif(img);
  206e00:	ee18 0a10 	vmov	r0, s16
	return GDISP_IMAGE_ERR_BADDATA;
  206e04:	f248 0702 	movw	r7, #32770	; 0x8002
	stopDecodeGif(img);
  206e08:	f7fb f83e 	bl	201e88 <stopDecodeGif>
	return GDISP_IMAGE_ERR_BADDATA;
  206e0c:	f7ff baef 	b.w	2063ee <gdispGImageDraw_GIF+0xdc>

00206e10 <_gdispPostInitDriver>:
void _gdispPostInitDriver(GDriver *g) {
  206e10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

#if GDISP_NEED_CLIP || GDISP_NEED_VALIDATION
	void gdispGSetClip(GDisplay *g, gCoord x, gCoord y, gCoord cx, gCoord cy) {
		MUTEX_ENTER(g);
  206e14:	f100 0720 	add.w	r7, r0, #32
		gdispGSetClip(gd, 0, 0, gd->g.Width, gd->g.Height);
  206e18:	f9b0 6008 	ldrsh.w	r6, [r0, #8]
void _gdispPostInitDriver(GDriver *g) {
  206e1c:	4604      	mov	r4, r0
		gdispGSetClip(gd, 0, 0, gd->g.Width, gd->g.Height);
  206e1e:	f9b0 500a 	ldrsh.w	r5, [r0, #10]
		MUTEX_ENTER(g);
  206e22:	4638      	mov	r0, r7
  206e24:	f7fd f9fc 	bl	204220 <chMtxLock>
		// Worst is using software clipping
		#if GDISP_HARDWARE_CLIP != GFXON
			{
				if (x < 0) { cx += x; x = 0; }
				if (y < 0) { cy += y; y = 0; }
				if (cx <= 0 || cy <= 0 || x >= g->g.Width || y >= g->g.Height) { x = y = cx = cy = 0; }
  206e28:	2e00      	cmp	r6, #0
  206e2a:	f9b4 2008 	ldrsh.w	r2, [r4, #8]
  206e2e:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
  206e32:	dd05      	ble.n	206e40 <_gdispPostInitDriver+0x30>
  206e34:	2d00      	cmp	r5, #0
  206e36:	dd03      	ble.n	206e40 <_gdispPostInitDriver+0x30>
  206e38:	2a00      	cmp	r2, #0
  206e3a:	dd01      	ble.n	206e40 <_gdispPostInitDriver+0x30>
  206e3c:	2b00      	cmp	r3, #0
  206e3e:	dc01      	bgt.n	206e44 <_gdispPostInitDriver+0x34>
  206e40:	2500      	movs	r5, #0
  206e42:	462e      	mov	r6, r5
				g->clipx0 = x;
				g->clipy0 = y;
				g->clipx1 = x+cx;	if (g->clipx1 > g->g.Width) g->clipx1 = g->g.Width;
  206e44:	4296      	cmp	r6, r2
				g->clipx0 = x;
  206e46:	f04f 0800 	mov.w	r8, #0
				g->clipy1 = y+cy;	if (g->clipy1 > g->g.Height) g->clipy1 = g->g.Height;
			}
		#endif
		MUTEX_EXIT(g);
  206e4a:	4638      	mov	r0, r7
				g->clipx1 = x+cx;	if (g->clipx1 > g->g.Width) g->clipx1 = g->g.Width;
  206e4c:	bfa8      	it	ge
  206e4e:	4616      	movge	r6, r2
				g->clipy1 = y+cy;	if (g->clipy1 > g->g.Height) g->clipy1 = g->g.Height;
  206e50:	429d      	cmp	r5, r3
				g->clipx0 = x;
  206e52:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
				g->clipy1 = y+cy;	if (g->clipy1 > g->g.Height) g->clipy1 = g->g.Height;
  206e56:	bfa8      	it	ge
  206e58:	461d      	movge	r5, r3
				g->clipx1 = x+cx;	if (g->clipx1 > g->g.Width) g->clipx1 = g->g.Width;
  206e5a:	86a6      	strh	r6, [r4, #52]	; 0x34
				g->clipy1 = y+cy;	if (g->clipy1 > g->g.Height) g->clipy1 = g->g.Height;
  206e5c:	86e5      	strh	r5, [r4, #54]	; 0x36
		MUTEX_EXIT(g);
  206e5e:	f7ff f8c1 	bl	205fe4 <chMtxUnlock>
	MUTEX_ENTER(g);
  206e62:	4638      	mov	r0, r7
  206e64:	f7fd f9dc 	bl	204220 <chMtxLock>
			g->p.cx = g->g.Width;
  206e68:	68a3      	ldr	r3, [r4, #8]
			gdisp_lld_fill_area(g);
  206e6a:	4620      	mov	r0, r4
			g->p.x = g->p.y = 0;
  206e6c:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
			g->p.cx = g->g.Width;
  206e70:	63e3      	str	r3, [r4, #60]	; 0x3c
			g->p.color = color;
  206e72:	231f      	movs	r3, #31
  206e74:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
			gdisp_lld_fill_area(g);
  206e78:	f7f9 fd8a 	bl	200990 <gdisp_lld_fill_area>
			MUTEX_EXIT(g);
  206e7c:	4638      	mov	r0, r7
  206e7e:	f7ff f8b1 	bl	205fe4 <chMtxUnlock>
	if (!GDISP)
  206e82:	4b03      	ldr	r3, [pc, #12]	; (206e90 <_gdispPostInitDriver+0x80>)
  206e84:	681a      	ldr	r2, [r3, #0]
  206e86:	b902      	cbnz	r2, 206e8a <_gdispPostInitDriver+0x7a>
		GDISP = gd;
  206e88:	601c      	str	r4, [r3, #0]
}
  206e8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  206e8e:	bf00      	nop
  206e90:	20000810 	.word	0x20000810

00206e94 <_gdispInitDriver>:
gBool _gdispInitDriver(GDriver *g, void *param, unsigned driverinstance, unsigned systeminstance) {
  206e94:	b538      	push	{r3, r4, r5, lr}
	MUTEX_INIT(gd);
  206e96:	f100 0520 	add.w	r5, r0, #32
	gd->systemdisplay = systeminstance;
  206e9a:	7703      	strb	r3, [r0, #28]
	gd->flags = 0;
  206e9c:	2300      	movs	r3, #0
gBool _gdispInitDriver(GDriver *g, void *param, unsigned driverinstance, unsigned systeminstance) {
  206e9e:	4604      	mov	r4, r0
	gd->controllerdisplay = driverinstance;
  206ea0:	7742      	strb	r2, [r0, #29]
	gd->flags = 0;
  206ea2:	83c3      	strh	r3, [r0, #30]
	gd->priv = param;
  206ea4:	6141      	str	r1, [r0, #20]
  mp->owner = NULL;
  206ea6:	6283      	str	r3, [r0, #40]	; 0x28
  tqp->prev = (thread_t *)tqp;
  206ea8:	e9c0 5508 	strd	r5, r5, [r0, #32]
	MUTEX_ENTER(gd);
  206eac:	4628      	mov	r0, r5
  206eae:	f7fd f9b7 	bl	204220 <chMtxLock>
	ret = gdisp_lld_init(gd);
  206eb2:	4620      	mov	r0, r4
  206eb4:	f7fd fa2c 	bl	204310 <gdisp_lld_init>
  206eb8:	4604      	mov	r4, r0
	MUTEX_EXIT(gd);
  206eba:	4628      	mov	r0, r5
  206ebc:	f7ff f892 	bl	205fe4 <chMtxUnlock>
}
  206ec0:	4620      	mov	r0, r4
  206ec2:	bd38      	pop	{r3, r4, r5, pc}

00206ec4 <__early_init>:
  rccResetAHB1(STM32_GPIO_EN_MASK);
  206ec4:	4a54      	ldr	r2, [pc, #336]	; (207018 <__early_init+0x154>)
  206ec6:	f240 71ff 	movw	r1, #2047	; 0x7ff
  gpio_init(GPIOA, &gpio_default_config.PAData);
  206eca:	4854      	ldr	r0, [pc, #336]	; (20701c <__early_init+0x158>)
void __early_init(void) {
  206ecc:	b508      	push	{r3, lr}
  rccResetAHB1(STM32_GPIO_EN_MASK);
  206ece:	6913      	ldr	r3, [r2, #16]
  206ed0:	430b      	orrs	r3, r1
  206ed2:	6113      	str	r3, [r2, #16]
  206ed4:	6913      	ldr	r3, [r2, #16]
  206ed6:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
  206eda:	f023 0307 	bic.w	r3, r3, #7
  206ede:	6113      	str	r3, [r2, #16]
  206ee0:	6913      	ldr	r3, [r2, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
  206ee2:	6b13      	ldr	r3, [r2, #48]	; 0x30
  206ee4:	430b      	orrs	r3, r1
  206ee6:	6313      	str	r3, [r2, #48]	; 0x30
  206ee8:	6d13      	ldr	r3, [r2, #80]	; 0x50
  206eea:	430b      	orrs	r3, r1
  gpio_init(GPIOA, &gpio_default_config.PAData);
  206eec:	494c      	ldr	r1, [pc, #304]	; (207020 <__early_init+0x15c>)
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
  206eee:	6513      	str	r3, [r2, #80]	; 0x50
  206ef0:	6d13      	ldr	r3, [r2, #80]	; 0x50
  gpio_init(GPIOA, &gpio_default_config.PAData);
  206ef2:	f7fa fa8b 	bl	20140c <gpio_init>
  gpio_init(GPIOB, &gpio_default_config.PBData);
  206ef6:	494b      	ldr	r1, [pc, #300]	; (207024 <__early_init+0x160>)
  206ef8:	484b      	ldr	r0, [pc, #300]	; (207028 <__early_init+0x164>)
  206efa:	f7fa fa87 	bl	20140c <gpio_init>
  gpio_init(GPIOC, &gpio_default_config.PCData);
  206efe:	494b      	ldr	r1, [pc, #300]	; (20702c <__early_init+0x168>)
  206f00:	484b      	ldr	r0, [pc, #300]	; (207030 <__early_init+0x16c>)
  206f02:	f7fa fa83 	bl	20140c <gpio_init>
  gpio_init(GPIOD, &gpio_default_config.PDData);
  206f06:	494b      	ldr	r1, [pc, #300]	; (207034 <__early_init+0x170>)
  206f08:	484b      	ldr	r0, [pc, #300]	; (207038 <__early_init+0x174>)
  206f0a:	f7fa fa7f 	bl	20140c <gpio_init>
  gpio_init(GPIOE, &gpio_default_config.PEData);
  206f0e:	494b      	ldr	r1, [pc, #300]	; (20703c <__early_init+0x178>)
  206f10:	484b      	ldr	r0, [pc, #300]	; (207040 <__early_init+0x17c>)
  206f12:	f7fa fa7b 	bl	20140c <gpio_init>
  gpio_init(GPIOF, &gpio_default_config.PFData);
  206f16:	494b      	ldr	r1, [pc, #300]	; (207044 <__early_init+0x180>)
  206f18:	484b      	ldr	r0, [pc, #300]	; (207048 <__early_init+0x184>)
  206f1a:	f7fa fa77 	bl	20140c <gpio_init>
  gpio_init(GPIOG, &gpio_default_config.PGData);
  206f1e:	494b      	ldr	r1, [pc, #300]	; (20704c <__early_init+0x188>)
  206f20:	484b      	ldr	r0, [pc, #300]	; (207050 <__early_init+0x18c>)
  206f22:	f7fa fa73 	bl	20140c <gpio_init>
  gpio_init(GPIOH, &gpio_default_config.PHData);
  206f26:	494b      	ldr	r1, [pc, #300]	; (207054 <__early_init+0x190>)
  206f28:	484b      	ldr	r0, [pc, #300]	; (207058 <__early_init+0x194>)
  206f2a:	f7fa fa6f 	bl	20140c <gpio_init>
  gpio_init(GPIOI, &gpio_default_config.PIData);
  206f2e:	494b      	ldr	r1, [pc, #300]	; (20705c <__early_init+0x198>)
  206f30:	484b      	ldr	r0, [pc, #300]	; (207060 <__early_init+0x19c>)
  206f32:	f7fa fa6b 	bl	20140c <gpio_init>
  gpio_init(GPIOJ, &gpio_default_config.PJData);
  206f36:	494b      	ldr	r1, [pc, #300]	; (207064 <__early_init+0x1a0>)
  206f38:	484b      	ldr	r0, [pc, #300]	; (207068 <__early_init+0x1a4>)
  206f3a:	f7fa fa67 	bl	20140c <gpio_init>
  gpio_init(GPIOK, &gpio_default_config.PKData);
  206f3e:	494b      	ldr	r1, [pc, #300]	; (20706c <__early_init+0x1a8>)
  206f40:	484b      	ldr	r0, [pc, #300]	; (207070 <__early_init+0x1ac>)
  206f42:	f7fa fa63 	bl	20140c <gpio_init>
#if !STM32_NO_INIT
  /* PWR clock enabled.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
  206f46:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
#endif

  /* PWR initialization.*/
  PWR->CR1 = STM32_VOS;
  206f4a:	f44f 4140 	mov.w	r1, #49152	; 0xc000
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
  206f4e:	6413      	str	r3, [r2, #64]	; 0x40
  PWR->CR1 = STM32_VOS;
  206f50:	4b48      	ldr	r3, [pc, #288]	; (207074 <__early_init+0x1b0>)
  206f52:	6019      	str	r1, [r3, #0]

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  206f54:	6813      	ldr	r3, [r2, #0]
  206f56:	f043 0301 	orr.w	r3, r3, #1
  206f5a:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
  206f5c:	6813      	ldr	r3, [r2, #0]
  206f5e:	079b      	lsls	r3, r3, #30
  206f60:	d5fc      	bpl.n	206f5c <__early_init+0x98>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
  206f62:	6893      	ldr	r3, [r2, #8]
  206f64:	f023 0303 	bic.w	r3, r3, #3
  206f68:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
  206f6a:	4b2b      	ldr	r3, [pc, #172]	; (207018 <__early_init+0x154>)
  206f6c:	461a      	mov	r2, r3
  206f6e:	6899      	ldr	r1, [r3, #8]
  206f70:	f011 010c 	ands.w	r1, r1, #12
  206f74:	d1fb      	bne.n	206f6e <__early_init+0xaa>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  206f76:	6818      	ldr	r0, [r3, #0]
  206f78:	f000 00f9 	and.w	r0, r0, #249	; 0xf9
  206f7c:	6018      	str	r0, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
  206f7e:	6099      	str	r1, [r3, #8]

#if STM32_HSE_ENABLED
  /* HSE activation.*/
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
  206f80:	6819      	ldr	r1, [r3, #0]
  206f82:	f441 21a0 	orr.w	r1, r1, #327680	; 0x50000
  206f86:	6019      	str	r1, [r3, #0]
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
  206f88:	6813      	ldr	r3, [r2, #0]
  206f8a:	0398      	lsls	r0, r3, #14
  206f8c:	d5fc      	bpl.n	206f88 <__early_init+0xc4>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
  206f8e:	4b3a      	ldr	r3, [pc, #232]	; (207078 <__early_init+0x1b4>)
  206f90:	6053      	str	r3, [r2, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
  206f92:	6813      	ldr	r3, [r2, #0]
  206f94:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  206f98:	6013      	str	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
  while ((PWR->CSR1 & PWR_CSR1_VOSRDY) == 0)
  206f9a:	4b36      	ldr	r3, [pc, #216]	; (207074 <__early_init+0x1b0>)
  206f9c:	461a      	mov	r2, r3
  206f9e:	6859      	ldr	r1, [r3, #4]
  206fa0:	0449      	lsls	r1, r1, #17
  206fa2:	d5fc      	bpl.n	206f9e <__early_init+0xda>
    ;                           /* Waits until power regulator is stable.   */

#if STM32_OVERDRIVE_REQUIRED
  /* Overdrive activation performed after activating the PLL in order to save
     time as recommended in RM in "Entering Over-drive mode" paragraph.*/
  PWR->CR1 |= PWR_CR1_ODEN;
  206fa4:	6819      	ldr	r1, [r3, #0]
  206fa6:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
  206faa:	6019      	str	r1, [r3, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODRDY))
  206fac:	6853      	ldr	r3, [r2, #4]
  206fae:	03d8      	lsls	r0, r3, #15
  206fb0:	d5fc      	bpl.n	206fac <__early_init+0xe8>
      ;
  PWR->CR1 |= PWR_CR1_ODSWEN;
  206fb2:	6813      	ldr	r3, [r2, #0]
  206fb4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  206fb8:	6013      	str	r3, [r2, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODSWRDY))
  206fba:	4a2e      	ldr	r2, [pc, #184]	; (207074 <__early_init+0x1b0>)
  206fbc:	6853      	ldr	r3, [r2, #4]
  206fbe:	0399      	lsls	r1, r3, #14
  206fc0:	d5fc      	bpl.n	206fbc <__early_init+0xf8>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
  206fc2:	4b15      	ldr	r3, [pc, #84]	; (207018 <__early_init+0x154>)
  206fc4:	681a      	ldr	r2, [r3, #0]
  206fc6:	0192      	lsls	r2, r2, #6
  206fc8:	d5fc      	bpl.n	206fc4 <__early_init+0x100>
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2SEL | STM32_MCO2PRE | STM32_MCO1PRE | STM32_I2SSRC |
  206fca:	4a2c      	ldr	r2, [pc, #176]	; (20707c <__early_init+0x1b8>)
  206fcc:	609a      	str	r2, [r3, #8]
    dckcfgr1 |= STM32_SAI2SEL;
#endif
#if STM32_SAI1SEL != STM32_SAI1SEL_OFF
    dckcfgr1 |= STM32_SAI1SEL;
#endif
    RCC->DCKCFGR1 = dckcfgr1;
  206fce:	f240 1201 	movw	r2, #257	; 0x101
  206fd2:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  }

  /* Peripheral clock sources.*/
  RCC->DCKCFGR2 = STM32_SDMMC2SEL | STM32_SDMMC1SEL | STM32_CK48MSEL  |
  206fd6:	2200      	movs	r2, #0
  206fd8:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
                  STM32_UART8SEL  | STM32_UART7SEL  | STM32_USART6SEL |
                  STM32_UART5SEL  | STM32_UART4SEL  | STM32_USART3SEL |
                  STM32_USART2SEL | STM32_USART1SEL;

  /* Flash setup.*/
  FLASH->ACR = FLASH_ACR_ARTEN | FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  206fdc:	f240 3207 	movw	r2, #775	; 0x307
  206fe0:	4b27      	ldr	r3, [pc, #156]	; (207080 <__early_init+0x1bc>)
  206fe2:	601a      	str	r2, [r3, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
  206fe4:	681a      	ldr	r2, [r3, #0]
  206fe6:	f002 020f 	and.w	r2, r2, #15
  206fea:	2a07      	cmp	r2, #7
  206fec:	d1fa      	bne.n	206fe4 <__early_init+0x120>
         (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
  206fee:	4b0a      	ldr	r3, [pc, #40]	; (207018 <__early_init+0x154>)
  206ff0:	689a      	ldr	r2, [r3, #8]
  206ff2:	f042 0202 	orr.w	r2, r2, #2
  206ff6:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
  206ff8:	689a      	ldr	r2, [r3, #8]
  206ffa:	f002 020c 	and.w	r2, r2, #12
  206ffe:	2a08      	cmp	r2, #8
  207000:	d1fa      	bne.n	206ff8 <__early_init+0x134>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
  207002:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  207004:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
  207008:	645a      	str	r2, [r3, #68]	; 0x44
  20700a:	6e5a      	ldr	r2, [r3, #100]	; 0x64
  20700c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
  207010:	665a      	str	r2, [r3, #100]	; 0x64
  207012:	6e5b      	ldr	r3, [r3, #100]	; 0x64
}
  207014:	bd08      	pop	{r3, pc}
  207016:	bf00      	nop
  207018:	40023800 	.word	0x40023800
  20701c:	40020000 	.word	0x40020000
  207020:	0800e75c 	.word	0x0800e75c
  207024:	0800e778 	.word	0x0800e778
  207028:	40020400 	.word	0x40020400
  20702c:	0800e794 	.word	0x0800e794
  207030:	40020800 	.word	0x40020800
  207034:	0800e7b0 	.word	0x0800e7b0
  207038:	40020c00 	.word	0x40020c00
  20703c:	0800e7cc 	.word	0x0800e7cc
  207040:	40021000 	.word	0x40021000
  207044:	0800e7e8 	.word	0x0800e7e8
  207048:	40021400 	.word	0x40021400
  20704c:	0800e804 	.word	0x0800e804
  207050:	40021800 	.word	0x40021800
  207054:	0800e820 	.word	0x0800e820
  207058:	40021c00 	.word	0x40021c00
  20705c:	0800e83c 	.word	0x0800e83c
  207060:	40022000 	.word	0x40022000
  207064:	0800e858 	.word	0x0800e858
  207068:	40022400 	.word	0x40022400
  20706c:	0800e874 	.word	0x0800e874
  207070:	40022800 	.word	0x40022800
  207074:	40007000 	.word	0x40007000
  207078:	09406c19 	.word	0x09406c19
  20707c:	30999400 	.word	0x30999400
  207080:	40023c00 	.word	0x40023c00

00207084 <Vector100>:
/**
 * @brief   FSMC shared interrupt handler.
 *
 * @notapi
 */
CH_IRQ_HANDLER(STM32_FSMC_HANDLER) {
  207084:	b508      	push	{r3, lr}

  CH_IRQ_PROLOGUE();
  207086:	4805      	ldr	r0, [pc, #20]	; (20709c <Vector100+0x18>)
  207088:	f7fd fc70 	bl	20496c <_trace_isr_enter>
#if STM32_NAND_USE_FSMC_NAND2
  if (FSMCD1.nand2->SR & FSMC_SR_ISR_MASK) {
    NANDD2.isr_handler(&NANDD2);
  }
#endif
  CH_IRQ_EPILOGUE();
  20708c:	4803      	ldr	r0, [pc, #12]	; (20709c <Vector100+0x18>)
  20708e:	f7fd fc59 	bl	204944 <_trace_isr_leave>
}
  207092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  CH_IRQ_EPILOGUE();
  207096:	f7fd b891 	b.w	2041bc <_port_irq_epilogue>
  20709a:	bf00      	nop
  20709c:	0800e4c0 	.word	0x0800e4c0

002070a0 <VectorD4>:
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
  2070a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  USART_TypeDef *u = sdp->usart;
  2070a4:	4c55      	ldr	r4, [pc, #340]	; (2071fc <VectorD4+0x15c>)
  OSAL_IRQ_PROLOGUE();
  2070a6:	4856      	ldr	r0, [pc, #344]	; (207200 <VectorD4+0x160>)
  2070a8:	f7fd fc60 	bl	20496c <_trace_isr_enter>
  USART_TypeDef *u = sdp->usart;
  2070ac:	6d66      	ldr	r6, [r4, #84]	; 0x54
  uint32_t cr1 = u->CR1;
  2070ae:	6837      	ldr	r7, [r6, #0]
  isr = u->ISR;
  2070b0:	69f5      	ldr	r5, [r6, #28]
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
  2070b2:	072a      	lsls	r2, r5, #28
  u->ICR = isr;
  2070b4:	6235      	str	r5, [r6, #32]
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
  2070b6:	d017      	beq.n	2070e8 <VectorD4+0x48>
    sts |= SD_OVERRUN_ERROR;
  2070b8:	f015 0108 	ands.w	r1, r5, #8
  2070bc:	bf18      	it	ne
  2070be:	2180      	movne	r1, #128	; 0x80
  if (isr & USART_ISR_PE)
  2070c0:	07eb      	lsls	r3, r5, #31
    sts |= SD_PARITY_ERROR;
  2070c2:	bf48      	it	mi
  2070c4:	f041 0120 	orrmi.w	r1, r1, #32
  if (isr & USART_ISR_FE)
  2070c8:	07a8      	lsls	r0, r5, #30
    sts |= SD_FRAMING_ERROR;
  2070ca:	bf48      	it	mi
  2070cc:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (isr & USART_ISR_NE)
  2070d0:	076a      	lsls	r2, r5, #29
    sts |= SD_NOISE_ERROR;
  2070d2:	bf48      	it	mi
  2070d4:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
  2070d8:	f7fd f80e 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  chEvtBroadcastFlagsI(esp, flags);
  2070dc:	4849      	ldr	r0, [pc, #292]	; (207204 <VectorD4+0x164>)
  2070de:	f7fd ffa7 	bl	205030 <chEvtBroadcastFlagsI>
  2070e2:	2300      	movs	r3, #0
  2070e4:	f383 8811 	msr	BASEPRI, r3
  if (isr & USART_ISR_LBDF) {
  2070e8:	05eb      	lsls	r3, r5, #23
  2070ea:	d509      	bpl.n	207100 <VectorD4+0x60>
  2070ec:	f7fd f804 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  2070f0:	f44f 7100 	mov.w	r1, #512	; 0x200
  2070f4:	4843      	ldr	r0, [pc, #268]	; (207204 <VectorD4+0x164>)
  2070f6:	f7fd ff9b 	bl	205030 <chEvtBroadcastFlagsI>
  2070fa:	2300      	movs	r3, #0
  2070fc:	f383 8811 	msr	BASEPRI, r3
  207100:	f8df 9100 	ldr.w	r9, [pc, #256]	; 207204 <VectorD4+0x164>
  chThdDequeueNextI(tqp, msg);
  207104:	f109 0a08 	add.w	sl, r9, #8
  while (isr & USART_ISR_RXNE) {
  207108:	f015 0820 	ands.w	r8, r5, #32
  20710c:	d11f      	bne.n	20714e <VectorD4+0xae>
  if (cr1 & USART_CR1_TXEIE) {
  20710e:	0638      	lsls	r0, r7, #24
  207110:	d553      	bpl.n	2071ba <VectorD4+0x11a>
  207112:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 207208 <VectorD4+0x168>
    while (isr & USART_ISR_TXE) {
  207116:	0629      	lsls	r1, r5, #24
  207118:	d54f      	bpl.n	2071ba <VectorD4+0x11a>
  20711a:	f7fc ffed 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
msg_t oqGetI(output_queue_t *oqp) {

  osalDbgCheckClassI();

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
  20711e:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	; 0x44
  207122:	429a      	cmp	r2, r3
  207124:	d102      	bne.n	20712c <VectorD4+0x8c>
  207126:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  207128:	2a00      	cmp	r2, #0
  20712a:	d13c      	bne.n	2071a6 <VectorD4+0x106>
    uint8_t b;

    oqp->q_counter++;
  20712c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  20712e:	3201      	adds	r2, #1
  207130:	63a2      	str	r2, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
  207132:	1c5a      	adds	r2, r3, #1
  207134:	64a2      	str	r2, [r4, #72]	; 0x48
  207136:	781d      	ldrb	r5, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
  207138:	6c23      	ldr	r3, [r4, #64]	; 0x40
  20713a:	429a      	cmp	r2, r3
  20713c:	d25a      	bcs.n	2071f4 <VectorD4+0x154>
  20713e:	4648      	mov	r0, r9
  207140:	f7fc fe5a 	bl	203df8 <chThdDequeueNextI.constprop.0>
      u->TDR = b;
  207144:	62b5      	str	r5, [r6, #40]	; 0x28
  207146:	f388 8811 	msr	BASEPRI, r8
      isr = u->ISR;
  20714a:	69f5      	ldr	r5, [r6, #28]
  20714c:	e7e3      	b.n	207116 <VectorD4+0x76>
  20714e:	f7fc ffd3 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
  207152:	6a73      	ldr	r3, [r6, #36]	; 0x24
  207154:	f894 505c 	ldrb.w	r5, [r4, #92]	; 0x5c
  207158:	401d      	ands	r5, r3
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
  20715a:	6963      	ldr	r3, [r4, #20]
  20715c:	b91b      	cbnz	r3, 207166 <VectorD4+0xc6>
  chEvtBroadcastFlagsI(esp, flags);
  20715e:	2104      	movs	r1, #4
  207160:	4648      	mov	r0, r9
  207162:	f7fd ff65 	bl	205030 <chEvtBroadcastFlagsI>
  if (!iqIsFullI(iqp)) {
  207166:	e9d4 3208 	ldrd	r3, r2, [r4, #32]
  20716a:	4293      	cmp	r3, r2
  20716c:	d10b      	bne.n	207186 <VectorD4+0xe6>
  20716e:	6962      	ldr	r2, [r4, #20]
  207170:	b14a      	cbz	r2, 207186 <VectorD4+0xe6>
  207172:	f44f 6180 	mov.w	r1, #1024	; 0x400
  207176:	4648      	mov	r0, r9
  207178:	f7fd ff5a 	bl	205030 <chEvtBroadcastFlagsI>
  20717c:	2300      	movs	r3, #0
  20717e:	f383 8811 	msr	BASEPRI, r3
    isr = u->ISR;
  207182:	69f5      	ldr	r5, [r6, #28]
  207184:	e7c0      	b.n	207108 <VectorD4+0x68>
    iqp->q_counter++;
  207186:	6962      	ldr	r2, [r4, #20]
  chThdDequeueNextI(tqp, msg);
  207188:	4650      	mov	r0, sl
  20718a:	3201      	adds	r2, #1
  20718c:	6162      	str	r2, [r4, #20]
    *iqp->q_wrptr++ = b;
  20718e:	1c5a      	adds	r2, r3, #1
  207190:	6222      	str	r2, [r4, #32]
  207192:	701d      	strb	r5, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
  207194:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
  207198:	429a      	cmp	r2, r3
      iqp->q_wrptr = iqp->q_buffer;
  20719a:	bf24      	itt	cs
  20719c:	69a3      	ldrcs	r3, [r4, #24]
  20719e:	6223      	strcs	r3, [r4, #32]
  2071a0:	f7fc fe2a 	bl	203df8 <chThdDequeueNextI.constprop.0>
  2071a4:	e7ea      	b.n	20717c <VectorD4+0xdc>
  chEvtBroadcastFlagsI(esp, flags);
  2071a6:	2108      	movs	r1, #8
  2071a8:	4816      	ldr	r0, [pc, #88]	; (207204 <VectorD4+0x164>)
  2071aa:	f7fd ff41 	bl	205030 <chEvtBroadcastFlagsI>
        u->CR1 = cr1 & ~USART_CR1_TXEIE;
  2071ae:	f027 0380 	bic.w	r3, r7, #128	; 0x80
  2071b2:	6033      	str	r3, [r6, #0]
  2071b4:	2300      	movs	r3, #0
  2071b6:	f383 8811 	msr	BASEPRI, r3
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_ISR_TC)) {
  2071ba:	067a      	lsls	r2, r7, #25
  2071bc:	d513      	bpl.n	2071e6 <VectorD4+0x146>
  2071be:	066b      	lsls	r3, r5, #25
  2071c0:	d511      	bpl.n	2071e6 <VectorD4+0x146>
  2071c2:	f7fc ff99 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
    if (oqIsEmptyI(&sdp->oqueue)) {
  2071c6:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	; 0x44
  2071ca:	429a      	cmp	r2, r3
  2071cc:	d108      	bne.n	2071e0 <VectorD4+0x140>
  2071ce:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  2071d0:	b133      	cbz	r3, 2071e0 <VectorD4+0x140>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
  2071d2:	f027 0740 	bic.w	r7, r7, #64	; 0x40
  2071d6:	2110      	movs	r1, #16
  2071d8:	480a      	ldr	r0, [pc, #40]	; (207204 <VectorD4+0x164>)
  2071da:	f7fd ff29 	bl	205030 <chEvtBroadcastFlagsI>
  2071de:	6037      	str	r7, [r6, #0]
  2071e0:	2300      	movs	r3, #0
  2071e2:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_EPILOGUE();
  2071e6:	4806      	ldr	r0, [pc, #24]	; (207200 <VectorD4+0x160>)
  2071e8:	f7fd fbac 	bl	204944 <_trace_isr_leave>
}
  2071ec:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
  2071f0:	f7fc bfe4 	b.w	2041bc <_port_irq_epilogue>
      oqp->q_rdptr = oqp->q_buffer;
  2071f4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  2071f6:	64a3      	str	r3, [r4, #72]	; 0x48
  2071f8:	e7a1      	b.n	20713e <VectorD4+0x9e>
  2071fa:	bf00      	nop
  2071fc:	2000088c 	.word	0x2000088c
  207200:	0800e474 	.word	0x0800e474
  207204:	20000890 	.word	0x20000890
  207208:	200008bc 	.word	0x200008bc

0020720c <Vector108>:
  OSAL_IRQ_PROLOGUE();
  20720c:	480e      	ldr	r0, [pc, #56]	; (207248 <Vector108+0x3c>)
OSAL_IRQ_HANDLER(STM32_TIM5_HANDLER) {
  20720e:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  207210:	f7fd fbac 	bl	20496c <_trace_isr_enter>
 *
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {

  gptp->tim->SR = 0;
  207214:	4b0d      	ldr	r3, [pc, #52]	; (20724c <Vector108+0x40>)
  207216:	2100      	movs	r1, #0
  if (gptp->state == GPT_ONESHOT) {
  207218:	7818      	ldrb	r0, [r3, #0]
  gptp->tim->SR = 0;
  20721a:	68da      	ldr	r2, [r3, #12]
  if (gptp->state == GPT_ONESHOT) {
  20721c:	2804      	cmp	r0, #4
  gptp->tim->SR = 0;
  20721e:	6111      	str	r1, [r2, #16]
  if (gptp->state == GPT_ONESHOT) {
  207220:	d107      	bne.n	207232 <Vector108+0x26>
    gptp->state = GPT_READY;                /* Back in GPT_READY state.     */
  207222:	2002      	movs	r0, #2
  207224:	7018      	strb	r0, [r3, #0]
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
  207226:	6011      	str	r1, [r2, #0]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  207228:	6111      	str	r1, [r2, #16]
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
  20722a:	68d1      	ldr	r1, [r2, #12]
  20722c:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  207230:	60d1      	str	r1, [r2, #12]
    gpt_lld_stop_timer(gptp);               /* Timer automatically stopped. */
  }
  gptp->config->callback(gptp);
  207232:	685b      	ldr	r3, [r3, #4]
  207234:	4805      	ldr	r0, [pc, #20]	; (20724c <Vector108+0x40>)
  207236:	685b      	ldr	r3, [r3, #4]
  207238:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  20723a:	4803      	ldr	r0, [pc, #12]	; (207248 <Vector108+0x3c>)
  20723c:	f7fd fb82 	bl	204944 <_trace_isr_leave>
}
  207240:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  207244:	f7fc bfba 	b.w	2041bc <_port_irq_epilogue>
  207248:	0800e42b 	.word	0x0800e42b
  20724c:	20000814 	.word	0x20000814

00207250 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
  207250:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  OSAL_IRQ_PROLOGUE();
  207254:	4825      	ldr	r0, [pc, #148]	; (2072ec <VectorB0+0x9c>)
  207256:	f7fd fb89 	bl	20496c <_trace_isr_enter>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
  20725a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  20725e:	691a      	ldr	r2, [r3, #16]
  207260:	0792      	lsls	r2, r2, #30
  207262:	d53b      	bpl.n	2072dc <VectorB0+0x8c>
    STM32_ST_TIM->SR = 0U;
  207264:	2500      	movs	r5, #0
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
  207266:	4c22      	ldr	r4, [pc, #136]	; (2072f0 <VectorB0+0xa0>)
  207268:	611d      	str	r5, [r3, #16]
  20726a:	f104 081c 	add.w	r8, r4, #28
  20726e:	f7fc ff43 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  207272:	46a9      	mov	r9, r5
  207274:	69e3      	ldr	r3, [r4, #28]
  207276:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
  20727a:	6aa1      	ldr	r1, [r4, #40]	; 0x28

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
  20727c:	689f      	ldr	r7, [r3, #8]
  20727e:	6a42      	ldr	r2, [r0, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
  207280:	1a56      	subs	r6, r2, r1
  207282:	42be      	cmp	r6, r7
  207284:	d319      	bcc.n	2072ba <VectorB0+0x6a>
  STM32_ST_TIM->DIER = 0;
  207286:	4607      	mov	r7, r0
    /* Consuming all timers between "vtp->lasttime" and now.*/
    do {
      vtfunc_t fn;

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
  207288:	6899      	ldr	r1, [r3, #8]
  20728a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
      nowdelta -= vtp->delta;
  20728c:	1a76      	subs	r6, r6, r1
      ch.vtlist.lasttime += vtp->delta;
  20728e:	440a      	add	r2, r1

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
  207290:	68d9      	ldr	r1, [r3, #12]
      ch.vtlist.lasttime += vtp->delta;
  207292:	62a2      	str	r2, [r4, #40]	; 0x28
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
  207294:	681a      	ldr	r2, [r3, #0]
      vtp->func = NULL;

      /* If the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
  207296:	4542      	cmp	r2, r8
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
  207298:	f8c2 8004 	str.w	r8, [r2, #4]
      ch.vtlist.next = vtp->next;
  20729c:	61e2      	str	r2, [r4, #28]
      vtp->func = NULL;
  20729e:	60dd      	str	r5, [r3, #12]
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
  2072a0:	d100      	bne.n	2072a4 <VectorB0+0x54>
  2072a2:	60fd      	str	r5, [r7, #12]
  2072a4:	f389 8811 	msr	BASEPRI, r9
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
  2072a8:	6918      	ldr	r0, [r3, #16]
  2072aa:	4788      	blx	r1
  2072ac:	f7fc ff24 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
  2072b0:	69e3      	ldr	r3, [r4, #28]
    }
    while (vtp->delta <= nowdelta);
  2072b2:	689a      	ldr	r2, [r3, #8]
  2072b4:	4296      	cmp	r6, r2
  2072b6:	d2e7      	bcs.n	207288 <VectorB0+0x38>
  2072b8:	e7dd      	b.n	207276 <VectorB0+0x26>
  }

  /* If the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
  2072ba:	69e5      	ldr	r5, [r4, #28]
  2072bc:	4545      	cmp	r5, r8
  2072be:	d00a      	beq.n	2072d6 <VectorB0+0x86>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  2072c0:	62a2      	str	r2, [r4, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
  2072c2:	68ac      	ldr	r4, [r5, #8]
  2072c4:	4421      	add	r1, r4
  2072c6:	1a89      	subs	r1, r1, r2
  2072c8:	60a9      	str	r1, [r5, #8]
  return systime + (systime_t)interval;
  2072ca:	689b      	ldr	r3, [r3, #8]
  2072cc:	2b02      	cmp	r3, #2
  2072ce:	bf2c      	ite	cs
  2072d0:	18d2      	addcs	r2, r2, r3
  2072d2:	3202      	addcc	r2, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  2072d4:	6342      	str	r2, [r0, #52]	; 0x34
  2072d6:	2300      	movs	r3, #0
  2072d8:	f383 8811 	msr	BASEPRI, r3
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
  2072dc:	4803      	ldr	r0, [pc, #12]	; (2072ec <VectorB0+0x9c>)
  2072de:	f7fd fb31 	bl	204944 <_trace_isr_leave>
}
  2072e2:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_EPILOGUE();
  2072e6:	f7fc bf69 	b.w	2041bc <_port_irq_epilogue>
  2072ea:	bf00      	nop
  2072ec:	0800e422 	.word	0x0800e422
  2072f0:	20000e8c 	.word	0x20000e8c

002072f4 <sdc_lld_collect_errors.isra.0.lto_priv.0>:
  if (sta & SDMMC_STA_CCRCFAIL)
  2072f4:	f001 0301 	and.w	r3, r1, #1
  if (sta & SDMMC_STA_DCRCFAIL)
  2072f8:	078a      	lsls	r2, r1, #30
    errors |= SDC_DATA_CRC_ERROR;
  2072fa:	bf48      	it	mi
  2072fc:	f043 0302 	orrmi.w	r3, r3, #2
  if (sta & SDMMC_STA_CTIMEOUT)
  207300:	074a      	lsls	r2, r1, #29
    errors |= SDC_COMMAND_TIMEOUT;
  207302:	bf48      	it	mi
  207304:	f043 0308 	orrmi.w	r3, r3, #8
  if (sta & SDMMC_STA_DTIMEOUT)
  207308:	070a      	lsls	r2, r1, #28
    errors |= SDC_DATA_TIMEOUT;
  20730a:	bf48      	it	mi
  20730c:	f043 0304 	orrmi.w	r3, r3, #4
  if (sta & SDMMC_STA_TXUNDERR)
  207310:	06ca      	lsls	r2, r1, #27
    errors |= SDC_TX_UNDERRUN;
  207312:	bf48      	it	mi
  207314:	f043 0310 	orrmi.w	r3, r3, #16
  if (sta & SDMMC_STA_RXOVERR)
  207318:	068a      	lsls	r2, r1, #26
  sdcp->errors |= errors;
  20731a:	6802      	ldr	r2, [r0, #0]
    errors |= SDC_RX_OVERRUN;
  20731c:	bf48      	it	mi
  20731e:	f043 0320 	orrmi.w	r3, r3, #32
  sdcp->errors |= errors;
  207322:	4313      	orrs	r3, r2
  207324:	6003      	str	r3, [r0, #0]
}
  207326:	4770      	bx	lr

00207328 <sdc_lld_send_cmd_long_crc>:
                               uint32_t *resp) {
  207328:	b510      	push	{r4, lr}
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_WAITRESP_1 |
  20732a:	f441 6198 	orr.w	r1, r1, #1216	; 0x4c0
  sdcp->sdmmc->ARG = arg;
  20732e:	6d04      	ldr	r4, [r0, #80]	; 0x50
  207330:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_WAITRESP_1 |
  207332:	60e1      	str	r1, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
  207334:	6b61      	ldr	r1, [r4, #52]	; 0x34
  207336:	f011 0245 	ands.w	r2, r1, #69	; 0x45
  20733a:	d0fb      	beq.n	207334 <sdc_lld_send_cmd_long_crc+0xc>
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
  20733c:	63a2      	str	r2, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_ERROR_MASK)) != 0) {
  20733e:	f011 023f 	ands.w	r2, r1, #63	; 0x3f
  207342:	d004      	beq.n	20734e <sdc_lld_send_cmd_long_crc+0x26>
    sdc_lld_collect_errors(sdcp, sta);
  207344:	3034      	adds	r0, #52	; 0x34
  207346:	f7ff ffd5 	bl	2072f4 <sdc_lld_collect_errors.isra.0.lto_priv.0>
    return HAL_FAILED;
  20734a:	2001      	movs	r0, #1
}
  20734c:	bd10      	pop	{r4, pc}
  *resp++ = sdcp->sdmmc->RESP4;
  20734e:	6a21      	ldr	r1, [r4, #32]
  return HAL_SUCCESS;
  207350:	4610      	mov	r0, r2
  *resp++ = sdcp->sdmmc->RESP4;
  207352:	6019      	str	r1, [r3, #0]
  *resp++ = sdcp->sdmmc->RESP3;
  207354:	69e1      	ldr	r1, [r4, #28]
  207356:	6059      	str	r1, [r3, #4]
  *resp++ = sdcp->sdmmc->RESP2;
  207358:	69a1      	ldr	r1, [r4, #24]
  20735a:	6099      	str	r1, [r3, #8]
  *resp   = sdcp->sdmmc->RESP1;
  20735c:	6961      	ldr	r1, [r4, #20]
  20735e:	60d9      	str	r1, [r3, #12]
  return HAL_SUCCESS;
  207360:	e7f4      	b.n	20734c <sdc_lld_send_cmd_long_crc+0x24>

00207362 <sdc_lld_send_cmd_short_crc>:
                                uint32_t *resp) {
  207362:	b510      	push	{r4, lr}
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
  207364:	f441 6188 	orr.w	r1, r1, #1088	; 0x440
  sdcp->sdmmc->ARG = arg;
  207368:	6d04      	ldr	r4, [r0, #80]	; 0x50
  20736a:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
  20736c:	60e1      	str	r1, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
  20736e:	6b61      	ldr	r1, [r4, #52]	; 0x34
  207370:	f011 0245 	ands.w	r2, r1, #69	; 0x45
  207374:	d0fb      	beq.n	20736e <sdc_lld_send_cmd_short_crc+0xc>
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL);
  207376:	63a2      	str	r2, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
  207378:	f011 0205 	ands.w	r2, r1, #5
  20737c:	d004      	beq.n	207388 <sdc_lld_send_cmd_short_crc+0x26>
    sdc_lld_collect_errors(sdcp, sta);
  20737e:	3034      	adds	r0, #52	; 0x34
  207380:	f7ff ffb8 	bl	2072f4 <sdc_lld_collect_errors.isra.0.lto_priv.0>
    return HAL_FAILED;
  207384:	2001      	movs	r0, #1
}
  207386:	bd10      	pop	{r4, pc}
  *resp = sdcp->sdmmc->RESP1;
  207388:	6961      	ldr	r1, [r4, #20]
  return HAL_SUCCESS;
  20738a:	4610      	mov	r0, r2
  *resp = sdcp->sdmmc->RESP1;
  20738c:	6019      	str	r1, [r3, #0]
  return HAL_SUCCESS;
  20738e:	e7fa      	b.n	207386 <sdc_lld_send_cmd_short_crc+0x24>

00207390 <sdc_lld_error_cleanup>:
                                  uint32_t *resp) {
  207390:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  207392:	4604      	mov	r4, r0
  207394:	4613      	mov	r3, r2
  uint32_t sta = sdcp->sdmmc->STA;
  207396:	6d00      	ldr	r0, [r0, #80]	; 0x50
                                  uint32_t *resp) {
  207398:	460e      	mov	r6, r1
  dmaStreamDisable(sdcp->dma);
  20739a:	6ce7      	ldr	r7, [r4, #76]	; 0x4c
  uint32_t sta = sdcp->sdmmc->STA;
  20739c:	6b41      	ldr	r1, [r0, #52]	; 0x34
  dmaStreamDisable(sdcp->dma);
  20739e:	683a      	ldr	r2, [r7, #0]
  2073a0:	6815      	ldr	r5, [r2, #0]
  2073a2:	f025 051f 	bic.w	r5, r5, #31
  2073a6:	6015      	str	r5, [r2, #0]
  2073a8:	6815      	ldr	r5, [r2, #0]
  2073aa:	f015 0501 	ands.w	r5, r5, #1
  2073ae:	d1fb      	bne.n	2073a8 <sdc_lld_error_cleanup+0x18>
  2073b0:	f8d7 c004 	ldr.w	ip, [r7, #4]
  2073b4:	223d      	movs	r2, #61	; 0x3d
  2073b6:	7a7f      	ldrb	r7, [r7, #9]
  2073b8:	9301      	str	r3, [sp, #4]
  2073ba:	40ba      	lsls	r2, r7
  2073bc:	f8cc 2000 	str.w	r2, [ip]
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
  2073c0:	4a0a      	ldr	r2, [pc, #40]	; (2073ec <sdc_lld_error_cleanup+0x5c>)
  2073c2:	6382      	str	r2, [r0, #56]	; 0x38
  sdcp->sdmmc->MASK  = 0;
  2073c4:	63c5      	str	r5, [r0, #60]	; 0x3c
  sdcp->sdmmc->DCTRL = 0;
  2073c6:	62c5      	str	r5, [r0, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
  2073c8:	f104 0034 	add.w	r0, r4, #52	; 0x34
  2073cc:	f7ff ff92 	bl	2072f4 <sdc_lld_collect_errors.isra.0.lto_priv.0>
  if (n > 1)
  2073d0:	2e01      	cmp	r6, #1
  2073d2:	d908      	bls.n	2073e6 <sdc_lld_error_cleanup+0x56>
    sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
  2073d4:	9b01      	ldr	r3, [sp, #4]
  2073d6:	462a      	mov	r2, r5
  2073d8:	210c      	movs	r1, #12
  2073da:	4620      	mov	r0, r4
}
  2073dc:	b003      	add	sp, #12
  2073de:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
  2073e2:	f7ff bfbe 	b.w	207362 <sdc_lld_send_cmd_short_crc>
}
  2073e6:	b003      	add	sp, #12
  2073e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  2073ea:	bf00      	nop
  2073ec:	004005ff 	.word	0x004005ff

002073f0 <sdc_lld_wait_transaction_end>:
                                         uint32_t *resp) {
  2073f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  2073f4:	4605      	mov	r5, r0
  2073f6:	460f      	mov	r7, r1
  2073f8:	4616      	mov	r6, r2
  2073fa:	f7fc fe7d 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  if (sdcp->sdmmc->MASK != 0)
  2073fe:	6d03      	ldr	r3, [r0, #80]	; 0x50
  207400:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  207402:	b143      	cbz	r3, 207416 <sdc_lld_wait_transaction_end+0x26>
  207404:	4b18      	ldr	r3, [pc, #96]	; (207468 <sdc_lld_wait_transaction_end+0x78>)
  207406:	699a      	ldr	r2, [r3, #24]
  *trp = tp;
  207408:	4603      	mov	r3, r0
    chSchGoSleepS(newstate);
  20740a:	2003      	movs	r0, #3
  20740c:	f843 2f3c 	str.w	r2, [r3, #60]!
  tp->u.wttrp = trp;
  207410:	6253      	str	r3, [r2, #36]	; 0x24
  207412:	f7fa f9cd 	bl	2017b0 <chSchGoSleepS>
  if ((sdcp->sdmmc->STA & SDMMC_STA_DATAEND) == 0) {
  207416:	6d2b      	ldr	r3, [r5, #80]	; 0x50
  207418:	6b58      	ldr	r0, [r3, #52]	; 0x34
  20741a:	f410 7080 	ands.w	r0, r0, #256	; 0x100
  20741e:	d104      	bne.n	20742a <sdc_lld_wait_transaction_end+0x3a>
  207420:	f380 8811 	msr	BASEPRI, r0
    return HAL_FAILED;
  207424:	2001      	movs	r0, #1
}
  207426:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  dmaWaitCompletion(sdcp->dma);
  20742a:	6ce9      	ldr	r1, [r5, #76]	; 0x4c
  20742c:	6808      	ldr	r0, [r1, #0]
  20742e:	6802      	ldr	r2, [r0, #0]
  207430:	f022 021e 	bic.w	r2, r2, #30
  207434:	6002      	str	r2, [r0, #0]
  207436:	6802      	ldr	r2, [r0, #0]
  207438:	f012 0201 	ands.w	r2, r2, #1
  20743c:	d1fb      	bne.n	207436 <sdc_lld_wait_transaction_end+0x46>
  20743e:	7a4c      	ldrb	r4, [r1, #9]
  207440:	6848      	ldr	r0, [r1, #4]
  207442:	213d      	movs	r1, #61	; 0x3d
  207444:	40a1      	lsls	r1, r4
  207446:	6001      	str	r1, [r0, #0]
  sdcp->sdmmc->ICR = SDMMC_ICR_ALL_FLAGS;
  207448:	4908      	ldr	r1, [pc, #32]	; (20746c <sdc_lld_wait_transaction_end+0x7c>)
  20744a:	6399      	str	r1, [r3, #56]	; 0x38
  sdcp->sdmmc->DCTRL = 0;
  20744c:	62da      	str	r2, [r3, #44]	; 0x2c
  20744e:	f382 8811 	msr	BASEPRI, r2
  if (n > 1)
  207452:	2f01      	cmp	r7, #1
  207454:	d906      	bls.n	207464 <sdc_lld_wait_transaction_end+0x74>
    return sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
  207456:	4633      	mov	r3, r6
  207458:	4628      	mov	r0, r5
  20745a:	210c      	movs	r1, #12
}
  20745c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    return sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
  207460:	f7ff bf7f 	b.w	207362 <sdc_lld_send_cmd_short_crc>
  return HAL_SUCCESS;
  207464:	4610      	mov	r0, r2
  207466:	e7de      	b.n	207426 <sdc_lld_wait_transaction_end+0x36>
  207468:	20000e8c 	.word	0x20000e8c
  20746c:	004005ff 	.word	0x004005ff

00207470 <sdc_lld_write_aligned.part.0>:
bool sdc_lld_write_aligned(SDCDriver *sdcp, uint32_t startblk,
  207470:	b537      	push	{r0, r1, r2, r4, r5, lr}
  207472:	461d      	mov	r5, r3
  dmaStreamSetMemory0(sdcp->dma, buf);
  207474:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
bool sdc_lld_write_aligned(SDCDriver *sdcp, uint32_t startblk,
  207476:	4604      	mov	r4, r0
  dmaStreamSetMemory0(sdcp->dma, buf);
  207478:	681b      	ldr	r3, [r3, #0]
  dmaStreamSetTransactionSize(sdcp->dma,
  20747a:	0268      	lsls	r0, r5, #9
  dmaStreamSetMemory0(sdcp->dma, buf);
  20747c:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
  20747e:	0882      	lsrs	r2, r0, #2
  207480:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
  207482:	6ca2      	ldr	r2, [r4, #72]	; 0x48
  207484:	f042 0240 	orr.w	r2, r2, #64	; 0x40
  207488:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
  20748a:	681a      	ldr	r2, [r3, #0]
  20748c:	f042 0201 	orr.w	r2, r2, #1
  207490:	601a      	str	r2, [r3, #0]
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
  207492:	6d23      	ldr	r3, [r4, #80]	; 0x50
  207494:	4a16      	ldr	r2, [pc, #88]	; (2074f0 <sdc_lld_write_aligned.part.0+0x80>)
  207496:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
  207498:	f44f 728d 	mov.w	r2, #282	; 0x11a
  20749c:	63da      	str	r2, [r3, #60]	; 0x3c
  sdcp->sdmmc->DLEN  = blocks * MMCSD_BLOCK_SIZE;
  20749e:	6298      	str	r0, [r3, #40]	; 0x28
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
  2074a0:	6b23      	ldr	r3, [r4, #48]	; 0x30
  2074a2:	06db      	lsls	r3, r3, #27
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
  2074a4:	ab01      	add	r3, sp, #4
    startblk *= MMCSD_BLOCK_SIZE;
  2074a6:	bf58      	it	pl
  2074a8:	0249      	lslpl	r1, r1, #9
  if (n > 1) {
  2074aa:	2d01      	cmp	r5, #1
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
  2074ac:	460a      	mov	r2, r1
  if (n > 1) {
  2074ae:	d90c      	bls.n	2074ca <sdc_lld_write_aligned.part.0+0x5a>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
  2074b0:	2119      	movs	r1, #25
  2074b2:	4620      	mov	r0, r4
  2074b4:	f7ff ff55 	bl	207362 <sdc_lld_send_cmd_short_crc>
  2074b8:	b148      	cbz	r0, 2074ce <sdc_lld_write_aligned.part.0+0x5e>
  sdc_lld_error_cleanup(sdcp, blocks, resp);
  2074ba:	4620      	mov	r0, r4
  2074bc:	aa01      	add	r2, sp, #4
  2074be:	4629      	mov	r1, r5
  2074c0:	f7ff ff66 	bl	207390 <sdc_lld_error_cleanup>
  return HAL_FAILED;
  2074c4:	2001      	movs	r0, #1
}
  2074c6:	b003      	add	sp, #12
  2074c8:	bd30      	pop	{r4, r5, pc}
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_BLOCK,
  2074ca:	2118      	movs	r1, #24
  2074cc:	e7f1      	b.n	2074b2 <sdc_lld_write_aligned.part.0+0x42>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
  2074ce:	4b09      	ldr	r3, [pc, #36]	; (2074f4 <sdc_lld_write_aligned.part.0+0x84>)
  2074d0:	9a01      	ldr	r2, [sp, #4]
  2074d2:	4013      	ands	r3, r2
  2074d4:	2b00      	cmp	r3, #0
  2074d6:	d1f0      	bne.n	2074ba <sdc_lld_write_aligned.part.0+0x4a>
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DBLOCKSIZE_3 |
  2074d8:	2299      	movs	r2, #153	; 0x99
  2074da:	6d23      	ldr	r3, [r4, #80]	; 0x50
  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == true)
  2074dc:	4629      	mov	r1, r5
  2074de:	4620      	mov	r0, r4
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DBLOCKSIZE_3 |
  2074e0:	62da      	str	r2, [r3, #44]	; 0x2c
  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == true)
  2074e2:	aa01      	add	r2, sp, #4
  2074e4:	f7ff ff84 	bl	2073f0 <sdc_lld_wait_transaction_end>
  2074e8:	2800      	cmp	r0, #0
  2074ea:	d0ec      	beq.n	2074c6 <sdc_lld_write_aligned.part.0+0x56>
  2074ec:	e7e5      	b.n	2074ba <sdc_lld_write_aligned.part.0+0x4a>
  2074ee:	bf00      	nop
  2074f0:	004005ff 	.word	0x004005ff
  2074f4:	fdffe008 	.word	0xfdffe008

002074f8 <sdc_lld_read_aligned.part.0>:
bool sdc_lld_read_aligned(SDCDriver *sdcp, uint32_t startblk,
  2074f8:	b537      	push	{r0, r1, r2, r4, r5, lr}
  2074fa:	461d      	mov	r5, r3
  dmaStreamSetMemory0(sdcp->dma, buf);
  2074fc:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
bool sdc_lld_read_aligned(SDCDriver *sdcp, uint32_t startblk,
  2074fe:	4604      	mov	r4, r0
  dmaStreamSetMemory0(sdcp->dma, buf);
  207500:	681b      	ldr	r3, [r3, #0]
  dmaStreamSetTransactionSize(sdcp->dma,
  207502:	0268      	lsls	r0, r5, #9
  dmaStreamSetMemory0(sdcp->dma, buf);
  207504:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
  207506:	0882      	lsrs	r2, r0, #2
  207508:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
  20750a:	6ca2      	ldr	r2, [r4, #72]	; 0x48
  20750c:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
  20750e:	681a      	ldr	r2, [r3, #0]
  207510:	f042 0201 	orr.w	r2, r2, #1
  207514:	601a      	str	r2, [r3, #0]
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
  207516:	6d23      	ldr	r3, [r4, #80]	; 0x50
  207518:	4a15      	ldr	r2, [pc, #84]	; (207570 <sdc_lld_read_aligned.part.0+0x78>)
  20751a:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
  20751c:	f44f 7295 	mov.w	r2, #298	; 0x12a
  207520:	63da      	str	r2, [r3, #60]	; 0x3c
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
  207522:	229b      	movs	r2, #155	; 0x9b
  sdcp->sdmmc->DLEN  = blocks * MMCSD_BLOCK_SIZE;
  207524:	6298      	str	r0, [r3, #40]	; 0x28
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
  207526:	62da      	str	r2, [r3, #44]	; 0x2c
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
  207528:	6b23      	ldr	r3, [r4, #48]	; 0x30
  20752a:	06db      	lsls	r3, r3, #27
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
  20752c:	ab01      	add	r3, sp, #4
    startblk *= MMCSD_BLOCK_SIZE;
  20752e:	bf58      	it	pl
  207530:	0249      	lslpl	r1, r1, #9
  if (n > 1) {
  207532:	2d01      	cmp	r5, #1
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
  207534:	460a      	mov	r2, r1
  if (n > 1) {
  207536:	d90c      	bls.n	207552 <sdc_lld_read_aligned.part.0+0x5a>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
  207538:	2112      	movs	r1, #18
  20753a:	4620      	mov	r0, r4
  20753c:	f7ff ff11 	bl	207362 <sdc_lld_send_cmd_short_crc>
  207540:	b148      	cbz	r0, 207556 <sdc_lld_read_aligned.part.0+0x5e>
  sdc_lld_error_cleanup(sdcp, blocks, resp);
  207542:	4620      	mov	r0, r4
  207544:	aa01      	add	r2, sp, #4
  207546:	4629      	mov	r1, r5
  207548:	f7ff ff22 	bl	207390 <sdc_lld_error_cleanup>
  return HAL_FAILED;
  20754c:	2001      	movs	r0, #1
}
  20754e:	b003      	add	sp, #12
  207550:	bd30      	pop	{r4, r5, pc}
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_SINGLE_BLOCK,
  207552:	2111      	movs	r1, #17
  207554:	e7f1      	b.n	20753a <sdc_lld_read_aligned.part.0+0x42>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
  207556:	4b07      	ldr	r3, [pc, #28]	; (207574 <sdc_lld_read_aligned.part.0+0x7c>)
  207558:	9a01      	ldr	r2, [sp, #4]
  20755a:	4013      	ands	r3, r2
  20755c:	2b00      	cmp	r3, #0
  20755e:	d1f0      	bne.n	207542 <sdc_lld_read_aligned.part.0+0x4a>
  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == true)
  207560:	aa01      	add	r2, sp, #4
  207562:	4629      	mov	r1, r5
  207564:	4620      	mov	r0, r4
  207566:	f7ff ff43 	bl	2073f0 <sdc_lld_wait_transaction_end>
  20756a:	2800      	cmp	r0, #0
  20756c:	d0ef      	beq.n	20754e <sdc_lld_read_aligned.part.0+0x56>
  20756e:	e7e8      	b.n	207542 <sdc_lld_read_aligned.part.0+0x4a>
  207570:	004005ff 	.word	0x004005ff
  207574:	fdffe008 	.word	0xfdffe008

00207578 <sdc_lld_read_special>:
                          uint8_t cmd, uint32_t arg) {
  207578:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  20757a:	4615      	mov	r5, r2
  20757c:	9301      	str	r3, [sp, #4]
  sdcp->sdmmc->DTIMER = sdcp->rtmo;
  20757e:	6c02      	ldr	r2, [r0, #64]	; 0x40
                          uint8_t cmd, uint32_t arg) {
  207580:	460e      	mov	r6, r1
  sdcp->sdmmc->DTIMER = sdcp->rtmo;
  207582:	6d03      	ldr	r3, [r0, #80]	; 0x50
                          uint8_t cmd, uint32_t arg) {
  207584:	4604      	mov	r4, r0
  sdcp->sdmmc->DTIMER = sdcp->rtmo;
  207586:	625a      	str	r2, [r3, #36]	; 0x24
  if (_sdc_wait_for_transfer_state(sdcp))
  207588:	f001 f910 	bl	2087ac <_sdc_wait_for_transfer_state>
  20758c:	9901      	ldr	r1, [sp, #4]
  20758e:	b138      	cbz	r0, 2075a0 <sdc_lld_read_special+0x28>
  sdc_lld_error_cleanup(sdcp, 1, resp);
  207590:	4620      	mov	r0, r4
  207592:	aa03      	add	r2, sp, #12
  207594:	2101      	movs	r1, #1
  207596:	f7ff fefb 	bl	207390 <sdc_lld_error_cleanup>
  return HAL_FAILED;
  20759a:	2001      	movs	r0, #1
}
  20759c:	b004      	add	sp, #16
  20759e:	bd70      	pop	{r4, r5, r6, pc}
  dmaStreamSetMemory0(sdcp->dma, buf);
  2075a0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
  2075a2:	9a08      	ldr	r2, [sp, #32]
  dmaStreamSetMemory0(sdcp->dma, buf);
  2075a4:	6818      	ldr	r0, [r3, #0]
  dmaStreamSetTransactionSize(sdcp->dma, bytes / sizeof (uint32_t));
  2075a6:	08ab      	lsrs	r3, r5, #2
  dmaStreamSetMemory0(sdcp->dma, buf);
  2075a8:	60c6      	str	r6, [r0, #12]
  dmaStreamSetTransactionSize(sdcp->dma, bytes / sizeof (uint32_t));
  2075aa:	6043      	str	r3, [r0, #4]
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
  2075ac:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  2075ae:	6003      	str	r3, [r0, #0]
  dmaStreamEnable(sdcp->dma);
  2075b0:	6803      	ldr	r3, [r0, #0]
  2075b2:	f043 0301 	orr.w	r3, r3, #1
  2075b6:	6003      	str	r3, [r0, #0]
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
  2075b8:	6d20      	ldr	r0, [r4, #80]	; 0x50
  2075ba:	4b0d      	ldr	r3, [pc, #52]	; (2075f0 <sdc_lld_read_special+0x78>)
  2075bc:	6383      	str	r3, [r0, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
  2075be:	f44f 7395 	mov.w	r3, #298	; 0x12a
  2075c2:	63c3      	str	r3, [r0, #60]	; 0x3c
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
  2075c4:	230f      	movs	r3, #15
  sdcp->sdmmc->DLEN  = bytes;
  2075c6:	6285      	str	r5, [r0, #40]	; 0x28
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
  2075c8:	62c3      	str	r3, [r0, #44]	; 0x2c
  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
  2075ca:	ab03      	add	r3, sp, #12
  2075cc:	4620      	mov	r0, r4
  2075ce:	f7ff fec8 	bl	207362 <sdc_lld_send_cmd_short_crc>
  2075d2:	2800      	cmp	r0, #0
  2075d4:	d1dc      	bne.n	207590 <sdc_lld_read_special+0x18>
                                 || MMCSD_R1_ERROR(resp[0]))
  2075d6:	4b07      	ldr	r3, [pc, #28]	; (2075f4 <sdc_lld_read_special+0x7c>)
  2075d8:	9a03      	ldr	r2, [sp, #12]
  2075da:	4013      	ands	r3, r2
  2075dc:	2b00      	cmp	r3, #0
  2075de:	d1d7      	bne.n	207590 <sdc_lld_read_special+0x18>
  if (sdc_lld_wait_transaction_end(sdcp, 1, resp))
  2075e0:	aa03      	add	r2, sp, #12
  2075e2:	2101      	movs	r1, #1
  2075e4:	4620      	mov	r0, r4
  2075e6:	f7ff ff03 	bl	2073f0 <sdc_lld_wait_transaction_end>
  2075ea:	2800      	cmp	r0, #0
  2075ec:	d0d6      	beq.n	20759c <sdc_lld_read_special+0x24>
  2075ee:	e7cf      	b.n	207590 <sdc_lld_read_special+0x18>
  2075f0:	004005ff 	.word	0x004005ff
  2075f4:	fdffe008 	.word	0xfdffe008

002075f8 <Vector104>:
OSAL_IRQ_HANDLER(STM32_SDMMC1_HANDLER) {
  2075f8:	b538      	push	{r3, r4, r5, lr}
  OSAL_IRQ_PROLOGUE();
  2075fa:	4d0b      	ldr	r5, [pc, #44]	; (207628 <Vector104+0x30>)
  SDMMC1->MASK = 0;
  2075fc:	2400      	movs	r4, #0
  OSAL_IRQ_PROLOGUE();
  2075fe:	4628      	mov	r0, r5
  207600:	f7fd f9b4 	bl	20496c <_trace_isr_enter>
  207604:	f7fc fd78 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  SDMMC1->MASK = 0;
  207608:	4b08      	ldr	r3, [pc, #32]	; (20762c <Vector104+0x34>)
  chThdResumeI(trp, msg);
  20760a:	4621      	mov	r1, r4
  20760c:	4808      	ldr	r0, [pc, #32]	; (207630 <Vector104+0x38>)
  20760e:	63dc      	str	r4, [r3, #60]	; 0x3c
  207610:	f7f9 fe8d 	bl	20132e <chThdResumeI>
  207614:	f384 8811 	msr	BASEPRI, r4
  OSAL_IRQ_EPILOGUE();
  207618:	4628      	mov	r0, r5
  20761a:	f7fd f993 	bl	204944 <_trace_isr_leave>
}
  20761e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
  207622:	f7fc bdcb 	b.w	2041bc <_port_irq_epilogue>
  207626:	bf00      	nop
  207628:	0800e506 	.word	0x0800e506
  20762c:	40012c00 	.word	0x40012c00
  207630:	20000928 	.word	0x20000928

00207634 <otg_txfifo_flush.isra.0.lto_priv.0>:
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
  207634:	0189      	lsls	r1, r1, #6
  207636:	f041 0120 	orr.w	r1, r1, #32
  20763a:	6101      	str	r1, [r0, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
  20763c:	6903      	ldr	r3, [r0, #16]
  20763e:	069b      	lsls	r3, r3, #26
  207640:	d4fc      	bmi.n	20763c <otg_txfifo_flush.isra.0.lto_priv.0+0x8>
  chSysPolledDelayX(cycles);
  207642:	2012      	movs	r0, #18
  207644:	f7f9 bec6 	b.w	2013d4 <chSysPolledDelayX>

00207648 <usb_lld_start_in>:
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
  207648:	eb00 0381 	add.w	r3, r0, r1, lsl #2
  20764c:	014a      	lsls	r2, r1, #5
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  20764e:	b570      	push	{r4, r5, r6, lr}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
  207650:	68dd      	ldr	r5, [r3, #12]
  207652:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
  207654:	696c      	ldr	r4, [r5, #20]
  isp->totsize = isp->txsize;
  207656:	6826      	ldr	r6, [r4, #0]
  207658:	60e6      	str	r6, [r4, #12]
  if (isp->txsize == 0) {
  20765a:	bb56      	cbnz	r6, 2076b2 <usb_lld_start_in+0x6a>
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  20765c:	441a      	add	r2, r3
  20765e:	f44f 2000 	mov.w	r0, #524288	; 0x80000
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
  207662:	f8c2 0910 	str.w	r0, [r2, #2320]	; 0x910
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
  207666:	682a      	ldr	r2, [r5, #0]
  207668:	f002 0203 	and.w	r2, r2, #3
  20766c:	2a01      	cmp	r2, #1
  20766e:	b20a      	sxth	r2, r1
  207670:	d10e      	bne.n	207690 <usb_lld_start_in+0x48>
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
  207672:	f8d3 0808 	ldr.w	r0, [r3, #2056]	; 0x808
  207676:	eb03 1442 	add.w	r4, r3, r2, lsl #5
  20767a:	f410 7f80 	tst.w	r0, #256	; 0x100
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
  20767e:	f8d4 0900 	ldr.w	r0, [r4, #2304]	; 0x900
  207682:	bf14      	ite	ne
  207684:	f040 5080 	orrne.w	r0, r0, #268435456	; 0x10000000
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  207688:	f040 5000 	orreq.w	r0, r0, #536870912	; 0x20000000
  20768c:	f8c4 0900 	str.w	r0, [r4, #2304]	; 0x900
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  207690:	eb03 1242 	add.w	r2, r3, r2, lsl #5
  207694:	f8d2 0900 	ldr.w	r0, [r2, #2304]	; 0x900
  207698:	f040 4004 	orr.w	r0, r0, #2214592512	; 0x84000000
  20769c:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
  2076a0:	2201      	movs	r2, #1
  2076a2:	f8d3 0834 	ldr.w	r0, [r3, #2100]	; 0x834
  2076a6:	fa02 f101 	lsl.w	r1, r2, r1
  2076aa:	4301      	orrs	r1, r0
  2076ac:	f8c3 1834 	str.w	r1, [r3, #2100]	; 0x834
}
  2076b0:	bd70      	pop	{r4, r5, r6, pc}
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
  2076b2:	b919      	cbnz	r1, 2076bc <usb_lld_start_in+0x74>
  2076b4:	2e40      	cmp	r6, #64	; 0x40
      isp->txsize = EP0_MAX_INSIZE;
  2076b6:	bf84      	itt	hi
  2076b8:	2040      	movhi	r0, #64	; 0x40
  2076ba:	6020      	strhi	r0, [r4, #0]
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
  2076bc:	6820      	ldr	r0, [r4, #0]
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
  2076be:	441a      	add	r2, r3
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
  2076c0:	8a2e      	ldrh	r6, [r5, #16]
  2076c2:	1984      	adds	r4, r0, r6
  2076c4:	3c01      	subs	r4, #1
  2076c6:	fbb4 f4f6 	udiv	r4, r4, r6
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
  2076ca:	ea40 40c4 	orr.w	r0, r0, r4, lsl #19
  2076ce:	f040 5000 	orr.w	r0, r0, #536870912	; 0x20000000
  2076d2:	e7c6      	b.n	207662 <usb_lld_start_in+0x1a>

002076d4 <otg_epin_handler.constprop.0>:
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
  2076d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  2076d6:	4604      	mov	r4, r0
  stm32_otg_t *otgp = usbp->otg;
  2076d8:	481d      	ldr	r0, [pc, #116]	; (207750 <otg_epin_handler.constprop.0+0x7c>)
  2076da:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
  uint32_t epint = otgp->ie[ep].DIEPINT;
  2076dc:	eb05 1344 	add.w	r3, r5, r4, lsl #5
  2076e0:	f8d3 6908 	ldr.w	r6, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
  2076e4:	07f1      	lsls	r1, r6, #31
  otgp->ie[ep].DIEPINT = epint;
  2076e6:	f8c3 6908 	str.w	r6, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
  2076ea:	d516      	bpl.n	20771a <otg_epin_handler.constprop.0+0x46>
  2076ec:	f8d5 3810 	ldr.w	r3, [r5, #2064]	; 0x810
  2076f0:	07da      	lsls	r2, r3, #31
  2076f2:	d512      	bpl.n	20771a <otg_epin_handler.constprop.0+0x46>
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
  2076f4:	eb00 0384 	add.w	r3, r0, r4, lsl #2
  2076f8:	68d9      	ldr	r1, [r3, #12]
  2076fa:	694b      	ldr	r3, [r1, #20]
    if (isp->txsize < isp->totsize) {
  2076fc:	681f      	ldr	r7, [r3, #0]
  2076fe:	68da      	ldr	r2, [r3, #12]
  207700:	4297      	cmp	r7, r2
  207702:	d217      	bcs.n	207734 <otg_epin_handler.constprop.0+0x60>
      isp->txsize = isp->totsize - isp->txsize;
  207704:	1bd2      	subs	r2, r2, r7
      isp->txcnt  = 0;
  207706:	2700      	movs	r7, #0
      isp->txsize = isp->totsize - isp->txsize;
  207708:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
  20770a:	605f      	str	r7, [r3, #4]
  20770c:	f7fc fcf4 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
      usb_lld_start_in(usbp, ep);
  207710:	4621      	mov	r1, r4
  207712:	f7ff ff99 	bl	207648 <usb_lld_start_in>
  207716:	f387 8811 	msr	BASEPRI, r7
  if ((epint & DIEPINT_TXFE) &&
  20771a:	0633      	lsls	r3, r6, #24
  20771c:	d517      	bpl.n	20774e <otg_epin_handler.constprop.0+0x7a>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
  20771e:	2301      	movs	r3, #1
  207720:	f8d5 2834 	ldr.w	r2, [r5, #2100]	; 0x834
  207724:	40a3      	lsls	r3, r4
  if ((epint & DIEPINT_TXFE) &&
  207726:	4213      	tst	r3, r2
  207728:	d011      	beq.n	20774e <otg_epin_handler.constprop.0+0x7a>
    otg_txfifo_handler(usbp, ep);
  20772a:	4620      	mov	r0, r4
}
  20772c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    otg_txfifo_handler(usbp, ep);
  207730:	f7f9 b854 	b.w	2007dc <otg_txfifo_handler.constprop.0>
      _usb_isr_invoke_in_cb(usbp, ep);
  207734:	2301      	movs	r3, #1
  207736:	fa03 f204 	lsl.w	r2, r3, r4
  20773a:	8903      	ldrh	r3, [r0, #8]
  20773c:	ea23 0302 	bic.w	r3, r3, r2
  207740:	8103      	strh	r3, [r0, #8]
  207742:	688b      	ldr	r3, [r1, #8]
  207744:	2b00      	cmp	r3, #0
  207746:	d0e8      	beq.n	20771a <otg_epin_handler.constprop.0+0x46>
  207748:	4621      	mov	r1, r4
  20774a:	4798      	blx	r3
  20774c:	e7e5      	b.n	20771a <otg_epin_handler.constprop.0+0x46>
}
  20774e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  207750:	20000e14 	.word	0x20000e14

00207754 <usb_lld_start_out>:
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
  207754:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  207758:	b530      	push	{r4, r5, lr}
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
  20775a:	68dd      	ldr	r5, [r3, #12]
  20775c:	69aa      	ldr	r2, [r5, #24]
  osp->totsize = osp->rxsize;
  20775e:	6813      	ldr	r3, [r2, #0]
  207760:	60d3      	str	r3, [r2, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
  207762:	b919      	cbnz	r1, 20776c <usb_lld_start_out+0x18>
  207764:	2b40      	cmp	r3, #64	; 0x40
      osp->rxsize = EP0_MAX_OUTSIZE;
  207766:	bf84      	itt	hi
  207768:	2340      	movhi	r3, #64	; 0x40
  20776a:	6013      	strhi	r3, [r2, #0]
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
  20776c:	8a6b      	ldrh	r3, [r5, #18]
  20776e:	6814      	ldr	r4, [r2, #0]
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
  207770:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
  207772:	441c      	add	r4, r3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
  207774:	eb02 1041 	add.w	r0, r2, r1, lsl #5
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
  207778:	3c01      	subs	r4, #1
  20777a:	b209      	sxth	r1, r1
  20777c:	fbb4 f4f3 	udiv	r4, r4, r3
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
  207780:	4363      	muls	r3, r4
  207782:	3303      	adds	r3, #3
  207784:	f023 0303 	bic.w	r3, r3, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
  207788:	ea43 43c4 	orr.w	r3, r3, r4, lsl #19
  20778c:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
  207790:	f8c0 3b10 	str.w	r3, [r0, #2832]	; 0xb10
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
  207794:	682b      	ldr	r3, [r5, #0]
  207796:	f003 0303 	and.w	r3, r3, #3
  20779a:	2b01      	cmp	r3, #1
  20779c:	d10e      	bne.n	2077bc <usb_lld_start_out+0x68>
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
  20779e:	f8d2 3808 	ldr.w	r3, [r2, #2056]	; 0x808
  2077a2:	eb02 1041 	add.w	r0, r2, r1, lsl #5
  2077a6:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
  2077aa:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
  2077ae:	bf14      	ite	ne
  2077b0:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
  2077b4:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
  2077b8:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
  2077bc:	eb02 1241 	add.w	r2, r2, r1, lsl #5
  2077c0:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
  2077c4:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
  2077c8:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
}
  2077cc:	bd30      	pop	{r4, r5, pc}
	...

002077d0 <otg_epout_handler.constprop.0>:
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
  2077d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
  2077d4:	4d23      	ldr	r5, [pc, #140]	; (207864 <otg_epout_handler.constprop.0+0x94>)
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
  2077d6:	4604      	mov	r4, r0
  stm32_otg_t *otgp = usbp->otg;
  2077d8:	6eee      	ldr	r6, [r5, #108]	; 0x6c
  uint32_t epint = otgp->oe[ep].DOEPINT;
  2077da:	eb06 1340 	add.w	r3, r6, r0, lsl #5
  2077de:	f8d3 7b08 	ldr.w	r7, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
  2077e2:	0738      	lsls	r0, r7, #28
  otgp->oe[ep].DOEPINT = epint;
  2077e4:	f8c3 7b08 	str.w	r7, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
  2077e8:	d50a      	bpl.n	207800 <otg_epout_handler.constprop.0+0x30>
  2077ea:	f8d6 3814 	ldr.w	r3, [r6, #2068]	; 0x814
  2077ee:	0719      	lsls	r1, r3, #28
  2077f0:	d506      	bpl.n	207800 <otg_epout_handler.constprop.0+0x30>
    _usb_isr_invoke_setup_cb(usbp, ep);
  2077f2:	eb05 0384 	add.w	r3, r5, r4, lsl #2
  2077f6:	4621      	mov	r1, r4
  2077f8:	4628      	mov	r0, r5
  2077fa:	68db      	ldr	r3, [r3, #12]
  2077fc:	685b      	ldr	r3, [r3, #4]
  2077fe:	4798      	blx	r3
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
  207800:	07fa      	lsls	r2, r7, #31
  207802:	d51e      	bpl.n	207842 <otg_epout_handler.constprop.0+0x72>
  207804:	f8d6 3814 	ldr.w	r3, [r6, #2068]	; 0x814
  207808:	07db      	lsls	r3, r3, #31
  20780a:	d51a      	bpl.n	207842 <otg_epout_handler.constprop.0+0x72>
    osp = usbp->epc[ep]->out_state;
  20780c:	eb05 0384 	add.w	r3, r5, r4, lsl #2
  207810:	68d9      	ldr	r1, [r3, #12]
    if (ep == 0) {
  207812:	b9c4      	cbnz	r4, 207846 <otg_epout_handler.constprop.0+0x76>
    osp = usbp->epc[ep]->out_state;
  207814:	698b      	ldr	r3, [r1, #24]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
  207816:	8a48      	ldrh	r0, [r1, #18]
  207818:	685e      	ldr	r6, [r3, #4]
  20781a:	fbb6 f2f0 	udiv	r2, r6, r0
  20781e:	fb00 6212 	mls	r2, r0, r2, r6
  207822:	b982      	cbnz	r2, 207846 <otg_epout_handler.constprop.0+0x76>
          (osp->rxsize < osp->totsize)) {
  207824:	6818      	ldr	r0, [r3, #0]
  207826:	68da      	ldr	r2, [r3, #12]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
  207828:	4290      	cmp	r0, r2
  20782a:	d20c      	bcs.n	207846 <otg_epout_handler.constprop.0+0x76>
        osp->rxsize = osp->totsize - osp->rxsize;
  20782c:	1a12      	subs	r2, r2, r0
        osp->rxcnt  = 0;
  20782e:	e9c3 2400 	strd	r2, r4, [r3]
  207832:	f7fc fc61 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
        usb_lld_start_out(usbp, ep);
  207836:	4621      	mov	r1, r4
  207838:	480a      	ldr	r0, [pc, #40]	; (207864 <otg_epout_handler.constprop.0+0x94>)
  20783a:	f7ff ff8b 	bl	207754 <usb_lld_start_out>
  20783e:	f384 8811 	msr	BASEPRI, r4
}
  207842:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    _usb_isr_invoke_out_cb(usbp, ep);
  207846:	2301      	movs	r3, #1
  207848:	fa03 f204 	lsl.w	r2, r3, r4
  20784c:	896b      	ldrh	r3, [r5, #10]
  20784e:	ea23 0302 	bic.w	r3, r3, r2
  207852:	816b      	strh	r3, [r5, #10]
  207854:	68cb      	ldr	r3, [r1, #12]
  207856:	2b00      	cmp	r3, #0
  207858:	d0f3      	beq.n	207842 <otg_epout_handler.constprop.0+0x72>
  20785a:	4621      	mov	r1, r4
  20785c:	4801      	ldr	r0, [pc, #4]	; (207864 <otg_epout_handler.constprop.0+0x94>)
}
  20785e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _usb_isr_invoke_out_cb(usbp, ep);
  207862:	4718      	bx	r3
  207864:	20000e14 	.word	0x20000e14

00207868 <Vector14C>:
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
  207868:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  stm32_otg_t *otgp = usbp->otg;
  20786c:	4ca0      	ldr	r4, [pc, #640]	; (207af0 <Vector14C+0x288>)
  OSAL_IRQ_PROLOGUE();
  20786e:	48a1      	ldr	r0, [pc, #644]	; (207af4 <Vector14C+0x28c>)
  207870:	f7fd f87c 	bl	20496c <_trace_isr_enter>
  stm32_otg_t *otgp = usbp->otg;
  207874:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
  sts  = otgp->GINTSTS;
  207876:	696e      	ldr	r6, [r5, #20]
  sts &= otgp->GINTMSK;
  207878:	69ab      	ldr	r3, [r5, #24]
  20787a:	401e      	ands	r6, r3
  if (sts & GINTSTS_USBRST) {
  20787c:	f416 5880 	ands.w	r8, r6, #4096	; 0x1000
  otgp->GINTSTS = sts;
  207880:	616e      	str	r6, [r5, #20]
  if (sts & GINTSTS_USBRST) {
  207882:	d069      	beq.n	207958 <Vector14C+0xf0>
  usbp->status        = 0;
  207884:	2600      	movs	r6, #0
  usbp->state         = USB_READY;
  207886:	2302      	movs	r3, #2
  otg_txfifo_flush(usbp, 0);
  207888:	4628      	mov	r0, r5
  20788a:	4631      	mov	r1, r6
  usbp->status        = 0;
  20788c:	6666      	str	r6, [r4, #100]	; 0x64
  usbp->state         = USB_READY;
  20788e:	7023      	strb	r3, [r4, #0]
    usbp->epc[i] = NULL;
  207890:	6226      	str	r6, [r4, #32]
  usbp->ep0state = USB_EP0_STP_WAITING;
  207892:	f884 604c 	strb.w	r6, [r4, #76]	; 0x4c
    usbp->epc[i] = NULL;
  207896:	e9c4 6602 	strd	r6, r6, [r4, #8]
  20789a:	e9c4 6604 	strd	r6, r6, [r4, #16]
  20789e:	e9c4 6606 	strd	r6, r6, [r4, #24]
  2078a2:	f7ff fec7 	bl	207634 <otg_txfifo_flush.isra.0.lto_priv.0>
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  2078a6:	6f22      	ldr	r2, [r4, #112]	; 0x70
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
  2078a8:	f04f 1301 	mov.w	r3, #65537	; 0x10001
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
  2078ac:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  2078b0:	6897      	ldr	r7, [r2, #8]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  2078b2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  otgp->DIEPEMPMSK = 0;
  2078b6:	f8c5 6834 	str.w	r6, [r5, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
  2078ba:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
  2078be:	eb05 1346 	add.w	r3, r5, r6, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  2078c2:	3601      	adds	r6, #1
  2078c4:	42be      	cmp	r6, r7
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
  2078c6:	f8c3 0900 	str.w	r0, [r3, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
  2078ca:	f8c3 0b00 	str.w	r0, [r3, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
  2078ce:	f8c3 1908 	str.w	r1, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  2078d2:	f8c3 1b08 	str.w	r1, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
  2078d6:	d9f2      	bls.n	2078be <Vector14C+0x56>
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
  2078d8:	6813      	ldr	r3, [r2, #0]
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
  2078da:	2210      	movs	r2, #16
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
  2078dc:	6763      	str	r3, [r4, #116]	; 0x74
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  2078de:	626b      	str	r3, [r5, #36]	; 0x24
  otg_rxfifo_flush(usbp);
  2078e0:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
  2078e2:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
  2078e4:	691e      	ldr	r6, [r3, #16]
  2078e6:	f016 0610 	ands.w	r6, r6, #16
  2078ea:	d1fb      	bne.n	2078e4 <Vector14C+0x7c>
  2078ec:	2012      	movs	r0, #18
  2078ee:	f7f9 fd71 	bl	2013d4 <chSysPolledDelayX>
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
  2078f2:	f8d5 3800 	ldr.w	r3, [r5, #2048]	; 0x800
  2078f6:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
  2078fa:	f8c5 3800 	str.w	r3, [r5, #2048]	; 0x800
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  2078fe:	69ab      	ldr	r3, [r5, #24]
  207900:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
  207904:	f043 0310 	orr.w	r3, r3, #16
  207908:	61ab      	str	r3, [r5, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  20790a:	2309      	movs	r3, #9
  20790c:	f8c5 3810 	str.w	r3, [r5, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
  207910:	f8c5 3814 	str.w	r3, [r5, #2068]	; 0x814
  usbp->epc[0] = &ep0config;
  207914:	4b78      	ldr	r3, [pc, #480]	; (207af8 <Vector14C+0x290>)
  207916:	60e3      	str	r3, [r4, #12]
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
  207918:	f04f 43c0 	mov.w	r3, #1610612736	; 0x60000000
  20791c:	f8c5 3b10 	str.w	r3, [r5, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
  207920:	4b76      	ldr	r3, [pc, #472]	; (207afc <Vector14C+0x294>)
  207922:	f8c5 3b00 	str.w	r3, [r5, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
  207926:	f8c5 6910 	str.w	r6, [r5, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
  20792a:	f8c5 3900 	str.w	r3, [r5, #2304]	; 0x900
  next = usbp->pmnext;
  20792e:	6f63      	ldr	r3, [r4, #116]	; 0x74
  usbp->pmnext += size;
  207930:	f103 0210 	add.w	r2, r3, #16
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
  207934:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  usbp->pmnext += size;
  207938:	6762      	str	r2, [r4, #116]	; 0x74
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
  20793a:	62ab      	str	r3, [r5, #40]	; 0x28
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
  20793c:	6863      	ldr	r3, [r4, #4]
  20793e:	681b      	ldr	r3, [r3, #0]
  207940:	b113      	cbz	r3, 207948 <Vector14C+0xe0>
  207942:	4631      	mov	r1, r6
  207944:	486a      	ldr	r0, [pc, #424]	; (207af0 <Vector14C+0x288>)
  207946:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  207948:	486a      	ldr	r0, [pc, #424]	; (207af4 <Vector14C+0x28c>)
  20794a:	f7fc fffb 	bl	204944 <_trace_isr_leave>
}
  20794e:	b003      	add	sp, #12
  207950:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
  207954:	f7fc bc32 	b.w	2041bc <_port_irq_epilogue>
  if (sts & GINTSTS_WKUPINT) {
  207958:	2e00      	cmp	r6, #0
  20795a:	da18      	bge.n	20798e <Vector14C+0x126>
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
  20795c:	f8d5 3e00 	ldr.w	r3, [r5, #3584]	; 0xe00
  207960:	079f      	lsls	r7, r3, #30
  207962:	d005      	beq.n	207970 <Vector14C+0x108>
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
  207964:	f8d5 3e00 	ldr.w	r3, [r5, #3584]	; 0xe00
  207968:	f023 0303 	bic.w	r3, r3, #3
  20796c:	f8c5 3e00 	str.w	r3, [r5, #3584]	; 0xe00
    otgp->DCTL &= ~DCTL_RWUSIG;
  207970:	f8d5 3804 	ldr.w	r3, [r5, #2052]	; 0x804
  207974:	f023 0301 	bic.w	r3, r3, #1
  207978:	f8c5 3804 	str.w	r3, [r5, #2052]	; 0x804
  usbp->state = usbp->saved_state;
  20797c:	f894 3068 	ldrb.w	r3, [r4, #104]	; 0x68
  207980:	7023      	strb	r3, [r4, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
  207982:	6863      	ldr	r3, [r4, #4]
  207984:	681b      	ldr	r3, [r3, #0]
  207986:	b113      	cbz	r3, 20798e <Vector14C+0x126>
  207988:	2105      	movs	r1, #5
  20798a:	4859      	ldr	r0, [pc, #356]	; (207af0 <Vector14C+0x288>)
  20798c:	4798      	blx	r3
  if (sts & GINTSTS_USBSUSP) {
  20798e:	0530      	lsls	r0, r6, #20
  207990:	d50a      	bpl.n	2079a8 <Vector14C+0x140>
  usbp->saved_state = usbp->state;
  207992:	7823      	ldrb	r3, [r4, #0]
  207994:	f884 3068 	strb.w	r3, [r4, #104]	; 0x68
  usbp->state       = USB_SUSPENDED;
  207998:	2305      	movs	r3, #5
  20799a:	7023      	strb	r3, [r4, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
  20799c:	6863      	ldr	r3, [r4, #4]
  20799e:	681b      	ldr	r3, [r3, #0]
  2079a0:	b113      	cbz	r3, 2079a8 <Vector14C+0x140>
  2079a2:	2104      	movs	r1, #4
  2079a4:	4852      	ldr	r0, [pc, #328]	; (207af0 <Vector14C+0x288>)
  2079a6:	4798      	blx	r3
  if (sts & GINTSTS_ENUMDNE) {
  2079a8:	04b1      	lsls	r1, r6, #18
  2079aa:	d50c      	bpl.n	2079c6 <Vector14C+0x15e>
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
  2079ac:	f8d5 3808 	ldr.w	r3, [r5, #2056]	; 0x808
  2079b0:	f013 0f06 	tst.w	r3, #6
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
  2079b4:	68eb      	ldr	r3, [r5, #12]
  2079b6:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
  2079ba:	bf0c      	ite	eq
  2079bc:	f443 5310 	orreq.w	r3, r3, #9216	; 0x2400
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
  2079c0:	f443 53a0 	orrne.w	r3, r3, #5120	; 0x1400
  2079c4:	60eb      	str	r3, [r5, #12]
  if (sts & GINTSTS_SOF) {
  2079c6:	0732      	lsls	r2, r6, #28
  2079c8:	d504      	bpl.n	2079d4 <Vector14C+0x16c>
    _usb_isr_invoke_sof_cb(usbp);
  2079ca:	6863      	ldr	r3, [r4, #4]
  2079cc:	68db      	ldr	r3, [r3, #12]
  2079ce:	b10b      	cbz	r3, 2079d4 <Vector14C+0x16c>
  2079d0:	4847      	ldr	r0, [pc, #284]	; (207af0 <Vector14C+0x288>)
  2079d2:	4798      	blx	r3
  if (sts & GINTSTS_IISOIXFR) {
  2079d4:	02f3      	lsls	r3, r6, #11
  2079d6:	f100 8093 	bmi.w	207b00 <Vector14C+0x298>
  if (sts & GINTSTS_IISOOXFR) {
  2079da:	02b7      	lsls	r7, r6, #10
  2079dc:	d527      	bpl.n	207a2e <Vector14C+0x1c6>
  stm32_otg_t *otgp = usbp->otg;
  2079de:	f8d4 906c 	ldr.w	r9, [r4, #108]	; 0x6c
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
  2079e2:	2700      	movs	r7, #0
      _usb_isr_invoke_out_cb(usbp, ep);
  2079e4:	f04f 0a01 	mov.w	sl, #1
  2079e8:	f8df b104 	ldr.w	fp, [pc, #260]	; 207af0 <Vector14C+0x288>
  2079ec:	eb09 1247 	add.w	r2, r9, r7, lsl #5
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
  2079f0:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
  2079f4:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
  2079f8:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
  2079fc:	d111      	bne.n	207a22 <Vector14C+0x1ba>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
  2079fe:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
  207a02:	2b00      	cmp	r3, #0
  207a04:	da0d      	bge.n	207a22 <Vector14C+0x1ba>
      _usb_isr_invoke_out_cb(usbp, ep);
  207a06:	8962      	ldrh	r2, [r4, #10]
  207a08:	fa0a f307 	lsl.w	r3, sl, r7
  207a0c:	ea22 0303 	bic.w	r3, r2, r3
  207a10:	8163      	strh	r3, [r4, #10]
  207a12:	eb04 0387 	add.w	r3, r4, r7, lsl #2
  207a16:	68db      	ldr	r3, [r3, #12]
  207a18:	68db      	ldr	r3, [r3, #12]
  207a1a:	b113      	cbz	r3, 207a22 <Vector14C+0x1ba>
  207a1c:	4639      	mov	r1, r7
  207a1e:	4658      	mov	r0, fp
  207a20:	4798      	blx	r3
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
  207a22:	3701      	adds	r7, #1
  207a24:	6f23      	ldr	r3, [r4, #112]	; 0x70
  207a26:	b2ff      	uxtb	r7, r7
  207a28:	689b      	ldr	r3, [r3, #8]
  207a2a:	429f      	cmp	r7, r3
  207a2c:	d9de      	bls.n	2079ec <Vector14C+0x184>
  if ((sts & GINTSTS_RXFLVL) != 0U) {
  207a2e:	06f0      	lsls	r0, r6, #27
  207a30:	d518      	bpl.n	207a64 <Vector14C+0x1fc>
  sts = usbp->otg->GRXSTSP;
  207a32:	6ee7      	ldr	r7, [r4, #108]	; 0x6c
  207a34:	6a3a      	ldr	r2, [r7, #32]
  cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
  207a36:	f3c2 100a 	ubfx	r0, r2, #4, #11
  ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
  207a3a:	f002 030f 	and.w	r3, r2, #15
  switch (sts & GRXSTSP_PKTSTS_MASK) {
  207a3e:	f402 12f0 	and.w	r2, r2, #1966080	; 0x1e0000
  207a42:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
  207a46:	f000 80a5 	beq.w	207b94 <Vector14C+0x32c>
  207a4a:	f5b2 2f40 	cmp.w	r2, #786432	; 0xc0000
  207a4e:	d109      	bne.n	207a64 <Vector14C+0x1fc>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
  207a50:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  size_t i = 0;
  207a54:	2200      	movs	r2, #0
      w = *fifop;
  207a56:	f507 5780 	add.w	r7, r7, #4096	; 0x1000
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
  207a5a:	68db      	ldr	r3, [r3, #12]
  207a5c:	6a1b      	ldr	r3, [r3, #32]
  while (i < n) {
  207a5e:	4290      	cmp	r0, r2
  207a60:	f040 808b 	bne.w	207b7a <Vector14C+0x312>
  if (sts & GINTSTS_OEPINT) {
  207a64:	0333      	lsls	r3, r6, #12
  src = otgp->DAINT;
  207a66:	f8d5 4818 	ldr.w	r4, [r5, #2072]	; 0x818
  if (sts & GINTSTS_OEPINT) {
  207a6a:	d51d      	bpl.n	207aa8 <Vector14C+0x240>
    if (src & (1 << 16))
  207a6c:	03e7      	lsls	r7, r4, #15
  207a6e:	d502      	bpl.n	207a76 <Vector14C+0x20e>
      otg_epout_handler(usbp, 0);
  207a70:	2000      	movs	r0, #0
  207a72:	f7ff fead 	bl	2077d0 <otg_epout_handler.constprop.0>
    if (src & (1 << 17))
  207a76:	03a5      	lsls	r5, r4, #14
  207a78:	d502      	bpl.n	207a80 <Vector14C+0x218>
      otg_epout_handler(usbp, 1);
  207a7a:	2001      	movs	r0, #1
  207a7c:	f7ff fea8 	bl	2077d0 <otg_epout_handler.constprop.0>
    if (src & (1 << 18))
  207a80:	0360      	lsls	r0, r4, #13
  207a82:	d502      	bpl.n	207a8a <Vector14C+0x222>
      otg_epout_handler(usbp, 2);
  207a84:	2002      	movs	r0, #2
  207a86:	f7ff fea3 	bl	2077d0 <otg_epout_handler.constprop.0>
    if (src & (1 << 19))
  207a8a:	0321      	lsls	r1, r4, #12
  207a8c:	d502      	bpl.n	207a94 <Vector14C+0x22c>
      otg_epout_handler(usbp, 3);
  207a8e:	2003      	movs	r0, #3
  207a90:	f7ff fe9e 	bl	2077d0 <otg_epout_handler.constprop.0>
    if (src & (1 << 20))
  207a94:	02e2      	lsls	r2, r4, #11
  207a96:	d502      	bpl.n	207a9e <Vector14C+0x236>
      otg_epout_handler(usbp, 4);
  207a98:	2004      	movs	r0, #4
  207a9a:	f7ff fe99 	bl	2077d0 <otg_epout_handler.constprop.0>
    if (src & (1 << 21))
  207a9e:	02a3      	lsls	r3, r4, #10
  207aa0:	d502      	bpl.n	207aa8 <Vector14C+0x240>
      otg_epout_handler(usbp, 5);
  207aa2:	2005      	movs	r0, #5
  207aa4:	f7ff fe94 	bl	2077d0 <otg_epout_handler.constprop.0>
  if (sts & GINTSTS_IEPINT) {
  207aa8:	0377      	lsls	r7, r6, #13
  207aaa:	f57f af4d 	bpl.w	207948 <Vector14C+0xe0>
    if (src & (1 << 0))
  207aae:	07e6      	lsls	r6, r4, #31
  207ab0:	d502      	bpl.n	207ab8 <Vector14C+0x250>
      otg_epin_handler(usbp, 0);
  207ab2:	2000      	movs	r0, #0
  207ab4:	f7ff fe0e 	bl	2076d4 <otg_epin_handler.constprop.0>
    if (src & (1 << 1))
  207ab8:	07a5      	lsls	r5, r4, #30
  207aba:	d502      	bpl.n	207ac2 <Vector14C+0x25a>
      otg_epin_handler(usbp, 1);
  207abc:	2001      	movs	r0, #1
  207abe:	f7ff fe09 	bl	2076d4 <otg_epin_handler.constprop.0>
    if (src & (1 << 2))
  207ac2:	0760      	lsls	r0, r4, #29
  207ac4:	d502      	bpl.n	207acc <Vector14C+0x264>
      otg_epin_handler(usbp, 2);
  207ac6:	2002      	movs	r0, #2
  207ac8:	f7ff fe04 	bl	2076d4 <otg_epin_handler.constprop.0>
    if (src & (1 << 3))
  207acc:	0721      	lsls	r1, r4, #28
  207ace:	d502      	bpl.n	207ad6 <Vector14C+0x26e>
      otg_epin_handler(usbp, 3);
  207ad0:	2003      	movs	r0, #3
  207ad2:	f7ff fdff 	bl	2076d4 <otg_epin_handler.constprop.0>
    if (src & (1 << 4))
  207ad6:	06e2      	lsls	r2, r4, #27
  207ad8:	d502      	bpl.n	207ae0 <Vector14C+0x278>
      otg_epin_handler(usbp, 4);
  207ada:	2004      	movs	r0, #4
  207adc:	f7ff fdfa 	bl	2076d4 <otg_epin_handler.constprop.0>
    if (src & (1 << 5))
  207ae0:	06a3      	lsls	r3, r4, #26
  207ae2:	f57f af31 	bpl.w	207948 <Vector14C+0xe0>
      otg_epin_handler(usbp, 5);
  207ae6:	2005      	movs	r0, #5
  207ae8:	f7ff fdf4 	bl	2076d4 <otg_epin_handler.constprop.0>
  207aec:	e72c      	b.n	207948 <Vector14C+0xe0>
  207aee:	bf00      	nop
  207af0:	20000e14 	.word	0x20000e14
  207af4:	0800e510 	.word	0x0800e510
  207af8:	0800e668 	.word	0x0800e668
  207afc:	10008040 	.word	0x10008040
  stm32_otg_t *otgp = usbp->otg;
  207b00:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
  207b02:	2700      	movs	r7, #0
      _usb_isr_invoke_in_cb(usbp, ep);
  207b04:	f04f 0a01 	mov.w	sl, #1
  207b08:	f8df b0dc 	ldr.w	fp, [pc, #220]	; 207be8 <Vector14C+0x380>
  stm32_otg_t *otgp = usbp->otg;
  207b0c:	9301      	str	r3, [sp, #4]
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
  207b0e:	6f23      	ldr	r3, [r4, #112]	; 0x70
  207b10:	fa5f f987 	uxtb.w	r9, r7
  207b14:	689b      	ldr	r3, [r3, #8]
  207b16:	454b      	cmp	r3, r9
  207b18:	f4ff af5f 	bcc.w	2079da <Vector14C+0x172>
  207b1c:	9b01      	ldr	r3, [sp, #4]
  207b1e:	eb03 1349 	add.w	r3, r3, r9, lsl #5
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
  207b22:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
  207b26:	f402 2240 	and.w	r2, r2, #786432	; 0xc0000
  207b2a:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
  207b2e:	d122      	bne.n	207b76 <Vector14C+0x30e>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
  207b30:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
  207b34:	2a00      	cmp	r2, #0
  207b36:	da1e      	bge.n	207b76 <Vector14C+0x30e>
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
  207b38:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
  207b3c:	f042 4290 	orr.w	r2, r2, #1207959552	; 0x48000000
  207b40:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
  207b44:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
  207b48:	2a00      	cmp	r2, #0
  207b4a:	dbfb      	blt.n	207b44 <Vector14C+0x2dc>
      otg_txfifo_flush(usbp, ep);
  207b4c:	4649      	mov	r1, r9
  207b4e:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
  207b50:	f7ff fd70 	bl	207634 <otg_txfifo_flush.isra.0.lto_priv.0>
      _usb_isr_invoke_in_cb(usbp, ep);
  207b54:	8922      	ldrh	r2, [r4, #8]
  207b56:	fa0a f309 	lsl.w	r3, sl, r9
  207b5a:	ea22 0303 	bic.w	r3, r2, r3
  207b5e:	8123      	strh	r3, [r4, #8]
  207b60:	eb04 0389 	add.w	r3, r4, r9, lsl #2
  207b64:	68db      	ldr	r3, [r3, #12]
  207b66:	689b      	ldr	r3, [r3, #8]
  207b68:	b113      	cbz	r3, 207b70 <Vector14C+0x308>
  207b6a:	4649      	mov	r1, r9
  207b6c:	4658      	mov	r0, fp
  207b6e:	4798      	blx	r3
      otg_txfifo_handler(usbp, ep);
  207b70:	4648      	mov	r0, r9
  207b72:	f7f8 fe33 	bl	2007dc <otg_txfifo_handler.constprop.0>
  207b76:	3701      	adds	r7, #1
  207b78:	e7c9      	b.n	207b0e <Vector14C+0x2a6>
    if ((i & 3) == 0){
  207b7a:	0791      	lsls	r1, r2, #30
  207b7c:	d101      	bne.n	207b82 <Vector14C+0x31a>
      w = *fifop;
  207b7e:	f8d7 8000 	ldr.w	r8, [r7]
    if (i < max) {
  207b82:	2a07      	cmp	r2, #7
    i++;
  207b84:	f102 0201 	add.w	r2, r2, #1
      *buf++ = (uint8_t)w;
  207b88:	bf9c      	itt	ls
  207b8a:	f803 8b01 	strbls.w	r8, [r3], #1
      w >>= 8;
  207b8e:	ea4f 2818 	movls.w	r8, r8, lsr #8
    i++;
  207b92:	e764      	b.n	207a5e <Vector14C+0x1f6>
                            usbp->epc[ep]->out_state->rxbuf,
  207b94:	3302      	adds	r3, #2
      w = *fifop;
  207b96:	f507 5780 	add.w	r7, r7, #4096	; 0x1000
                            usbp->epc[ep]->out_state->rxbuf,
  207b9a:	eb04 0283 	add.w	r2, r4, r3, lsl #2
  207b9e:	6852      	ldr	r2, [r2, #4]
  207ba0:	f8d2 c018 	ldr.w	ip, [r2, #24]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
  207ba4:	f8dc 2008 	ldr.w	r2, [ip, #8]
  207ba8:	e9dc 1c00 	ldrd	r1, ip, [ip]
  207bac:	eba1 0c0c 	sub.w	ip, r1, ip
  size_t i = 0;
  207bb0:	2100      	movs	r1, #0
  while (i < n) {
  207bb2:	4288      	cmp	r0, r1
  207bb4:	d10a      	bne.n	207bcc <Vector14C+0x364>
    usbp->epc[ep]->out_state->rxbuf += cnt;
  207bb6:	eb04 0483 	add.w	r4, r4, r3, lsl #2
  207bba:	6863      	ldr	r3, [r4, #4]
  207bbc:	699b      	ldr	r3, [r3, #24]
  207bbe:	689a      	ldr	r2, [r3, #8]
  207bc0:	4402      	add	r2, r0
  207bc2:	609a      	str	r2, [r3, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
  207bc4:	685a      	ldr	r2, [r3, #4]
  207bc6:	4410      	add	r0, r2
  207bc8:	6058      	str	r0, [r3, #4]
  207bca:	e74b      	b.n	207a64 <Vector14C+0x1fc>
    if ((i & 3) == 0){
  207bcc:	f011 0f03 	tst.w	r1, #3
  207bd0:	d101      	bne.n	207bd6 <Vector14C+0x36e>
      w = *fifop;
  207bd2:	f8d7 8000 	ldr.w	r8, [r7]
    if (i < max) {
  207bd6:	458c      	cmp	ip, r1
    i++;
  207bd8:	f101 0101 	add.w	r1, r1, #1
      *buf++ = (uint8_t)w;
  207bdc:	bf84      	itt	hi
  207bde:	f802 8b01 	strbhi.w	r8, [r2], #1
      w >>= 8;
  207be2:	ea4f 2818 	movhi.w	r8, r8, lsr #8
    i++;
  207be6:	e7e4      	b.n	207bb2 <Vector14C+0x34a>
  207be8:	20000e14 	.word	0x20000e14

00207bec <Vector164>:
OSAL_IRQ_HANDLER(STM32_I2C3_ERROR_HANDLER) {
  207bec:	b570      	push	{r4, r5, r6, lr}
  uint32_t isr = I2CD3.i2c->ISR;
  207bee:	4c0b      	ldr	r4, [pc, #44]	; (207c1c <Vector164+0x30>)
  OSAL_IRQ_PROLOGUE();
  207bf0:	4d0b      	ldr	r5, [pc, #44]	; (207c20 <Vector164+0x34>)
  uint32_t isr = I2CD3.i2c->ISR;
  207bf2:	6b23      	ldr	r3, [r4, #48]	; 0x30
  OSAL_IRQ_PROLOGUE();
  207bf4:	4628      	mov	r0, r5
  uint32_t isr = I2CD3.i2c->ISR;
  207bf6:	699e      	ldr	r6, [r3, #24]
  OSAL_IRQ_PROLOGUE();
  207bf8:	f7fc feb8 	bl	20496c <_trace_isr_enter>
  I2CD3.i2c->ICR = isr & I2C_ERROR_MASK;
  207bfc:	6b23      	ldr	r3, [r4, #48]	; 0x30
  i2c_lld_serve_error_interrupt(&I2CD3, isr);
  207bfe:	4620      	mov	r0, r4
  I2CD3.i2c->ICR = isr & I2C_ERROR_MASK;
  207c00:	f406 527c 	and.w	r2, r6, #16128	; 0x3f00
  i2c_lld_serve_error_interrupt(&I2CD3, isr);
  207c04:	4631      	mov	r1, r6
  I2CD3.i2c->ICR = isr & I2C_ERROR_MASK;
  207c06:	61da      	str	r2, [r3, #28]
  i2c_lld_serve_error_interrupt(&I2CD3, isr);
  207c08:	f7fc ff2d 	bl	204a66 <i2c_lld_serve_error_interrupt>
  OSAL_IRQ_EPILOGUE();
  207c0c:	4628      	mov	r0, r5
  207c0e:	f7fc fe99 	bl	204944 <_trace_isr_leave>
}
  207c12:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
  207c16:	f7fc bad1 	b.w	2041bc <_port_irq_epilogue>
  207c1a:	bf00      	nop
  207c1c:	20000858 	.word	0x20000858
  207c20:	0800e4ac 	.word	0x0800e4ac

00207c24 <Vector160>:
OSAL_IRQ_HANDLER(STM32_I2C3_EVENT_HANDLER) {
  207c24:	b570      	push	{r4, r5, r6, lr}
  uint32_t isr = I2CD3.i2c->ISR;
  207c26:	4c0b      	ldr	r4, [pc, #44]	; (207c54 <Vector160+0x30>)
  OSAL_IRQ_PROLOGUE();
  207c28:	4d0b      	ldr	r5, [pc, #44]	; (207c58 <Vector160+0x34>)
  uint32_t isr = I2CD3.i2c->ISR;
  207c2a:	6b23      	ldr	r3, [r4, #48]	; 0x30
  OSAL_IRQ_PROLOGUE();
  207c2c:	4628      	mov	r0, r5
  uint32_t isr = I2CD3.i2c->ISR;
  207c2e:	699e      	ldr	r6, [r3, #24]
  OSAL_IRQ_PROLOGUE();
  207c30:	f7fc fe9c 	bl	20496c <_trace_isr_enter>
  I2CD3.i2c->ICR = isr & I2C_INT_MASK;
  207c34:	6b23      	ldr	r3, [r4, #48]	; 0x30
  i2c_lld_serve_interrupt(&I2CD3, isr);
  207c36:	4620      	mov	r0, r4
  I2CD3.i2c->ICR = isr & I2C_INT_MASK;
  207c38:	f006 02fe 	and.w	r2, r6, #254	; 0xfe
  i2c_lld_serve_interrupt(&I2CD3, isr);
  207c3c:	4631      	mov	r1, r6
  I2CD3.i2c->ICR = isr & I2C_INT_MASK;
  207c3e:	61da      	str	r2, [r3, #28]
  i2c_lld_serve_interrupt(&I2CD3, isr);
  207c40:	f7fc ff3d 	bl	204abe <i2c_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
  207c44:	4628      	mov	r0, r5
  207c46:	f7fc fe7d 	bl	204944 <_trace_isr_leave>
}
  207c4a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
  207c4e:	f7fc bab5 	b.w	2041bc <_port_irq_epilogue>
  207c52:	bf00      	nop
  207c54:	20000858 	.word	0x20000858
  207c58:	0800e498 	.word	0x0800e498

00207c5c <VectorC0>:
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  207c5c:	b570      	push	{r4, r5, r6, lr}
  uint32_t isr = I2CD1.i2c->ISR;
  207c5e:	4c0b      	ldr	r4, [pc, #44]	; (207c8c <VectorC0+0x30>)
  OSAL_IRQ_PROLOGUE();
  207c60:	4d0b      	ldr	r5, [pc, #44]	; (207c90 <VectorC0+0x34>)
  uint32_t isr = I2CD1.i2c->ISR;
  207c62:	6b23      	ldr	r3, [r4, #48]	; 0x30
  OSAL_IRQ_PROLOGUE();
  207c64:	4628      	mov	r0, r5
  uint32_t isr = I2CD1.i2c->ISR;
  207c66:	699e      	ldr	r6, [r3, #24]
  OSAL_IRQ_PROLOGUE();
  207c68:	f7fc fe80 	bl	20496c <_trace_isr_enter>
  I2CD1.i2c->ICR = isr & I2C_ERROR_MASK;
  207c6c:	6b23      	ldr	r3, [r4, #48]	; 0x30
  i2c_lld_serve_error_interrupt(&I2CD1, isr);
  207c6e:	4620      	mov	r0, r4
  I2CD1.i2c->ICR = isr & I2C_ERROR_MASK;
  207c70:	f406 527c 	and.w	r2, r6, #16128	; 0x3f00
  i2c_lld_serve_error_interrupt(&I2CD1, isr);
  207c74:	4631      	mov	r1, r6
  I2CD1.i2c->ICR = isr & I2C_ERROR_MASK;
  207c76:	61da      	str	r2, [r3, #28]
  i2c_lld_serve_error_interrupt(&I2CD1, isr);
  207c78:	f7fc fef5 	bl	204a66 <i2c_lld_serve_error_interrupt>
  OSAL_IRQ_EPILOGUE();
  207c7c:	4628      	mov	r0, r5
  207c7e:	f7fc fe61 	bl	204944 <_trace_isr_leave>
}
  207c82:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
  207c86:	f7fc ba99 	b.w	2041bc <_port_irq_epilogue>
  207c8a:	bf00      	nop
  207c8c:	20000824 	.word	0x20000824
  207c90:	0800e486 	.word	0x0800e486

00207c94 <VectorBC>:
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
  207c94:	b570      	push	{r4, r5, r6, lr}
  uint32_t isr = I2CD1.i2c->ISR;
  207c96:	4c0b      	ldr	r4, [pc, #44]	; (207cc4 <VectorBC+0x30>)
  OSAL_IRQ_PROLOGUE();
  207c98:	4d0b      	ldr	r5, [pc, #44]	; (207cc8 <VectorBC+0x34>)
  uint32_t isr = I2CD1.i2c->ISR;
  207c9a:	6b23      	ldr	r3, [r4, #48]	; 0x30
  OSAL_IRQ_PROLOGUE();
  207c9c:	4628      	mov	r0, r5
  uint32_t isr = I2CD1.i2c->ISR;
  207c9e:	699e      	ldr	r6, [r3, #24]
  OSAL_IRQ_PROLOGUE();
  207ca0:	f7fc fe64 	bl	20496c <_trace_isr_enter>
  I2CD1.i2c->ICR = isr & I2C_INT_MASK;
  207ca4:	6b23      	ldr	r3, [r4, #48]	; 0x30
  i2c_lld_serve_interrupt(&I2CD1, isr);
  207ca6:	4620      	mov	r0, r4
  I2CD1.i2c->ICR = isr & I2C_INT_MASK;
  207ca8:	f006 02fe 	and.w	r2, r6, #254	; 0xfe
  i2c_lld_serve_interrupt(&I2CD1, isr);
  207cac:	4631      	mov	r1, r6
  I2CD1.i2c->ICR = isr & I2C_INT_MASK;
  207cae:	61da      	str	r2, [r3, #28]
  i2c_lld_serve_interrupt(&I2CD1, isr);
  207cb0:	f7fc ff05 	bl	204abe <i2c_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
  207cb4:	4628      	mov	r0, r5
  207cb6:	f7fc fe45 	bl	204944 <_trace_isr_leave>
}
  207cba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  OSAL_IRQ_EPILOGUE();
  207cbe:	f7fc ba7d 	b.w	2041bc <_port_irq_epilogue>
  207cc2:	bf00      	nop
  207cc4:	20000824 	.word	0x20000824
  207cc8:	0800e46b 	.word	0x0800e46b

00207ccc <Vector158>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  207ccc:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  207cce:	480b      	ldr	r0, [pc, #44]	; (207cfc <Vector158+0x30>)
  207cd0:	f7fc fe4c 	bl	20496c <_trace_isr_enter>
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  207cd4:	4b0a      	ldr	r3, [pc, #40]	; (207d00 <Vector158+0x34>)
  207cd6:	6859      	ldr	r1, [r3, #4]
  207cd8:	0d89      	lsrs	r1, r1, #22
  207cda:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 22U;
  207cde:	058a      	lsls	r2, r1, #22
  207ce0:	60da      	str	r2, [r3, #12]
  if (dma.streams[15].func)
  207ce2:	4a08      	ldr	r2, [pc, #32]	; (207d04 <Vector158+0x38>)
  207ce4:	6fd3      	ldr	r3, [r2, #124]	; 0x7c
  207ce6:	b113      	cbz	r3, 207cee <Vector158+0x22>
    dma.streams[15].func(dma.streams[15].param, flags);
  207ce8:	f8d2 0080 	ldr.w	r0, [r2, #128]	; 0x80
  207cec:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  207cee:	4803      	ldr	r0, [pc, #12]	; (207cfc <Vector158+0x30>)
  207cf0:	f7fc fe28 	bl	204944 <_trace_isr_leave>
}
  207cf4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  207cf8:	f7fc ba60 	b.w	2041bc <_port_irq_epilogue>
  207cfc:	0800e4fc 	.word	0x0800e4fc
  207d00:	40026400 	.word	0x40026400
  207d04:	200018a8 	.word	0x200018a8

00207d08 <Vector154>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  207d08:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  207d0a:	480b      	ldr	r0, [pc, #44]	; (207d38 <Vector154+0x30>)
  207d0c:	f7fc fe2e 	bl	20496c <_trace_isr_enter>
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  207d10:	4b0a      	ldr	r3, [pc, #40]	; (207d3c <Vector154+0x34>)
  207d12:	6859      	ldr	r1, [r3, #4]
  207d14:	0c09      	lsrs	r1, r1, #16
  207d16:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 16U;
  207d1a:	040a      	lsls	r2, r1, #16
  207d1c:	60da      	str	r2, [r3, #12]
  if (dma.streams[14].func)
  207d1e:	4a08      	ldr	r2, [pc, #32]	; (207d40 <Vector154+0x38>)
  207d20:	6f53      	ldr	r3, [r2, #116]	; 0x74
  207d22:	b10b      	cbz	r3, 207d28 <Vector154+0x20>
    dma.streams[14].func(dma.streams[14].param, flags);
  207d24:	6f90      	ldr	r0, [r2, #120]	; 0x78
  207d26:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  207d28:	4803      	ldr	r0, [pc, #12]	; (207d38 <Vector154+0x30>)
  207d2a:	f7fc fe0b 	bl	204944 <_trace_isr_leave>
}
  207d2e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  207d32:	f7fc ba43 	b.w	2041bc <_port_irq_epilogue>
  207d36:	bf00      	nop
  207d38:	0800e4f2 	.word	0x0800e4f2
  207d3c:	40026400 	.word	0x40026400
  207d40:	200018a8 	.word	0x200018a8

00207d44 <Vector150>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  207d44:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  207d46:	480b      	ldr	r0, [pc, #44]	; (207d74 <Vector150+0x30>)
  207d48:	f7fc fe10 	bl	20496c <_trace_isr_enter>
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  207d4c:	4b0a      	ldr	r3, [pc, #40]	; (207d78 <Vector150+0x34>)
  207d4e:	6859      	ldr	r1, [r3, #4]
  207d50:	0989      	lsrs	r1, r1, #6
  207d52:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 6U;
  207d56:	018a      	lsls	r2, r1, #6
  207d58:	60da      	str	r2, [r3, #12]
  if (dma.streams[13].func)
  207d5a:	4a08      	ldr	r2, [pc, #32]	; (207d7c <Vector150+0x38>)
  207d5c:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
  207d5e:	b10b      	cbz	r3, 207d64 <Vector150+0x20>
    dma.streams[13].func(dma.streams[13].param, flags);
  207d60:	6f10      	ldr	r0, [r2, #112]	; 0x70
  207d62:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  207d64:	4803      	ldr	r0, [pc, #12]	; (207d74 <Vector150+0x30>)
  207d66:	f7fc fded 	bl	204944 <_trace_isr_leave>
}
  207d6a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  207d6e:	f7fc ba25 	b.w	2041bc <_port_irq_epilogue>
  207d72:	bf00      	nop
  207d74:	0800e4e8 	.word	0x0800e4e8
  207d78:	40026400 	.word	0x40026400
  207d7c:	200018a8 	.word	0x200018a8

00207d80 <Vector130>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  207d80:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  207d82:	480a      	ldr	r0, [pc, #40]	; (207dac <Vector130+0x2c>)
  207d84:	f7fc fdf2 	bl	20496c <_trace_isr_enter>
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  207d88:	4b09      	ldr	r3, [pc, #36]	; (207db0 <Vector130+0x30>)
  if (dma.streams[12].func)
  207d8a:	4a0a      	ldr	r2, [pc, #40]	; (207db4 <Vector130+0x34>)
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  207d8c:	6859      	ldr	r1, [r3, #4]
  207d8e:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
  207d92:	60d9      	str	r1, [r3, #12]
  if (dma.streams[12].func)
  207d94:	6e53      	ldr	r3, [r2, #100]	; 0x64
  207d96:	b10b      	cbz	r3, 207d9c <Vector130+0x1c>
    dma.streams[12].func(dma.streams[12].param, flags);
  207d98:	6e90      	ldr	r0, [r2, #104]	; 0x68
  207d9a:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  207d9c:	4803      	ldr	r0, [pc, #12]	; (207dac <Vector130+0x2c>)
  207d9e:	f7fc fdd1 	bl	204944 <_trace_isr_leave>
}
  207da2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  207da6:	f7fc ba09 	b.w	2041bc <_port_irq_epilogue>
  207daa:	bf00      	nop
  207dac:	0800e4de 	.word	0x0800e4de
  207db0:	40026400 	.word	0x40026400
  207db4:	200018a8 	.word	0x200018a8

00207db8 <Vector12C>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  207db8:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  207dba:	480b      	ldr	r0, [pc, #44]	; (207de8 <Vector12C+0x30>)
  207dbc:	f7fc fdd6 	bl	20496c <_trace_isr_enter>
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  207dc0:	4b0a      	ldr	r3, [pc, #40]	; (207dec <Vector12C+0x34>)
  207dc2:	6819      	ldr	r1, [r3, #0]
  207dc4:	0d89      	lsrs	r1, r1, #22
  207dc6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 22U;
  207dca:	058a      	lsls	r2, r1, #22
  207dcc:	609a      	str	r2, [r3, #8]
  if (dma.streams[11].func)
  207dce:	4a08      	ldr	r2, [pc, #32]	; (207df0 <Vector12C+0x38>)
  207dd0:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
  207dd2:	b10b      	cbz	r3, 207dd8 <Vector12C+0x20>
    dma.streams[11].func(dma.streams[11].param, flags);
  207dd4:	6e10      	ldr	r0, [r2, #96]	; 0x60
  207dd6:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  207dd8:	4803      	ldr	r0, [pc, #12]	; (207de8 <Vector12C+0x30>)
  207dda:	f7fc fdb3 	bl	204944 <_trace_isr_leave>
}
  207dde:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  207de2:	f7fc b9eb 	b.w	2041bc <_port_irq_epilogue>
  207de6:	bf00      	nop
  207de8:	0800e4d4 	.word	0x0800e4d4
  207dec:	40026400 	.word	0x40026400
  207df0:	200018a8 	.word	0x200018a8

00207df4 <Vector128>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  207df4:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  207df6:	480b      	ldr	r0, [pc, #44]	; (207e24 <Vector128+0x30>)
  207df8:	f7fc fdb8 	bl	20496c <_trace_isr_enter>
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  207dfc:	4b0a      	ldr	r3, [pc, #40]	; (207e28 <Vector128+0x34>)
  207dfe:	6819      	ldr	r1, [r3, #0]
  207e00:	0c09      	lsrs	r1, r1, #16
  207e02:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 16U;
  207e06:	040a      	lsls	r2, r1, #16
  207e08:	609a      	str	r2, [r3, #8]
  if (dma.streams[10].func)
  207e0a:	4a08      	ldr	r2, [pc, #32]	; (207e2c <Vector128+0x38>)
  207e0c:	6d53      	ldr	r3, [r2, #84]	; 0x54
  207e0e:	b10b      	cbz	r3, 207e14 <Vector128+0x20>
    dma.streams[10].func(dma.streams[10].param, flags);
  207e10:	6d90      	ldr	r0, [r2, #88]	; 0x58
  207e12:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  207e14:	4803      	ldr	r0, [pc, #12]	; (207e24 <Vector128+0x30>)
  207e16:	f7fc fd95 	bl	204944 <_trace_isr_leave>
}
  207e1a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  207e1e:	f7fc b9cd 	b.w	2041bc <_port_irq_epilogue>
  207e22:	bf00      	nop
  207e24:	0800e4ca 	.word	0x0800e4ca
  207e28:	40026400 	.word	0x40026400
  207e2c:	200018a8 	.word	0x200018a8

00207e30 <Vector124>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  207e30:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  207e32:	480b      	ldr	r0, [pc, #44]	; (207e60 <Vector124+0x30>)
  207e34:	f7fc fd9a 	bl	20496c <_trace_isr_enter>
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  207e38:	4b0a      	ldr	r3, [pc, #40]	; (207e64 <Vector124+0x34>)
  207e3a:	6819      	ldr	r1, [r3, #0]
  207e3c:	0989      	lsrs	r1, r1, #6
  207e3e:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 6U;
  207e42:	018a      	lsls	r2, r1, #6
  207e44:	609a      	str	r2, [r3, #8]
  if (dma.streams[9].func)
  207e46:	4a08      	ldr	r2, [pc, #32]	; (207e68 <Vector124+0x38>)
  207e48:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
  207e4a:	b10b      	cbz	r3, 207e50 <Vector124+0x20>
    dma.streams[9].func(dma.streams[9].param, flags);
  207e4c:	6d10      	ldr	r0, [r2, #80]	; 0x50
  207e4e:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  207e50:	4803      	ldr	r0, [pc, #12]	; (207e60 <Vector124+0x30>)
  207e52:	f7fc fd77 	bl	204944 <_trace_isr_leave>
}
  207e56:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  207e5a:	f7fc b9af 	b.w	2041bc <_port_irq_epilogue>
  207e5e:	bf00      	nop
  207e60:	0800e4b6 	.word	0x0800e4b6
  207e64:	40026400 	.word	0x40026400
  207e68:	200018a8 	.word	0x200018a8

00207e6c <Vector120>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  207e6c:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  207e6e:	480a      	ldr	r0, [pc, #40]	; (207e98 <Vector120+0x2c>)
  207e70:	f7fc fd7c 	bl	20496c <_trace_isr_enter>
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  207e74:	4b09      	ldr	r3, [pc, #36]	; (207e9c <Vector120+0x30>)
  if (dma.streams[8].func)
  207e76:	4a0a      	ldr	r2, [pc, #40]	; (207ea0 <Vector120+0x34>)
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  207e78:	6819      	ldr	r1, [r3, #0]
  207e7a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
  207e7e:	6099      	str	r1, [r3, #8]
  if (dma.streams[8].func)
  207e80:	6c53      	ldr	r3, [r2, #68]	; 0x44
  207e82:	b10b      	cbz	r3, 207e88 <Vector120+0x1c>
    dma.streams[8].func(dma.streams[8].param, flags);
  207e84:	6c90      	ldr	r0, [r2, #72]	; 0x48
  207e86:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  207e88:	4803      	ldr	r0, [pc, #12]	; (207e98 <Vector120+0x2c>)
  207e8a:	f7fc fd5b 	bl	204944 <_trace_isr_leave>
}
  207e8e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  207e92:	f7fc b993 	b.w	2041bc <_port_irq_epilogue>
  207e96:	bf00      	nop
  207e98:	0800e4a2 	.word	0x0800e4a2
  207e9c:	40026400 	.word	0x40026400
  207ea0:	200018a8 	.word	0x200018a8

00207ea4 <VectorFC>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  207ea4:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  207ea6:	480b      	ldr	r0, [pc, #44]	; (207ed4 <VectorFC+0x30>)
  207ea8:	f7fc fd60 	bl	20496c <_trace_isr_enter>
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  207eac:	4b0a      	ldr	r3, [pc, #40]	; (207ed8 <VectorFC+0x34>)
  207eae:	6859      	ldr	r1, [r3, #4]
  207eb0:	0d89      	lsrs	r1, r1, #22
  207eb2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 22U;
  207eb6:	058a      	lsls	r2, r1, #22
  207eb8:	60da      	str	r2, [r3, #12]
  if (dma.streams[7].func)
  207eba:	4a08      	ldr	r2, [pc, #32]	; (207edc <VectorFC+0x38>)
  207ebc:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
  207ebe:	b10b      	cbz	r3, 207ec4 <VectorFC+0x20>
    dma.streams[7].func(dma.streams[7].param, flags);
  207ec0:	6c10      	ldr	r0, [r2, #64]	; 0x40
  207ec2:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  207ec4:	4803      	ldr	r0, [pc, #12]	; (207ed4 <VectorFC+0x30>)
  207ec6:	f7fc fd3d 	bl	204944 <_trace_isr_leave>
}
  207eca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  207ece:	f7fc b975 	b.w	2041bc <_port_irq_epilogue>
  207ed2:	bf00      	nop
  207ed4:	0800e48f 	.word	0x0800e48f
  207ed8:	40026000 	.word	0x40026000
  207edc:	200018a8 	.word	0x200018a8

00207ee0 <Vector84>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  207ee0:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  207ee2:	480b      	ldr	r0, [pc, #44]	; (207f10 <Vector84+0x30>)
  207ee4:	f7fc fd42 	bl	20496c <_trace_isr_enter>
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  207ee8:	4b0a      	ldr	r3, [pc, #40]	; (207f14 <Vector84+0x34>)
  207eea:	6859      	ldr	r1, [r3, #4]
  207eec:	0c09      	lsrs	r1, r1, #16
  207eee:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 16U;
  207ef2:	040a      	lsls	r2, r1, #16
  207ef4:	60da      	str	r2, [r3, #12]
  if (dma.streams[6].func)
  207ef6:	4a08      	ldr	r2, [pc, #32]	; (207f18 <Vector84+0x38>)
  207ef8:	6b53      	ldr	r3, [r2, #52]	; 0x34
  207efa:	b10b      	cbz	r3, 207f00 <Vector84+0x20>
    dma.streams[6].func(dma.streams[6].param, flags);
  207efc:	6b90      	ldr	r0, [r2, #56]	; 0x38
  207efe:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  207f00:	4803      	ldr	r0, [pc, #12]	; (207f10 <Vector84+0x30>)
  207f02:	f7fc fd1f 	bl	204944 <_trace_isr_leave>
}
  207f06:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  207f0a:	f7fc b957 	b.w	2041bc <_port_irq_epilogue>
  207f0e:	bf00      	nop
  207f10:	0800e47d 	.word	0x0800e47d
  207f14:	40026000 	.word	0x40026000
  207f18:	200018a8 	.word	0x200018a8

00207f1c <Vector80>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  207f1c:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  207f1e:	480b      	ldr	r0, [pc, #44]	; (207f4c <Vector80+0x30>)
  207f20:	f7fc fd24 	bl	20496c <_trace_isr_enter>
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  207f24:	4b0a      	ldr	r3, [pc, #40]	; (207f50 <Vector80+0x34>)
  207f26:	6859      	ldr	r1, [r3, #4]
  207f28:	0989      	lsrs	r1, r1, #6
  207f2a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 6U;
  207f2e:	018a      	lsls	r2, r1, #6
  207f30:	60da      	str	r2, [r3, #12]
  if (dma.streams[5].func)
  207f32:	4a08      	ldr	r2, [pc, #32]	; (207f54 <Vector80+0x38>)
  207f34:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
  207f36:	b10b      	cbz	r3, 207f3c <Vector80+0x20>
    dma.streams[5].func(dma.streams[5].param, flags);
  207f38:	6b10      	ldr	r0, [r2, #48]	; 0x30
  207f3a:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  207f3c:	4803      	ldr	r0, [pc, #12]	; (207f4c <Vector80+0x30>)
  207f3e:	f7fc fd01 	bl	204944 <_trace_isr_leave>
}
  207f42:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  207f46:	f7fc b939 	b.w	2041bc <_port_irq_epilogue>
  207f4a:	bf00      	nop
  207f4c:	0800e462 	.word	0x0800e462
  207f50:	40026000 	.word	0x40026000
  207f54:	200018a8 	.word	0x200018a8

00207f58 <Vector7C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  207f58:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  207f5a:	480a      	ldr	r0, [pc, #40]	; (207f84 <Vector7C+0x2c>)
  207f5c:	f7fc fd06 	bl	20496c <_trace_isr_enter>
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  207f60:	4b09      	ldr	r3, [pc, #36]	; (207f88 <Vector7C+0x30>)
  if (dma.streams[4].func)
  207f62:	4a0a      	ldr	r2, [pc, #40]	; (207f8c <Vector7C+0x34>)
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  207f64:	6859      	ldr	r1, [r3, #4]
  207f66:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
  207f6a:	60d9      	str	r1, [r3, #12]
  if (dma.streams[4].func)
  207f6c:	6a53      	ldr	r3, [r2, #36]	; 0x24
  207f6e:	b10b      	cbz	r3, 207f74 <Vector7C+0x1c>
    dma.streams[4].func(dma.streams[4].param, flags);
  207f70:	6a90      	ldr	r0, [r2, #40]	; 0x28
  207f72:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  207f74:	4803      	ldr	r0, [pc, #12]	; (207f84 <Vector7C+0x2c>)
  207f76:	f7fc fce5 	bl	204944 <_trace_isr_leave>
}
  207f7a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  207f7e:	f7fc b91d 	b.w	2041bc <_port_irq_epilogue>
  207f82:	bf00      	nop
  207f84:	0800e459 	.word	0x0800e459
  207f88:	40026000 	.word	0x40026000
  207f8c:	200018a8 	.word	0x200018a8

00207f90 <Vector78>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  207f90:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  207f92:	480b      	ldr	r0, [pc, #44]	; (207fc0 <Vector78+0x30>)
  207f94:	f7fc fcea 	bl	20496c <_trace_isr_enter>
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  207f98:	4b0a      	ldr	r3, [pc, #40]	; (207fc4 <Vector78+0x34>)
  207f9a:	6819      	ldr	r1, [r3, #0]
  207f9c:	0d89      	lsrs	r1, r1, #22
  207f9e:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 22U;
  207fa2:	058a      	lsls	r2, r1, #22
  207fa4:	609a      	str	r2, [r3, #8]
  if (dma.streams[3].func)
  207fa6:	4a08      	ldr	r2, [pc, #32]	; (207fc8 <Vector78+0x38>)
  207fa8:	69d3      	ldr	r3, [r2, #28]
  207faa:	b10b      	cbz	r3, 207fb0 <Vector78+0x20>
    dma.streams[3].func(dma.streams[3].param, flags);
  207fac:	6a10      	ldr	r0, [r2, #32]
  207fae:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  207fb0:	4803      	ldr	r0, [pc, #12]	; (207fc0 <Vector78+0x30>)
  207fb2:	f7fc fcc7 	bl	204944 <_trace_isr_leave>
}
  207fb6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  207fba:	f7fc b8ff 	b.w	2041bc <_port_irq_epilogue>
  207fbe:	bf00      	nop
  207fc0:	0800e450 	.word	0x0800e450
  207fc4:	40026000 	.word	0x40026000
  207fc8:	200018a8 	.word	0x200018a8

00207fcc <Vector74>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  207fcc:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  207fce:	480b      	ldr	r0, [pc, #44]	; (207ffc <Vector74+0x30>)
  207fd0:	f7fc fccc 	bl	20496c <_trace_isr_enter>
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  207fd4:	4b0a      	ldr	r3, [pc, #40]	; (208000 <Vector74+0x34>)
  207fd6:	6819      	ldr	r1, [r3, #0]
  207fd8:	0c09      	lsrs	r1, r1, #16
  207fda:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 16U;
  207fde:	040a      	lsls	r2, r1, #16
  207fe0:	609a      	str	r2, [r3, #8]
  if (dma.streams[2].func)
  207fe2:	4a08      	ldr	r2, [pc, #32]	; (208004 <Vector74+0x38>)
  207fe4:	6953      	ldr	r3, [r2, #20]
  207fe6:	b10b      	cbz	r3, 207fec <Vector74+0x20>
    dma.streams[2].func(dma.streams[2].param, flags);
  207fe8:	6990      	ldr	r0, [r2, #24]
  207fea:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  207fec:	4803      	ldr	r0, [pc, #12]	; (207ffc <Vector74+0x30>)
  207fee:	f7fc fca9 	bl	204944 <_trace_isr_leave>
}
  207ff2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  207ff6:	f7fc b8e1 	b.w	2041bc <_port_irq_epilogue>
  207ffa:	bf00      	nop
  207ffc:	0800e447 	.word	0x0800e447
  208000:	40026000 	.word	0x40026000
  208004:	200018a8 	.word	0x200018a8

00208008 <Vector70>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  208008:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  20800a:	480b      	ldr	r0, [pc, #44]	; (208038 <Vector70+0x30>)
  20800c:	f7fc fcae 	bl	20496c <_trace_isr_enter>
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  208010:	4b0a      	ldr	r3, [pc, #40]	; (20803c <Vector70+0x34>)
  208012:	6819      	ldr	r1, [r3, #0]
  208014:	0989      	lsrs	r1, r1, #6
  208016:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 6U;
  20801a:	018a      	lsls	r2, r1, #6
  20801c:	609a      	str	r2, [r3, #8]
  if (dma.streams[1].func)
  20801e:	4a08      	ldr	r2, [pc, #32]	; (208040 <Vector70+0x38>)
  208020:	68d3      	ldr	r3, [r2, #12]
  208022:	b10b      	cbz	r3, 208028 <Vector70+0x20>
    dma.streams[1].func(dma.streams[1].param, flags);
  208024:	6910      	ldr	r0, [r2, #16]
  208026:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  208028:	4803      	ldr	r0, [pc, #12]	; (208038 <Vector70+0x30>)
  20802a:	f7fc fc8b 	bl	204944 <_trace_isr_leave>
}
  20802e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  208032:	f7fc b8c3 	b.w	2041bc <_port_irq_epilogue>
  208036:	bf00      	nop
  208038:	0800e43e 	.word	0x0800e43e
  20803c:	40026000 	.word	0x40026000
  208040:	200018a8 	.word	0x200018a8

00208044 <Vector6C>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
  208044:	b508      	push	{r3, lr}
  OSAL_IRQ_PROLOGUE();
  208046:	480a      	ldr	r0, [pc, #40]	; (208070 <Vector6C+0x2c>)
  208048:	f7fc fc90 	bl	20496c <_trace_isr_enter>
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
  20804c:	4b09      	ldr	r3, [pc, #36]	; (208074 <Vector6C+0x30>)
  if (dma.streams[0].func)
  20804e:	4a0a      	ldr	r2, [pc, #40]	; (208078 <Vector6C+0x34>)
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
  208050:	6819      	ldr	r1, [r3, #0]
  208052:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
  208056:	6099      	str	r1, [r3, #8]
  if (dma.streams[0].func)
  208058:	6853      	ldr	r3, [r2, #4]
  20805a:	b10b      	cbz	r3, 208060 <Vector6C+0x1c>
    dma.streams[0].func(dma.streams[0].param, flags);
  20805c:	6890      	ldr	r0, [r2, #8]
  20805e:	4798      	blx	r3
  OSAL_IRQ_EPILOGUE();
  208060:	4803      	ldr	r0, [pc, #12]	; (208070 <Vector6C+0x2c>)
  208062:	f7fc fc6f 	bl	204944 <_trace_isr_leave>
}
  208066:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  20806a:	f7fc b8a7 	b.w	2041bc <_port_irq_epilogue>
  20806e:	bf00      	nop
  208070:	0800e435 	.word	0x0800e435
  208074:	40026000 	.word	0x40026000
  208078:	200018a8 	.word	0x200018a8

0020807c <sduInterruptTransmitted>:
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {

  (void)usbp;
  (void)ep;
}
  20807c:	4770      	bx	lr
	...

00208080 <sduRequestsHook>:
  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
  208080:	f890 305c 	ldrb.w	r3, [r0, #92]	; 0x5c
  208084:	f003 0360 	and.w	r3, r3, #96	; 0x60
  208088:	2b20      	cmp	r3, #32
  20808a:	d106      	bne.n	20809a <sduRequestsHook+0x1a>
    switch (usbp->setup[1]) {
  20808c:	f890 205d 	ldrb.w	r2, [r0, #93]	; 0x5d
  208090:	2300      	movs	r3, #0
  208092:	2a21      	cmp	r2, #33	; 0x21
  208094:	d803      	bhi.n	20809e <sduRequestsHook+0x1e>
  208096:	2a1f      	cmp	r2, #31
  208098:	d806      	bhi.n	2080a8 <sduRequestsHook+0x28>
  return false;
  20809a:	2000      	movs	r0, #0
}
  20809c:	4770      	bx	lr
    switch (usbp->setup[1]) {
  20809e:	2a22      	cmp	r2, #34	; 0x22
  2080a0:	d1fb      	bne.n	20809a <sduRequestsHook+0x1a>
      usbSetupTransfer(usbp, NULL, 0, NULL);
  2080a2:	e9c0 3314 	strd	r3, r3, [r0, #80]	; 0x50
  2080a6:	e003      	b.n	2080b0 <sduRequestsHook+0x30>
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
  2080a8:	4a03      	ldr	r2, [pc, #12]	; (2080b8 <sduRequestsHook+0x38>)
  2080aa:	6502      	str	r2, [r0, #80]	; 0x50
  2080ac:	2207      	movs	r2, #7
  2080ae:	6542      	str	r2, [r0, #84]	; 0x54
      usbSetupTransfer(usbp, NULL, 0, NULL);
  2080b0:	6583      	str	r3, [r0, #88]	; 0x58
      return true;
  2080b2:	2001      	movs	r0, #1
  2080b4:	4770      	bx	lr
  2080b6:	bf00      	nop
  2080b8:	20010058 	.word	0x20010058

002080bc <_ctl>:
}
  2080bc:	2000      	movs	r0, #0
  2080be:	4770      	bx	lr

002080c0 <_ctl.lto_priv.0>:
  2080c0:	2000      	movs	r0, #0
  2080c2:	4770      	bx	lr

002080c4 <sdcGetInfo>:
 */
bool sdcGetInfo(SDCDriver *sdcp, BlockDeviceInfo *bdip) {

  osalDbgCheck((sdcp != NULL) && (bdip != NULL));

  if (sdcp->state != BLK_READY) {
  2080c4:	7903      	ldrb	r3, [r0, #4]
  2080c6:	2b05      	cmp	r3, #5
    return HAL_FAILED;
  }

  bdip->blk_num = sdcp->capacity;
  2080c8:	bf05      	ittet	eq
  2080ca:	6a83      	ldreq	r3, [r0, #40]	; 0x28
  bdip->blk_size = MMCSD_BLOCK_SIZE;

  return HAL_SUCCESS;
  2080cc:	2000      	moveq	r0, #0
    return HAL_FAILED;
  2080ce:	2001      	movne	r0, #1
  bdip->blk_num = sdcp->capacity;
  2080d0:	604b      	streq	r3, [r1, #4]
  bdip->blk_size = MMCSD_BLOCK_SIZE;
  2080d2:	bf04      	itt	eq
  2080d4:	f44f 7300 	moveq.w	r3, #512	; 0x200
  2080d8:	600b      	streq	r3, [r1, #0]
}
  2080da:	4770      	bx	lr

002080dc <sdcSync>:
  if (sdcp->state != BLK_READY) {
  2080dc:	7900      	ldrb	r0, [r0, #4]
}
  2080de:	3805      	subs	r0, #5
  2080e0:	bf18      	it	ne
  2080e2:	2001      	movne	r0, #1
  2080e4:	4770      	bx	lr

002080e6 <_mmcsd_get_slice>:
  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
  startoff = start % 32U;
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
  2080e6:	f001 031f 	and.w	r3, r1, #31
                          uint32_t start) {
  2080ea:	b570      	push	{r4, r5, r6, lr}
  startidx = start / 32U;
  2080ec:	0955      	lsrs	r5, r2, #5
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
  2080ee:	1c5c      	adds	r4, r3, #1
  2080f0:	2301      	movs	r3, #1
  endidx   = end / 32U;
  2080f2:	094e      	lsrs	r6, r1, #5

  /* One or two pieces?*/
  if (startidx < endidx) {
  2080f4:	ebb5 1f51 	cmp.w	r5, r1, lsr #5
  startoff = start % 32U;
  2080f8:	f002 021f 	and.w	r2, r2, #31
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
  2080fc:	fa03 f304 	lsl.w	r3, r3, r4
  208100:	f850 4025 	ldr.w	r4, [r0, r5, lsl #2]
    return (data[startidx] >> startoff) |               /* Two pieces case. */
           ((data[endidx] & endmask) << (32U - startoff));
  208104:	bf3c      	itt	cc
  208106:	f850 1026 	ldrcc.w	r1, [r0, r6, lsl #2]
  20810a:	f1c2 0020 	rsbcc	r0, r2, #32
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
  20810e:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
           ((data[endidx] & endmask) << (32U - startoff));
  208112:	bf37      	itett	cc
  208114:	400b      	andcc	r3, r1
  }
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
  208116:	ea03 0004 	andcs.w	r0, r3, r4
           ((data[endidx] & endmask) << (32U - startoff));
  20811a:	fa03 f100 	lslcc.w	r1, r3, r0
    return (data[startidx] >> startoff) |               /* Two pieces case. */
  20811e:	fa24 f002 	lsrcc.w	r0, r4, r2
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
  208122:	bf2c      	ite	cs
  208124:	40d0      	lsrcs	r0, r2
    return (data[startidx] >> startoff) |               /* Two pieces case. */
  208126:	4308      	orrcc	r0, r1
}
  208128:	bd70      	pop	{r4, r5, r6, pc}

0020812a <_mmcsd_get_capacity>:
 * @return              The card capacity.
 * @retval 0            CSD format error
 *
 * @notapi
 */
uint32_t _mmcsd_get_capacity(const uint32_t *csd) {
  20812a:	b570      	push	{r4, r5, r6, lr}
  uint32_t a, b, c;

  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
  20812c:	227e      	movs	r2, #126	; 0x7e
  20812e:	217f      	movs	r1, #127	; 0x7f
uint32_t _mmcsd_get_capacity(const uint32_t *csd) {
  208130:	4605      	mov	r5, r0
  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
  208132:	f7ff ffd8 	bl	2080e6 <_mmcsd_get_slice>
  208136:	b118      	cbz	r0, 208140 <_mmcsd_get_capacity+0x16>
  208138:	2801      	cmp	r0, #1
  20813a:	d019      	beq.n	208170 <_mmcsd_get_capacity+0x46>
  20813c:	2000      	movs	r0, #0
  default:
    /* Reserved value detected.*/
    break;
  }
  return 0U;
}
  20813e:	bd70      	pop	{r4, r5, r6, pc}
    a = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
  208140:	223e      	movs	r2, #62	; 0x3e
  208142:	2149      	movs	r1, #73	; 0x49
  208144:	4628      	mov	r0, r5
  208146:	f7ff ffce 	bl	2080e6 <_mmcsd_get_slice>
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
  20814a:	222f      	movs	r2, #47	; 0x2f
    a = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
  20814c:	4604      	mov	r4, r0
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
  20814e:	2131      	movs	r1, #49	; 0x31
  208150:	4628      	mov	r0, r5
  208152:	f7ff ffc8 	bl	2080e6 <_mmcsd_get_slice>
  208156:	4606      	mov	r6, r0
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
  208158:	3401      	adds	r4, #1
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
  20815a:	2250      	movs	r2, #80	; 0x50
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
  20815c:	3602      	adds	r6, #2
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
  20815e:	2153      	movs	r1, #83	; 0x53
  208160:	4628      	mov	r0, r5
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
  208162:	40b4      	lsls	r4, r6
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
  208164:	f7ff ffbf 	bl	2080e6 <_mmcsd_get_slice>
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
  208168:	3809      	subs	r0, #9
  20816a:	fa04 f000 	lsl.w	r0, r4, r0
  20816e:	e7e6      	b.n	20813e <_mmcsd_get_capacity+0x14>
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
  208170:	2230      	movs	r2, #48	; 0x30
  208172:	2145      	movs	r1, #69	; 0x45
  208174:	4628      	mov	r0, r5
  208176:	f7ff ffb6 	bl	2080e6 <_mmcsd_get_slice>
  20817a:	3001      	adds	r0, #1
  20817c:	0280      	lsls	r0, r0, #10
  20817e:	e7de      	b.n	20813e <_mmcsd_get_capacity+0x14>

00208180 <obqPostFullBufferS>:
  *((size_t *)obqp->bwrptr) = size;
  208180:	6903      	ldr	r3, [r0, #16]
  208182:	6019      	str	r1, [r3, #0]
  obqp->bcounter--;
  208184:	68c2      	ldr	r2, [r0, #12]
  208186:	3a01      	subs	r2, #1
  208188:	60c2      	str	r2, [r0, #12]
  obqp->bwrptr += obqp->bsize;
  20818a:	69c2      	ldr	r2, [r0, #28]
  20818c:	4413      	add	r3, r2
  if (obqp->bwrptr >= obqp->btop) {
  20818e:	6982      	ldr	r2, [r0, #24]
  208190:	4293      	cmp	r3, r2
  obqp->bwrptr += obqp->bsize;
  208192:	6103      	str	r3, [r0, #16]
    obqp->bwrptr = obqp->buffers;
  208194:	bf24      	itt	cs
  208196:	6a43      	ldrcs	r3, [r0, #36]	; 0x24
  208198:	6103      	strcs	r3, [r0, #16]
  obqp->ptr = NULL;
  20819a:	2300      	movs	r3, #0
  20819c:	6283      	str	r3, [r0, #40]	; 0x28
  if (obqp->notify != NULL) {
  20819e:	6b03      	ldr	r3, [r0, #48]	; 0x30
  2081a0:	b103      	cbz	r3, 2081a4 <obqPostFullBufferS+0x24>
    obqp->notify(obqp);
  2081a2:	4718      	bx	r3
}
  2081a4:	4770      	bx	lr

002081a6 <ibqReleaseEmptyBufferS>:
  ibqp->bcounter--;
  2081a6:	68c3      	ldr	r3, [r0, #12]
  ibqp->brdptr += ibqp->bsize;
  2081a8:	69c2      	ldr	r2, [r0, #28]
  ibqp->bcounter--;
  2081aa:	3b01      	subs	r3, #1
  2081ac:	60c3      	str	r3, [r0, #12]
  ibqp->brdptr += ibqp->bsize;
  2081ae:	6943      	ldr	r3, [r0, #20]
  2081b0:	4413      	add	r3, r2
  if (ibqp->brdptr >= ibqp->btop) {
  2081b2:	6982      	ldr	r2, [r0, #24]
  2081b4:	4293      	cmp	r3, r2
  ibqp->brdptr += ibqp->bsize;
  2081b6:	6143      	str	r3, [r0, #20]
    ibqp->brdptr = ibqp->buffers;
  2081b8:	bf24      	itt	cs
  2081ba:	6a43      	ldrcs	r3, [r0, #36]	; 0x24
  2081bc:	6143      	strcs	r3, [r0, #20]
  ibqp->ptr = NULL;
  2081be:	2300      	movs	r3, #0
  2081c0:	6283      	str	r3, [r0, #40]	; 0x28
  if (ibqp->notify != NULL) {
  2081c2:	6b03      	ldr	r3, [r0, #48]	; 0x30
  2081c4:	b103      	cbz	r3, 2081c8 <ibqReleaseEmptyBufferS+0x22>
    ibqp->notify(ibqp);
  2081c6:	4718      	bx	r3
}
  2081c8:	4770      	bx	lr
	...

002081cc <sdcConnect>:
bool sdcConnect(SDCDriver *sdcp) {
  2081cc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  sdcp->state = BLK_CONNECTING;
  2081d0:	2303      	movs	r3, #3
bool sdcConnect(SDCDriver *sdcp) {
  2081d2:	b085      	sub	sp, #20
  sdcp->sdmmc->CLKCR  = SDMMC_CLKDIV_LS;
  2081d4:	2276      	movs	r2, #118	; 0x76
  2081d6:	4604      	mov	r4, r0
  sdcp->state = BLK_CONNECTING;
  2081d8:	7103      	strb	r3, [r0, #4]
  2081da:	6d03      	ldr	r3, [r0, #80]	; 0x50
bool sdcConnect(SDCDriver *sdcp) {
  2081dc:	af02      	add	r7, sp, #8
  chThdSleep(delay);
  2081de:	2064      	movs	r0, #100	; 0x64
  2081e0:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->POWER |= SDMMC_POWER_PWRCTRL_0 | SDMMC_POWER_PWRCTRL_1;
  2081e2:	681a      	ldr	r2, [r3, #0]
  2081e4:	f042 0203 	orr.w	r2, r2, #3
  2081e8:	601a      	str	r2, [r3, #0]
  sdcp->sdmmc->CLKCR |= SDMMC_CLKCR_CLKEN;
  2081ea:	685a      	ldr	r2, [r3, #4]
  2081ec:	f442 7280 	orr.w	r2, r2, #256	; 0x100
  2081f0:	605a      	str	r2, [r3, #4]
  2081f2:	f7fd f91d 	bl	205430 <chThdSleep>
  sdcp->sdmmc->ARG = arg;
  2081f6:	6d23      	ldr	r3, [r4, #80]	; 0x50
  2081f8:	2200      	movs	r2, #0
  2081fa:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_CPSMEN;
  2081fc:	f44f 6280 	mov.w	r2, #1024	; 0x400
  208200:	60da      	str	r2, [r3, #12]
  while ((sdcp->sdmmc->STA & SDMMC_STA_CMDSENT) == 0)
  208202:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  208204:	0610      	lsls	r0, r2, #24
  208206:	d5fc      	bpl.n	208202 <sdcConnect+0x36>
  sdcp->sdmmc->ICR = SDMMC_ICR_CMDSENTC;
  208208:	2280      	movs	r2, #128	; 0x80
  if (!sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_IF_COND,
  20820a:	2108      	movs	r1, #8
  20820c:	4620      	mov	r0, r4
  20820e:	639a      	str	r2, [r3, #56]	; 0x38
  208210:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
  208214:	1d3b      	adds	r3, r7, #4
  208216:	f7ff f8a4 	bl	207362 <sdc_lld_send_cmd_short_crc>
  20821a:	4602      	mov	r2, r0
  20821c:	b9c0      	cbnz	r0, 208250 <sdcConnect+0x84>
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
  20821e:	2301      	movs	r3, #1
  208220:	6323      	str	r3, [r4, #48]	; 0x30
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
  208222:	687b      	ldr	r3, [r7, #4]
  208224:	f3c3 2303 	ubfx	r3, r3, #8, #4
  208228:	2b01      	cmp	r3, #1
  20822a:	d109      	bne.n	208240 <sdcConnect+0x74>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
  20822c:	1d3b      	adds	r3, r7, #4
  20822e:	2137      	movs	r1, #55	; 0x37
  208230:	4620      	mov	r0, r4
  208232:	f7ff f896 	bl	207362 <sdc_lld_send_cmd_short_crc>
  208236:	b918      	cbnz	r0, 208240 <sdcConnect+0x74>
        MMCSD_R1_ERROR(resp[0])) {
  208238:	4ba9      	ldr	r3, [pc, #676]	; (2084e0 <sdcConnect+0x314>)
  20823a:	687a      	ldr	r2, [r7, #4]
  20823c:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
  20823e:	b1a3      	cbz	r3, 20826a <sdcConnect+0x9e>
  sdcp->sdmmc->CLKCR = 0;
  208240:	6d23      	ldr	r3, [r4, #80]	; 0x50
  208242:	2200      	movs	r2, #0
  return HAL_FAILED;
  208244:	2501      	movs	r5, #1
  208246:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->POWER = 0;
  208248:	601a      	str	r2, [r3, #0]
  sdcp->state = BLK_ACTIVE;
  20824a:	2302      	movs	r3, #2
  20824c:	7123      	strb	r3, [r4, #4]
  return HAL_FAILED;
  20824e:	e180      	b.n	208552 <sdcConnect+0x386>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
  208250:	1d3b      	adds	r3, r7, #4
  208252:	2200      	movs	r2, #0
  208254:	2137      	movs	r1, #55	; 0x37
  208256:	4620      	mov	r0, r4
  208258:	f7ff f883 	bl	207362 <sdc_lld_send_cmd_short_crc>
  20825c:	b918      	cbnz	r0, 208266 <sdcConnect+0x9a>
        MMCSD_R1_ERROR(resp[0])) {
  20825e:	4ba0      	ldr	r3, [pc, #640]	; (2084e0 <sdcConnect+0x314>)
  208260:	687a      	ldr	r2, [r7, #4]
  208262:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
  208264:	b1db      	cbz	r3, 20829e <sdcConnect+0xd2>
      sdcp->cardmode = SDC_MODE_CARDTYPE_MMC;
  208266:	2302      	movs	r3, #2
  208268:	6323      	str	r3, [r4, #48]	; 0x30
  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_MMC) {
  20826a:	6b23      	ldr	r3, [r4, #48]	; 0x30
  20826c:	f003 030f 	and.w	r3, r3, #15
  208270:	2b02      	cmp	r3, #2
  208272:	f040 80dc 	bne.w	20842e <sdcConnect+0x262>
  208276:	2564      	movs	r5, #100	; 0x64
  sdcp->sdmmc->ARG = arg;
  208278:	4e9a      	ldr	r6, [pc, #616]	; (2084e4 <sdcConnect+0x318>)
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
  20827a:	f240 4841 	movw	r8, #1089	; 0x441
  sdcp->sdmmc->ARG = arg;
  20827e:	6d23      	ldr	r3, [r4, #80]	; 0x50
  208280:	609e      	str	r6, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
  208282:	f8c3 800c 	str.w	r8, [r3, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
  208286:	6b59      	ldr	r1, [r3, #52]	; 0x34
  208288:	f011 0245 	ands.w	r2, r1, #69	; 0x45
  20828c:	d0fb      	beq.n	208286 <sdcConnect+0xba>
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
  20828e:	639a      	str	r2, [r3, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT)) != 0) {
  208290:	074a      	lsls	r2, r1, #29
  208292:	d510      	bpl.n	2082b6 <sdcConnect+0xea>
    sdc_lld_collect_errors(sdcp, sta);
  208294:	f104 0034 	add.w	r0, r4, #52	; 0x34
  208298:	f7ff f82c 	bl	2072f4 <sdc_lld_collect_errors.isra.0.lto_priv.0>
    return HAL_FAILED;
  20829c:	e7d0      	b.n	208240 <sdcConnect+0x74>
  sdcp->sdmmc->ARG = arg;
  20829e:	6d22      	ldr	r2, [r4, #80]	; 0x50
      sdcp->cardmode = SDC_MODE_CARDTYPE_SDV11;
  2082a0:	6323      	str	r3, [r4, #48]	; 0x30
  2082a2:	6093      	str	r3, [r2, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_CPSMEN;
  2082a4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  2082a8:	60d3      	str	r3, [r2, #12]
  while ((sdcp->sdmmc->STA & SDMMC_STA_CMDSENT) == 0)
  2082aa:	6b53      	ldr	r3, [r2, #52]	; 0x34
  2082ac:	0619      	lsls	r1, r3, #24
  2082ae:	d5fc      	bpl.n	2082aa <sdcConnect+0xde>
  sdcp->sdmmc->ICR = SDMMC_ICR_CMDSENTC;
  2082b0:	2380      	movs	r3, #128	; 0x80
  2082b2:	6393      	str	r3, [r2, #56]	; 0x38
  2082b4:	e7d9      	b.n	20826a <sdcConnect+0x9e>
  *resp = sdcp->sdmmc->RESP1;
  2082b6:	695b      	ldr	r3, [r3, #20]
    if ((resp[0] & 0x80000000U) != 0U) {
  2082b8:	2b00      	cmp	r3, #0
  2082ba:	f280 80b1 	bge.w	208420 <sdcConnect+0x254>
      if ((resp[0] & 0x40000000U) != 0U) {
  2082be:	005a      	lsls	r2, r3, #1
  2082c0:	d503      	bpl.n	2082ca <sdcConnect+0xfe>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
  2082c2:	6b23      	ldr	r3, [r4, #48]	; 0x30
  2082c4:	f043 0310 	orr.w	r3, r3, #16
  2082c8:	6323      	str	r3, [r4, #48]	; 0x30
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_ALL_SEND_CID, 0, sdcp->cid)) {
  2082ca:	2200      	movs	r2, #0
  2082cc:	f104 0308 	add.w	r3, r4, #8
  2082d0:	2102      	movs	r1, #2
  2082d2:	4620      	mov	r0, r4
  2082d4:	f7ff f828 	bl	207328 <sdc_lld_send_cmd_long_crc>
  2082d8:	4602      	mov	r2, r0
  2082da:	2800      	cmp	r0, #0
  2082dc:	d1b0      	bne.n	208240 <sdcConnect+0x74>
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_RELATIVE_ADDR,
  2082de:	f104 0338 	add.w	r3, r4, #56	; 0x38
  2082e2:	2103      	movs	r1, #3
  2082e4:	4620      	mov	r0, r4
  2082e6:	f7ff f83c 	bl	207362 <sdc_lld_send_cmd_short_crc>
  2082ea:	2800      	cmp	r0, #0
  2082ec:	d1a8      	bne.n	208240 <sdcConnect+0x74>
                                sdcp->rca, sdcp->csd)) {
  2082ee:	f104 0518 	add.w	r5, r4, #24
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
  2082f2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  2082f4:	2109      	movs	r1, #9
  2082f6:	4620      	mov	r0, r4
  2082f8:	462b      	mov	r3, r5
  2082fa:	f7ff f815 	bl	207328 <sdc_lld_send_cmd_long_crc>
  2082fe:	2800      	cmp	r0, #0
  208300:	d19e      	bne.n	208240 <sdcConnect+0x74>
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEL_DESEL_CARD,
  208302:	463b      	mov	r3, r7
  208304:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  208306:	2107      	movs	r1, #7
  208308:	4620      	mov	r0, r4
  20830a:	f7ff f82a 	bl	207362 <sdc_lld_send_cmd_short_crc>
  20830e:	4680      	mov	r8, r0
  208310:	2800      	cmp	r0, #0
  208312:	d195      	bne.n	208240 <sdcConnect+0x74>
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
  208314:	6b23      	ldr	r3, [r4, #48]	; 0x30
  208316:	f003 030f 	and.w	r3, r3, #15
  20831a:	2b02      	cmp	r3, #2
  20831c:	f040 80b6 	bne.w	20848c <sdcConnect+0x2c0>
  uint8_t *scratchpad = sdcp->config->scratchpad;
  208320:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  if (NULL == scratchpad) {
  208322:	681b      	ldr	r3, [r3, #0]
  208324:	b12b      	cbz	r3, 208332 <sdcConnect+0x166>
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
  208326:	1d3b      	adds	r3, r7, #4
  208328:	4a6f      	ldr	r2, [pc, #444]	; (2084e8 <sdcConnect+0x31c>)
  20832a:	2106      	movs	r1, #6
  20832c:	4620      	mov	r0, r4
  20832e:	f7ff f818 	bl	207362 <sdc_lld_send_cmd_short_crc>
  sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) | SDMMC_CLKDIV_HS |
  208332:	6d22      	ldr	r2, [r4, #80]	; 0x50
  208334:	6853      	ldr	r3, [r2, #4]
  208336:	f423 733f 	bic.w	r3, r3, #764	; 0x2fc
  20833a:	f023 0303 	bic.w	r3, r3, #3
  20833e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  208342:	6053      	str	r3, [r2, #4]
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
  208344:	6b23      	ldr	r3, [r4, #48]	; 0x30
  208346:	f003 030f 	and.w	r3, r3, #15
  20834a:	2b02      	cmp	r3, #2
  20834c:	f040 80c3 	bne.w	2084d6 <sdcConnect+0x30a>
    if (_mmcsd_get_slice(sdcp->csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE) > 1U) {
  208350:	227e      	movs	r2, #126	; 0x7e
  208352:	217f      	movs	r1, #127	; 0x7f
  208354:	4628      	mov	r0, r5
  208356:	f7ff fec6 	bl	2080e6 <_mmcsd_get_slice>
  20835a:	2801      	cmp	r0, #1
  20835c:	f240 80bb 	bls.w	2084d6 <sdcConnect+0x30a>
      uint8_t *ext_csd = sdcp->config->scratchpad;
  208360:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  208362:	681d      	ldr	r5, [r3, #0]
      if (NULL == ext_csd) {
  208364:	2d00      	cmp	r5, #0
  208366:	f43f af6b 	beq.w	208240 <sdcConnect+0x74>
      if(sdc_lld_read_special(sdcp, ext_csd, 512, MMCSD_CMD_SEND_EXT_CSD, 0)) {
  20836a:	2300      	movs	r3, #0
  20836c:	f44f 7200 	mov.w	r2, #512	; 0x200
  208370:	4629      	mov	r1, r5
  208372:	4620      	mov	r0, r4
  208374:	9300      	str	r3, [sp, #0]
  208376:	2308      	movs	r3, #8
  208378:	f7ff f8fe 	bl	207578 <sdc_lld_read_special>
  20837c:	2800      	cmp	r0, #0
  20837e:	f47f af5f 	bne.w	208240 <sdcConnect+0x74>
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
         ((uint32_t)ext_csd[214] << 16U) +
  208382:	f895 30d6 	ldrb.w	r3, [r5, #214]	; 0xd6
  return ((uint32_t)ext_csd[215] << 24U) +
  208386:	f895 20d7 	ldrb.w	r2, [r5, #215]	; 0xd7
         ((uint32_t)ext_csd[214] << 16U) +
  20838a:	041b      	lsls	r3, r3, #16
  return ((uint32_t)ext_csd[215] << 24U) +
  20838c:	eb03 6302 	add.w	r3, r3, r2, lsl #24
         ((uint32_t)ext_csd[213] << 8U)  +
         (uint32_t)ext_csd[212];
  208390:	f895 20d4 	ldrb.w	r2, [r5, #212]	; 0xd4
         ((uint32_t)ext_csd[213] << 8U)  +
  208394:	4413      	add	r3, r2
  208396:	f895 20d5 	ldrb.w	r2, [r5, #213]	; 0xd5
  20839a:	eb03 2302 	add.w	r3, r3, r2, lsl #8
      sdcp->capacity = _mmcsd_get_capacity_ext(ext_csd);
  20839e:	62a3      	str	r3, [r4, #40]	; 0x28
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BLOCKLEN,
  2083a0:	463b      	mov	r3, r7
  2083a2:	f44f 7200 	mov.w	r2, #512	; 0x200
  2083a6:	2110      	movs	r1, #16
  2083a8:	4620      	mov	r0, r4
  2083aa:	f7fe ffda 	bl	207362 <sdc_lld_send_cmd_short_crc>
  2083ae:	4605      	mov	r5, r0
  2083b0:	2800      	cmp	r0, #0
  2083b2:	f47f af45 	bne.w	208240 <sdcConnect+0x74>
      MMCSD_R1_ERROR(resp[0])) {
  2083b6:	f8df 8128 	ldr.w	r8, [pc, #296]	; 2084e0 <sdcConnect+0x314>
                                 MMCSD_BLOCK_SIZE, resp) ||
  2083ba:	683b      	ldr	r3, [r7, #0]
  2083bc:	4646      	mov	r6, r8
  2083be:	ea13 0f08 	tst.w	r3, r8
  2083c2:	f47f af3d 	bne.w	208240 <sdcConnect+0x74>
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
  2083c6:	6b23      	ldr	r3, [r4, #48]	; 0x30
  2083c8:	f013 0f0e 	tst.w	r3, #14
  2083cc:	f003 020f 	and.w	r2, r3, #15
  2083d0:	f000 8094 	beq.w	2084fc <sdcConnect+0x330>
  2083d4:	2a02      	cmp	r2, #2
  2083d6:	f47f af33 	bne.w	208240 <sdcConnect+0x74>
  switch (sdcp->config->bus_width) {
  2083da:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  2083dc:	7919      	ldrb	r1, [r3, #4]
  2083de:	2901      	cmp	r1, #1
  2083e0:	f000 80bc 	beq.w	20855c <sdcConnect+0x390>
  2083e4:	2902      	cmp	r1, #2
  2083e6:	f000 80bb 	beq.w	208560 <sdcConnect+0x394>
  2083ea:	2900      	cmp	r1, #0
  2083ec:	f000 80af 	beq.w	20854e <sdcConnect+0x382>
  2083f0:	4a3e      	ldr	r2, [pc, #248]	; (2084ec <sdcConnect+0x320>)
  uint32_t clk = sdcp->sdmmc->CLKCR & ~SDMMC_CLKCR_WIDBUS;
  2083f2:	6d20      	ldr	r0, [r4, #80]	; 0x50
  switch (mode) {
  2083f4:	2901      	cmp	r1, #1
  uint32_t clk = sdcp->sdmmc->CLKCR & ~SDMMC_CLKCR_WIDBUS;
  2083f6:	6843      	ldr	r3, [r0, #4]
  2083f8:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
  switch (mode) {
  2083fc:	f000 80b2 	beq.w	208564 <sdcConnect+0x398>
  208400:	2902      	cmp	r1, #2
  208402:	f000 80b2 	beq.w	20856a <sdcConnect+0x39e>
  208406:	b901      	cbnz	r1, 20840a <sdcConnect+0x23e>
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_1;
  208408:	6043      	str	r3, [r0, #4]
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
  20840a:	1d3b      	adds	r3, r7, #4
  20840c:	2106      	movs	r1, #6
  20840e:	4620      	mov	r0, r4
  208410:	f7fe ffa7 	bl	207362 <sdc_lld_send_cmd_short_crc>
  208414:	2800      	cmp	r0, #0
  208416:	f47f af13 	bne.w	208240 <sdcConnect+0x74>
  20841a:	687b      	ldr	r3, [r7, #4]
  20841c:	4233      	tst	r3, r6
  20841e:	e094      	b.n	20854a <sdcConnect+0x37e>
    if (++i >= (unsigned)SDC_INIT_RETRY) {
  208420:	3d01      	subs	r5, #1
  208422:	f43f af0d 	beq.w	208240 <sdcConnect+0x74>
  208426:	2064      	movs	r0, #100	; 0x64
  208428:	f7fd f802 	bl	205430 <chThdSleep>
  20842c:	e727      	b.n	20827e <sdcConnect+0xb2>
    ocr = SDC_INIT_OCR;
  20842e:	4d30      	ldr	r5, [pc, #192]	; (2084f0 <sdcConnect+0x324>)
  208430:	2664      	movs	r6, #100	; 0x64
  208432:	4a30      	ldr	r2, [pc, #192]	; (2084f4 <sdcConnect+0x328>)
        MMCSD_R1_ERROR(resp[0])) {
  208434:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 2084e0 <sdcConnect+0x314>
    ocr = SDC_INIT_OCR;
  208438:	2b01      	cmp	r3, #1
  20843a:	bf18      	it	ne
  20843c:	4615      	movne	r5, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
  20843e:	1d3b      	adds	r3, r7, #4
  208440:	2200      	movs	r2, #0
  208442:	2137      	movs	r1, #55	; 0x37
  208444:	4620      	mov	r0, r4
  208446:	f7fe ff8c 	bl	207362 <sdc_lld_send_cmd_short_crc>
  20844a:	2800      	cmp	r0, #0
  20844c:	f47f aef8 	bne.w	208240 <sdcConnect+0x74>
  208450:	687a      	ldr	r2, [r7, #4]
  208452:	6d23      	ldr	r3, [r4, #80]	; 0x50
  208454:	ea12 0f08 	tst.w	r2, r8
  208458:	f47f aef2 	bne.w	208240 <sdcConnect+0x74>
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
  20845c:	f240 4269 	movw	r2, #1129	; 0x469
  sdcp->sdmmc->ARG = arg;
  208460:	609d      	str	r5, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
  208462:	60da      	str	r2, [r3, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
  208464:	6b59      	ldr	r1, [r3, #52]	; 0x34
  208466:	f011 0245 	ands.w	r2, r1, #69	; 0x45
  20846a:	d0fb      	beq.n	208464 <sdcConnect+0x298>
  if ((sta & (SDMMC_STA_CTIMEOUT)) != 0) {
  20846c:	0748      	lsls	r0, r1, #29
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
  20846e:	639a      	str	r2, [r3, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT)) != 0) {
  208470:	f53f af10 	bmi.w	208294 <sdcConnect+0xc8>
  *resp = sdcp->sdmmc->RESP1;
  208474:	695b      	ldr	r3, [r3, #20]
    if ((resp[0] & 0x80000000U) != 0U) {
  208476:	2b00      	cmp	r3, #0
  208478:	607b      	str	r3, [r7, #4]
  20847a:	f6ff af20 	blt.w	2082be <sdcConnect+0xf2>
    if (++i >= (unsigned)SDC_INIT_RETRY) {
  20847e:	3e01      	subs	r6, #1
  208480:	f43f aede 	beq.w	208240 <sdcConnect+0x74>
  208484:	2064      	movs	r0, #100	; 0x64
  208486:	f7fc ffd3 	bl	205430 <chThdSleep>
  20848a:	e7d8      	b.n	20843e <sdcConnect+0x272>
static bool sdc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
  20848c:	466e      	mov	r6, sp
  uint8_t tmp[N];
  20848e:	b090      	sub	sp, #64	; 0x40
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
  208490:	227e      	movs	r2, #126	; 0x7e
  208492:	217f      	movs	r1, #127	; 0x7f
  208494:	4628      	mov	r0, r5
  uint8_t tmp[N];
  208496:	f10d 0908 	add.w	r9, sp, #8
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
  20849a:	f7ff fe24 	bl	2080e6 <_mmcsd_get_slice>
  20849e:	b908      	cbnz	r0, 2084a4 <sdcConnect+0x2d8>
  2084a0:	46b5      	mov	sp, r6
  2084a2:	e746      	b.n	208332 <sdcConnect+0x166>
  if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, 0)) {
  2084a4:	2306      	movs	r3, #6
  2084a6:	2240      	movs	r2, #64	; 0x40
  2084a8:	4649      	mov	r1, r9
  2084aa:	4620      	mov	r0, r4
  2084ac:	f8cd 8000 	str.w	r8, [sp]
  2084b0:	f7ff f862 	bl	207578 <sdc_lld_read_special>
  2084b4:	b968      	cbnz	r0, 2084d2 <sdcConnect+0x306>
  return ((uint16_t)buf[start] << 8U) | (uint16_t)buf[start + 1U];
  2084b6:	f899 300d 	ldrb.w	r3, [r9, #13]
  if ((sdc_cmd6_extract_info(SD_SWITCH_FUNCTION_SPEED, tmp) & 2U) == 2U) {
  2084ba:	079b      	lsls	r3, r3, #30
  2084bc:	d5f0      	bpl.n	2084a0 <sdcConnect+0x2d4>
    if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, cmdarg)) {
  2084be:	4b0e      	ldr	r3, [pc, #56]	; (2084f8 <sdcConnect+0x32c>)
  2084c0:	2240      	movs	r2, #64	; 0x40
  2084c2:	4649      	mov	r1, r9
  2084c4:	4620      	mov	r0, r4
  2084c6:	9300      	str	r3, [sp, #0]
  2084c8:	2306      	movs	r3, #6
  2084ca:	f7ff f855 	bl	207578 <sdc_lld_read_special>
  2084ce:	2800      	cmp	r0, #0
  2084d0:	d0e6      	beq.n	2084a0 <sdcConnect+0x2d4>
  2084d2:	46b5      	mov	sp, r6
  2084d4:	e6b4      	b.n	208240 <sdcConnect+0x74>
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
  2084d6:	4628      	mov	r0, r5
  2084d8:	f7ff fe27 	bl	20812a <_mmcsd_get_capacity>
  2084dc:	62a0      	str	r0, [r4, #40]	; 0x28
  2084de:	e75f      	b.n	2083a0 <sdcConnect+0x1d4>
  2084e0:	fdffe008 	.word	0xfdffe008
  2084e4:	c0ff8000 	.word	0xc0ff8000
  2084e8:	03b90100 	.word	0x03b90100
  2084ec:	03b70000 	.word	0x03b70000
  2084f0:	50ff8000 	.word	0x50ff8000
  2084f4:	80100000 	.word	0x80100000
  2084f8:	80fffff1 	.word	0x80fffff1
  if (SDC_MODE_1BIT == sdcp->config->bus_width) {
  2084fc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  2084fe:	791b      	ldrb	r3, [r3, #4]
  208500:	b32b      	cbz	r3, 20854e <sdcConnect+0x382>
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
  208502:	2b01      	cmp	r3, #1
  208504:	f47f ae9c 	bne.w	208240 <sdcConnect+0x74>
  208508:	6d22      	ldr	r2, [r4, #80]	; 0x50
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
  20850a:	2137      	movs	r1, #55	; 0x37
  20850c:	4620      	mov	r0, r4
  uint32_t clk = sdcp->sdmmc->CLKCR & ~SDMMC_CLKCR_WIDBUS;
  20850e:	6853      	ldr	r3, [r2, #4]
  208510:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_0;
  208514:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  208518:	6053      	str	r3, [r2, #4]
  20851a:	1d3b      	adds	r3, r7, #4
  20851c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  20851e:	f7fe ff20 	bl	207362 <sdc_lld_send_cmd_short_crc>
  208522:	2800      	cmp	r0, #0
  208524:	f47f ae8c 	bne.w	208240 <sdcConnect+0x74>
  208528:	687b      	ldr	r3, [r7, #4]
  20852a:	ea13 0f08 	tst.w	r3, r8
  20852e:	f47f ae87 	bne.w	208240 <sdcConnect+0x74>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
  208532:	1d3b      	adds	r3, r7, #4
  208534:	2202      	movs	r2, #2
  208536:	2106      	movs	r1, #6
  208538:	4620      	mov	r0, r4
  20853a:	f7fe ff12 	bl	207362 <sdc_lld_send_cmd_short_crc>
  20853e:	2800      	cmp	r0, #0
  208540:	f47f ae7e 	bne.w	208240 <sdcConnect+0x74>
  208544:	687b      	ldr	r3, [r7, #4]
  208546:	ea13 0f08 	tst.w	r3, r8
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
  20854a:	f47f ae79 	bne.w	208240 <sdcConnect+0x74>
  sdcp->state = BLK_READY;
  20854e:	2305      	movs	r3, #5
  208550:	7123      	strb	r3, [r4, #4]
}
  208552:	4628      	mov	r0, r5
  208554:	370c      	adds	r7, #12
  208556:	46bd      	mov	sp, r7
  208558:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 1, 0);
  20855c:	4a04      	ldr	r2, [pc, #16]	; (208570 <sdcConnect+0x3a4>)
  20855e:	e748      	b.n	2083f2 <sdcConnect+0x226>
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 2, 0);
  208560:	4a04      	ldr	r2, [pc, #16]	; (208574 <sdcConnect+0x3a8>)
  208562:	e746      	b.n	2083f2 <sdcConnect+0x226>
  208564:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  208568:	e74e      	b.n	208408 <sdcConnect+0x23c>
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_1;
  20856a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  20856e:	e74b      	b.n	208408 <sdcConnect+0x23c>
  208570:	03b70100 	.word	0x03b70100
  208574:	03b70200 	.word	0x03b70200

00208578 <obqGetEmptyBufferTimeoutS>:
                                sysinterval_t timeout) {
  208578:	b538      	push	{r3, r4, r5, lr}
  20857a:	4604      	mov	r4, r0
  20857c:	460d      	mov	r5, r1
  while (obqIsFullI(obqp)) {
  20857e:	68e3      	ldr	r3, [r4, #12]
  208580:	b13b      	cbz	r3, 208592 <obqGetEmptyBufferTimeoutS+0x1a>
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
  208582:	6923      	ldr	r3, [r4, #16]
  obqp->top = obqp->bwrptr + obqp->bsize;
  208584:	2000      	movs	r0, #0
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
  208586:	1d1a      	adds	r2, r3, #4
  208588:	62a2      	str	r2, [r4, #40]	; 0x28
  obqp->top = obqp->bwrptr + obqp->bsize;
  20858a:	69e2      	ldr	r2, [r4, #28]
  20858c:	4413      	add	r3, r2
  20858e:	62e3      	str	r3, [r4, #44]	; 0x2c
  return MSG_OK;
  208590:	e007      	b.n	2085a2 <obqGetEmptyBufferTimeoutS+0x2a>
    if (obqp->suspended) {
  208592:	7a23      	ldrb	r3, [r4, #8]
  208594:	b933      	cbnz	r3, 2085a4 <obqGetEmptyBufferTimeoutS+0x2c>
  return chThdEnqueueTimeoutS(tqp, timeout);
  208596:	4629      	mov	r1, r5
  208598:	4620      	mov	r0, r4
  20859a:	f7fc ff39 	bl	205410 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
  20859e:	2800      	cmp	r0, #0
  2085a0:	daed      	bge.n	20857e <obqGetEmptyBufferTimeoutS+0x6>
}
  2085a2:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
  2085a4:	f06f 0001 	mvn.w	r0, #1
  2085a8:	e7fb      	b.n	2085a2 <obqGetEmptyBufferTimeoutS+0x2a>

002085aa <ibqGetFullBufferTimeoutS>:
                                 sysinterval_t timeout) {
  2085aa:	b538      	push	{r3, r4, r5, lr}
  2085ac:	4604      	mov	r4, r0
  2085ae:	460d      	mov	r5, r1
  while (ibqIsEmptyI(ibqp)) {
  2085b0:	68e3      	ldr	r3, [r4, #12]
  2085b2:	b13b      	cbz	r3, 2085c4 <ibqGetFullBufferTimeoutS+0x1a>
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
  2085b4:	6962      	ldr	r2, [r4, #20]
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
  2085b6:	2000      	movs	r0, #0
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
  2085b8:	1d13      	adds	r3, r2, #4
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
  2085ba:	6812      	ldr	r2, [r2, #0]
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
  2085bc:	62a3      	str	r3, [r4, #40]	; 0x28
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
  2085be:	4413      	add	r3, r2
  2085c0:	62e3      	str	r3, [r4, #44]	; 0x2c
  return MSG_OK;
  2085c2:	e007      	b.n	2085d4 <ibqGetFullBufferTimeoutS+0x2a>
    if (ibqp->suspended) {
  2085c4:	7a23      	ldrb	r3, [r4, #8]
  2085c6:	b933      	cbnz	r3, 2085d6 <ibqGetFullBufferTimeoutS+0x2c>
  2085c8:	4629      	mov	r1, r5
  2085ca:	4620      	mov	r0, r4
  2085cc:	f7fc ff20 	bl	205410 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
  2085d0:	2800      	cmp	r0, #0
  2085d2:	daed      	bge.n	2085b0 <ibqGetFullBufferTimeoutS+0x6>
}
  2085d4:	bd38      	pop	{r3, r4, r5, pc}
      return MSG_RESET;
  2085d6:	f06f 0001 	mvn.w	r0, #1
  2085da:	e7fb      	b.n	2085d4 <ibqGetFullBufferTimeoutS+0x2a>

002085dc <usbStartTransmitI>:
                       const uint8_t *buf, size_t n) {
  2085dc:	b4f0      	push	{r4, r5, r6, r7}
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  2085de:	2501      	movs	r5, #1
  isp = usbp->epc[ep]->in_state;
  2085e0:	eb00 0481 	add.w	r4, r0, r1, lsl #2
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  2085e4:	8907      	ldrh	r7, [r0, #8]
  2085e6:	408d      	lsls	r5, r1
  isp = usbp->epc[ep]->in_state;
  2085e8:	68e4      	ldr	r4, [r4, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  2085ea:	433d      	orrs	r5, r7
  isp = usbp->epc[ep]->in_state;
  2085ec:	6964      	ldr	r4, [r4, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  2085ee:	8105      	strh	r5, [r0, #8]
  isp->txsize = n;
  2085f0:	6023      	str	r3, [r4, #0]
  isp->txcnt  = 0;
  2085f2:	2300      	movs	r3, #0
  isp->txbuf  = buf;
  2085f4:	60a2      	str	r2, [r4, #8]
  isp->txcnt  = 0;
  2085f6:	6063      	str	r3, [r4, #4]
}
  2085f8:	bcf0      	pop	{r4, r5, r6, r7}
  usb_lld_start_in(usbp, ep);
  2085fa:	f7ff b825 	b.w	207648 <usb_lld_start_in>

002085fe <usbStartReceiveI>:
                      uint8_t *buf, size_t n) {
  2085fe:	b4f0      	push	{r4, r5, r6, r7}
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  208600:	2501      	movs	r5, #1
  osp = usbp->epc[ep]->out_state;
  208602:	eb00 0481 	add.w	r4, r0, r1, lsl #2
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  208606:	8947      	ldrh	r7, [r0, #10]
  208608:	408d      	lsls	r5, r1
  osp = usbp->epc[ep]->out_state;
  20860a:	68e4      	ldr	r4, [r4, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  20860c:	433d      	orrs	r5, r7
  osp = usbp->epc[ep]->out_state;
  20860e:	69a4      	ldr	r4, [r4, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  208610:	8145      	strh	r5, [r0, #10]
  osp->rxsize = n;
  208612:	6023      	str	r3, [r4, #0]
  osp->rxcnt  = 0;
  208614:	2300      	movs	r3, #0
  osp->rxbuf  = buf;
  208616:	60a2      	str	r2, [r4, #8]
  osp->rxcnt  = 0;
  208618:	6063      	str	r3, [r4, #4]
}
  20861a:	bcf0      	pop	{r4, r5, r6, r7}
  usb_lld_start_out(usbp, ep);
  20861c:	f7ff b89a 	b.w	207754 <usb_lld_start_out>

00208620 <usbInitEndpointI>:
                      const USBEndpointConfig *epcp) {
  208620:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  208624:	eb00 0981 	add.w	r9, r0, r1, lsl #2
  208628:	4607      	mov	r7, r0
  if (epcp->in_state != NULL) {
  20862a:	6950      	ldr	r0, [r2, #20]
                      const USBEndpointConfig *epcp) {
  20862c:	460c      	mov	r4, r1
  20862e:	4615      	mov	r5, r2
  208630:	fa0f fa81 	sxth.w	sl, r1
  usbp->epc[ep] = epcp;
  208634:	f8c9 200c 	str.w	r2, [r9, #12]
  if (epcp->in_state != NULL) {
  208638:	b118      	cbz	r0, 208642 <usbInitEndpointI+0x22>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
  20863a:	2210      	movs	r2, #16
  20863c:	2100      	movs	r1, #0
  20863e:	f003 fe18 	bl	20c272 <memset>
  if (epcp->out_state != NULL) {
  208642:	69a8      	ldr	r0, [r5, #24]
  208644:	b118      	cbz	r0, 20864e <usbInitEndpointI+0x2e>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
  208646:	2210      	movs	r2, #16
  208648:	2100      	movs	r1, #0
  20864a:	f003 fe12 	bl	20c272 <memset>
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
  20864e:	f8d9 200c 	ldr.w	r2, [r9, #12]
  otgp->oe[ep].DOEPTSIZ = 0;
  208652:	2100      	movs	r1, #0
  stm32_otg_t *otgp = usbp->otg;
  208654:	6efd      	ldr	r5, [r7, #108]	; 0x6c
  otgp->oe[ep].DOEPTSIZ = 0;
  208656:	0160      	lsls	r0, r4, #5
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
  208658:	6816      	ldr	r6, [r2, #0]
  20865a:	f006 0603 	and.w	r6, r6, #3
  20865e:	1e73      	subs	r3, r6, #1
  208660:	2b02      	cmp	r3, #2
  otgp->oe[ep].DOEPTSIZ = 0;
  208662:	eb05 1344 	add.w	r3, r5, r4, lsl #5
  208666:	bf98      	it	ls
  208668:	04b6      	lslls	r6, r6, #18
  20866a:	f8c3 1b10 	str.w	r1, [r3, #2832]	; 0xb10
  20866e:	f104 0310 	add.w	r3, r4, #16
  208672:	f04f 0101 	mov.w	r1, #1
  208676:	bf94      	ite	ls
  208678:	f106 5680 	addls.w	r6, r6, #268435456	; 0x10000000
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
  20867c:	4e35      	ldrhi	r6, [pc, #212]	; (208754 <usbInitEndpointI+0x134>)
  20867e:	fa01 f103 	lsl.w	r1, r1, r3
  if (usbp->epc[ep]->out_state != NULL) {
  208682:	6993      	ldr	r3, [r2, #24]
  208684:	bf98      	it	ls
  208686:	f506 4600 	addls.w	r6, r6, #32768	; 0x8000
  20868a:	2b00      	cmp	r3, #0
  20868c:	d03d      	beq.n	20870a <usbInitEndpointI+0xea>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
  20868e:	f8b2 c012 	ldrh.w	ip, [r2, #18]
  208692:	f104 0358 	add.w	r3, r4, #88	; 0x58
  208696:	ea4c 0c06 	orr.w	ip, ip, r6
  20869a:	015b      	lsls	r3, r3, #5
  20869c:	f845 c003 	str.w	ip, [r5, r3]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  2086a0:	f8d5 381c 	ldr.w	r3, [r5, #2076]	; 0x81c
  2086a4:	4319      	orrs	r1, r3
  otgp->ie[ep].DIEPTSIZ = 0;
  2086a6:	182b      	adds	r3, r5, r0
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  2086a8:	f8c5 181c 	str.w	r1, [r5, #2076]	; 0x81c
  otgp->ie[ep].DIEPTSIZ = 0;
  2086ac:	2100      	movs	r1, #0
  2086ae:	f04f 0801 	mov.w	r8, #1
  2086b2:	f8c3 1910 	str.w	r1, [r3, #2320]	; 0x910
  if (usbp->epc[ep]->in_state != NULL) {
  2086b6:	fa08 f804 	lsl.w	r8, r8, r4
  2086ba:	6953      	ldr	r3, [r2, #20]
  2086bc:	1e61      	subs	r1, r4, #1
  2086be:	b38b      	cbz	r3, 208724 <usbInitEndpointI+0x104>
    fsize = usbp->epc[ep]->in_maxsize / 4;
  2086c0:	8a13      	ldrh	r3, [r2, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
  2086c2:	8b92      	ldrh	r2, [r2, #28]
    fsize = usbp->epc[ep]->in_maxsize / 4;
  2086c4:	089b      	lsrs	r3, r3, #2
    if (usbp->epc[ep]->in_multiplier > 1)
  2086c6:	2a01      	cmp	r2, #1
      fsize *= usbp->epc[ep]->in_multiplier;
  2086c8:	bf88      	it	hi
  2086ca:	4353      	mulhi	r3, r2
  next = usbp->pmnext;
  2086cc:	6f7a      	ldr	r2, [r7, #116]	; 0x74
  usbp->pmnext += size;
  2086ce:	1898      	adds	r0, r3, r2
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
  2086d0:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
  2086d4:	f101 0240 	add.w	r2, r1, #64	; 0x40
    otg_txfifo_flush(usbp, ep);
  2086d8:	4621      	mov	r1, r4
  usbp->pmnext += size;
  2086da:	6778      	str	r0, [r7, #116]	; 0x74
    otg_txfifo_flush(usbp, ep);
  2086dc:	4628      	mov	r0, r5
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
  2086de:	eb05 0282 	add.w	r2, r5, r2, lsl #2
  2086e2:	6053      	str	r3, [r2, #4]
    otg_txfifo_flush(usbp, ep);
  2086e4:	f7fe ffa6 	bl	207634 <otg_txfifo_flush.isra.0.lto_priv.0>
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
  2086e8:	f8d9 300c 	ldr.w	r3, [r9, #12]
  2086ec:	8a1b      	ldrh	r3, [r3, #16]
                           DIEPCTL_TXFNUM(ep) |
  2086ee:	ea43 5384 	orr.w	r3, r3, r4, lsl #22
    otgp->ie[ep].DIEPCTL = ctl |
  2086f2:	3448      	adds	r4, #72	; 0x48
                           DIEPCTL_TXFNUM(ep) |
  2086f4:	431e      	orrs	r6, r3
    otgp->ie[ep].DIEPCTL = ctl |
  2086f6:	0164      	lsls	r4, r4, #5
  2086f8:	512e      	str	r6, [r5, r4]
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  2086fa:	f8d5 381c 	ldr.w	r3, [r5, #2076]	; 0x81c
  2086fe:	ea43 0308 	orr.w	r3, r3, r8
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
  208702:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
}
  208706:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
  20870a:	eb05 1c4a 	add.w	ip, r5, sl, lsl #5
  20870e:	f8dc 3b00 	ldr.w	r3, [ip, #2816]	; 0xb00
  208712:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  208716:	f8cc 3b00 	str.w	r3, [ip, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  20871a:	f8d5 381c 	ldr.w	r3, [r5, #2076]	; 0x81c
  20871e:	ea23 0101 	bic.w	r1, r3, r1
  208722:	e7c0      	b.n	2086a6 <usbInitEndpointI+0x86>
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
  208724:	f104 033f 	add.w	r3, r4, #63	; 0x3f
  208728:	4a0b      	ldr	r2, [pc, #44]	; (208758 <usbInitEndpointI+0x138>)
  20872a:	eb05 1a4a 	add.w	sl, r5, sl, lsl #5
    otg_txfifo_flush(usbp, ep);
  20872e:	4621      	mov	r1, r4
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
  208730:	eb05 0383 	add.w	r3, r5, r3, lsl #2
    otg_txfifo_flush(usbp, ep);
  208734:	4628      	mov	r0, r5
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
  208736:	605a      	str	r2, [r3, #4]
    otg_txfifo_flush(usbp, ep);
  208738:	f7fe ff7c 	bl	207634 <otg_txfifo_flush.isra.0.lto_priv.0>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
  20873c:	f8da 3900 	ldr.w	r3, [sl, #2304]	; 0x900
  208740:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  208744:	f8ca 3900 	str.w	r3, [sl, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
  208748:	f8d5 381c 	ldr.w	r3, [r5, #2076]	; 0x81c
  20874c:	ea23 0308 	bic.w	r3, r3, r8
  208750:	e7d7      	b.n	208702 <usbInitEndpointI+0xe2>
  208752:	bf00      	nop
  208754:	10008000 	.word	0x10008000
  208758:	02000400 	.word	0x02000400

0020875c <sdu_start_receive.lto_priv.0>:
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
  20875c:	f8d0 148c 	ldr.w	r1, [r0, #1164]	; 0x48c
static bool sdu_start_receive(SerialUSBDriver *sdup) {
  208760:	b538      	push	{r3, r4, r5, lr}
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
  208762:	680c      	ldr	r4, [r1, #0]
  208764:	7823      	ldrb	r3, [r4, #0]
  208766:	2b04      	cmp	r3, #4
  208768:	d118      	bne.n	20879c <sdu_start_receive.lto_priv.0+0x40>
  20876a:	7a03      	ldrb	r3, [r0, #8]
  20876c:	2b02      	cmp	r3, #2
  20876e:	d115      	bne.n	20879c <sdu_start_receive.lto_priv.0+0x40>
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
  208770:	790a      	ldrb	r2, [r1, #4]
  208772:	2301      	movs	r3, #1
  208774:	8965      	ldrh	r5, [r4, #10]
  208776:	fa03 f202 	lsl.w	r2, r3, r2
  20877a:	422a      	tst	r2, r5
  20877c:	d10e      	bne.n	20879c <sdu_start_receive.lto_priv.0+0x40>
  if (ibqIsFullI(ibqp)) {
  20877e:	e9d0 2507 	ldrd	r2, r5, [r0, #28]
  208782:	42aa      	cmp	r2, r5
  208784:	d101      	bne.n	20878a <sdu_start_receive.lto_priv.0+0x2e>
  208786:	6980      	ldr	r0, [r0, #24]
  208788:	b950      	cbnz	r0, 2087a0 <sdu_start_receive.lto_priv.0+0x44>
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
  20878a:	4620      	mov	r0, r4
  20878c:	f44f 7380 	mov.w	r3, #256	; 0x100
  208790:	3204      	adds	r2, #4
  208792:	7949      	ldrb	r1, [r1, #5]
  208794:	f7ff ff33 	bl	2085fe <usbStartReceiveI>
  return false;
  208798:	2000      	movs	r0, #0
}
  20879a:	bd38      	pop	{r3, r4, r5, pc}
    return true;
  20879c:	2001      	movs	r0, #1
  20879e:	e7fc      	b.n	20879a <sdu_start_receive.lto_priv.0+0x3e>
  2087a0:	4618      	mov	r0, r3
  2087a2:	e7fa      	b.n	20879a <sdu_start_receive.lto_priv.0+0x3e>

002087a4 <ibnotify.lto_priv.0>:
  (void) sdu_start_receive(sdup);
  2087a4:	6b40      	ldr	r0, [r0, #52]	; 0x34
  2087a6:	f7ff bfd9 	b.w	20875c <sdu_start_receive.lto_priv.0>
	...

002087ac <_sdc_wait_for_transfer_state>:
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
  2087ac:	b537      	push	{r0, r1, r2, r4, r5, lr}
  2087ae:	4604      	mov	r4, r0
        MMCSD_R1_ERROR(resp[0])) {
  2087b0:	4d0c      	ldr	r5, [pc, #48]	; (2087e4 <_sdc_wait_for_transfer_state+0x38>)
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
  2087b2:	ab01      	add	r3, sp, #4
  2087b4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  2087b6:	210d      	movs	r1, #13
  2087b8:	4620      	mov	r0, r4
  2087ba:	f7fe fdd2 	bl	207362 <sdc_lld_send_cmd_short_crc>
  2087be:	b970      	cbnz	r0, 2087de <_sdc_wait_for_transfer_state+0x32>
        MMCSD_R1_ERROR(resp[0])) {
  2087c0:	9b01      	ldr	r3, [sp, #4]
                                   sdcp->rca, resp) ||
  2087c2:	422b      	tst	r3, r5
  2087c4:	d10a      	bne.n	2087dc <_sdc_wait_for_transfer_state+0x30>
    switch (MMCSD_R1_STS(resp[0])) {
  2087c6:	f3c3 2343 	ubfx	r3, r3, #9, #4
  2087ca:	2b04      	cmp	r3, #4
  2087cc:	d007      	beq.n	2087de <_sdc_wait_for_transfer_state+0x32>
  2087ce:	3b05      	subs	r3, #5
  2087d0:	2b02      	cmp	r3, #2
  2087d2:	d803      	bhi.n	2087dc <_sdc_wait_for_transfer_state+0x30>
  chThdSleep(delay);
  2087d4:	200a      	movs	r0, #10
  2087d6:	f7fc fe2b 	bl	205430 <chThdSleep>
      continue;
  2087da:	e7ea      	b.n	2087b2 <_sdc_wait_for_transfer_state+0x6>
    switch (MMCSD_R1_STS(resp[0])) {
  2087dc:	2001      	movs	r0, #1
}
  2087de:	b003      	add	sp, #12
  2087e0:	bd30      	pop	{r4, r5, pc}
  2087e2:	bf00      	nop
  2087e4:	fdffe008 	.word	0xfdffe008

002087e8 <sdcWrite>:
              const uint8_t *buf, uint32_t n) {
  2087e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  2087ec:	461e      	mov	r6, r3
  if ((startblk + n - 1U) > sdcp->capacity) {
  2087ee:	3b01      	subs	r3, #1
              const uint8_t *buf, uint32_t n) {
  2087f0:	4617      	mov	r7, r2
  if ((startblk + n - 1U) > sdcp->capacity) {
  2087f2:	6a82      	ldr	r2, [r0, #40]	; 0x28
  2087f4:	440b      	add	r3, r1
              const uint8_t *buf, uint32_t n) {
  2087f6:	4604      	mov	r4, r0
  2087f8:	460d      	mov	r5, r1
  if ((startblk + n - 1U) > sdcp->capacity) {
  2087fa:	4293      	cmp	r3, r2
  2087fc:	d906      	bls.n	20880c <sdcWrite+0x24>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
  2087fe:	6b43      	ldr	r3, [r0, #52]	; 0x34
  208800:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  208804:	6343      	str	r3, [r0, #52]	; 0x34
    return HAL_FAILED;
  208806:	2001      	movs	r0, #1
}
  208808:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  sdcp->state = BLK_WRITING;
  20880c:	2307      	movs	r3, #7
  20880e:	7103      	strb	r3, [r0, #4]
  if (((unsigned)buf & 3) != 0) {
  208810:	07bb      	lsls	r3, r7, #30
  208812:	d026      	beq.n	208862 <sdcWrite+0x7a>
  208814:	ebc1 52c1 	rsb	r2, r1, r1, lsl #23
  208818:	440e      	add	r6, r1
      memcpy(u.buf, buf, MMCSD_BLOCK_SIZE);
  20881a:	f8df 8064 	ldr.w	r8, [pc, #100]	; 208880 <sdcWrite+0x98>
  20881e:	eb07 2742 	add.w	r7, r7, r2, lsl #9
    for (i = 0; i < blocks; i++) {
  208822:	42b5      	cmp	r5, r6
  208824:	d101      	bne.n	20882a <sdcWrite+0x42>
    return HAL_SUCCESS;
  208826:	2000      	movs	r0, #0
  208828:	e00e      	b.n	208848 <sdcWrite+0x60>
      memcpy(u.buf, buf, MMCSD_BLOCK_SIZE);
  20882a:	f44f 7200 	mov.w	r2, #512	; 0x200
  20882e:	eb07 2145 	add.w	r1, r7, r5, lsl #9
  208832:	4813      	ldr	r0, [pc, #76]	; (208880 <sdcWrite+0x98>)
  208834:	f003 fd10 	bl	20c258 <memcpy>
  sdcp->sdmmc->DTIMER = sdcp->wtmo;
  208838:	6d23      	ldr	r3, [r4, #80]	; 0x50
  20883a:	6c62      	ldr	r2, [r4, #68]	; 0x44
  if (_sdc_wait_for_transfer_state(sdcp))
  20883c:	4620      	mov	r0, r4
  sdcp->sdmmc->DTIMER = sdcp->wtmo;
  20883e:	625a      	str	r2, [r3, #36]	; 0x24
  if (_sdc_wait_for_transfer_state(sdcp))
  208840:	f7ff ffb4 	bl	2087ac <_sdc_wait_for_transfer_state>
  208844:	b118      	cbz	r0, 20884e <sdcWrite+0x66>
        return HAL_FAILED;
  208846:	2001      	movs	r0, #1
  sdcp->state = BLK_READY;
  208848:	2305      	movs	r3, #5
  20884a:	7123      	strb	r3, [r4, #4]
  return status;
  20884c:	e7dc      	b.n	208808 <sdcWrite+0x20>
  20884e:	2301      	movs	r3, #1
  208850:	4642      	mov	r2, r8
  208852:	4629      	mov	r1, r5
  208854:	4620      	mov	r0, r4
  208856:	f7fe fe0b 	bl	207470 <sdc_lld_write_aligned.part.0>
      if (sdc_lld_write_aligned(sdcp, startblk, u.buf, 1))
  20885a:	2800      	cmp	r0, #0
  20885c:	d1f3      	bne.n	208846 <sdcWrite+0x5e>
      startblk++;
  20885e:	3501      	adds	r5, #1
  208860:	e7df      	b.n	208822 <sdcWrite+0x3a>
  sdcp->sdmmc->DTIMER = sdcp->wtmo;
  208862:	6d03      	ldr	r3, [r0, #80]	; 0x50
  208864:	6c42      	ldr	r2, [r0, #68]	; 0x44
  208866:	625a      	str	r2, [r3, #36]	; 0x24
  if (_sdc_wait_for_transfer_state(sdcp))
  208868:	f7ff ffa0 	bl	2087ac <_sdc_wait_for_transfer_state>
  20886c:	2800      	cmp	r0, #0
  20886e:	d1ea      	bne.n	208846 <sdcWrite+0x5e>
  208870:	4633      	mov	r3, r6
  208872:	463a      	mov	r2, r7
  208874:	4629      	mov	r1, r5
  208876:	4620      	mov	r0, r4
  208878:	f7fe fdfa 	bl	207470 <sdc_lld_write_aligned.part.0>
  20887c:	e7e4      	b.n	208848 <sdcWrite+0x60>
  20887e:	bf00      	nop
  208880:	20003e70 	.word	0x20003e70

00208884 <sdcRead>:
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
  208884:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  208888:	461e      	mov	r6, r3
  if ((startblk + n - 1U) > sdcp->capacity) {
  20888a:	3b01      	subs	r3, #1
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
  20888c:	4617      	mov	r7, r2
  if ((startblk + n - 1U) > sdcp->capacity) {
  20888e:	6a82      	ldr	r2, [r0, #40]	; 0x28
  208890:	440b      	add	r3, r1
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
  208892:	4604      	mov	r4, r0
  208894:	460d      	mov	r5, r1
  if ((startblk + n - 1U) > sdcp->capacity) {
  208896:	4293      	cmp	r3, r2
  208898:	d906      	bls.n	2088a8 <sdcRead+0x24>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
  20889a:	6b43      	ldr	r3, [r0, #52]	; 0x34
  20889c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  2088a0:	6343      	str	r3, [r0, #52]	; 0x34
    return HAL_FAILED;
  2088a2:	2001      	movs	r0, #1
}
  2088a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  sdcp->state = BLK_READING;
  2088a8:	2306      	movs	r3, #6
  2088aa:	7103      	strb	r3, [r0, #4]
  if (((unsigned)buf & 3) != 0) {
  2088ac:	07bb      	lsls	r3, r7, #30
  2088ae:	d026      	beq.n	2088fe <sdcRead+0x7a>
  2088b0:	ebc1 52c1 	rsb	r2, r1, r1, lsl #23
  2088b4:	440e      	add	r6, r1
  2088b6:	f8df 8064 	ldr.w	r8, [pc, #100]	; 20891c <sdcRead+0x98>
  2088ba:	eb07 2742 	add.w	r7, r7, r2, lsl #9
    for (i = 0; i < blocks; i++) {
  2088be:	42b5      	cmp	r5, r6
  2088c0:	d101      	bne.n	2088c6 <sdcRead+0x42>
    return HAL_SUCCESS;
  2088c2:	2000      	movs	r0, #0
  2088c4:	e007      	b.n	2088d6 <sdcRead+0x52>
  sdcp->sdmmc->DTIMER = sdcp->rtmo;
  2088c6:	6d23      	ldr	r3, [r4, #80]	; 0x50
  if (_sdc_wait_for_transfer_state(sdcp))
  2088c8:	4620      	mov	r0, r4
  sdcp->sdmmc->DTIMER = sdcp->rtmo;
  2088ca:	6c22      	ldr	r2, [r4, #64]	; 0x40
  2088cc:	625a      	str	r2, [r3, #36]	; 0x24
  if (_sdc_wait_for_transfer_state(sdcp))
  2088ce:	f7ff ff6d 	bl	2087ac <_sdc_wait_for_transfer_state>
  2088d2:	b118      	cbz	r0, 2088dc <sdcRead+0x58>
        return HAL_FAILED;
  2088d4:	2001      	movs	r0, #1
  sdcp->state = BLK_READY;
  2088d6:	2305      	movs	r3, #5
  2088d8:	7123      	strb	r3, [r4, #4]
  return status;
  2088da:	e7e3      	b.n	2088a4 <sdcRead+0x20>
  2088dc:	2301      	movs	r3, #1
  2088de:	4a0f      	ldr	r2, [pc, #60]	; (20891c <sdcRead+0x98>)
  2088e0:	4629      	mov	r1, r5
  2088e2:	4620      	mov	r0, r4
  2088e4:	f7fe fe08 	bl	2074f8 <sdc_lld_read_aligned.part.0>
      if (sdc_lld_read_aligned(sdcp, startblk, u.buf, 1))
  2088e8:	2800      	cmp	r0, #0
  2088ea:	d1f3      	bne.n	2088d4 <sdcRead+0x50>
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
  2088ec:	eb07 2045 	add.w	r0, r7, r5, lsl #9
  2088f0:	f44f 7200 	mov.w	r2, #512	; 0x200
  2088f4:	4641      	mov	r1, r8
      startblk++;
  2088f6:	3501      	adds	r5, #1
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
  2088f8:	f003 fcae 	bl	20c258 <memcpy>
      startblk++;
  2088fc:	e7df      	b.n	2088be <sdcRead+0x3a>
  sdcp->sdmmc->DTIMER = sdcp->rtmo;
  2088fe:	6d03      	ldr	r3, [r0, #80]	; 0x50
  208900:	6c02      	ldr	r2, [r0, #64]	; 0x40
  208902:	625a      	str	r2, [r3, #36]	; 0x24
  if (_sdc_wait_for_transfer_state(sdcp))
  208904:	f7ff ff52 	bl	2087ac <_sdc_wait_for_transfer_state>
  208908:	2800      	cmp	r0, #0
  20890a:	d1e3      	bne.n	2088d4 <sdcRead+0x50>
  20890c:	4633      	mov	r3, r6
  20890e:	463a      	mov	r2, r7
  208910:	4629      	mov	r1, r5
  208912:	4620      	mov	r0, r4
  208914:	f7fe fdf0 	bl	2074f8 <sdc_lld_read_aligned.part.0>
  208918:	e7dd      	b.n	2088d6 <sdcRead+0x52>
  20891a:	bf00      	nop
  20891c:	20003e70 	.word	0x20003e70

00208920 <obqGetFullBufferI>:
  if (obqIsEmptyI(obqp)) {
  208920:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
  208924:	429a      	cmp	r2, r3
  208926:	d101      	bne.n	20892c <obqGetFullBufferI+0xc>
  208928:	68c2      	ldr	r2, [r0, #12]
  20892a:	b922      	cbnz	r2, 208936 <obqGetFullBufferI+0x16>
  *sizep = *((size_t *)obqp->brdptr);
  20892c:	4618      	mov	r0, r3
  20892e:	f850 3b04 	ldr.w	r3, [r0], #4
  208932:	600b      	str	r3, [r1, #0]
  return obqp->brdptr + sizeof (size_t);
  208934:	4770      	bx	lr
    return NULL;
  208936:	2000      	movs	r0, #0
}
  208938:	4770      	bx	lr

0020893a <obnotify.lto_priv.0>:
static void obnotify(io_buffers_queue_t *bqp) {
  20893a:	b513      	push	{r0, r1, r4, lr}
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
  20893c:	6b44      	ldr	r4, [r0, #52]	; 0x34
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
  20893e:	f8d4 348c 	ldr.w	r3, [r4, #1164]	; 0x48c
  208942:	681a      	ldr	r2, [r3, #0]
  208944:	7811      	ldrb	r1, [r2, #0]
  208946:	2904      	cmp	r1, #4
  208948:	d115      	bne.n	208976 <obnotify.lto_priv.0+0x3c>
  20894a:	7a21      	ldrb	r1, [r4, #8]
  20894c:	2902      	cmp	r1, #2
  20894e:	d112      	bne.n	208976 <obnotify.lto_priv.0+0x3c>
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
  208950:	7919      	ldrb	r1, [r3, #4]
  208952:	2301      	movs	r3, #1
  208954:	8912      	ldrh	r2, [r2, #8]
  208956:	408b      	lsls	r3, r1
  208958:	4213      	tst	r3, r2
  20895a:	d10c      	bne.n	208976 <obnotify.lto_priv.0+0x3c>
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
  20895c:	a901      	add	r1, sp, #4
  20895e:	f104 0044 	add.w	r0, r4, #68	; 0x44
  208962:	f7ff ffdd 	bl	208920 <obqGetFullBufferI>
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
  208966:	f8d4 448c 	ldr.w	r4, [r4, #1164]	; 0x48c
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
  20896a:	4602      	mov	r2, r0
    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
  20896c:	9b01      	ldr	r3, [sp, #4]
  20896e:	7921      	ldrb	r1, [r4, #4]
  208970:	6820      	ldr	r0, [r4, #0]
  208972:	f7ff fe33 	bl	2085dc <usbStartTransmitI>
}
  208976:	b002      	add	sp, #8
  208978:	bd10      	pop	{r4, pc}
	...

0020897c <halInit>:
  rccResetAHB1(~STM32_GPIO_EN_MASK);
  20897c:	4b97      	ldr	r3, [pc, #604]	; (208bdc <halInit+0x260>)
  rccResetAHB2(~0);
  20897e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  rccResetAHB1(~STM32_GPIO_EN_MASK);
  208982:	691a      	ldr	r2, [r3, #16]
  208984:	ea6f 5242 	mvn.w	r2, r2, lsl #21
  208988:	ea6f 5252 	mvn.w	r2, r2, lsr #21
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
  20898c:	b5f0      	push	{r4, r5, r6, r7, lr}
  20898e:	611a      	str	r2, [r3, #16]
  208990:	691a      	ldr	r2, [r3, #16]
  208992:	f3c2 020a 	ubfx	r2, r2, #0, #11
  208996:	611a      	str	r2, [r3, #16]
  208998:	691a      	ldr	r2, [r3, #16]
  rccResetAHB2(~0);
  20899a:	695a      	ldr	r2, [r3, #20]
  20899c:	6158      	str	r0, [r3, #20]
  20899e:	695a      	ldr	r2, [r3, #20]
  2089a0:	2200      	movs	r2, #0
  2089a2:	615a      	str	r2, [r3, #20]
  2089a4:	6959      	ldr	r1, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
  2089a6:	6a19      	ldr	r1, [r3, #32]
  2089a8:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
  2089ac:	6219      	str	r1, [r3, #32]
  2089ae:	6a19      	ldr	r1, [r3, #32]
  2089b0:	f001 5180 	and.w	r1, r1, #268435456	; 0x10000000
  2089b4:	6219      	str	r1, [r3, #32]
  2089b6:	6a19      	ldr	r1, [r3, #32]
  rccResetAPB2(~0);
  2089b8:	6a59      	ldr	r1, [r3, #36]	; 0x24
  2089ba:	6258      	str	r0, [r3, #36]	; 0x24
  PWR->CR1 |= PWR_CR1_DBP;
  2089bc:	4888      	ldr	r0, [pc, #544]	; (208be0 <halInit+0x264>)
  rccResetAPB2(~0);
  2089be:	6a59      	ldr	r1, [r3, #36]	; 0x24
  2089c0:	625a      	str	r2, [r3, #36]	; 0x24
  2089c2:	6a59      	ldr	r1, [r3, #36]	; 0x24
  PWR->CR1 |= PWR_CR1_DBP;
  2089c4:	6801      	ldr	r1, [r0, #0]
  2089c6:	f441 7180 	orr.w	r1, r1, #256	; 0x100
  2089ca:	6001      	str	r1, [r0, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
  2089cc:	6f19      	ldr	r1, [r3, #112]	; 0x70
  2089ce:	f401 7140 	and.w	r1, r1, #768	; 0x300
  2089d2:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
  2089d6:	d003      	beq.n	2089e0 <halInit+0x64>
    RCC->BDCR = RCC_BDCR_BDRST;
  2089d8:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  2089dc:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
  2089de:	671a      	str	r2, [r3, #112]	; 0x70
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
  2089e0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  2089e2:	f042 0219 	orr.w	r2, r2, #25
  2089e6:	671a      	str	r2, [r3, #112]	; 0x70
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
  2089e8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  2089ea:	0792      	lsls	r2, r2, #30
  2089ec:	d5fc      	bpl.n	2089e8 <halInit+0x6c>
  PWR->CSR1 &= ~PWR_CSR1_BRE;
  2089ee:	4a7c      	ldr	r2, [pc, #496]	; (208be0 <halInit+0x264>)
  dma.allocated_mask = 0U;
  2089f0:	2400      	movs	r4, #0
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
  2089f2:	250c      	movs	r5, #12
  2089f4:	487b      	ldr	r0, [pc, #492]	; (208be4 <halInit+0x268>)
  2089f6:	6853      	ldr	r3, [r2, #4]
  2089f8:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  2089fc:	6053      	str	r3, [r2, #4]
  2089fe:	4623      	mov	r3, r4
  dma.allocated_mask = 0U;
  208a00:	4a79      	ldr	r2, [pc, #484]	; (208be8 <halInit+0x26c>)
  208a02:	f842 4b04 	str.w	r4, [r2], #4
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
  208a06:	fb05 f104 	mul.w	r1, r5, r4
  208a0a:	5809      	ldr	r1, [r1, r0]
  208a0c:	600b      	str	r3, [r1, #0]
    dma.streams[i].func = NULL;
  208a0e:	f842 3034 	str.w	r3, [r2, r4, lsl #3]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
  208a12:	3401      	adds	r4, #1
  208a14:	2c10      	cmp	r4, #16
  208a16:	d1f6      	bne.n	208a06 <halInit+0x8a>
  DMA1->LIFCR = 0xFFFFFFFFU;
  208a18:	4a74      	ldr	r2, [pc, #464]	; (208bec <halInit+0x270>)
  208a1a:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208a1e:	2160      	movs	r1, #96	; 0x60
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208a20:	2040      	movs	r0, #64	; 0x40
  208a22:	6095      	str	r5, [r2, #8]
  208a24:	2680      	movs	r6, #128	; 0x80
  DMA1->HIFCR = 0xFFFFFFFFU;
  208a26:	60d5      	str	r5, [r2, #12]
  208a28:	f44f 7700 	mov.w	r7, #512	; 0x200
  DMA2->LIFCR = 0xFFFFFFFFU;
  208a2c:	f8c2 5408 	str.w	r5, [r2, #1032]	; 0x408
  DMA2->HIFCR = 0xFFFFFFFFU;
  208a30:	f8c2 540c 	str.w	r5, [r2, #1036]	; 0x40c
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208a34:	4a6e      	ldr	r2, [pc, #440]	; (208bf0 <halInit+0x274>)
  sdp->vmt = &vmt;
  208a36:	f8df c21c 	ldr.w	ip, [pc, #540]	; 208c54 <halInit+0x2d8>
  208a3a:	f882 1306 	strb.w	r1, [r2, #774]	; 0x306
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208a3e:	f8c2 0180 	str.w	r0, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208a42:	6010      	str	r0, [r2, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208a44:	f44f 7080 	mov.w	r0, #256	; 0x100
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208a48:	f882 1307 	strb.w	r1, [r2, #775]	; 0x307
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208a4c:	f8c2 6180 	str.w	r6, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208a50:	6016      	str	r6, [r2, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208a52:	f882 1308 	strb.w	r1, [r2, #776]	; 0x308
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208a56:	f8c2 0180 	str.w	r0, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208a5a:	6010      	str	r0, [r2, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208a5c:	f882 1309 	strb.w	r1, [r2, #777]	; 0x309
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208a60:	f8c2 7180 	str.w	r7, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208a64:	6017      	str	r7, [r2, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208a66:	f44f 6780 	mov.w	r7, #1024	; 0x400
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208a6a:	f882 130a 	strb.w	r1, [r2, #778]	; 0x30a
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208a6e:	f8c2 7180 	str.w	r7, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208a72:	6017      	str	r7, [r2, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208a74:	f44f 0700 	mov.w	r7, #8388608	; 0x800000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208a78:	f882 1317 	strb.w	r1, [r2, #791]	; 0x317
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208a7c:	f8c2 7180 	str.w	r7, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208a80:	6017      	str	r7, [r2, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208a82:	f882 1328 	strb.w	r1, [r2, #808]	; 0x328
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208a86:	f8c2 0184 	str.w	r0, [r2, #388]	; 0x184
  GPTD5.tim = STM32_TIM5;
  208a8a:	495a      	ldr	r1, [pc, #360]	; (208bf4 <halInit+0x278>)
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208a8c:	6050      	str	r0, [r2, #4]
  208a8e:	485a      	ldr	r0, [pc, #360]	; (208bf8 <halInit+0x27c>)
  gptp->config = NULL;
  208a90:	604b      	str	r3, [r1, #4]
  208a92:	60c8      	str	r0, [r1, #12]
  gptp->state  = GPT_STOP;
  208a94:	2001      	movs	r0, #1
  208a96:	7008      	strb	r0, [r1, #0]
  i2cp->state  = I2C_STOP;
  208a98:	4958      	ldr	r1, [pc, #352]	; (208bfc <halInit+0x280>)
  tqp->next = (thread_t *)tqp;
  208a9a:	f101 070c 	add.w	r7, r1, #12
  i2cp->config = NULL;
  208a9e:	604b      	str	r3, [r1, #4]
  i2cp->state  = I2C_STOP;
  208aa0:	7008      	strb	r0, [r1, #0]
  tqp->prev = (thread_t *)tqp;
  208aa2:	e9c1 7703 	strd	r7, r7, [r1, #12]
  I2CD1.i2c    = I2C1;
  208aa6:	4f56      	ldr	r7, [pc, #344]	; (208c00 <halInit+0x284>)
  208aa8:	614b      	str	r3, [r1, #20]
  I2CD1.thread = NULL;
  208aaa:	61cb      	str	r3, [r1, #28]
  I2CD1.i2c    = I2C1;
  208aac:	630f      	str	r7, [r1, #48]	; 0x30
  208aae:	4955      	ldr	r1, [pc, #340]	; (208c04 <halInit+0x288>)
  tqp->next = (thread_t *)tqp;
  208ab0:	f101 070c 	add.w	r7, r1, #12
  i2cp->config = NULL;
  208ab4:	604b      	str	r3, [r1, #4]
  208ab6:	614b      	str	r3, [r1, #20]
  I2CD3.thread = NULL;
  208ab8:	61cb      	str	r3, [r1, #28]
  i2cp->state  = I2C_STOP;
  208aba:	7008      	strb	r0, [r1, #0]
  tqp->prev = (thread_t *)tqp;
  208abc:	e9c1 7703 	strd	r7, r7, [r1, #12]
  I2CD3.i2c    = I2C3;
  208ac0:	4f51      	ldr	r7, [pc, #324]	; (208c08 <halInit+0x28c>)
  208ac2:	630f      	str	r7, [r1, #48]	; 0x30
  208ac4:	4951      	ldr	r1, [pc, #324]	; (208c0c <halInit+0x290>)
  208ac6:	460f      	mov	r7, r1
  iqp->q_counter = 0;
  208ac8:	614b      	str	r3, [r1, #20]
  oqp->q_counter = size;
  208aca:	638c      	str	r4, [r1, #56]	; 0x38
  208acc:	f847 cb04 	str.w	ip, [r7], #4
  208ad0:	604f      	str	r7, [r1, #4]
  tqp->next = (thread_t *)tqp;
  208ad2:	f101 070c 	add.w	r7, r1, #12
  oqp->q_buffer  = bp;
  208ad6:	4c4e      	ldr	r4, [pc, #312]	; (208c10 <halInit+0x294>)
  sdp->state = SD_STOP;
  208ad8:	7208      	strb	r0, [r1, #8]
  208ada:	63cc      	str	r4, [r1, #60]	; 0x3c
  tqp->prev = (thread_t *)tqp;
  208adc:	e9c1 7703 	strd	r7, r7, [r1, #12]
  iqp->q_buffer  = bp;
  208ae0:	4f4c      	ldr	r7, [pc, #304]	; (208c14 <halInit+0x298>)
  oqp->q_wrptr   = bp;
  208ae2:	e9c1 4411 	strd	r4, r4, [r1, #68]	; 0x44
  iqp->q_buffer  = bp;
  208ae6:	618f      	str	r7, [r1, #24]
  oqp->q_top     = bp + size;
  208ae8:	3410      	adds	r4, #16
  iqp->q_wrptr   = bp;
  208aea:	e9c1 7708 	strd	r7, r7, [r1, #32]
  iqp->q_top     = bp + size;
  208aee:	3710      	adds	r7, #16
  oqp->q_top     = bp + size;
  208af0:	640c      	str	r4, [r1, #64]	; 0x40
  oqp->q_notify  = onfy;
  208af2:	4c49      	ldr	r4, [pc, #292]	; (208c18 <halInit+0x29c>)
  iqp->q_top     = bp + size;
  208af4:	61cf      	str	r7, [r1, #28]
  tqp->next = (thread_t *)tqp;
  208af6:	f101 0730 	add.w	r7, r1, #48	; 0x30
  oqp->q_link    = link;
  208afa:	e9c1 4113 	strd	r4, r1, [r1, #76]	; 0x4c
  tqp->prev = (thread_t *)tqp;
  208afe:	e9c1 770c 	strd	r7, r7, [r1, #48]	; 0x30
  SD1.clock = STM32_USART1CLK;
  208b02:	4c46      	ldr	r4, [pc, #280]	; (208c1c <halInit+0x2a0>)
  208b04:	4f46      	ldr	r7, [pc, #280]	; (208c20 <halInit+0x2a4>)
  iqp->q_link    = link;
  208b06:	e9c1 310a 	strd	r3, r1, [r1, #40]	; 0x28
  208b0a:	e9c1 7415 	strd	r7, r4, [r1, #84]	; 0x54
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208b0e:	21c0      	movs	r1, #192	; 0xc0
  sdcp->vmt      = &sdc_vmt;
  208b10:	4c44      	ldr	r4, [pc, #272]	; (208c24 <halInit+0x2a8>)
  208b12:	f882 1325 	strb.w	r1, [r2, #805]	; 0x325
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208b16:	2120      	movs	r1, #32
  208b18:	f8c2 1184 	str.w	r1, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208b1c:	6051      	str	r1, [r2, #4]
  208b1e:	4942      	ldr	r1, [pc, #264]	; (208c28 <halInit+0x2ac>)
  208b20:	600c      	str	r4, [r1, #0]
  SDCD1.rtmo   = SDMMC1_READ_TIMEOUT;
  208b22:	4c42      	ldr	r4, [pc, #264]	; (208c2c <halInit+0x2b0>)
  sdcp->state    = BLK_STOP;
  208b24:	7108      	strb	r0, [r1, #4]
  sdcp->errors   = SDC_NO_ERROR;
  208b26:	634b      	str	r3, [r1, #52]	; 0x34
  SDCD1.thread = NULL;
  208b28:	63cb      	str	r3, [r1, #60]	; 0x3c
  SDCD1.dma    = NULL;
  208b2a:	64cb      	str	r3, [r1, #76]	; 0x4c
  SDCD1.wtmo   = SDMMC1_WRITE_TIMEOUT;
  208b2c:	e9c1 4410 	strd	r4, r4, [r1, #64]	; 0x40
  SDCD1.sdmmc  = SDMMC1;
  208b30:	4c3f      	ldr	r4, [pc, #252]	; (208c30 <halInit+0x2b4>)
  sdcp->capacity = 0;
  208b32:	e9c1 330a 	strd	r3, r3, [r1, #40]	; 0x28
  208b36:	650c      	str	r4, [r1, #80]	; 0x50
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208b38:	2190      	movs	r1, #144	; 0x90
  208b3a:	f882 1331 	strb.w	r1, [r2, #817]	; 0x331
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208b3e:	f44f 3100 	mov.w	r1, #131072	; 0x20000
  208b42:	f8c2 1184 	str.w	r1, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208b46:	6051      	str	r1, [r2, #4]
  spip->state = SPI_STOP;
  208b48:	493a      	ldr	r1, [pc, #232]	; (208c34 <halInit+0x2b8>)
  tqp->next = (thread_t *)tqp;
  208b4a:	f101 040c 	add.w	r4, r1, #12
  208b4e:	7008      	strb	r0, [r1, #0]
  SPID2.dmatx     = NULL;
  208b50:	624b      	str	r3, [r1, #36]	; 0x24
  208b52:	614b      	str	r3, [r1, #20]
  tqp->prev = (thread_t *)tqp;
  208b54:	e9c1 4403 	strd	r4, r4, [r1, #12]
  SPID2.spi       = SPI2;
  208b58:	4c37      	ldr	r4, [pc, #220]	; (208c38 <halInit+0x2bc>)
  SPID2.dmarx     = NULL;
  208b5a:	e9c1 4307 	strd	r4, r3, [r1, #28]
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_STREAM) |
  208b5e:	4c37      	ldr	r4, [pc, #220]	; (208c3c <halInit+0x2c0>)
  208b60:	628c      	str	r4, [r1, #40]	; 0x28
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_STREAM) |
  208b62:	3430      	adds	r4, #48	; 0x30
  spip->thread = NULL;
  208b64:	e9c1 3301 	strd	r3, r3, [r1, #4]
  208b68:	62cc      	str	r4, [r1, #44]	; 0x2c
  trngp->state  = TRNG_STOP;
  208b6a:	4935      	ldr	r1, [pc, #212]	; (208c40 <halInit+0x2c4>)
  TRNGD1.rng = RNG;
  208b6c:	4c35      	ldr	r4, [pc, #212]	; (208c44 <halInit+0x2c8>)
  208b6e:	7008      	strb	r0, [r1, #0]
  trngp->config = NULL;
  208b70:	604b      	str	r3, [r1, #4]
  208b72:	608c      	str	r4, [r1, #8]
  USBD1.otg       = OTG_FS;
  208b74:	f04f 44a0 	mov.w	r4, #1342177280	; 0x50000000
  usbp->state        = USB_STOP;
  208b78:	4933      	ldr	r1, [pc, #204]	; (208c48 <halInit+0x2cc>)
    usbp->in_params[i]  = NULL;
  208b7a:	624b      	str	r3, [r1, #36]	; 0x24
    usbp->out_params[i] = NULL;
  208b7c:	638b      	str	r3, [r1, #56]	; 0x38
  usbp->state        = USB_STOP;
  208b7e:	7008      	strb	r0, [r1, #0]
    usbp->in_params[i]  = NULL;
  208b80:	628b      	str	r3, [r1, #40]	; 0x28
  208b82:	66cc      	str	r4, [r1, #108]	; 0x6c
  USBD1.otgparams = &fsparams;
  208b84:	4c31      	ldr	r4, [pc, #196]	; (208c4c <halInit+0x2d0>)
    usbp->out_params[i] = NULL;
  208b86:	640b      	str	r3, [r1, #64]	; 0x40
    usbp->in_params[i]  = NULL;
  208b88:	62cb      	str	r3, [r1, #44]	; 0x2c
  208b8a:	634b      	str	r3, [r1, #52]	; 0x34
    usbp->out_params[i] = NULL;
  208b8c:	63cb      	str	r3, [r1, #60]	; 0x3c
    usbp->in_params[i]  = NULL;
  208b8e:	630b      	str	r3, [r1, #48]	; 0x30
    usbp->out_params[i] = NULL;
  208b90:	644b      	str	r3, [r1, #68]	; 0x44
  208b92:	648b      	str	r3, [r1, #72]	; 0x48
  208b94:	670c      	str	r4, [r1, #112]	; 0x70
  usbp->transmitting = 0;
  208b96:	e9c1 3301 	strd	r3, r3, [r1, #4]

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
  208b9a:	4910      	ldr	r1, [pc, #64]	; (208bdc <halInit+0x260>)
  208b9c:	6c0c      	ldr	r4, [r1, #64]	; 0x40
  208b9e:	4304      	orrs	r4, r0
  208ba0:	640c      	str	r4, [r1, #64]	; 0x40
  208ba2:	6e0c      	ldr	r4, [r1, #96]	; 0x60
  208ba4:	4304      	orrs	r4, r0
  208ba6:	660c      	str	r4, [r1, #96]	; 0x60

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
  208ba8:	4c29      	ldr	r4, [pc, #164]	; (208c50 <halInit+0x2d4>)
  ST_ENABLE_CLOCK();
  208baa:	6e09      	ldr	r1, [r1, #96]	; 0x60
  ST_ENABLE_STOP();
  208bac:	68a1      	ldr	r1, [r4, #8]
  208bae:	4301      	orrs	r1, r0
  208bb0:	60a1      	str	r1, [r4, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  208bb2:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  208bb6:	f642 242f 	movw	r4, #10799	; 0x2a2f
  208bba:	628c      	str	r4, [r1, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  208bbc:	62cd      	str	r5, [r1, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
  208bbe:	618b      	str	r3, [r1, #24]
  STM32_ST_TIM->CCR[0] = 0;
  208bc0:	634b      	str	r3, [r1, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
  208bc2:	60cb      	str	r3, [r1, #12]
  STM32_ST_TIM->CR2    = 0;
  208bc4:	604b      	str	r3, [r1, #4]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208bc6:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  208bca:	6148      	str	r0, [r1, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
  208bcc:	6008      	str	r0, [r1, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  208bce:	f882 631c 	strb.w	r6, [r2, #796]	; 0x31c
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  208bd2:	f8c2 3180 	str.w	r3, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  208bd6:	6013      	str	r3, [r2, #0]
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
  208bd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  208bda:	bf00      	nop
  208bdc:	40023800 	.word	0x40023800
  208be0:	40007000 	.word	0x40007000
  208be4:	0800e524 	.word	0x0800e524
  208be8:	200018a8 	.word	0x200018a8
  208bec:	40026000 	.word	0x40026000
  208bf0:	e000e100 	.word	0xe000e100
  208bf4:	20000814 	.word	0x20000814
  208bf8:	40000c00 	.word	0x40000c00
  208bfc:	20000824 	.word	0x20000824
  208c00:	40005400 	.word	0x40005400
  208c04:	20000858 	.word	0x20000858
  208c08:	40005c00 	.word	0x40005c00
  208c0c:	2000088c 	.word	0x2000088c
  208c10:	20003e60 	.word	0x20003e60
  208c14:	20003e50 	.word	0x20003e50
  208c18:	0020143d 	.word	0x0020143d
  208c1c:	066ff300 	.word	0x066ff300
  208c20:	40011000 	.word	0x40011000
  208c24:	0800eb1c 	.word	0x0800eb1c
  208c28:	200008ec 	.word	0x200008ec
  208c2c:	016e3600 	.word	0x016e3600
  208c30:	40012c00 	.word	0x40012c00
  208c34:	20000dd8 	.word	0x20000dd8
  208c38:	40003800 	.word	0x40003800
  208c3c:	00010016 	.word	0x00010016
  208c40:	20000e08 	.word	0x20000e08
  208c44:	50060800 	.word	0x50060800
  208c48:	20000e14 	.word	0x20000e14
  208c4c:	0800ea90 	.word	0x0800ea90
  208c50:	e0042000 	.word	0xe0042000
  208c54:	0800eb40 	.word	0x0800eb40

00208c58 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
  208c58:	b5f0      	push	{r4, r5, r6, r7, lr}
  208c5a:	2008      	movs	r0, #8
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
  208c5c:	4910      	ldr	r1, [pc, #64]	; (208ca0 <__init_ram_areas+0x48>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
  208c5e:	2600      	movs	r6, #0
    uint32_t *p = rap->init_area;
  208c60:	680a      	ldr	r2, [r1, #0]
    while (p < rap->clear_area) {
  208c62:	e9d1 3401 	ldrd	r3, r4, [r1, #4]
  208c66:	3a04      	subs	r2, #4
    uint32_t *p = rap->init_area;
  208c68:	461d      	mov	r5, r3
    while (p < rap->clear_area) {
  208c6a:	42ac      	cmp	r4, r5
  208c6c:	d810      	bhi.n	208c90 <__init_ram_areas+0x38>
  208c6e:	1ce2      	adds	r2, r4, #3
  208c70:	1edd      	subs	r5, r3, #3
  208c72:	1ad2      	subs	r2, r2, r3
  208c74:	f022 0203 	bic.w	r2, r2, #3
  208c78:	42ac      	cmp	r4, r5
  208c7a:	bf38      	it	cc
  208c7c:	2200      	movcc	r2, #0
  208c7e:	4413      	add	r3, r2
    while (p < rap->no_init_area) {
  208c80:	68ca      	ldr	r2, [r1, #12]
  208c82:	429a      	cmp	r2, r3
  208c84:	d809      	bhi.n	208c9a <__init_ram_areas+0x42>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
  208c86:	3801      	subs	r0, #1
    rap++;
  208c88:	f101 0110 	add.w	r1, r1, #16
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
  208c8c:	d1e8      	bne.n	208c60 <__init_ram_areas+0x8>
#endif
}
  208c8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      *p = *tp;
  208c90:	f852 7f04 	ldr.w	r7, [r2, #4]!
  208c94:	f845 7b04 	str.w	r7, [r5], #4
      tp++;
  208c98:	e7e7      	b.n	208c6a <__init_ram_areas+0x12>
      *p = 0;
  208c9a:	f843 6b04 	str.w	r6, [r3], #4
      p++;
  208c9e:	e7f0      	b.n	208c82 <__init_ram_areas+0x2a>
  208ca0:	0800ea9c 	.word	0x0800ea9c

00208ca4 <__default_exit>:
  }
  208ca4:	e7fe      	b.n	208ca4 <__default_exit>

00208ca6 <__late_init>:
void __late_init(void) {}
  208ca6:	4770      	bx	lr

00208ca8 <__core_init>:
void __core_init(void) {
  208ca8:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("dsb 0xF":::"memory");
  208caa:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  208cae:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
  208cb2:	4b1a      	ldr	r3, [pc, #104]	; (208d1c <__core_init+0x74>)
  208cb4:	2100      	movs	r1, #0
  208cb6:	f8c3 1250 	str.w	r1, [r3, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
  208cba:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  208cbe:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
  208cc2:	695a      	ldr	r2, [r3, #20]
  208cc4:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
  208cc8:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
  208cca:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  208cce:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
  208cd2:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
  208cd6:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
  208cda:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  208cde:	f643 74e0 	movw	r4, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  208ce2:	f3c2 00c9 	ubfx	r0, r2, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
  208ce6:	f3c2 324e 	ubfx	r2, r2, #13, #15
  208cea:	0152      	lsls	r2, r2, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  208cec:	ea02 0604 	and.w	r6, r2, r4
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  208cf0:	4601      	mov	r1, r0
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  208cf2:	ea46 7581 	orr.w	r5, r6, r1, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
  208cf6:	3901      	subs	r1, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  208cf8:	f8c3 5260 	str.w	r5, [r3, #608]	; 0x260
      } while (ways-- != 0U);
  208cfc:	d2f9      	bcs.n	208cf2 <__core_init+0x4a>
  208cfe:	3a20      	subs	r2, #32
    } while(sets-- != 0U);
  208d00:	f112 0f20 	cmn.w	r2, #32
  208d04:	d1f2      	bne.n	208cec <__core_init+0x44>
  208d06:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
  208d0a:	695a      	ldr	r2, [r3, #20]
  208d0c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  208d10:	615a      	str	r2, [r3, #20]
  208d12:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  208d16:	f3bf 8f6f 	isb	sy
}
  208d1a:	bd70      	pop	{r4, r5, r6, pc}
  208d1c:	e000ed00 	.word	0xe000ed00

00208d20 <sduDataReceived>:
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
  208d20:	310d      	adds	r1, #13
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
  208d22:	b538      	push	{r3, r4, r5, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
  208d24:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
  if (sdup == NULL) {
  208d28:	b334      	cbz	r4, 208d78 <sduDataReceived+0x58>
  208d2a:	f7fb f9e5 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  size = usbGetReceiveTransactionSizeX(sdup->config->usbp,
  208d2e:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
  208d32:	6813      	ldr	r3, [r2, #0]
  208d34:	7952      	ldrb	r2, [r2, #5]
  208d36:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  208d3a:	68db      	ldr	r3, [r3, #12]
  208d3c:	699b      	ldr	r3, [r3, #24]
  208d3e:	685d      	ldr	r5, [r3, #4]
  if (size > (size_t)0) {
  208d40:	b1a5      	cbz	r5, 208d6c <sduDataReceived+0x4c>
  chEvtBroadcastFlagsI(esp, flags);
  208d42:	2104      	movs	r1, #4
  208d44:	1860      	adds	r0, r4, r1
  208d46:	f7fc f973 	bl	205030 <chEvtBroadcastFlagsI>
  *((size_t *)ibqp->bwrptr) = size;
  208d4a:	69e3      	ldr	r3, [r4, #28]
    ibqPostFullBufferI(&sdup->ibqueue, size);
  208d4c:	f104 000c 	add.w	r0, r4, #12
  208d50:	601d      	str	r5, [r3, #0]
  ibqp->bcounter++;
  208d52:	69a2      	ldr	r2, [r4, #24]
  208d54:	3201      	adds	r2, #1
  208d56:	61a2      	str	r2, [r4, #24]
  ibqp->bwrptr += ibqp->bsize;
  208d58:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  208d5a:	4413      	add	r3, r2
  if (ibqp->bwrptr >= ibqp->btop) {
  208d5c:	6a62      	ldr	r2, [r4, #36]	; 0x24
  208d5e:	4293      	cmp	r3, r2
  ibqp->bwrptr += ibqp->bsize;
  208d60:	61e3      	str	r3, [r4, #28]
    ibqp->bwrptr = ibqp->buffers;
  208d62:	bf24      	itt	cs
  208d64:	6b23      	ldrcs	r3, [r4, #48]	; 0x30
  208d66:	61e3      	strcs	r3, [r4, #28]
  chThdDequeueNextI(tqp, msg);
  208d68:	f7fb f846 	bl	203df8 <chThdDequeueNextI.constprop.0>
  (void) sdu_start_receive(sdup);
  208d6c:	4620      	mov	r0, r4
  208d6e:	f7ff fcf5 	bl	20875c <sdu_start_receive.lto_priv.0>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  208d72:	2300      	movs	r3, #0
  208d74:	f383 8811 	msr	BASEPRI, r3
}
  208d78:	bd38      	pop	{r3, r4, r5, pc}

00208d7a <sduDataTransmitted>:
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
  208d7a:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
  208d7e:	b5f0      	push	{r4, r5, r6, r7, lr}
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
  208d80:	6a1c      	ldr	r4, [r3, #32]
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
  208d82:	b085      	sub	sp, #20
  208d84:	4605      	mov	r5, r0
  208d86:	460e      	mov	r6, r1
  if (sdup == NULL) {
  208d88:	b354      	cbz	r4, 208de0 <sduDataTransmitted+0x66>
  208d8a:	eb05 0786 	add.w	r7, r5, r6, lsl #2
  208d8e:	f7fb f9b3 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  chEvtBroadcastFlagsI(esp, flags);
  208d92:	1d20      	adds	r0, r4, #4
  208d94:	2108      	movs	r1, #8
  208d96:	f7fc f94b 	bl	205030 <chEvtBroadcastFlagsI>
  if (usbp->epc[ep]->in_state->txsize > 0U) {
  208d9a:	68fb      	ldr	r3, [r7, #12]
  208d9c:	f104 0044 	add.w	r0, r4, #68	; 0x44
  208da0:	695b      	ldr	r3, [r3, #20]
  208da2:	681b      	ldr	r3, [r3, #0]
  208da4:	b17b      	cbz	r3, 208dc6 <sduDataTransmitted+0x4c>
  obqp->bcounter++;
  208da6:	6d23      	ldr	r3, [r4, #80]	; 0x50
  obqp->brdptr += obqp->bsize;
  208da8:	6e22      	ldr	r2, [r4, #96]	; 0x60
  obqp->bcounter++;
  208daa:	3301      	adds	r3, #1
  chThdDequeueNextI(tqp, msg);
  208dac:	9001      	str	r0, [sp, #4]
  208dae:	6523      	str	r3, [r4, #80]	; 0x50
  obqp->brdptr += obqp->bsize;
  208db0:	6da3      	ldr	r3, [r4, #88]	; 0x58
  208db2:	4413      	add	r3, r2
  if (obqp->brdptr >= obqp->btop) {
  208db4:	6de2      	ldr	r2, [r4, #92]	; 0x5c
  208db6:	4293      	cmp	r3, r2
  obqp->brdptr += obqp->bsize;
  208db8:	65a3      	str	r3, [r4, #88]	; 0x58
    obqp->brdptr = obqp->buffers;
  208dba:	bf24      	itt	cs
  208dbc:	6ea3      	ldrcs	r3, [r4, #104]	; 0x68
  208dbe:	65a3      	strcs	r3, [r4, #88]	; 0x58
  208dc0:	f7fb f81a 	bl	203df8 <chThdDequeueNextI.constprop.0>
  208dc4:	9801      	ldr	r0, [sp, #4]
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
  208dc6:	a903      	add	r1, sp, #12
  208dc8:	f7ff fdaa 	bl	208920 <obqGetFullBufferI>
  if (buf != NULL) {
  208dcc:	4602      	mov	r2, r0
  208dce:	b148      	cbz	r0, 208de4 <sduDataTransmitted+0x6a>
    usbStartTransmitI(usbp, ep, buf, n);
  208dd0:	9b03      	ldr	r3, [sp, #12]
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
  208dd2:	4631      	mov	r1, r6
  208dd4:	4628      	mov	r0, r5
  208dd6:	f7ff fc01 	bl	2085dc <usbStartTransmitI>
  208dda:	2300      	movs	r3, #0
  208ddc:	f383 8811 	msr	BASEPRI, r3
}
  208de0:	b005      	add	sp, #20
  208de2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
  208de4:	68fb      	ldr	r3, [r7, #12]
  208de6:	695a      	ldr	r2, [r3, #20]
  208de8:	6812      	ldr	r2, [r2, #0]
  208dea:	2a00      	cmp	r2, #0
  208dec:	d0f5      	beq.n	208dda <sduDataTransmitted+0x60>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
  208dee:	8a1b      	ldrh	r3, [r3, #16]
  208df0:	3b01      	subs	r3, #1
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
  208df2:	4013      	ands	r3, r2
  208df4:	d1f1      	bne.n	208dda <sduDataTransmitted+0x60>
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
  208df6:	f105 025c 	add.w	r2, r5, #92	; 0x5c
  208dfa:	e7ea      	b.n	208dd2 <sduDataTransmitted+0x58>

00208dfc <sdcDisconnect>:
bool sdcDisconnect(SDCDriver *sdcp) {
  208dfc:	b538      	push	{r3, r4, r5, lr}
  208dfe:	4604      	mov	r4, r0
  208e00:	f7fb f97a 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  if (sdcp->state == BLK_ACTIVE) {
  208e04:	2500      	movs	r5, #0
  208e06:	7923      	ldrb	r3, [r4, #4]
  208e08:	2b02      	cmp	r3, #2
  208e0a:	d103      	bne.n	208e14 <sdcDisconnect+0x18>
  208e0c:	f385 8811 	msr	BASEPRI, r5
    return HAL_SUCCESS;
  208e10:	4628      	mov	r0, r5
}
  208e12:	bd38      	pop	{r3, r4, r5, pc}
  sdcp->state = BLK_DISCONNECTING;
  208e14:	2304      	movs	r3, #4
  208e16:	7123      	strb	r3, [r4, #4]
  208e18:	f385 8811 	msr	BASEPRI, r5
  if (_sdc_wait_for_transfer_state(sdcp)) {
  208e1c:	4620      	mov	r0, r4
  208e1e:	f7ff fcc5 	bl	2087ac <_sdc_wait_for_transfer_state>
  208e22:	6d23      	ldr	r3, [r4, #80]	; 0x50
  208e24:	2202      	movs	r2, #2
  208e26:	b118      	cbz	r0, 208e30 <sdcDisconnect+0x34>
  sdcp->sdmmc->CLKCR = 0;
  208e28:	605d      	str	r5, [r3, #4]
  sdcp->sdmmc->POWER = 0;
  208e2a:	601d      	str	r5, [r3, #0]
  sdcp->state = BLK_ACTIVE;
  208e2c:	7122      	strb	r2, [r4, #4]
  return HAL_SUCCESS;
  208e2e:	e7f0      	b.n	208e12 <sdcDisconnect+0x16>
  sdcp->sdmmc->CLKCR = 0;
  208e30:	6058      	str	r0, [r3, #4]
  sdcp->sdmmc->POWER = 0;
  208e32:	6018      	str	r0, [r3, #0]
  208e34:	e7fa      	b.n	208e2c <sdcDisconnect+0x30>

00208e36 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
  208e36:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  208e3a:	4690      	mov	r8, r2
  208e3c:	f04f 0b00 	mov.w	fp, #0
  208e40:	4604      	mov	r4, r0
  208e42:	460e      	mov	r6, r1
  208e44:	4647      	mov	r7, r8
  208e46:	4699      	mov	r9, r3
  qnotify_t nfy = oqp->q_notify;
  208e48:	f8d0 a01c 	ldr.w	sl, [r0, #28]
  208e4c:	f7fb f954 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
  208e50:	b36f      	cbz	r7, 208eae <oqWriteTimeout+0x78>
  if (n > oqGetEmptyI(oqp)) {
  208e52:	68a3      	ldr	r3, [r4, #8]
  208e54:	429f      	cmp	r7, r3
  208e56:	d90d      	bls.n	208e74 <oqWriteTimeout+0x3e>
    n = oqGetEmptyI(oqp);
  208e58:	68a5      	ldr	r5, [r4, #8]
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
  208e5a:	e9d4 3004 	ldrd	r3, r0, [r4, #16]
  208e5e:	1a1b      	subs	r3, r3, r0
  if (n < s1) {
  208e60:	42ab      	cmp	r3, r5
  208e62:	d909      	bls.n	208e78 <oqWriteTimeout+0x42>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
  208e64:	462a      	mov	r2, r5
  208e66:	4631      	mov	r1, r6
  208e68:	f003 f9f6 	bl	20c258 <memcpy>
    oqp->q_wrptr += n;
  208e6c:	6963      	ldr	r3, [r4, #20]
  208e6e:	442b      	add	r3, r5
    oqp->q_wrptr = oqp->q_buffer;
  208e70:	6163      	str	r3, [r4, #20]
  208e72:	e012      	b.n	208e9a <oqWriteTimeout+0x64>
  if (n > oqGetEmptyI(oqp)) {
  208e74:	463d      	mov	r5, r7
  208e76:	e7f0      	b.n	208e5a <oqWriteTimeout+0x24>
  else if (n > s1) {
  208e78:	d221      	bcs.n	208ebe <oqWriteTimeout+0x88>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
  208e7a:	461a      	mov	r2, r3
  208e7c:	4631      	mov	r1, r6
  208e7e:	9301      	str	r3, [sp, #4]
  208e80:	f003 f9ea 	bl	20c258 <memcpy>
    s2 = n - s1;
  208e84:	9b01      	ldr	r3, [sp, #4]
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
  208e86:	68e0      	ldr	r0, [r4, #12]
    s2 = n - s1;
  208e88:	1aea      	subs	r2, r5, r3
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
  208e8a:	18f1      	adds	r1, r6, r3
  208e8c:	9201      	str	r2, [sp, #4]
  208e8e:	f003 f9e3 	bl	20c258 <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
  208e92:	68e3      	ldr	r3, [r4, #12]
  208e94:	9a01      	ldr	r2, [sp, #4]
  208e96:	441a      	add	r2, r3
  208e98:	6162      	str	r2, [r4, #20]
  oqp->q_counter -= n;
  208e9a:	68a3      	ldr	r3, [r4, #8]
  208e9c:	1b5b      	subs	r3, r3, r5
  208e9e:	60a3      	str	r3, [r4, #8]
    size_t done;

    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
  208ea0:	b99d      	cbnz	r5, 208eca <oqWriteTimeout+0x94>
  return chThdEnqueueTimeoutS(tqp, timeout);
  208ea2:	4649      	mov	r1, r9
  208ea4:	4620      	mov	r0, r4
  208ea6:	f7fc fab3 	bl	205410 <chThdEnqueueTimeoutS>
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
  208eaa:	2800      	cmp	r0, #0
  208eac:	d0d0      	beq.n	208e50 <oqWriteTimeout+0x1a>
  208eae:	2300      	movs	r3, #0
  208eb0:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
  208eb4:	eba8 0007 	sub.w	r0, r8, r7
  208eb8:	b003      	add	sp, #12
  208eba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
  208ebe:	462a      	mov	r2, r5
  208ec0:	4631      	mov	r1, r6
  208ec2:	f003 f9c9 	bl	20c258 <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
  208ec6:	68e3      	ldr	r3, [r4, #12]
  208ec8:	e7d2      	b.n	208e70 <oqWriteTimeout+0x3a>
      if (nfy != NULL) {
  208eca:	f1ba 0f00 	cmp.w	sl, #0
  208ece:	d001      	beq.n	208ed4 <oqWriteTimeout+0x9e>
        nfy(oqp);
  208ed0:	4620      	mov	r0, r4
  208ed2:	47d0      	blx	sl
  208ed4:	f38b 8811 	msr	BASEPRI, fp
      n  -= done;
  208ed8:	1b7f      	subs	r7, r7, r5
      bp += done;
  208eda:	442e      	add	r6, r5
  208edc:	f7fb f90c 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
  208ee0:	e7b6      	b.n	208e50 <oqWriteTimeout+0x1a>

00208ee2 <_writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
  208ee2:	3030      	adds	r0, #48	; 0x30
  208ee4:	f7ff bfa7 	b.w	208e36 <oqWriteTimeout>

00208ee8 <_write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
  208ee8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  208eec:	3030      	adds	r0, #48	; 0x30
  208eee:	f7ff bfa2 	b.w	208e36 <oqWriteTimeout>

00208ef2 <oqPutTimeout>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
  208ef2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  208ef4:	4604      	mov	r4, r0
  208ef6:	460d      	mov	r5, r1
  208ef8:	4616      	mov	r6, r2
  port_lock();
  208efa:	f7fb f8fd 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  while (oqIsFullI(oqp)) {
  208efe:	68a7      	ldr	r7, [r4, #8]
  208f00:	b1a7      	cbz	r7, 208f2c <oqPutTimeout+0x3a>
  oqp->q_counter--;
  208f02:	68a3      	ldr	r3, [r4, #8]
  208f04:	3b01      	subs	r3, #1
  208f06:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
  208f08:	6963      	ldr	r3, [r4, #20]
  208f0a:	1c5a      	adds	r2, r3, #1
  208f0c:	6162      	str	r2, [r4, #20]
  208f0e:	701d      	strb	r5, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
  208f10:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
  208f14:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
  208f16:	bf24      	itt	cs
  208f18:	68e3      	ldrcs	r3, [r4, #12]
  208f1a:	6163      	strcs	r3, [r4, #20]
  if (oqp->q_notify != NULL) {
  208f1c:	69e3      	ldr	r3, [r4, #28]
  208f1e:	b10b      	cbz	r3, 208f24 <oqPutTimeout+0x32>
    oqp->q_notify(oqp);
  208f20:	4620      	mov	r0, r4
  208f22:	4798      	blx	r3
  208f24:	2000      	movs	r0, #0
  208f26:	f380 8811 	msr	BASEPRI, r0
  return MSG_OK;
  208f2a:	e007      	b.n	208f3c <oqPutTimeout+0x4a>
  208f2c:	4631      	mov	r1, r6
  208f2e:	4620      	mov	r0, r4
  208f30:	f7fc fa6e 	bl	205410 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
  208f34:	2800      	cmp	r0, #0
  208f36:	dae2      	bge.n	208efe <oqPutTimeout+0xc>
  208f38:	f387 8811 	msr	BASEPRI, r7
}
  208f3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00208f3e <_putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
  208f3e:	3030      	adds	r0, #48	; 0x30
  208f40:	f7ff bfd7 	b.w	208ef2 <oqPutTimeout>

00208f44 <_put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
  208f44:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  208f48:	3030      	adds	r0, #48	; 0x30
  208f4a:	f7ff bfd2 	b.w	208ef2 <oqPutTimeout>

00208f4e <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
  208f4e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  208f52:	4690      	mov	r8, r2
  208f54:	f04f 0b00 	mov.w	fp, #0
  208f58:	4604      	mov	r4, r0
  208f5a:	460e      	mov	r6, r1
  208f5c:	4647      	mov	r7, r8
  208f5e:	4699      	mov	r9, r3
  qnotify_t nfy = iqp->q_notify;
  208f60:	f8d0 a01c 	ldr.w	sl, [r0, #28]
  208f64:	f7fb f8c8 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  while (n > 0U) {
  208f68:	b36f      	cbz	r7, 208fc6 <iqReadTimeout+0x78>
  if (n > iqGetFullI(iqp)) {
  208f6a:	68a3      	ldr	r3, [r4, #8]
  208f6c:	429f      	cmp	r7, r3
  208f6e:	d90d      	bls.n	208f8c <iqReadTimeout+0x3e>
    n = iqGetFullI(iqp);
  208f70:	68a5      	ldr	r5, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
  208f72:	69a1      	ldr	r1, [r4, #24]
  208f74:	6923      	ldr	r3, [r4, #16]
  208f76:	1a5b      	subs	r3, r3, r1
  if (n < s1) {
  208f78:	42ab      	cmp	r3, r5
  208f7a:	d909      	bls.n	208f90 <iqReadTimeout+0x42>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
  208f7c:	462a      	mov	r2, r5
  208f7e:	4630      	mov	r0, r6
  208f80:	f003 f96a 	bl	20c258 <memcpy>
    iqp->q_rdptr += n;
  208f84:	69a3      	ldr	r3, [r4, #24]
  208f86:	442b      	add	r3, r5
    iqp->q_rdptr = iqp->q_buffer;
  208f88:	61a3      	str	r3, [r4, #24]
  208f8a:	e012      	b.n	208fb2 <iqReadTimeout+0x64>
  if (n > iqGetFullI(iqp)) {
  208f8c:	463d      	mov	r5, r7
  208f8e:	e7f0      	b.n	208f72 <iqReadTimeout+0x24>
  else if (n > s1) {
  208f90:	d221      	bcs.n	208fd6 <iqReadTimeout+0x88>
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
  208f92:	461a      	mov	r2, r3
  208f94:	4630      	mov	r0, r6
  208f96:	9301      	str	r3, [sp, #4]
  208f98:	f003 f95e 	bl	20c258 <memcpy>
    s2 = n - s1;
  208f9c:	9b01      	ldr	r3, [sp, #4]
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
  208f9e:	68e1      	ldr	r1, [r4, #12]
    s2 = n - s1;
  208fa0:	1aea      	subs	r2, r5, r3
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
  208fa2:	18f0      	adds	r0, r6, r3
  208fa4:	9201      	str	r2, [sp, #4]
  208fa6:	f003 f957 	bl	20c258 <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
  208faa:	68e3      	ldr	r3, [r4, #12]
  208fac:	9a01      	ldr	r2, [sp, #4]
  208fae:	441a      	add	r2, r3
  208fb0:	61a2      	str	r2, [r4, #24]
  iqp->q_counter -= n;
  208fb2:	68a3      	ldr	r3, [r4, #8]
  208fb4:	1b5b      	subs	r3, r3, r5
  208fb6:	60a3      	str	r3, [r4, #8]
    if (done == (size_t)0) {
  208fb8:	b99d      	cbnz	r5, 208fe2 <iqReadTimeout+0x94>
  208fba:	4649      	mov	r1, r9
  208fbc:	4620      	mov	r0, r4
  208fbe:	f7fc fa27 	bl	205410 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
  208fc2:	2800      	cmp	r0, #0
  208fc4:	d0d0      	beq.n	208f68 <iqReadTimeout+0x1a>
  208fc6:	2300      	movs	r3, #0
  208fc8:	f383 8811 	msr	BASEPRI, r3
}
  208fcc:	eba8 0007 	sub.w	r0, r8, r7
  208fd0:	b003      	add	sp, #12
  208fd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
  208fd6:	462a      	mov	r2, r5
  208fd8:	4630      	mov	r0, r6
  208fda:	f003 f93d 	bl	20c258 <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
  208fde:	68e3      	ldr	r3, [r4, #12]
  208fe0:	e7d2      	b.n	208f88 <iqReadTimeout+0x3a>
      if (nfy != NULL) {
  208fe2:	f1ba 0f00 	cmp.w	sl, #0
  208fe6:	d001      	beq.n	208fec <iqReadTimeout+0x9e>
        nfy(iqp);
  208fe8:	4620      	mov	r0, r4
  208fea:	47d0      	blx	sl
  208fec:	f38b 8811 	msr	BASEPRI, fp
      n  -= done;
  208ff0:	1b7f      	subs	r7, r7, r5
      bp += done;
  208ff2:	442e      	add	r6, r5
  208ff4:	f7fb f880 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  _dbg_check_lock();
  208ff8:	e7b6      	b.n	208f68 <iqReadTimeout+0x1a>

00208ffa <_readt>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
  208ffa:	300c      	adds	r0, #12
  208ffc:	f7ff bfa7 	b.w	208f4e <iqReadTimeout>

00209000 <_read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
  209000:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  209004:	300c      	adds	r0, #12
  209006:	f7ff bfa2 	b.w	208f4e <iqReadTimeout>

0020900a <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
  20900a:	b570      	push	{r4, r5, r6, lr}
  20900c:	4604      	mov	r4, r0
  20900e:	460d      	mov	r5, r1
  port_lock();
  209010:	f7fb f872 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  while (iqIsEmptyI(iqp)) {
  209014:	68a6      	ldr	r6, [r4, #8]
  209016:	b1a6      	cbz	r6, 209042 <iqGetTimeout+0x38>
  iqp->q_counter--;
  209018:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  20901a:	69a2      	ldr	r2, [r4, #24]
  iqp->q_counter--;
  20901c:	3b01      	subs	r3, #1
  20901e:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  209020:	1c53      	adds	r3, r2, #1
  209022:	61a3      	str	r3, [r4, #24]
  209024:	7815      	ldrb	r5, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
  209026:	6922      	ldr	r2, [r4, #16]
  209028:	4293      	cmp	r3, r2
    iqp->q_rdptr = iqp->q_buffer;
  20902a:	bf24      	itt	cs
  20902c:	68e3      	ldrcs	r3, [r4, #12]
  20902e:	61a3      	strcs	r3, [r4, #24]
  if (iqp->q_notify != NULL) {
  209030:	69e3      	ldr	r3, [r4, #28]
  209032:	b10b      	cbz	r3, 209038 <iqGetTimeout+0x2e>
    iqp->q_notify(iqp);
  209034:	4620      	mov	r0, r4
  209036:	4798      	blx	r3
  209038:	2300      	movs	r3, #0
  20903a:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
  20903e:	4628      	mov	r0, r5
  209040:	e007      	b.n	209052 <iqGetTimeout+0x48>
  209042:	4629      	mov	r1, r5
  209044:	4620      	mov	r0, r4
  209046:	f7fc f9e3 	bl	205410 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
  20904a:	2800      	cmp	r0, #0
  20904c:	dae2      	bge.n	209014 <iqGetTimeout+0xa>
  20904e:	f386 8811 	msr	BASEPRI, r6
}
  209052:	bd70      	pop	{r4, r5, r6, pc}

00209054 <_gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
  209054:	300c      	adds	r0, #12
  209056:	f7ff bfd8 	b.w	20900a <iqGetTimeout>

0020905a <_get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
  20905a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  20905e:	300c      	adds	r0, #12
  209060:	f7ff bfd3 	b.w	20900a <iqGetTimeout>

00209064 <obqWriteTimeout>:
                       size_t n, sysinterval_t timeout) {
  209064:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  size_t w = 0;
  209068:	2600      	movs	r6, #0
                       size_t n, sysinterval_t timeout) {
  20906a:	4604      	mov	r4, r0
  20906c:	460d      	mov	r5, r1
  20906e:	4690      	mov	r8, r2
  209070:	46b2      	mov	sl, r6
  209072:	4699      	mov	r9, r3
  209074:	f7fb f840 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
    if (obqp->ptr == NULL) {
  209078:	6aa7      	ldr	r7, [r4, #40]	; 0x28
  20907a:	b94f      	cbnz	r7, 209090 <obqWriteTimeout+0x2c>
      msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
  20907c:	4649      	mov	r1, r9
  20907e:	4620      	mov	r0, r4
  209080:	f7ff fa7a 	bl	208578 <obqGetEmptyBufferTimeoutS>
      if (msg != MSG_OK) {
  209084:	b120      	cbz	r0, 209090 <obqWriteTimeout+0x2c>
  209086:	f387 8811 	msr	BASEPRI, r7
}
  20908a:	4630      	mov	r0, r6
  20908c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    size = (size_t)obqp->top - (size_t)obqp->ptr;
  209090:	e9d4 070a 	ldrd	r0, r7, [r4, #40]	; 0x28
  209094:	1a3a      	subs	r2, r7, r0
    if (size > (n - w)) {
  209096:	eba8 0706 	sub.w	r7, r8, r6
  20909a:	4297      	cmp	r7, r2
  20909c:	bf28      	it	cs
  20909e:	4617      	movcs	r7, r2
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
  2090a0:	2f40      	cmp	r7, #64	; 0x40
  2090a2:	d91b      	bls.n	2090dc <obqWriteTimeout+0x78>
      memcpy(obqp->ptr, bp, (size_t)BUFFERS_CHUNKS_SIZE);
  2090a4:	f105 0340 	add.w	r3, r5, #64	; 0x40
  2090a8:	f855 2b04 	ldr.w	r2, [r5], #4
  2090ac:	429d      	cmp	r5, r3
  2090ae:	f840 2b04 	str.w	r2, [r0], #4
  2090b2:	d1f9      	bne.n	2090a8 <obqWriteTimeout+0x44>
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
  2090b4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      w         += (size_t)BUFFERS_CHUNKS_SIZE;
  2090b6:	3640      	adds	r6, #64	; 0x40
      obqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
  2090b8:	3340      	adds	r3, #64	; 0x40
  2090ba:	62a3      	str	r3, [r4, #40]	; 0x28
    if (obqp->ptr >= obqp->top) {
  2090bc:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	; 0x28
  2090c0:	429a      	cmp	r2, r3
  2090c2:	d304      	bcc.n	2090ce <obqWriteTimeout+0x6a>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
  2090c4:	69e1      	ldr	r1, [r4, #28]
  2090c6:	4620      	mov	r0, r4
  2090c8:	3904      	subs	r1, #4
  2090ca:	f7ff f859 	bl	208180 <obqPostFullBufferS>
  2090ce:	f38a 8811 	msr	BASEPRI, sl
    if (w >= n) {
  2090d2:	4546      	cmp	r6, r8
  2090d4:	d2d9      	bcs.n	20908a <obqWriteTimeout+0x26>
  2090d6:	f7fb f80f 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  _dbg_check_lock();
  2090da:	e7cd      	b.n	209078 <obqWriteTimeout+0x14>
      memcpy(obqp->ptr, bp, size);
  2090dc:	4629      	mov	r1, r5
  2090de:	463a      	mov	r2, r7
  2090e0:	f003 f8ba 	bl	20c258 <memcpy>
      obqp->ptr += size;
  2090e4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      bp        += size;
  2090e6:	443d      	add	r5, r7
      w         += size;
  2090e8:	443e      	add	r6, r7
      obqp->ptr += size;
  2090ea:	443b      	add	r3, r7
  2090ec:	62a3      	str	r3, [r4, #40]	; 0x28
      w         += size;
  2090ee:	e7e5      	b.n	2090bc <obqWriteTimeout+0x58>

002090f0 <_writet.lto_priv.0>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
  2090f0:	3044      	adds	r0, #68	; 0x44
  2090f2:	f7ff bfb7 	b.w	209064 <obqWriteTimeout>

002090f6 <_write.lto_priv.0>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
  2090f6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  2090fa:	3044      	adds	r0, #68	; 0x44
  2090fc:	f7ff bfb2 	b.w	209064 <obqWriteTimeout>

00209100 <obqPutTimeout>:
                    sysinterval_t timeout) {
  209100:	b573      	push	{r0, r1, r4, r5, r6, lr}
  209102:	4604      	mov	r4, r0
  209104:	460d      	mov	r5, r1
  209106:	9201      	str	r2, [sp, #4]
  port_lock();
  209108:	f7fa fff6 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  if (obqp->ptr == NULL) {
  20910c:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  20910e:	9901      	ldr	r1, [sp, #4]
  209110:	b93e      	cbnz	r6, 209122 <obqPutTimeout+0x22>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
  209112:	4620      	mov	r0, r4
  209114:	f7ff fa30 	bl	208578 <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
  209118:	b118      	cbz	r0, 209122 <obqPutTimeout+0x22>
  20911a:	f386 8811 	msr	BASEPRI, r6
}
  20911e:	b002      	add	sp, #8
  209120:	bd70      	pop	{r4, r5, r6, pc}
  *obqp->ptr = b;
  209122:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  209124:	701d      	strb	r5, [r3, #0]
  obqp->ptr++;
  209126:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
  209128:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  obqp->ptr++;
  20912a:	3301      	adds	r3, #1
  if (obqp->ptr >= obqp->top) {
  20912c:	4293      	cmp	r3, r2
  obqp->ptr++;
  20912e:	62a3      	str	r3, [r4, #40]	; 0x28
  if (obqp->ptr >= obqp->top) {
  209130:	d304      	bcc.n	20913c <obqPutTimeout+0x3c>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
  209132:	69e1      	ldr	r1, [r4, #28]
  209134:	4620      	mov	r0, r4
  209136:	3904      	subs	r1, #4
  209138:	f7ff f822 	bl	208180 <obqPostFullBufferS>
  20913c:	2000      	movs	r0, #0
  20913e:	f380 8811 	msr	BASEPRI, r0
  return MSG_OK;
  209142:	e7ec      	b.n	20911e <obqPutTimeout+0x1e>

00209144 <_putt.lto_priv.0>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
  209144:	3044      	adds	r0, #68	; 0x44
  209146:	f7ff bfdb 	b.w	209100 <obqPutTimeout>

0020914a <_put.lto_priv.0>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
  20914a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  20914e:	3044      	adds	r0, #68	; 0x44
  209150:	f7ff bfd6 	b.w	209100 <obqPutTimeout>

00209154 <ibqReadTimeout>:
                      size_t n, sysinterval_t timeout) {
  209154:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  size_t r = 0;
  209158:	2500      	movs	r5, #0
                      size_t n, sysinterval_t timeout) {
  20915a:	4604      	mov	r4, r0
  20915c:	460e      	mov	r6, r1
  20915e:	4617      	mov	r7, r2
  209160:	46a9      	mov	r9, r5
  209162:	4698      	mov	r8, r3
  209164:	f7fa ffc8 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
    if (ibqp->ptr == NULL) {
  209168:	f8d4 a028 	ldr.w	sl, [r4, #40]	; 0x28
  20916c:	f1ba 0f00 	cmp.w	sl, #0
  209170:	d109      	bne.n	209186 <ibqReadTimeout+0x32>
      msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
  209172:	4641      	mov	r1, r8
  209174:	4620      	mov	r0, r4
  209176:	f7ff fa18 	bl	2085aa <ibqGetFullBufferTimeoutS>
      if (msg != MSG_OK) {
  20917a:	b120      	cbz	r0, 209186 <ibqReadTimeout+0x32>
  20917c:	f38a 8811 	msr	BASEPRI, sl
}
  209180:	4628      	mov	r0, r5
  209182:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
  209186:	e9d4 120a 	ldrd	r1, r2, [r4, #40]	; 0x28
    if (size > (n - r)) {
  20918a:	eba7 0a05 	sub.w	sl, r7, r5
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
  20918e:	1a52      	subs	r2, r2, r1
    if (size > (n - r)) {
  209190:	4592      	cmp	sl, r2
  209192:	bf28      	it	cs
  209194:	4692      	movcs	sl, r2
    if (size > (size_t)BUFFERS_CHUNKS_SIZE) {
  209196:	f1ba 0f40 	cmp.w	sl, #64	; 0x40
  20919a:	d91b      	bls.n	2091d4 <ibqReadTimeout+0x80>
      memcpy(bp, ibqp->ptr, BUFFERS_CHUNKS_SIZE);
  20919c:	4633      	mov	r3, r6
  20919e:	f101 0240 	add.w	r2, r1, #64	; 0x40
  2091a2:	f851 0b04 	ldr.w	r0, [r1], #4
  2091a6:	4291      	cmp	r1, r2
  2091a8:	f843 0b04 	str.w	r0, [r3], #4
  2091ac:	d1f9      	bne.n	2091a2 <ibqReadTimeout+0x4e>
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
  2091ae:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      bp        += (size_t)BUFFERS_CHUNKS_SIZE;
  2091b0:	3640      	adds	r6, #64	; 0x40
      r         += (size_t)BUFFERS_CHUNKS_SIZE;
  2091b2:	3540      	adds	r5, #64	; 0x40
      ibqp->ptr += (size_t)BUFFERS_CHUNKS_SIZE;
  2091b4:	3340      	adds	r3, #64	; 0x40
  2091b6:	62a3      	str	r3, [r4, #40]	; 0x28
    if (ibqp->ptr >= ibqp->top) {
  2091b8:	e9d4 230a 	ldrd	r2, r3, [r4, #40]	; 0x28
  2091bc:	429a      	cmp	r2, r3
  2091be:	d302      	bcc.n	2091c6 <ibqReadTimeout+0x72>
      ibqReleaseEmptyBufferS(ibqp);
  2091c0:	4620      	mov	r0, r4
  2091c2:	f7fe fff0 	bl	2081a6 <ibqReleaseEmptyBufferS>
  2091c6:	f389 8811 	msr	BASEPRI, r9
    if (r >= n) {
  2091ca:	42bd      	cmp	r5, r7
  2091cc:	d2d8      	bcs.n	209180 <ibqReadTimeout+0x2c>
  2091ce:	f7fa ff93 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  _dbg_check_lock();
  2091d2:	e7c9      	b.n	209168 <ibqReadTimeout+0x14>
      memcpy(bp, ibqp->ptr, size);
  2091d4:	4630      	mov	r0, r6
  2091d6:	4652      	mov	r2, sl
  2091d8:	f003 f83e 	bl	20c258 <memcpy>
      ibqp->ptr += size;
  2091dc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      bp        += size;
  2091de:	4456      	add	r6, sl
      r         += size;
  2091e0:	4455      	add	r5, sl
      ibqp->ptr += size;
  2091e2:	4453      	add	r3, sl
  2091e4:	62a3      	str	r3, [r4, #40]	; 0x28
      r         += size;
  2091e6:	e7e7      	b.n	2091b8 <ibqReadTimeout+0x64>

002091e8 <_readt.lto_priv.0>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
  2091e8:	300c      	adds	r0, #12
  2091ea:	f7ff bfb3 	b.w	209154 <ibqReadTimeout>

002091ee <_read.lto_priv.0>:
  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
  2091ee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  2091f2:	300c      	adds	r0, #12
  2091f4:	f7ff bfae 	b.w	209154 <ibqReadTimeout>

002091f8 <ibqGetTimeout>:
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, sysinterval_t timeout) {
  2091f8:	b573      	push	{r0, r1, r4, r5, r6, lr}
  2091fa:	4604      	mov	r4, r0
  2091fc:	9101      	str	r1, [sp, #4]
  port_lock();
  2091fe:	f7fa ff7b 	bl	2040f8 <port_lock.lto_priv.0.lto_priv.0>
  if (ibqp->ptr == NULL) {
  209202:	9901      	ldr	r1, [sp, #4]
  209204:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  209206:	b94e      	cbnz	r6, 20921c <ibqGetTimeout+0x24>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
  209208:	4620      	mov	r0, r4
  20920a:	f7ff f9ce 	bl	2085aa <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
  20920e:	4605      	mov	r5, r0
  209210:	b120      	cbz	r0, 20921c <ibqGetTimeout+0x24>
  209212:	f386 8811 	msr	BASEPRI, r6
}
  209216:	4628      	mov	r0, r5
  209218:	b002      	add	sp, #8
  20921a:	bd70      	pop	{r4, r5, r6, pc}
  msg = (msg_t)*ibqp->ptr;
  20921c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
  20921e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  msg = (msg_t)*ibqp->ptr;
  209220:	f813 5b01 	ldrb.w	r5, [r3], #1
  if (ibqp->ptr >= ibqp->top) {
  209224:	4293      	cmp	r3, r2
  ibqp->ptr++;
  209226:	62a3      	str	r3, [r4, #40]	; 0x28
  if (ibqp->ptr >= ibqp->top) {
  209228:	d302      	bcc.n	209230 <ibqGetTimeout+0x38>
    ibqReleaseEmptyBufferS(ibqp);
  20922a:	4620      	mov	r0, r4
  20922c:	f7fe ffbb 	bl	2081a6 <ibqReleaseEmptyBufferS>
  209230:	2300      	movs	r3, #0
  209232:	f383 8811 	msr	BASEPRI, r3
  return msg;
  209236:	e7ee      	b.n	209216 <ibqGetTimeout+0x1e>

00209238 <_gett.lto_priv.0>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
  209238:	300c      	adds	r0, #12
  20923a:	f7ff bfdd 	b.w	2091f8 <ibqGetTimeout>

0020923e <_get.lto_priv.0>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
  20923e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  209242:	300c      	adds	r0, #12
  209244:	f7ff bfd8 	b.w	2091f8 <ibqGetTimeout>

00209248 <__errno>:

int *
__errno ()
{
  return &_REENT->_errno;
}
  209248:	4b01      	ldr	r3, [pc, #4]	; (209250 <__errno+0x8>)
  20924a:	6818      	ldr	r0, [r3, #0]
  20924c:	4770      	bx	lr
  20924e:	bf00      	nop
  209250:	20010060 	.word	0x20010060

00209254 <malloc_stats>:

#if !defined (_ELIX_LEVEL) || _ELIX_LEVEL >= 2
void
malloc_stats (void)
{
  _malloc_stats_r (_REENT);
  209254:	4b01      	ldr	r3, [pc, #4]	; (20925c <malloc_stats+0x8>)
  209256:	6818      	ldr	r0, [r3, #0]
  209258:	f000 b890 	b.w	20937c <_malloc_stats_r>
  20925c:	20010060 	.word	0x20010060

00209260 <_mallinfo_r>:

#ifdef DEFINE_MALLINFO
struct mallinfo current_mallinfo={0,0,0,0,0,0,0,0,0,0};

struct mallinfo nano_mallinfo(RONEARG)
{
  209260:	b570      	push	{r4, r5, r6, lr}
    size_t free_size = 0;
    size_t total_size;

    MALLOC_LOCK;

    if (sbrk_start == NULL) total_size = 0;
  209262:	4c16      	ldr	r4, [pc, #88]	; (2092bc <_mallinfo_r+0x5c>)
{
  209264:	4605      	mov	r5, r0
    MALLOC_LOCK;
  209266:	4608      	mov	r0, r1
{
  209268:	460e      	mov	r6, r1
    MALLOC_LOCK;
  20926a:	f7fb f817 	bl	20429c <__malloc_lock>
    if (sbrk_start == NULL) total_size = 0;
  20926e:	6823      	ldr	r3, [r4, #0]
  209270:	b143      	cbz	r3, 209284 <_mallinfo_r+0x24>
    else {
        sbrk_now = _SBRK_R(RCALL 0);
  209272:	2100      	movs	r1, #0
  209274:	4630      	mov	r0, r6
  209276:	f000 fef5 	bl	20a064 <_sbrk_r>

        if (sbrk_now == (void *)-1)
  20927a:	1c42      	adds	r2, r0, #1
        sbrk_now = _SBRK_R(RCALL 0);
  20927c:	4603      	mov	r3, r0
            total_size = (size_t)-1;
        else
            total_size = (size_t) (sbrk_now - sbrk_start);
  20927e:	bf1c      	itt	ne
  209280:	6820      	ldrne	r0, [r4, #0]
  209282:	1a1b      	subne	r3, r3, r0
    }

    for (pf = free_list; pf; pf = pf->next)
  209284:	4a0e      	ldr	r2, [pc, #56]	; (2092c0 <_mallinfo_r+0x60>)
    size_t free_size = 0;
  209286:	2000      	movs	r0, #0
    for (pf = free_list; pf; pf = pf->next)
  209288:	6812      	ldr	r2, [r2, #0]
  20928a:	b992      	cbnz	r2, 2092b2 <_mallinfo_r+0x52>
        free_size += pf->size;

    current_mallinfo.arena = total_size;
  20928c:	4c0d      	ldr	r4, [pc, #52]	; (2092c4 <_mallinfo_r+0x64>)
  20928e:	6023      	str	r3, [r4, #0]
    current_mallinfo.fordblks = free_size;
    current_mallinfo.uordblks = total_size - free_size;
  209290:	1a1b      	subs	r3, r3, r0
    current_mallinfo.fordblks = free_size;
  209292:	6220      	str	r0, [r4, #32]

    MALLOC_UNLOCK;
  209294:	4630      	mov	r0, r6
    current_mallinfo.uordblks = total_size - free_size;
  209296:	61e3      	str	r3, [r4, #28]
    return current_mallinfo;
  209298:	462e      	mov	r6, r5
    MALLOC_UNLOCK;
  20929a:	f7fc fed5 	bl	206048 <__malloc_unlock>
    return current_mallinfo;
  20929e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  2092a0:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  2092a2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  2092a4:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  2092a6:	e894 0003 	ldmia.w	r4, {r0, r1}
  2092aa:	e886 0003 	stmia.w	r6, {r0, r1}
}
  2092ae:	4628      	mov	r0, r5
  2092b0:	bd70      	pop	{r4, r5, r6, pc}
        free_size += pf->size;
  2092b2:	6811      	ldr	r1, [r2, #0]
    for (pf = free_list; pf; pf = pf->next)
  2092b4:	6852      	ldr	r2, [r2, #4]
        free_size += pf->size;
  2092b6:	4408      	add	r0, r1
  2092b8:	e7e7      	b.n	20928a <_mallinfo_r+0x2a>
  2092ba:	bf00      	nop
  2092bc:	2000409c 	.word	0x2000409c
  2092c0:	20004098 	.word	0x20004098
  2092c4:	20004070 	.word	0x20004070

002092c8 <_malloc_r>:
{
  2092c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    alloc_size = ALIGN_TO(s, CHUNK_ALIGN); /* size of aligned data load */
  2092ca:	1ccd      	adds	r5, r1, #3
{
  2092cc:	4606      	mov	r6, r0
    alloc_size = ALIGN_TO(s, CHUNK_ALIGN); /* size of aligned data load */
  2092ce:	f025 0503 	bic.w	r5, r5, #3
    alloc_size += CHUNK_OFFSET; /* size of chunk head */
  2092d2:	3508      	adds	r5, #8
    alloc_size = MAX(alloc_size, MALLOC_MINCHUNK);
  2092d4:	2d0c      	cmp	r5, #12
  2092d6:	bf38      	it	cc
  2092d8:	250c      	movcc	r5, #12
    if (alloc_size >= MAX_ALLOC_SIZE || alloc_size < s)
  2092da:	2d00      	cmp	r5, #0
  2092dc:	db01      	blt.n	2092e2 <_malloc_r+0x1a>
  2092de:	42a9      	cmp	r1, r5
  2092e0:	d903      	bls.n	2092ea <_malloc_r+0x22>
        RERRNO = ENOMEM;
  2092e2:	230c      	movs	r3, #12
  2092e4:	6033      	str	r3, [r6, #0]
            return NULL;
  2092e6:	2000      	movs	r0, #0
}
  2092e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    MALLOC_LOCK;
  2092ea:	f7fa ffd7 	bl	20429c <__malloc_lock>
    p = free_list;
  2092ee:	4921      	ldr	r1, [pc, #132]	; (209374 <_malloc_r+0xac>)
  2092f0:	680a      	ldr	r2, [r1, #0]
    r = p;
  2092f2:	4614      	mov	r4, r2
    while (r)
  2092f4:	b99c      	cbnz	r4, 20931e <_malloc_r+0x56>
    if (sbrk_start == NULL) sbrk_start = _SBRK_R(RCALL 0);
  2092f6:	4f20      	ldr	r7, [pc, #128]	; (209378 <_malloc_r+0xb0>)
  2092f8:	683b      	ldr	r3, [r7, #0]
  2092fa:	b923      	cbnz	r3, 209306 <_malloc_r+0x3e>
  2092fc:	4621      	mov	r1, r4
  2092fe:	4630      	mov	r0, r6
  209300:	f000 feb0 	bl	20a064 <_sbrk_r>
  209304:	6038      	str	r0, [r7, #0]
    p = _SBRK_R(RCALL s);
  209306:	4629      	mov	r1, r5
  209308:	4630      	mov	r0, r6
  20930a:	f000 feab 	bl	20a064 <_sbrk_r>
    if (p == (void *)-1)
  20930e:	1c43      	adds	r3, r0, #1
  209310:	d123      	bne.n	20935a <_malloc_r+0x92>
            RERRNO = ENOMEM;
  209312:	230c      	movs	r3, #12
            MALLOC_UNLOCK;
  209314:	4630      	mov	r0, r6
            RERRNO = ENOMEM;
  209316:	6033      	str	r3, [r6, #0]
            MALLOC_UNLOCK;
  209318:	f7fc fe96 	bl	206048 <__malloc_unlock>
  20931c:	e7e3      	b.n	2092e6 <_malloc_r+0x1e>
        int rem = r->size - alloc_size;
  20931e:	6823      	ldr	r3, [r4, #0]
        if (rem >= 0)
  209320:	1b5b      	subs	r3, r3, r5
  209322:	d417      	bmi.n	209354 <_malloc_r+0x8c>
            if (rem >= MALLOC_MINCHUNK)
  209324:	2b0b      	cmp	r3, #11
  209326:	d903      	bls.n	209330 <_malloc_r+0x68>
                r->size = rem;
  209328:	6023      	str	r3, [r4, #0]
                r = (chunk *)((char *)r + rem);
  20932a:	441c      	add	r4, r3
        r->size = alloc_size;
  20932c:	6025      	str	r5, [r4, #0]
  20932e:	e004      	b.n	20933a <_malloc_r+0x72>
            else if (p == r)
  209330:	6863      	ldr	r3, [r4, #4]
  209332:	42a2      	cmp	r2, r4
                free_list = r->next;
  209334:	bf0c      	ite	eq
  209336:	600b      	streq	r3, [r1, #0]
                p->next = r->next;
  209338:	6053      	strne	r3, [r2, #4]
    MALLOC_UNLOCK;
  20933a:	4630      	mov	r0, r6
  20933c:	f7fc fe84 	bl	206048 <__malloc_unlock>
    align_ptr = (char *)ALIGN_TO((unsigned long)ptr, MALLOC_ALIGN);
  209340:	f104 000b 	add.w	r0, r4, #11
    ptr = (char *)r + CHUNK_OFFSET;
  209344:	1d23      	adds	r3, r4, #4
    align_ptr = (char *)ALIGN_TO((unsigned long)ptr, MALLOC_ALIGN);
  209346:	f020 0007 	bic.w	r0, r0, #7
    if (offset)
  20934a:	1ac2      	subs	r2, r0, r3
  20934c:	d0cc      	beq.n	2092e8 <_malloc_r+0x20>
        *(long *)((char *)r + offset) = -offset;
  20934e:	1a1b      	subs	r3, r3, r0
  209350:	50a3      	str	r3, [r4, r2]
  209352:	e7c9      	b.n	2092e8 <_malloc_r+0x20>
        r=r->next;
  209354:	4622      	mov	r2, r4
  209356:	6864      	ldr	r4, [r4, #4]
  209358:	e7cc      	b.n	2092f4 <_malloc_r+0x2c>
    align_p = (char*)ALIGN_TO((unsigned long)p, CHUNK_ALIGN);
  20935a:	1cc4      	adds	r4, r0, #3
  20935c:	f024 0403 	bic.w	r4, r4, #3
    if (align_p != p)
  209360:	42a0      	cmp	r0, r4
  209362:	d0e3      	beq.n	20932c <_malloc_r+0x64>
        p = _SBRK_R(RCALL align_p - p);
  209364:	1a21      	subs	r1, r4, r0
  209366:	4630      	mov	r0, r6
  209368:	f000 fe7c 	bl	20a064 <_sbrk_r>
        if (p == (void *)-1)
  20936c:	3001      	adds	r0, #1
  20936e:	d1dd      	bne.n	20932c <_malloc_r+0x64>
  209370:	e7cf      	b.n	209312 <_malloc_r+0x4a>
  209372:	bf00      	nop
  209374:	20004098 	.word	0x20004098
  209378:	2000409c 	.word	0x2000409c

0020937c <_malloc_stats_r>:
#endif /* DEFINE_MALLINFO */

#ifdef DEFINE_MALLOC_STATS
void nano_malloc_stats(RONEARG)
{
  20937c:	b530      	push	{r4, r5, lr}
  20937e:	b08b      	sub	sp, #44	; 0x2c
    nano_mallinfo(RONECALL);
    fiprintf(stderr, "max system bytes = %10u\n",
  209380:	4d0d      	ldr	r5, [pc, #52]	; (2093b8 <_malloc_stats_r+0x3c>)
{
  209382:	4601      	mov	r1, r0
    fiprintf(stderr, "max system bytes = %10u\n",
  209384:	4c0d      	ldr	r4, [pc, #52]	; (2093bc <_malloc_stats_r+0x40>)
    nano_mallinfo(RONECALL);
  209386:	4668      	mov	r0, sp
  209388:	f7ff ff6a 	bl	209260 <_mallinfo_r>
    fiprintf(stderr, "max system bytes = %10u\n",
  20938c:	682b      	ldr	r3, [r5, #0]
  20938e:	6822      	ldr	r2, [r4, #0]
  209390:	490b      	ldr	r1, [pc, #44]	; (2093c0 <_malloc_stats_r+0x44>)
  209392:	68d8      	ldr	r0, [r3, #12]
  209394:	f002 fbac 	bl	20baf0 <fiprintf>
             current_mallinfo.arena);
    fiprintf(stderr, "system bytes     = %10u\n",
  209398:	682b      	ldr	r3, [r5, #0]
  20939a:	6822      	ldr	r2, [r4, #0]
  20939c:	4909      	ldr	r1, [pc, #36]	; (2093c4 <_malloc_stats_r+0x48>)
  20939e:	68d8      	ldr	r0, [r3, #12]
  2093a0:	f002 fba6 	bl	20baf0 <fiprintf>
             current_mallinfo.arena);
    fiprintf(stderr, "in use bytes     = %10u\n",
  2093a4:	682b      	ldr	r3, [r5, #0]
  2093a6:	69e2      	ldr	r2, [r4, #28]
  2093a8:	4907      	ldr	r1, [pc, #28]	; (2093c8 <_malloc_stats_r+0x4c>)
  2093aa:	68d8      	ldr	r0, [r3, #12]
             current_mallinfo.uordblks);
}
  2093ac:	b00b      	add	sp, #44	; 0x2c
  2093ae:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    fiprintf(stderr, "in use bytes     = %10u\n",
  2093b2:	f002 bb9d 	b.w	20baf0 <fiprintf>
  2093b6:	bf00      	nop
  2093b8:	20010060 	.word	0x20010060
  2093bc:	20004070 	.word	0x20004070
  2093c0:	0800eb6c 	.word	0x0800eb6c
  2093c4:	0800eb85 	.word	0x0800eb85
  2093c8:	0800eb9e 	.word	0x0800eb9e

002093cc <__cvt>:
   [aAeEfFgG]; if it is [aA], then the return string lives in BUF,
   otherwise the return value shares the mprec reentrant storage.  */
char *
__cvt (struct _reent *data, _PRINTF_FLOAT_TYPE value, int ndigits, int flags,
       char *sign, int *decpt, int ch, int *length, char *buf)
{
  2093cc:	b5f0      	push	{r4, r5, r6, r7, lr}
  2093ce:	ed2d 8b02 	vpush	{d8}
  2093d2:	eeb0 8b40 	vmov.f64	d8, d0
  2093d6:	b085      	sub	sp, #20
  2093d8:	4617      	mov	r7, r2
  2093da:	460c      	mov	r4, r1
      *sign = '-';
    }
  else
    *sign = '\000';

  if (ch == 'f' || ch == 'F')
  2093dc:	9d0d      	ldr	r5, [sp, #52]	; 0x34
  if (word0 (tmp) & Sign_bit)
  2093de:	ee18 2a90 	vmov	r2, s17
{
  2093e2:	9e0c      	ldr	r6, [sp, #48]	; 0x30
  if (ch == 'f' || ch == 'F')
  2093e4:	f025 0520 	bic.w	r5, r5, #32
  if (word0 (tmp) & Sign_bit)
  2093e8:	2a00      	cmp	r2, #0
      *sign = '-';
  2093ea:	bfb6      	itet	lt
  2093ec:	222d      	movlt	r2, #45	; 0x2d
    *sign = '\000';
  2093ee:	2200      	movge	r2, #0
      value = -value;
  2093f0:	eeb1 8b40 	vneglt.f64	d8, d0
  if (ch == 'f' || ch == 'F')
  2093f4:	2d46      	cmp	r5, #70	; 0x46
  2093f6:	701a      	strb	r2, [r3, #0]
  2093f8:	d004      	beq.n	209404 <__cvt+0x38>
    }
  else
    {
      /* To obtain ndigits after the decimal point for the 'e'
	 and 'E' formats, round to ndigits + 1 significant figures.  */
      if (ch == 'e' || ch == 'E')
  2093fa:	2d45      	cmp	r5, #69	; 0x45
  2093fc:	d100      	bne.n	209400 <__cvt+0x34>
	{
	  ndigits++;
  2093fe:	3401      	adds	r4, #1
	}
      /* Ndigits significant digits.  */
      mode = 2;
  209400:	2102      	movs	r1, #2
  209402:	e000      	b.n	209406 <__cvt+0x3a>
      mode = 3;
  209404:	2103      	movs	r1, #3
    }

  digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
  209406:	ab03      	add	r3, sp, #12
  209408:	eeb0 0b48 	vmov.f64	d0, d8
  20940c:	4622      	mov	r2, r4
  20940e:	9301      	str	r3, [sp, #4]
  209410:	ab02      	add	r3, sp, #8
  209412:	9300      	str	r3, [sp, #0]
  209414:	4633      	mov	r3, r6
  209416:	f001 fd53 	bl	20aec0 <_dtoa_r>

  /* Print trailing zeros.  */
  if ((ch != 'g' && ch != 'G') || flags & ALT)
  20941a:	2d47      	cmp	r5, #71	; 0x47
  20941c:	d109      	bne.n	209432 <__cvt+0x66>
  20941e:	07fb      	lsls	r3, r7, #31
  209420:	d407      	bmi.n	209432 <__cvt+0x66>
      if (value == 0)
	rve = bp;
      while (rve < bp)
	*rve++ = '0';
    }
  *length = rve - digits;
  209422:	9b03      	ldr	r3, [sp, #12]
  209424:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  209426:	1a1b      	subs	r3, r3, r0
  209428:	6013      	str	r3, [r2, #0]
  return (digits);
}
  20942a:	b005      	add	sp, #20
  20942c:	ecbd 8b02 	vpop	{d8}
  209430:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (ch == 'f' || ch == 'F')
  209432:	2d46      	cmp	r5, #70	; 0x46
      bp = digits + ndigits;
  209434:	eb00 0204 	add.w	r2, r0, r4
      if (ch == 'f' || ch == 'F')
  209438:	d10c      	bne.n	209454 <__cvt+0x88>
	  if (*digits == '0' && value)
  20943a:	7803      	ldrb	r3, [r0, #0]
  20943c:	2b30      	cmp	r3, #48	; 0x30
  20943e:	d107      	bne.n	209450 <__cvt+0x84>
  209440:	eeb5 8b40 	vcmp.f64	d8, #0.0
  209444:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	    *decpt = -ndigits + 1;
  209448:	bf1c      	itt	ne
  20944a:	f1c4 0401 	rsbne	r4, r4, #1
  20944e:	6034      	strne	r4, [r6, #0]
	  bp += *decpt;
  209450:	6833      	ldr	r3, [r6, #0]
  209452:	441a      	add	r2, r3
      if (value == 0)
  209454:	eeb5 8b40 	vcmp.f64	d8, #0.0
	*rve++ = '0';
  209458:	2130      	movs	r1, #48	; 0x30
      if (value == 0)
  20945a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	rve = bp;
  20945e:	bf08      	it	eq
  209460:	9203      	streq	r2, [sp, #12]
      while (rve < bp)
  209462:	9b03      	ldr	r3, [sp, #12]
  209464:	4293      	cmp	r3, r2
  209466:	d2dc      	bcs.n	209422 <__cvt+0x56>
	*rve++ = '0';
  209468:	1c5c      	adds	r4, r3, #1
  20946a:	9403      	str	r4, [sp, #12]
  20946c:	7019      	strb	r1, [r3, #0]
  20946e:	e7f8      	b.n	209462 <__cvt+0x96>

00209470 <__exponent>:
/* This function is copied from exponent in vfprintf.c with support for
   C99 formats removed.  We don't use the original function in order to
   decouple nano implementation of formatted IO from the Newlib one.  */
int
__exponent (char *p0, int exp, int fmtch)
{
  209470:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  char expbuf[MAXEXPLEN];
#define isa 0

  p = p0;
  *p++ = isa ? 'p' - 'a' + fmtch : fmtch;
  if (exp < 0)
  209472:	2900      	cmp	r1, #0
  *p++ = isa ? 'p' - 'a' + fmtch : fmtch;
  209474:	4603      	mov	r3, r0
    {
      exp = -exp;
  209476:	bfb8      	it	lt
  209478:	4249      	neglt	r1, r1
  *p++ = isa ? 'p' - 'a' + fmtch : fmtch;
  20947a:	f803 2b02 	strb.w	r2, [r3], #2
      *p++ = '-';
  20947e:	bfb4      	ite	lt
  209480:	222d      	movlt	r2, #45	; 0x2d
    }
  else
    *p++ = '+';
  209482:	222b      	movge	r2, #43	; 0x2b
  t = expbuf + MAXEXPLEN;
  if (exp > 9)
  209484:	2909      	cmp	r1, #9
  209486:	7042      	strb	r2, [r0, #1]
  209488:	dd2a      	ble.n	2094e0 <__exponent+0x70>
  t = expbuf + MAXEXPLEN;
  20948a:	f10d 0407 	add.w	r4, sp, #7
    {
      do
	{
	  *--t = to_char (exp % 10);
  20948e:	270a      	movs	r7, #10
  209490:	46a4      	mov	ip, r4
  209492:	460a      	mov	r2, r1
  209494:	46a6      	mov	lr, r4
  209496:	3c01      	subs	r4, #1
	}
      while ((exp /= 10) > 9);
  209498:	2a63      	cmp	r2, #99	; 0x63
	  *--t = to_char (exp % 10);
  20949a:	fb91 f6f7 	sdiv	r6, r1, r7
  20949e:	fb07 1516 	mls	r5, r7, r6, r1
      while ((exp /= 10) > 9);
  2094a2:	4631      	mov	r1, r6
	  *--t = to_char (exp % 10);
  2094a4:	f105 0530 	add.w	r5, r5, #48	; 0x30
  2094a8:	f80e 5c01 	strb.w	r5, [lr, #-1]
      while ((exp /= 10) > 9);
  2094ac:	dcf1      	bgt.n	209492 <__exponent+0x22>
      *--t = to_char (exp);
  2094ae:	3130      	adds	r1, #48	; 0x30
  2094b0:	f1ae 0502 	sub.w	r5, lr, #2
  2094b4:	f804 1c01 	strb.w	r1, [r4, #-1]
      for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
  2094b8:	1c44      	adds	r4, r0, #1
      *--t = to_char (exp);
  2094ba:	4629      	mov	r1, r5
      for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
  2094bc:	4561      	cmp	r1, ip
  2094be:	d30a      	bcc.n	2094d6 <__exponent+0x66>
  2094c0:	f10d 0209 	add.w	r2, sp, #9
  2094c4:	eba2 020e 	sub.w	r2, r2, lr
  2094c8:	4565      	cmp	r5, ip
  2094ca:	bf88      	it	hi
  2094cc:	2200      	movhi	r2, #0
  2094ce:	4413      	add	r3, r2
      if (!isa)
	*p++ = '0';
      *p++ = to_char (exp);
    }
  return (p - p0);
}
  2094d0:	1a18      	subs	r0, r3, r0
  2094d2:	b003      	add	sp, #12
  2094d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
      for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
  2094d6:	f811 2b01 	ldrb.w	r2, [r1], #1
  2094da:	f804 2f01 	strb.w	r2, [r4, #1]!
  2094de:	e7ed      	b.n	2094bc <__exponent+0x4c>
	*p++ = '0';
  2094e0:	2330      	movs	r3, #48	; 0x30
      *p++ = to_char (exp);
  2094e2:	3130      	adds	r1, #48	; 0x30
	*p++ = '0';
  2094e4:	7083      	strb	r3, [r0, #2]
      *p++ = to_char (exp);
  2094e6:	1d03      	adds	r3, r0, #4
  2094e8:	70c1      	strb	r1, [r0, #3]
  2094ea:	e7f1      	b.n	2094d0 <__exponent+0x60>
  2094ec:	0000      	movs	r0, r0
	...

002094f0 <_printf_float>:
_printf_float (struct _reent *data,
	       struct _prt_data_t *pdata,
	       FILE * fp,
	       int (*pfunc) (struct _reent *, FILE *, const char *,
			     size_t len), va_list * ap)
{
  2094f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  2094f4:	b08b      	sub	sp, #44	; 0x2c
  2094f6:	460c      	mov	r4, r1
  2094f8:	4616      	mov	r6, r2
  2094fa:	461f      	mov	r7, r3
  2094fc:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
  209500:	4605      	mov	r5, r0
#define _fpvalue (pdata->_double_)

  char *decimal_point = _localeconv_r (data)->decimal_point;
  209502:	f002 fe83 	bl	20c20c <_localeconv_r>
  209506:	f8d0 b000 	ldr.w	fp, [r0]
  size_t decp_len = strlen (decimal_point);
  20950a:	4658      	mov	r0, fp
  20950c:	f7f6 ff43 	bl	200396 <strlen>
  /* Integer value of exponent.  */
  int expt;
  /* Character count for expstr.  */
  int expsize = 0;
  /* Actual number of digits returned by cvt.  */
  int ndig = 0;
  209510:	2300      	movs	r3, #0
  size_t decp_len = strlen (decimal_point);
  209512:	4682      	mov	sl, r0
  char *cp;
  int n;
  /* Field size expanded by dprec(not for _printf_float).  */
  int realsz;
  char code = pdata->code;
  209514:	f894 9018 	ldrb.w	r9, [r4, #24]
  int ndig = 0;
  209518:	9308      	str	r3, [sp, #32]

  if (pdata->flags & LONGDBL)
  20951a:	f8d8 3000 	ldr.w	r3, [r8]
  20951e:	6822      	ldr	r2, [r4, #0]
    {
      _fpvalue = (double) GET_ARG (N, *ap, _LONG_DOUBLE);
  209520:	3307      	adds	r3, #7
  209522:	f023 0307 	bic.w	r3, r3, #7
  209526:	f103 0108 	add.w	r1, r3, #8
  20952a:	f8c8 1000 	str.w	r1, [r8]
  20952e:	e9d3 0100 	ldrd	r0, r1, [r3]
  /* Do this before tricky precision changes.

     If the output is infinite or NaN, leading
     zeros are not permitted.  Otherwise, scanf
     could not read what printf wrote.  */
  if (isinf (_fpvalue))
  209532:	ed9f 7b99 	vldr	d7, [pc, #612]	; 209798 <_printf_float+0x2a8>
      _fpvalue = (double) GET_ARG (N, *ap, _LONG_DOUBLE);
  209536:	e9c4 0112 	strd	r0, r1, [r4, #72]	; 0x48
  if (isinf (_fpvalue))
  20953a:	ed94 0b12 	vldr	d0, [r4, #72]	; 0x48
  20953e:	eeb0 6bc0 	vabs.f64	d6, d0
  209542:	eeb4 6b47 	vcmp.f64	d6, d7
  209546:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20954a:	dd24      	ble.n	209596 <_printf_float+0xa6>
    {
      if (_fpvalue < 0)
  20954c:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
  209550:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  209554:	d502      	bpl.n	20955c <_printf_float+0x6c>
	pdata->l_buf[0] = '-';
  209556:	232d      	movs	r3, #45	; 0x2d
  209558:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
      if (code <= 'G')		/* 'A', 'E', 'F', or 'G'.  */
	cp = "INF";
      else
	cp = "inf";
  20955c:	4b90      	ldr	r3, [pc, #576]	; (2097a0 <_printf_float+0x2b0>)
  20955e:	4891      	ldr	r0, [pc, #580]	; (2097a4 <_printf_float+0x2b4>)
      if (signbit (_fpvalue))
	pdata->l_buf[0] = '-';
      if (code <= 'G')		/* 'A', 'E', 'F', or 'G'.  */
	cp = "NAN";
      else
	cp = "nan";
  209560:	f1b9 0f47 	cmp.w	r9, #71	; 0x47
  209564:	bf94      	ite	ls
  209566:	4698      	movls	r8, r3
  209568:	4680      	movhi	r8, r0
      pdata->size = 3;
  20956a:	2303      	movs	r3, #3
      pdata->flags &= ~ZEROPAD;
  20956c:	f022 0204 	bic.w	r2, r2, #4
      pdata->size = 3;
  209570:	6123      	str	r3, [r4, #16]
  int expsize = 0;
  209572:	2300      	movs	r3, #0
      pdata->flags &= ~ZEROPAD;
  209574:	6022      	str	r2, [r4, #0]
  int expsize = 0;
  209576:	9304      	str	r3, [sp, #16]
    }

  if (softsign)
    pdata->l_buf[0] = '-';
print_float:
  if (_printf_common (data, pdata, &realsz, fp, pfunc) == -1)
  209578:	4633      	mov	r3, r6
  20957a:	aa09      	add	r2, sp, #36	; 0x24
  20957c:	4621      	mov	r1, r4
  20957e:	4628      	mov	r0, r5
  209580:	9700      	str	r7, [sp, #0]
  209582:	f000 f9d3 	bl	20992c <_printf_common>
  209586:	3001      	adds	r0, #1
  209588:	f040 808a 	bne.w	2096a0 <_printf_float+0x1b0>
  if (pdata->flags & LADJUST)
    PAD (pdata->width - realsz, pdata->blank);

  return (pdata->width > realsz ? pdata->width : realsz);
error:
  return -1;
  20958c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

#undef _fpvalue
}
  209590:	b00b      	add	sp, #44	; 0x2c
  209592:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (isnan (_fpvalue))
  209596:	eeb4 0b40 	vcmp.f64	d0, d0
  20959a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20959e:	d709      	bvc.n	2095b4 <_printf_float+0xc4>
      if (signbit (_fpvalue))
  2095a0:	ee10 3a90 	vmov	r3, s1
	cp = "nan";
  2095a4:	4880      	ldr	r0, [pc, #512]	; (2097a8 <_printf_float+0x2b8>)
      if (signbit (_fpvalue))
  2095a6:	2b00      	cmp	r3, #0
	pdata->l_buf[0] = '-';
  2095a8:	bfbc      	itt	lt
  2095aa:	232d      	movlt	r3, #45	; 0x2d
  2095ac:	f884 3043 	strblt.w	r3, [r4, #67]	; 0x43
	cp = "nan";
  2095b0:	4b7e      	ldr	r3, [pc, #504]	; (2097ac <_printf_float+0x2bc>)
  2095b2:	e7d5      	b.n	209560 <_printf_float+0x70>
  if (pdata->prec == -1)
  2095b4:	f009 01df 	and.w	r1, r9, #223	; 0xdf
  2095b8:	6863      	ldr	r3, [r4, #4]
  2095ba:	9104      	str	r1, [sp, #16]
  2095bc:	1c59      	adds	r1, r3, #1
  2095be:	d13c      	bne.n	20963a <_printf_float+0x14a>
      pdata->prec = DEFPREC;
  2095c0:	2306      	movs	r3, #6
      pdata->prec = 1;
  2095c2:	6063      	str	r3, [r4, #4]
  cp = __cvt (data, _fpvalue, pdata->prec, pdata->flags, &softsign,
  2095c4:	2300      	movs	r3, #0
  pdata->flags |= FPT;
  2095c6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
  cp = __cvt (data, _fpvalue, pdata->prec, pdata->flags, &softsign,
  2095ca:	6861      	ldr	r1, [r4, #4]
  2095cc:	4628      	mov	r0, r5
  2095ce:	9303      	str	r3, [sp, #12]
  2095d0:	ab08      	add	r3, sp, #32
  pdata->flags |= FPT;
  2095d2:	6022      	str	r2, [r4, #0]
  cp = __cvt (data, _fpvalue, pdata->prec, pdata->flags, &softsign,
  2095d4:	e9cd 9301 	strd	r9, r3, [sp, #4]
  2095d8:	ab07      	add	r3, sp, #28
  2095da:	9300      	str	r3, [sp, #0]
  2095dc:	f10d 031b 	add.w	r3, sp, #27
  2095e0:	f7ff fef4 	bl	2093cc <__cvt>
  if (code == 'g' || code == 'G')
  2095e4:	9b04      	ldr	r3, [sp, #16]
  cp = __cvt (data, _fpvalue, pdata->prec, pdata->flags, &softsign,
  2095e6:	4680      	mov	r8, r0
  if (code == 'g' || code == 'G')
  2095e8:	9907      	ldr	r1, [sp, #28]
  2095ea:	2b47      	cmp	r3, #71	; 0x47
  2095ec:	d108      	bne.n	209600 <_printf_float+0x110>
      if (expt <= -4 || expt > pdata->prec)
  2095ee:	1cc8      	adds	r0, r1, #3
  2095f0:	db02      	blt.n	2095f8 <_printf_float+0x108>
  2095f2:	6863      	ldr	r3, [r4, #4]
  2095f4:	4299      	cmp	r1, r3
  2095f6:	dd41      	ble.n	20967c <_printf_float+0x18c>
	code -= 2;
  2095f8:	f1a9 0902 	sub.w	r9, r9, #2
  2095fc:	fa5f f989 	uxtb.w	r9, r9
  if (code <= 'e')
  209600:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
  209604:	d820      	bhi.n	209648 <_printf_float+0x158>
      --expt;
  209606:	3901      	subs	r1, #1
      expsize = __exponent (pdata->expstr, expt, code);
  209608:	464a      	mov	r2, r9
  20960a:	f104 0050 	add.w	r0, r4, #80	; 0x50
      --expt;
  20960e:	9107      	str	r1, [sp, #28]
      expsize = __exponent (pdata->expstr, expt, code);
  209610:	f7ff ff2e 	bl	209470 <__exponent>
      pdata->size = expsize + ndig;
  209614:	9a08      	ldr	r2, [sp, #32]
      expsize = __exponent (pdata->expstr, expt, code);
  209616:	9004      	str	r0, [sp, #16]
      pdata->size = expsize + ndig;
  209618:	1813      	adds	r3, r2, r0
      if (ndig > 1 || pdata->flags & ALT)
  20961a:	2a01      	cmp	r2, #1
      pdata->size = expsize + ndig;
  20961c:	6123      	str	r3, [r4, #16]
      if (ndig > 1 || pdata->flags & ALT)
  20961e:	dc02      	bgt.n	209626 <_printf_float+0x136>
  209620:	6822      	ldr	r2, [r4, #0]
  209622:	07d2      	lsls	r2, r2, #31
  209624:	d501      	bpl.n	20962a <_printf_float+0x13a>
	++pdata->size;
  209626:	3301      	adds	r3, #1
  209628:	6123      	str	r3, [r4, #16]
  if (softsign)
  20962a:	f89d 301b 	ldrb.w	r3, [sp, #27]
  20962e:	2b00      	cmp	r3, #0
  209630:	d0a2      	beq.n	209578 <_printf_float+0x88>
    pdata->l_buf[0] = '-';
  209632:	232d      	movs	r3, #45	; 0x2d
  209634:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  209638:	e79e      	b.n	209578 <_printf_float+0x88>
  else if ((code == 'g' || code == 'G') && pdata->prec == 0)
  20963a:	9904      	ldr	r1, [sp, #16]
  20963c:	2947      	cmp	r1, #71	; 0x47
  20963e:	d1c1      	bne.n	2095c4 <_printf_float+0xd4>
  209640:	2b00      	cmp	r3, #0
  209642:	d1bf      	bne.n	2095c4 <_printf_float+0xd4>
      pdata->prec = 1;
  209644:	2301      	movs	r3, #1
  209646:	e7bc      	b.n	2095c2 <_printf_float+0xd2>
      if (code == 'f')
  209648:	f1b9 0f66 	cmp.w	r9, #102	; 0x66
  20964c:	d118      	bne.n	209680 <_printf_float+0x190>
	  if (expt > 0)
  20964e:	2900      	cmp	r1, #0
  209650:	6863      	ldr	r3, [r4, #4]
  209652:	dd0b      	ble.n	20966c <_printf_float+0x17c>
	      pdata->size = expt;
  209654:	6121      	str	r1, [r4, #16]
	      if (pdata->prec || pdata->flags & ALT)
  209656:	b913      	cbnz	r3, 20965e <_printf_float+0x16e>
  209658:	6822      	ldr	r2, [r4, #0]
  20965a:	07d0      	lsls	r0, r2, #31
  20965c:	d502      	bpl.n	209664 <_printf_float+0x174>
		pdata->size += pdata->prec + 1;
  20965e:	3301      	adds	r3, #1
  209660:	440b      	add	r3, r1
	pdata->size = ndig + (expt > 0 ? 1 : 2 - expt);
  209662:	6123      	str	r3, [r4, #16]
  int expsize = 0;
  209664:	2300      	movs	r3, #0
      pdata->lead = expt;
  209666:	65a1      	str	r1, [r4, #88]	; 0x58
  int expsize = 0;
  209668:	9304      	str	r3, [sp, #16]
  20966a:	e7de      	b.n	20962a <_printf_float+0x13a>
	      ? pdata->prec + 2 : 1;
  20966c:	b913      	cbnz	r3, 209674 <_printf_float+0x184>
	    pdata->size = (pdata->prec || pdata->flags & ALT)
  20966e:	6822      	ldr	r2, [r4, #0]
  209670:	07d2      	lsls	r2, r2, #31
  209672:	d501      	bpl.n	209678 <_printf_float+0x188>
	      ? pdata->prec + 2 : 1;
  209674:	3302      	adds	r3, #2
  209676:	e7f4      	b.n	209662 <_printf_float+0x172>
  209678:	2301      	movs	r3, #1
  20967a:	e7f2      	b.n	209662 <_printf_float+0x172>
	code = 'g';
  20967c:	f04f 0967 	mov.w	r9, #103	; 0x67
      else if (expt >= ndig)
  209680:	9b08      	ldr	r3, [sp, #32]
  209682:	4299      	cmp	r1, r3
  209684:	db05      	blt.n	209692 <_printf_float+0x1a2>
	  if (pdata->flags & ALT)
  209686:	6823      	ldr	r3, [r4, #0]
	  pdata->size = expt;
  209688:	6121      	str	r1, [r4, #16]
	  if (pdata->flags & ALT)
  20968a:	07d8      	lsls	r0, r3, #31
  20968c:	d5ea      	bpl.n	209664 <_printf_float+0x174>
	    ++pdata->size;
  20968e:	1c4b      	adds	r3, r1, #1
  209690:	e7e7      	b.n	209662 <_printf_float+0x172>
	pdata->size = ndig + (expt > 0 ? 1 : 2 - expt);
  209692:	2900      	cmp	r1, #0
  209694:	bfd4      	ite	le
  209696:	f1c1 0202 	rsble	r2, r1, #2
  20969a:	2201      	movgt	r2, #1
  20969c:	4413      	add	r3, r2
  20969e:	e7e0      	b.n	209662 <_printf_float+0x172>
  if ((pdata->flags & FPT) == 0)
  2096a0:	6823      	ldr	r3, [r4, #0]
  2096a2:	055a      	lsls	r2, r3, #21
  2096a4:	d407      	bmi.n	2096b6 <_printf_float+0x1c6>
      PRINT (cp, pdata->size);
  2096a6:	6923      	ldr	r3, [r4, #16]
		  PRINT (cp, ndig);
  2096a8:	4642      	mov	r2, r8
	  PRINT (pdata->expstr, expsize);
  2096aa:	4631      	mov	r1, r6
  2096ac:	4628      	mov	r0, r5
  2096ae:	47b8      	blx	r7
  2096b0:	3001      	adds	r0, #1
  2096b2:	d12a      	bne.n	20970a <_printf_float+0x21a>
  2096b4:	e76a      	b.n	20958c <_printf_float+0x9c>
      if (code >= 'f')
  2096b6:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
  2096ba:	f240 80e2 	bls.w	209882 <_printf_float+0x392>
	  if (_fpvalue == 0)
  2096be:	ed94 7b12 	vldr	d7, [r4, #72]	; 0x48
  2096c2:	eeb5 7b40 	vcmp.f64	d7, #0.0
  2096c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2096ca:	d133      	bne.n	209734 <_printf_float+0x244>
	      PRINT ("0", 1);
  2096cc:	2301      	movs	r3, #1
  2096ce:	4a38      	ldr	r2, [pc, #224]	; (2097b0 <_printf_float+0x2c0>)
  2096d0:	4631      	mov	r1, r6
  2096d2:	4628      	mov	r0, r5
  2096d4:	47b8      	blx	r7
  2096d6:	3001      	adds	r0, #1
  2096d8:	f43f af58 	beq.w	20958c <_printf_float+0x9c>
	      if (expt < ndig || pdata->flags & ALT)
  2096dc:	e9dd 2307 	ldrd	r2, r3, [sp, #28]
  2096e0:	429a      	cmp	r2, r3
  2096e2:	db02      	blt.n	2096ea <_printf_float+0x1fa>
  2096e4:	6823      	ldr	r3, [r4, #0]
  2096e6:	07d8      	lsls	r0, r3, #31
  2096e8:	d50f      	bpl.n	20970a <_printf_float+0x21a>
		  PRINT (decimal_point, decp_len);
  2096ea:	4653      	mov	r3, sl
  2096ec:	465a      	mov	r2, fp
  2096ee:	4631      	mov	r1, r6
  2096f0:	4628      	mov	r0, r5
  2096f2:	47b8      	blx	r7
  2096f4:	3001      	adds	r0, #1
  2096f6:	f43f af49 	beq.w	20958c <_printf_float+0x9c>
		  PAD (ndig - 1, pdata->zero);
  2096fa:	f04f 0800 	mov.w	r8, #0
  2096fe:	f104 091a 	add.w	r9, r4, #26
  209702:	9b08      	ldr	r3, [sp, #32]
  209704:	3b01      	subs	r3, #1
  209706:	4543      	cmp	r3, r8
  209708:	dc09      	bgt.n	20971e <_printf_float+0x22e>
  if (pdata->flags & LADJUST)
  20970a:	6823      	ldr	r3, [r4, #0]
  20970c:	079b      	lsls	r3, r3, #30
  20970e:	f100 8108 	bmi.w	209922 <_printf_float+0x432>
  return (pdata->width > realsz ? pdata->width : realsz);
  209712:	68e0      	ldr	r0, [r4, #12]
  209714:	9b09      	ldr	r3, [sp, #36]	; 0x24
  209716:	4298      	cmp	r0, r3
  209718:	bfb8      	it	lt
  20971a:	4618      	movlt	r0, r3
  20971c:	e738      	b.n	209590 <_printf_float+0xa0>
		  PAD (ndig - 1, pdata->zero);
  20971e:	2301      	movs	r3, #1
  209720:	464a      	mov	r2, r9
  209722:	4631      	mov	r1, r6
  209724:	4628      	mov	r0, r5
  209726:	47b8      	blx	r7
  209728:	3001      	adds	r0, #1
  20972a:	f43f af2f 	beq.w	20958c <_printf_float+0x9c>
  20972e:	f108 0801 	add.w	r8, r8, #1
  209732:	e7e6      	b.n	209702 <_printf_float+0x212>
	  else if (expt <= 0)
  209734:	9b07      	ldr	r3, [sp, #28]
  209736:	2b00      	cmp	r3, #0
  209738:	dc3c      	bgt.n	2097b4 <_printf_float+0x2c4>
	      PRINT ("0", 1);
  20973a:	2301      	movs	r3, #1
  20973c:	4a1c      	ldr	r2, [pc, #112]	; (2097b0 <_printf_float+0x2c0>)
  20973e:	4631      	mov	r1, r6
  209740:	4628      	mov	r0, r5
  209742:	47b8      	blx	r7
  209744:	3001      	adds	r0, #1
  209746:	f43f af21 	beq.w	20958c <_printf_float+0x9c>
	      if (expt || ndig || pdata->flags & ALT)
  20974a:	e9dd 2307 	ldrd	r2, r3, [sp, #28]
  20974e:	4313      	orrs	r3, r2
  209750:	d102      	bne.n	209758 <_printf_float+0x268>
  209752:	6823      	ldr	r3, [r4, #0]
  209754:	07d9      	lsls	r1, r3, #31
  209756:	d5d8      	bpl.n	20970a <_printf_float+0x21a>
		  PRINT (decimal_point, decp_len);
  209758:	4653      	mov	r3, sl
  20975a:	465a      	mov	r2, fp
  20975c:	4631      	mov	r1, r6
  20975e:	4628      	mov	r0, r5
  209760:	47b8      	blx	r7
  209762:	3001      	adds	r0, #1
  209764:	f43f af12 	beq.w	20958c <_printf_float+0x9c>
		  PAD (-expt, pdata->zero);
  209768:	f04f 0900 	mov.w	r9, #0
  20976c:	f104 0a1a 	add.w	sl, r4, #26
  209770:	9b07      	ldr	r3, [sp, #28]
  209772:	425b      	negs	r3, r3
  209774:	454b      	cmp	r3, r9
  209776:	dc01      	bgt.n	20977c <_printf_float+0x28c>
		  PRINT (cp, ndig);
  209778:	9b08      	ldr	r3, [sp, #32]
  20977a:	e795      	b.n	2096a8 <_printf_float+0x1b8>
		  PAD (-expt, pdata->zero);
  20977c:	2301      	movs	r3, #1
  20977e:	4652      	mov	r2, sl
  209780:	4631      	mov	r1, r6
  209782:	4628      	mov	r0, r5
  209784:	47b8      	blx	r7
  209786:	3001      	adds	r0, #1
  209788:	f43f af00 	beq.w	20958c <_printf_float+0x9c>
  20978c:	f109 0901 	add.w	r9, r9, #1
  209790:	e7ee      	b.n	209770 <_printf_float+0x280>
  209792:	bf00      	nop
  209794:	f3af 8000 	nop.w
  209798:	ffffffff 	.word	0xffffffff
  20979c:	7fefffff 	.word	0x7fefffff
  2097a0:	0800ebb7 	.word	0x0800ebb7
  2097a4:	0800ebbb 	.word	0x0800ebbb
  2097a8:	0800ebc3 	.word	0x0800ebc3
  2097ac:	0800ebbf 	.word	0x0800ebbf
  2097b0:	0800dc50 	.word	0x0800dc50
	      PRINTANDPAD (cp, convbuf + ndig, pdata->lead, pdata->zero);
  2097b4:	9a08      	ldr	r2, [sp, #32]
  2097b6:	6da3      	ldr	r3, [r4, #88]	; 0x58
  2097b8:	429a      	cmp	r2, r3
  2097ba:	bfa8      	it	ge
  2097bc:	461a      	movge	r2, r3
  2097be:	2a00      	cmp	r2, #0
  2097c0:	4691      	mov	r9, r2
  2097c2:	dc38      	bgt.n	209836 <_printf_float+0x346>
		  PAD (-expt, pdata->zero);
  2097c4:	2300      	movs	r3, #0
	      PRINTANDPAD (cp, convbuf + ndig, pdata->lead, pdata->zero);
  2097c6:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
  2097ca:	f104 021a 	add.w	r2, r4, #26
		  PAD (-expt, pdata->zero);
  2097ce:	9305      	str	r3, [sp, #20]
	      PRINTANDPAD (cp, convbuf + ndig, pdata->lead, pdata->zero);
  2097d0:	6da3      	ldr	r3, [r4, #88]	; 0x58
  2097d2:	9905      	ldr	r1, [sp, #20]
  2097d4:	9304      	str	r3, [sp, #16]
  2097d6:	eba3 0309 	sub.w	r3, r3, r9
  2097da:	428b      	cmp	r3, r1
  2097dc:	dc33      	bgt.n	209846 <_printf_float+0x356>
	      if (expt < ndig || pdata->flags & ALT)
  2097de:	e9dd 2307 	ldrd	r2, r3, [sp, #28]
  2097e2:	429a      	cmp	r2, r3
  2097e4:	db3c      	blt.n	209860 <_printf_float+0x370>
  2097e6:	6823      	ldr	r3, [r4, #0]
  2097e8:	07da      	lsls	r2, r3, #31
  2097ea:	d439      	bmi.n	209860 <_printf_float+0x370>
	      PRINTANDPAD (cp, convbuf + ndig, ndig - expt, pdata->zero);
  2097ec:	9a08      	ldr	r2, [sp, #32]
  2097ee:	9b04      	ldr	r3, [sp, #16]
  2097f0:	9907      	ldr	r1, [sp, #28]
  2097f2:	1ad3      	subs	r3, r2, r3
  2097f4:	eba2 0901 	sub.w	r9, r2, r1
  2097f8:	4599      	cmp	r9, r3
  2097fa:	bfa8      	it	ge
  2097fc:	4699      	movge	r9, r3
  2097fe:	f1b9 0f00 	cmp.w	r9, #0
  209802:	dc35      	bgt.n	209870 <_printf_float+0x380>
		  PAD (-expt, pdata->zero);
  209804:	f04f 0800 	mov.w	r8, #0
	      PRINTANDPAD (cp, convbuf + ndig, ndig - expt, pdata->zero);
  209808:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
  20980c:	f104 0a1a 	add.w	sl, r4, #26
  209810:	e9dd 2307 	ldrd	r2, r3, [sp, #28]
  209814:	1a9b      	subs	r3, r3, r2
  209816:	eba3 0309 	sub.w	r3, r3, r9
  20981a:	4543      	cmp	r3, r8
  20981c:	f77f af75 	ble.w	20970a <_printf_float+0x21a>
  209820:	2301      	movs	r3, #1
  209822:	4652      	mov	r2, sl
  209824:	4631      	mov	r1, r6
  209826:	4628      	mov	r0, r5
  209828:	47b8      	blx	r7
  20982a:	3001      	adds	r0, #1
  20982c:	f43f aeae 	beq.w	20958c <_printf_float+0x9c>
  209830:	f108 0801 	add.w	r8, r8, #1
  209834:	e7ec      	b.n	209810 <_printf_float+0x320>
	      PRINTANDPAD (cp, convbuf + ndig, pdata->lead, pdata->zero);
  209836:	4613      	mov	r3, r2
  209838:	4631      	mov	r1, r6
  20983a:	4642      	mov	r2, r8
  20983c:	4628      	mov	r0, r5
  20983e:	47b8      	blx	r7
  209840:	3001      	adds	r0, #1
  209842:	d1bf      	bne.n	2097c4 <_printf_float+0x2d4>
  209844:	e6a2      	b.n	20958c <_printf_float+0x9c>
  209846:	2301      	movs	r3, #1
  209848:	4631      	mov	r1, r6
  20984a:	4628      	mov	r0, r5
  20984c:	9204      	str	r2, [sp, #16]
  20984e:	47b8      	blx	r7
  209850:	3001      	adds	r0, #1
  209852:	f43f ae9b 	beq.w	20958c <_printf_float+0x9c>
  209856:	9b05      	ldr	r3, [sp, #20]
  209858:	9a04      	ldr	r2, [sp, #16]
  20985a:	3301      	adds	r3, #1
  20985c:	9305      	str	r3, [sp, #20]
  20985e:	e7b7      	b.n	2097d0 <_printf_float+0x2e0>
		PRINT (decimal_point, decp_len);
  209860:	4653      	mov	r3, sl
  209862:	465a      	mov	r2, fp
  209864:	4631      	mov	r1, r6
  209866:	4628      	mov	r0, r5
  209868:	47b8      	blx	r7
  20986a:	3001      	adds	r0, #1
  20986c:	d1be      	bne.n	2097ec <_printf_float+0x2fc>
  20986e:	e68d      	b.n	20958c <_printf_float+0x9c>
	      PRINTANDPAD (cp, convbuf + ndig, ndig - expt, pdata->zero);
  209870:	9a04      	ldr	r2, [sp, #16]
  209872:	464b      	mov	r3, r9
  209874:	4631      	mov	r1, r6
  209876:	4628      	mov	r0, r5
  209878:	4442      	add	r2, r8
  20987a:	47b8      	blx	r7
  20987c:	3001      	adds	r0, #1
  20987e:	d1c1      	bne.n	209804 <_printf_float+0x314>
  209880:	e684      	b.n	20958c <_printf_float+0x9c>
	  if (ndig > 1 || pdata->flags & ALT)
  209882:	9a08      	ldr	r2, [sp, #32]
  209884:	2a01      	cmp	r2, #1
  209886:	dc01      	bgt.n	20988c <_printf_float+0x39c>
  209888:	07db      	lsls	r3, r3, #31
  20988a:	d537      	bpl.n	2098fc <_printf_float+0x40c>
	      PRINT (cp, 1);
  20988c:	2301      	movs	r3, #1
  20988e:	4642      	mov	r2, r8
  209890:	4631      	mov	r1, r6
  209892:	4628      	mov	r0, r5
  209894:	47b8      	blx	r7
  209896:	3001      	adds	r0, #1
  209898:	f43f ae78 	beq.w	20958c <_printf_float+0x9c>
	      PRINT (decimal_point, decp_len);
  20989c:	4653      	mov	r3, sl
  20989e:	465a      	mov	r2, fp
  2098a0:	4631      	mov	r1, r6
  2098a2:	4628      	mov	r0, r5
  2098a4:	47b8      	blx	r7
  2098a6:	3001      	adds	r0, #1
  2098a8:	f43f ae70 	beq.w	20958c <_printf_float+0x9c>
	      if (_fpvalue)
  2098ac:	ed94 7b12 	vldr	d7, [r4, #72]	; 0x48
  2098b0:	eeb5 7b40 	vcmp.f64	d7, #0.0
  2098b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2098b8:	d01b      	beq.n	2098f2 <_printf_float+0x402>
		  PRINT (cp, ndig - 1);
  2098ba:	9b08      	ldr	r3, [sp, #32]
  2098bc:	f108 0201 	add.w	r2, r8, #1
  2098c0:	3b01      	subs	r3, #1
	    PRINT (cp, 1);
  2098c2:	4631      	mov	r1, r6
  2098c4:	4628      	mov	r0, r5
  2098c6:	47b8      	blx	r7
  2098c8:	3001      	adds	r0, #1
  2098ca:	d10e      	bne.n	2098ea <_printf_float+0x3fa>
  2098cc:	e65e      	b.n	20958c <_printf_float+0x9c>
		PAD (ndig - 1, pdata->zero);
  2098ce:	2301      	movs	r3, #1
  2098d0:	464a      	mov	r2, r9
  2098d2:	4631      	mov	r1, r6
  2098d4:	4628      	mov	r0, r5
  2098d6:	47b8      	blx	r7
  2098d8:	3001      	adds	r0, #1
  2098da:	f43f ae57 	beq.w	20958c <_printf_float+0x9c>
  2098de:	f108 0801 	add.w	r8, r8, #1
  2098e2:	9b08      	ldr	r3, [sp, #32]
  2098e4:	3b01      	subs	r3, #1
  2098e6:	4543      	cmp	r3, r8
  2098e8:	dcf1      	bgt.n	2098ce <_printf_float+0x3de>
	  PRINT (pdata->expstr, expsize);
  2098ea:	9b04      	ldr	r3, [sp, #16]
  2098ec:	f104 0250 	add.w	r2, r4, #80	; 0x50
  2098f0:	e6db      	b.n	2096aa <_printf_float+0x1ba>
		PAD (ndig - 1, pdata->zero);
  2098f2:	f04f 0800 	mov.w	r8, #0
  2098f6:	f104 091a 	add.w	r9, r4, #26
  2098fa:	e7f2      	b.n	2098e2 <_printf_float+0x3f2>
	    PRINT (cp, 1);
  2098fc:	2301      	movs	r3, #1
  2098fe:	4642      	mov	r2, r8
  209900:	e7df      	b.n	2098c2 <_printf_float+0x3d2>
    PAD (pdata->width - realsz, pdata->blank);
  209902:	2301      	movs	r3, #1
  209904:	464a      	mov	r2, r9
  209906:	4631      	mov	r1, r6
  209908:	4628      	mov	r0, r5
  20990a:	47b8      	blx	r7
  20990c:	3001      	adds	r0, #1
  20990e:	f43f ae3d 	beq.w	20958c <_printf_float+0x9c>
  209912:	f108 0801 	add.w	r8, r8, #1
  209916:	68e3      	ldr	r3, [r4, #12]
  209918:	9909      	ldr	r1, [sp, #36]	; 0x24
  20991a:	1a5b      	subs	r3, r3, r1
  20991c:	4543      	cmp	r3, r8
  20991e:	dcf0      	bgt.n	209902 <_printf_float+0x412>
  209920:	e6f7      	b.n	209712 <_printf_float+0x222>
  209922:	f04f 0800 	mov.w	r8, #0
  209926:	f104 0919 	add.w	r9, r4, #25
  20992a:	e7f4      	b.n	209916 <_printf_float+0x426>

0020992c <_printf_common>:
		struct _prt_data_t *pdata,
		int *realsz,
		FILE *fp,
		int (*pfunc)(struct _reent *, FILE *,
			     const char *, size_t len))
{
  20992c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  209930:	4616      	mov	r6, r2
  209932:	4699      	mov	r9, r3
   * If flags&FPT, ch must be in [aAeEfg].
   *
   * Compute actual size, so we know how much to pad.
   * size excludes decimal prec; realsz includes it.
   */
  *realsz = pdata->dprec > pdata->size ? pdata->dprec : pdata->size;
  209934:	688a      	ldr	r2, [r1, #8]
{
  209936:	4607      	mov	r7, r0
  *realsz = pdata->dprec > pdata->size ? pdata->dprec : pdata->size;
  209938:	690b      	ldr	r3, [r1, #16]
{
  20993a:	460c      	mov	r4, r1
  20993c:	f8dd 8020 	ldr.w	r8, [sp, #32]
  *realsz = pdata->dprec > pdata->size ? pdata->dprec : pdata->size;
  209940:	4293      	cmp	r3, r2
  209942:	bfb8      	it	lt
  209944:	4613      	movlt	r3, r2
  209946:	6033      	str	r3, [r6, #0]
  if (pdata->l_buf[0])
  209948:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
  20994c:	b10a      	cbz	r2, 209952 <_printf_common+0x26>
    (*realsz)++;
  20994e:	3301      	adds	r3, #1
  209950:	6033      	str	r3, [r6, #0]

  if (pdata->flags & HEXPREFIX)
  209952:	6823      	ldr	r3, [r4, #0]
  209954:	0699      	lsls	r1, r3, #26
    *realsz += 2;
  209956:	bf42      	ittt	mi
  209958:	6833      	ldrmi	r3, [r6, #0]
  20995a:	3302      	addmi	r3, #2
  20995c:	6033      	strmi	r3, [r6, #0]

  /* Right-adjusting blank padding.  */
  if ((pdata->flags & (LADJUST|ZEROPAD)) == 0)
  20995e:	6825      	ldr	r5, [r4, #0]
  209960:	f015 0506 	ands.w	r5, r5, #6
  209964:	d106      	bne.n	209974 <_printf_common+0x48>
    PAD (pdata->width - *realsz, pdata->blank);
  209966:	f104 0a19 	add.w	sl, r4, #25
  20996a:	68e3      	ldr	r3, [r4, #12]
  20996c:	6832      	ldr	r2, [r6, #0]
  20996e:	1a9b      	subs	r3, r3, r2
  209970:	42ab      	cmp	r3, r5
  209972:	dc29      	bgt.n	2099c8 <_printf_common+0x9c>

  /* Prefix.  */
  n = 0;
  if (pdata->l_buf[0])
  209974:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
  209978:	1e13      	subs	r3, r2, #0
    n++;

  if (pdata->flags & HEXPREFIX)
  20997a:	6822      	ldr	r2, [r4, #0]
  if (pdata->l_buf[0])
  20997c:	bf18      	it	ne
  20997e:	2301      	movne	r3, #1
  if (pdata->flags & HEXPREFIX)
  209980:	0692      	lsls	r2, r2, #26
  209982:	d42e      	bmi.n	2099e2 <_printf_common+0xb6>
    {
      pdata->l_buf[n++] = '0';
      pdata->l_buf[n++] = pdata->l_buf[2];
    }

  PRINT (pdata->l_buf, n);
  209984:	f104 0243 	add.w	r2, r4, #67	; 0x43
  209988:	4649      	mov	r1, r9
  20998a:	4638      	mov	r0, r7
  20998c:	47c0      	blx	r8
  20998e:	3001      	adds	r0, #1
  209990:	d021      	beq.n	2099d6 <_printf_common+0xaa>
  n = pdata->width - *realsz;
  if ((pdata->flags & (LADJUST|ZEROPAD)) != ZEROPAD || n < 0)
  209992:	6823      	ldr	r3, [r4, #0]
    n = 0;

  if (pdata->dprec > pdata->size)
    n += pdata->dprec - pdata->size;

  PAD (n, pdata->zero);
  209994:	341a      	adds	r4, #26
  n = pdata->width - *realsz;
  209996:	f854 5c0e 	ldr.w	r5, [r4, #-14]
  if ((pdata->flags & (LADJUST|ZEROPAD)) != ZEROPAD || n < 0)
  20999a:	f003 0306 	and.w	r3, r3, #6
  n = pdata->width - *realsz;
  20999e:	6832      	ldr	r2, [r6, #0]
  PAD (n, pdata->zero);
  2099a0:	2600      	movs	r6, #0
  if ((pdata->flags & (LADJUST|ZEROPAD)) != ZEROPAD || n < 0)
  2099a2:	2b04      	cmp	r3, #4
  if (pdata->dprec > pdata->size)
  2099a4:	f854 3c12 	ldr.w	r3, [r4, #-18]
  n = pdata->width - *realsz;
  2099a8:	bf08      	it	eq
  2099aa:	1aad      	subeq	r5, r5, r2
  if (pdata->dprec > pdata->size)
  2099ac:	f854 2c0a 	ldr.w	r2, [r4, #-10]
    n = 0;
  2099b0:	bf14      	ite	ne
  2099b2:	2500      	movne	r5, #0
  2099b4:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
  if (pdata->dprec > pdata->size)
  2099b8:	4293      	cmp	r3, r2
    n += pdata->dprec - pdata->size;
  2099ba:	bfc4      	itt	gt
  2099bc:	1a9b      	subgt	r3, r3, r2
  2099be:	18ed      	addgt	r5, r5, r3
  PAD (n, pdata->zero);
  2099c0:	42b5      	cmp	r5, r6
  2099c2:	d11a      	bne.n	2099fa <_printf_common+0xce>
  return 0;
  2099c4:	2000      	movs	r0, #0
  2099c6:	e008      	b.n	2099da <_printf_common+0xae>
    PAD (pdata->width - *realsz, pdata->blank);
  2099c8:	2301      	movs	r3, #1
  2099ca:	4652      	mov	r2, sl
  2099cc:	4649      	mov	r1, r9
  2099ce:	4638      	mov	r0, r7
  2099d0:	47c0      	blx	r8
  2099d2:	3001      	adds	r0, #1
  2099d4:	d103      	bne.n	2099de <_printf_common+0xb2>
error:
  return -1;
  2099d6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  2099da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    PAD (pdata->width - *realsz, pdata->blank);
  2099de:	3501      	adds	r5, #1
  2099e0:	e7c3      	b.n	20996a <_printf_common+0x3e>
      pdata->l_buf[n++] = '0';
  2099e2:	18e1      	adds	r1, r4, r3
  2099e4:	1c5a      	adds	r2, r3, #1
  2099e6:	2030      	movs	r0, #48	; 0x30
      pdata->l_buf[n++] = pdata->l_buf[2];
  2099e8:	3302      	adds	r3, #2
  2099ea:	4422      	add	r2, r4
      pdata->l_buf[n++] = '0';
  2099ec:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
      pdata->l_buf[n++] = pdata->l_buf[2];
  2099f0:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
  2099f4:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
  2099f8:	e7c4      	b.n	209984 <_printf_common+0x58>
  PAD (n, pdata->zero);
  2099fa:	2301      	movs	r3, #1
  2099fc:	4622      	mov	r2, r4
  2099fe:	4649      	mov	r1, r9
  209a00:	4638      	mov	r0, r7
  209a02:	47c0      	blx	r8
  209a04:	3001      	adds	r0, #1
  209a06:	d0e6      	beq.n	2099d6 <_printf_common+0xaa>
  209a08:	3601      	adds	r6, #1
  209a0a:	e7d9      	b.n	2099c0 <_printf_common+0x94>

00209a0c <_printf_i>:
int
_printf_i (struct _reent *data, struct _prt_data_t *pdata, FILE *fp,
	   int (*pfunc)(struct _reent *, FILE *, const char *, size_t len),
	   va_list *ap)
{
  209a0c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
  209a10:	460c      	mov	r4, r1
  209a12:	4691      	mov	r9, r2
  209a14:	4680      	mov	r8, r0
  209a16:	469a      	mov	sl, r3
  int n;
  char *cp = pdata->buf + BUF;
  char *xdigs = "0123456789ABCDEF";

  /* Decoding the conversion specifier.  */
  switch (pdata->code)
  209a18:	7e27      	ldrb	r7, [r4, #24]
  char *cp = pdata->buf + BUF;
  209a1a:	f104 0243 	add.w	r2, r4, #67	; 0x43
{
  209a1e:	990c      	ldr	r1, [sp, #48]	; 0x30
  switch (pdata->code)
  209a20:	2f78      	cmp	r7, #120	; 0x78
  209a22:	d807      	bhi.n	209a34 <_printf_i+0x28>
  209a24:	2f62      	cmp	r7, #98	; 0x62
  209a26:	d80a      	bhi.n	209a3e <_printf_i+0x32>
  209a28:	2f00      	cmp	r7, #0
  209a2a:	f000 80d8 	beq.w	209bde <_printf_i+0x1d2>
  209a2e:	2f58      	cmp	r7, #88	; 0x58
  209a30:	f000 80a3 	beq.w	209b7a <_printf_i+0x16e>
      pdata->size = pdata->prec;
      goto non_number_nosign;
    default:
      /* "%?" prints ?, unless ? is NUL.  */
      /* Pretend it was %c with argument ch.  */
      *--cp = pdata->code;
  209a34:	f104 0642 	add.w	r6, r4, #66	; 0x42
  209a38:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
  209a3c:	e03a      	b.n	209ab4 <_printf_i+0xa8>
  209a3e:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
  209a42:	2b15      	cmp	r3, #21
  209a44:	d8f6      	bhi.n	209a34 <_printf_i+0x28>
  209a46:	a001      	add	r0, pc, #4	; (adr r0, 209a4c <_printf_i+0x40>)
  209a48:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
  209a4c:	00209aa5 	.word	0x00209aa5
  209a50:	00209ab9 	.word	0x00209ab9
  209a54:	00209a35 	.word	0x00209a35
  209a58:	00209a35 	.word	0x00209a35
  209a5c:	00209a35 	.word	0x00209a35
  209a60:	00209a35 	.word	0x00209a35
  209a64:	00209ab9 	.word	0x00209ab9
  209a68:	00209a35 	.word	0x00209a35
  209a6c:	00209a35 	.word	0x00209a35
  209a70:	00209a35 	.word	0x00209a35
  209a74:	00209a35 	.word	0x00209a35
  209a78:	00209bc5 	.word	0x00209bc5
  209a7c:	00209ae9 	.word	0x00209ae9
  209a80:	00209ba7 	.word	0x00209ba7
  209a84:	00209a35 	.word	0x00209a35
  209a88:	00209a35 	.word	0x00209a35
  209a8c:	00209be7 	.word	0x00209be7
  209a90:	00209a35 	.word	0x00209a35
  209a94:	00209ae9 	.word	0x00209ae9
  209a98:	00209a35 	.word	0x00209a35
  209a9c:	00209a35 	.word	0x00209a35
  209aa0:	00209baf 	.word	0x00209baf
      *--cp = GET_ARG (N, *ap, int);
  209aa4:	680b      	ldr	r3, [r1, #0]
  209aa6:	f104 0642 	add.w	r6, r4, #66	; 0x42
  209aaa:	1d1a      	adds	r2, r3, #4
  209aac:	681b      	ldr	r3, [r3, #0]
  209aae:	600a      	str	r2, [r1, #0]
  209ab0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      pdata->size = 1;
  209ab4:	2301      	movs	r3, #1
  209ab6:	e0a3      	b.n	209c00 <_printf_i+0x1f4>
      _uquad = SARG (pdata->flags);
  209ab8:	6825      	ldr	r5, [r4, #0]
  209aba:	6808      	ldr	r0, [r1, #0]
  209abc:	062e      	lsls	r6, r5, #24
  209abe:	f100 0304 	add.w	r3, r0, #4
  209ac2:	d50a      	bpl.n	209ada <_printf_i+0xce>
  209ac4:	6805      	ldr	r5, [r0, #0]
  209ac6:	600b      	str	r3, [r1, #0]
      if ((long) _uquad < 0)
  209ac8:	2d00      	cmp	r5, #0
  209aca:	da03      	bge.n	209ad4 <_printf_i+0xc8>
	  pdata->l_buf[0] = '-';
  209acc:	232d      	movs	r3, #45	; 0x2d
	  _uquad = -_uquad;
  209ace:	426d      	negs	r5, r5
	  pdata->l_buf[0] = '-';
  209ad0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  char *xdigs = "0123456789ABCDEF";
  209ad4:	485e      	ldr	r0, [pc, #376]	; (209c50 <_printf_i+0x244>)
      base = 10;
  209ad6:	230a      	movs	r3, #10
  209ad8:	e019      	b.n	209b0e <_printf_i+0x102>
      _uquad = SARG (pdata->flags);
  209ada:	f015 0f40 	tst.w	r5, #64	; 0x40
  209ade:	6805      	ldr	r5, [r0, #0]
  209ae0:	600b      	str	r3, [r1, #0]
  209ae2:	bf18      	it	ne
  209ae4:	b22d      	sxthne	r5, r5
  209ae6:	e7ef      	b.n	209ac8 <_printf_i+0xbc>
      _uquad = UARG (pdata->flags);
  209ae8:	680b      	ldr	r3, [r1, #0]
  209aea:	6825      	ldr	r5, [r4, #0]
  209aec:	1d18      	adds	r0, r3, #4
  209aee:	6008      	str	r0, [r1, #0]
  209af0:	0628      	lsls	r0, r5, #24
  209af2:	d501      	bpl.n	209af8 <_printf_i+0xec>
  209af4:	681d      	ldr	r5, [r3, #0]
  209af6:	e002      	b.n	209afe <_printf_i+0xf2>
  209af8:	0669      	lsls	r1, r5, #25
  209afa:	d5fb      	bpl.n	209af4 <_printf_i+0xe8>
  209afc:	881d      	ldrh	r5, [r3, #0]
  char *xdigs = "0123456789ABCDEF";
  209afe:	2f6f      	cmp	r7, #111	; 0x6f
  209b00:	4853      	ldr	r0, [pc, #332]	; (209c50 <_printf_i+0x244>)
  209b02:	bf0c      	ite	eq
  209b04:	2308      	moveq	r3, #8
  209b06:	230a      	movne	r3, #10
      pdata->l_buf[0] = '\0';
  209b08:	2100      	movs	r1, #0
  209b0a:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
      if ((pdata->dprec = pdata->prec) >= 0)
  209b0e:	6866      	ldr	r6, [r4, #4]
  209b10:	2e00      	cmp	r6, #0
  209b12:	60a6      	str	r6, [r4, #8]
	pdata->flags &= ~ZEROPAD;
  209b14:	bfa2      	ittt	ge
  209b16:	6821      	ldrge	r1, [r4, #0]
  209b18:	f021 0104 	bicge.w	r1, r1, #4
  209b1c:	6021      	strge	r1, [r4, #0]
      if (_uquad != 0 || pdata->prec != 0)
  209b1e:	b90d      	cbnz	r5, 209b24 <_printf_i+0x118>
  209b20:	2e00      	cmp	r6, #0
  209b22:	d04d      	beq.n	209bc0 <_printf_i+0x1b4>
      base = 10;
  209b24:	4616      	mov	r6, r2
	      *--cp = xdigs[_uquad % base];
  209b26:	fbb5 f1f3 	udiv	r1, r5, r3
  209b2a:	fb03 5711 	mls	r7, r3, r1, r5
  209b2e:	5dc7      	ldrb	r7, [r0, r7]
  209b30:	f806 7d01 	strb.w	r7, [r6, #-1]!
	      _uquad /= base;
  209b34:	462f      	mov	r7, r5
  209b36:	460d      	mov	r5, r1
	  while (_uquad);
  209b38:	42bb      	cmp	r3, r7
  209b3a:	d9f4      	bls.n	209b26 <_printf_i+0x11a>
      if (base == 8 && (pdata->flags & ALT) && pdata->prec <= pdata->size)
  209b3c:	2b08      	cmp	r3, #8
  209b3e:	d10b      	bne.n	209b58 <_printf_i+0x14c>
  209b40:	6823      	ldr	r3, [r4, #0]
  209b42:	07df      	lsls	r7, r3, #31
  209b44:	d508      	bpl.n	209b58 <_printf_i+0x14c>
  209b46:	6923      	ldr	r3, [r4, #16]
  209b48:	6861      	ldr	r1, [r4, #4]
  209b4a:	4299      	cmp	r1, r3
	*--cp = '0';
  209b4c:	bfde      	ittt	le
  209b4e:	2330      	movle	r3, #48	; 0x30
  209b50:	f806 3c01 	strble.w	r3, [r6, #-1]
  209b54:	f106 36ff 	addle.w	r6, r6, #4294967295	; 0xffffffff
      pdata->size = pdata->buf + BUF - cp;
  209b58:	1b92      	subs	r2, r2, r6
  209b5a:	6122      	str	r2, [r4, #16]
      pdata->l_buf[0] = '\0';
      break;
    }

    /* Output.  */
    n = _printf_common (data, pdata, &realsz, fp, pfunc);
  209b5c:	464b      	mov	r3, r9
  209b5e:	aa03      	add	r2, sp, #12
  209b60:	4621      	mov	r1, r4
  209b62:	4640      	mov	r0, r8
  209b64:	f8cd a000 	str.w	sl, [sp]
  209b68:	f7ff fee0 	bl	20992c <_printf_common>
    if (n == -1)
  209b6c:	3001      	adds	r0, #1
  209b6e:	d14c      	bne.n	209c0a <_printf_i+0x1fe>
    if (pdata->flags & LADJUST)
      PAD (pdata->width - realsz, pdata->blank);

    return (pdata->width > realsz ? pdata->width : realsz);
error:
    return -1;
  209b70:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  209b74:	b004      	add	sp, #16
  209b76:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  char *xdigs = "0123456789ABCDEF";
  209b7a:	4835      	ldr	r0, [pc, #212]	; (209c50 <_printf_i+0x244>)
      pdata->l_buf[2] = 'X';
  209b7c:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
      _uquad = UARG (pdata->flags);
  209b80:	6823      	ldr	r3, [r4, #0]
  209b82:	680e      	ldr	r6, [r1, #0]
  209b84:	061f      	lsls	r7, r3, #24
  209b86:	f856 5b04 	ldr.w	r5, [r6], #4
  209b8a:	600e      	str	r6, [r1, #0]
  209b8c:	d514      	bpl.n	209bb8 <_printf_i+0x1ac>
      if (pdata->flags & ALT)
  209b8e:	07d9      	lsls	r1, r3, #31
	pdata->flags |= HEXPREFIX;
  209b90:	bf44      	itt	mi
  209b92:	f043 0320 	orrmi.w	r3, r3, #32
  209b96:	6023      	strmi	r3, [r4, #0]
      if (_uquad == 0)
  209b98:	b91d      	cbnz	r5, 209ba2 <_printf_i+0x196>
	pdata->flags &= ~HEXPREFIX;
  209b9a:	6823      	ldr	r3, [r4, #0]
  209b9c:	f023 0320 	bic.w	r3, r3, #32
  209ba0:	6023      	str	r3, [r4, #0]
      base = 16;
  209ba2:	2310      	movs	r3, #16
  209ba4:	e7b0      	b.n	209b08 <_printf_i+0xfc>
      pdata->flags |= HEXPREFIX;
  209ba6:	6823      	ldr	r3, [r4, #0]
  209ba8:	f043 0320 	orr.w	r3, r3, #32
  209bac:	6023      	str	r3, [r4, #0]
      pdata->l_buf[2] = 'x';
  209bae:	2378      	movs	r3, #120	; 0x78
      xdigs = "0123456789abcdef";
  209bb0:	4828      	ldr	r0, [pc, #160]	; (209c54 <_printf_i+0x248>)
      pdata->l_buf[2] = 'x';
  209bb2:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
      xdigs = "0123456789abcdef";
  209bb6:	e7e3      	b.n	209b80 <_printf_i+0x174>
      _uquad = UARG (pdata->flags);
  209bb8:	065e      	lsls	r6, r3, #25
  209bba:	bf48      	it	mi
  209bbc:	b2ad      	uxthmi	r5, r5
  209bbe:	e7e6      	b.n	209b8e <_printf_i+0x182>
  char *cp = pdata->buf + BUF;
  209bc0:	4616      	mov	r6, r2
  209bc2:	e7bb      	b.n	209b3c <_printf_i+0x130>
      if (pdata->flags & LONGINT)
  209bc4:	680b      	ldr	r3, [r1, #0]
  209bc6:	6826      	ldr	r6, [r4, #0]
  209bc8:	1d1d      	adds	r5, r3, #4
  209bca:	6960      	ldr	r0, [r4, #20]
	*GET_ARG (N, *ap, long_ptr_t) = pdata->ret;
  209bcc:	600d      	str	r5, [r1, #0]
      if (pdata->flags & LONGINT)
  209bce:	0635      	lsls	r5, r6, #24
	*GET_ARG (N, *ap, long_ptr_t) = pdata->ret;
  209bd0:	681b      	ldr	r3, [r3, #0]
      if (pdata->flags & LONGINT)
  209bd2:	d501      	bpl.n	209bd8 <_printf_i+0x1cc>
	*GET_ARG (N, *ap, int_ptr_t) = pdata->ret;
  209bd4:	6018      	str	r0, [r3, #0]
  209bd6:	e002      	b.n	209bde <_printf_i+0x1d2>
      else if (pdata->flags & SHORTINT)
  209bd8:	0671      	lsls	r1, r6, #25
  209bda:	d5fb      	bpl.n	209bd4 <_printf_i+0x1c8>
	*GET_ARG (N, *ap, short_ptr_t) = pdata->ret;
  209bdc:	8018      	strh	r0, [r3, #0]
      pdata->size = 0;
  209bde:	2300      	movs	r3, #0
  char *cp = pdata->buf + BUF;
  209be0:	4616      	mov	r6, r2
      pdata->size = 0;
  209be2:	6123      	str	r3, [r4, #16]
      break;
  209be4:	e7ba      	b.n	209b5c <_printf_i+0x150>
      cp = GET_ARG (N, *ap, char_ptr_t);
  209be6:	680b      	ldr	r3, [r1, #0]
  209be8:	1d1a      	adds	r2, r3, #4
  209bea:	600a      	str	r2, [r1, #0]
      char *p = memchr (cp, 0, pdata->prec);
  209bec:	2100      	movs	r1, #0
      cp = GET_ARG (N, *ap, char_ptr_t);
  209bee:	681e      	ldr	r6, [r3, #0]
      char *p = memchr (cp, 0, pdata->prec);
  209bf0:	6862      	ldr	r2, [r4, #4]
  209bf2:	4630      	mov	r0, r6
  209bf4:	f7f6 fbdc 	bl	2003b0 <memchr>
      if (p != NULL)
  209bf8:	b108      	cbz	r0, 209bfe <_printf_i+0x1f2>
	pdata->prec = p - cp;
  209bfa:	1b80      	subs	r0, r0, r6
  209bfc:	6060      	str	r0, [r4, #4]
      pdata->size = pdata->prec;
  209bfe:	6863      	ldr	r3, [r4, #4]
      pdata->size = 1;
  209c00:	6123      	str	r3, [r4, #16]
      pdata->l_buf[0] = '\0';
  209c02:	2300      	movs	r3, #0
  209c04:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
      break;
  209c08:	e7a8      	b.n	209b5c <_printf_i+0x150>
    PRINT (cp, pdata->size);
  209c0a:	6923      	ldr	r3, [r4, #16]
  209c0c:	4632      	mov	r2, r6
  209c0e:	4649      	mov	r1, r9
  209c10:	4640      	mov	r0, r8
  209c12:	47d0      	blx	sl
  209c14:	3001      	adds	r0, #1
  209c16:	d0ab      	beq.n	209b70 <_printf_i+0x164>
    if (pdata->flags & LADJUST)
  209c18:	6823      	ldr	r3, [r4, #0]
  209c1a:	079b      	lsls	r3, r3, #30
  209c1c:	d413      	bmi.n	209c46 <_printf_i+0x23a>
    return (pdata->width > realsz ? pdata->width : realsz);
  209c1e:	68e0      	ldr	r0, [r4, #12]
  209c20:	9b03      	ldr	r3, [sp, #12]
  209c22:	4298      	cmp	r0, r3
  209c24:	bfb8      	it	lt
  209c26:	4618      	movlt	r0, r3
  209c28:	e7a4      	b.n	209b74 <_printf_i+0x168>
      PAD (pdata->width - realsz, pdata->blank);
  209c2a:	2301      	movs	r3, #1
  209c2c:	4632      	mov	r2, r6
  209c2e:	4649      	mov	r1, r9
  209c30:	4640      	mov	r0, r8
  209c32:	47d0      	blx	sl
  209c34:	3001      	adds	r0, #1
  209c36:	d09b      	beq.n	209b70 <_printf_i+0x164>
  209c38:	3501      	adds	r5, #1
  209c3a:	68e3      	ldr	r3, [r4, #12]
  209c3c:	9903      	ldr	r1, [sp, #12]
  209c3e:	1a5b      	subs	r3, r3, r1
  209c40:	42ab      	cmp	r3, r5
  209c42:	dcf2      	bgt.n	209c2a <_printf_i+0x21e>
  209c44:	e7eb      	b.n	209c1e <_printf_i+0x212>
  209c46:	2500      	movs	r5, #0
  209c48:	f104 0619 	add.w	r6, r4, #25
  209c4c:	e7f5      	b.n	209c3a <_printf_i+0x22e>
  209c4e:	bf00      	nop
  209c50:	0800ebc7 	.word	0x0800ebc7
  209c54:	0800ebd8 	.word	0x0800ebd8

00209c58 <_scanf_float>:
#ifdef FLOATING_POINT
int
_scanf_float (struct _reent *rptr,
	      struct _scan_data_t *pdata,
	      FILE *fp, va_list *ap)
{
  209c58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  209c5c:	b087      	sub	sp, #28
  209c5e:	4617      	mov	r7, r2
#endif
    {
      width_left = pdata->width - (BUF - 1);
      pdata->width = BUF - 1;
    }
  pdata->flags |= SIGNOK | NDIGITS | DPTOK | EXPOK;
  209c60:	468b      	mov	fp, r1
{
  209c62:	4680      	mov	r8, r0
  209c64:	9303      	str	r3, [sp, #12]
  209c66:	460c      	mov	r4, r1
  if (pdata->width - 1 > BUF - 2)
  209c68:	688b      	ldr	r3, [r1, #8]
  209c6a:	1e5a      	subs	r2, r3, #1
  209c6c:	f5b2 7fae 	cmp.w	r2, #348	; 0x15c
      width_left = pdata->width - (BUF - 1);
  209c70:	bf8b      	itete	hi
  209c72:	f46f 75ae 	mvnhi.w	r5, #348	; 0x15c
  unsigned width_left = 0;
  209c76:	2300      	movls	r3, #0
      width_left = pdata->width - (BUF - 1);
  209c78:	195b      	addhi	r3, r3, r5
  unsigned width_left = 0;
  209c7a:	9302      	strls	r3, [sp, #8]
  char infcount = 0;
  209c7c:	f04f 0500 	mov.w	r5, #0
      width_left = pdata->width - (BUF - 1);
  209c80:	bf84      	itt	hi
  209c82:	9302      	strhi	r3, [sp, #8]
      pdata->width = BUF - 1;
  209c84:	f240 135d 	movwhi	r3, #349	; 0x15d
  char nancount = 0;
  209c88:	46aa      	mov	sl, r5
  zeroes = 0;
  209c8a:	46a9      	mov	r9, r5
      pdata->width = BUF - 1;
  209c8c:	bf88      	it	hi
  209c8e:	608b      	strhi	r3, [r1, #8]
  pdata->flags |= SIGNOK | NDIGITS | DPTOK | EXPOK;
  209c90:	680b      	ldr	r3, [r1, #0]
  long leading_zeroes = 0;
  209c92:	9501      	str	r5, [sp, #4]
  pdata->flags |= SIGNOK | NDIGITS | DPTOK | EXPOK;
  209c94:	f443 63f0 	orr.w	r3, r3, #1920	; 0x780
  209c98:	f84b 3b1c 	str.w	r3, [fp], #28
  exp_adjust = 0;
  for (p = pdata->buf; pdata->width; )
  209c9c:	465e      	mov	r6, fp
  exp_adjust = 0;
  209c9e:	e9cd 5504 	strd	r5, r5, [sp, #16]
  for (p = pdata->buf; pdata->width; )
  209ca2:	68a2      	ldr	r2, [r4, #8]
  209ca4:	b152      	cbz	r2, 209cbc <_scanf_float+0x64>
    {
      c = *fp->_p;
  209ca6:	683b      	ldr	r3, [r7, #0]
  209ca8:	781b      	ldrb	r3, [r3, #0]
      /* This code mimicks the integer conversion code,
	 but is much simpler.  */
      switch (c)
  209caa:	2b4e      	cmp	r3, #78	; 0x4e
  209cac:	d864      	bhi.n	209d78 <_scanf_float+0x120>
  209cae:	2b40      	cmp	r3, #64	; 0x40
  209cb0:	d83c      	bhi.n	209d2c <_scanf_float+0xd4>
  209cb2:	f1a3 012b 	sub.w	r1, r3, #43	; 0x2b
  209cb6:	b2c8      	uxtb	r0, r1
  209cb8:	280e      	cmp	r0, #14
  209cba:	d93a      	bls.n	209d32 <_scanf_float+0xda>
	fp->_p++;
      else if (pdata->pfn_refill (rptr, fp))
	/* "EOF".  */
	break;
    }
  if (zeroes)
  209cbc:	f1b9 0f00 	cmp.w	r9, #0
  209cc0:	d003      	beq.n	209cca <_scanf_float+0x72>
    pdata->flags &= ~NDIGITS;
  209cc2:	6823      	ldr	r3, [r4, #0]
  209cc4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  209cc8:	6023      	str	r3, [r4, #0]
     check here if we have an outstanding nancount, and if so
     put back the chars we did swallow and treat as a failed
     match.

     FIXME - we still don't handle NAN([0xdigits]).  */
  if (nancount - 1U < 2U)
  209cca:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
  209cce:	f1ba 0f01 	cmp.w	sl, #1
  209cd2:	f200 8113 	bhi.w	209efc <_scanf_float+0x2a4>
    {
      /* "nancount && nancount < 3".  */
      /* Newlib's ungetc works even if we called __srefill in
	 the middle of a partial parse, but POSIX does not
	 guarantee that in all implementations of ungetc.  */
      while (p > pdata->buf)
  209cd6:	455e      	cmp	r6, fp
  209cd8:	f200 8105 	bhi.w	209ee6 <_scanf_float+0x28e>
	{
	  pdata->pfn_ungetc (rptr, *--p, fp); /* "[-+nNaA]".  */
	  --pdata->nread;
	}
      return MATCH_FAILURE;
  209cdc:	2501      	movs	r5, #1
	    *flp = fp;
	}
      pdata->nassigned++;
    }
  return 0;
}
  209cde:	4628      	mov	r0, r5
  209ce0:	b007      	add	sp, #28
  209ce2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  209ce6:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
  209cea:	2a0d      	cmp	r2, #13
  209cec:	d8e6      	bhi.n	209cbc <_scanf_float+0x64>
  209cee:	a101      	add	r1, pc, #4	; (adr r1, 209cf4 <_scanf_float+0x9c>)
  209cf0:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
  209cf4:	00209e33 	.word	0x00209e33
  209cf8:	00209cbd 	.word	0x00209cbd
  209cfc:	00209cbd 	.word	0x00209cbd
  209d00:	00209cbd 	.word	0x00209cbd
  209d04:	00209e93 	.word	0x00209e93
  209d08:	00209e6b 	.word	0x00209e6b
  209d0c:	00209cbd 	.word	0x00209cbd
  209d10:	00209cbd 	.word	0x00209cbd
  209d14:	00209e41 	.word	0x00209e41
  209d18:	00209cbd 	.word	0x00209cbd
  209d1c:	00209cbd 	.word	0x00209cbd
  209d20:	00209cbd 	.word	0x00209cbd
  209d24:	00209cbd 	.word	0x00209cbd
  209d28:	00209df9 	.word	0x00209df9
  209d2c:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
  209d30:	e7db      	b.n	209cea <_scanf_float+0x92>
  209d32:	290e      	cmp	r1, #14
  209d34:	d8c2      	bhi.n	209cbc <_scanf_float+0x64>
  209d36:	a001      	add	r0, pc, #4	; (adr r0, 209d3c <_scanf_float+0xe4>)
  209d38:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
  209d3c:	00209deb 	.word	0x00209deb
  209d40:	00209cbd 	.word	0x00209cbd
  209d44:	00209deb 	.word	0x00209deb
  209d48:	00209e7f 	.word	0x00209e7f
  209d4c:	00209cbd 	.word	0x00209cbd
  209d50:	00209d99 	.word	0x00209d99
  209d54:	00209dd5 	.word	0x00209dd5
  209d58:	00209dd5 	.word	0x00209dd5
  209d5c:	00209dd5 	.word	0x00209dd5
  209d60:	00209dd5 	.word	0x00209dd5
  209d64:	00209dd5 	.word	0x00209dd5
  209d68:	00209dd5 	.word	0x00209dd5
  209d6c:	00209dd5 	.word	0x00209dd5
  209d70:	00209dd5 	.word	0x00209dd5
  209d74:	00209dd5 	.word	0x00209dd5
      switch (c)
  209d78:	2b6e      	cmp	r3, #110	; 0x6e
  209d7a:	d809      	bhi.n	209d90 <_scanf_float+0x138>
  209d7c:	2b60      	cmp	r3, #96	; 0x60
  209d7e:	d8b2      	bhi.n	209ce6 <_scanf_float+0x8e>
  209d80:	2b54      	cmp	r3, #84	; 0x54
  209d82:	d077      	beq.n	209e74 <_scanf_float+0x21c>
  209d84:	2b59      	cmp	r3, #89	; 0x59
  209d86:	d199      	bne.n	209cbc <_scanf_float+0x64>
	  if (infcount == 7)
  209d88:	2d07      	cmp	r5, #7
  209d8a:	d197      	bne.n	209cbc <_scanf_float+0x64>
	      infcount = 8;
  209d8c:	2508      	movs	r5, #8
  209d8e:	e029      	b.n	209de4 <_scanf_float+0x18c>
      switch (c)
  209d90:	2b74      	cmp	r3, #116	; 0x74
  209d92:	d06f      	beq.n	209e74 <_scanf_float+0x21c>
  209d94:	2b79      	cmp	r3, #121	; 0x79
  209d96:	e7f6      	b.n	209d86 <_scanf_float+0x12e>
	  if (pdata->flags & NDIGITS)
  209d98:	6821      	ldr	r1, [r4, #0]
  209d9a:	05c8      	lsls	r0, r1, #23
  209d9c:	d51a      	bpl.n	209dd4 <_scanf_float+0x17c>
	      pdata->flags &= ~SIGNOK;
  209d9e:	f021 0180 	bic.w	r1, r1, #128	; 0x80
	      if (width_left)
  209da2:	9b02      	ldr	r3, [sp, #8]
	      zeroes++;
  209da4:	f109 0901 	add.w	r9, r9, #1
	      pdata->flags &= ~SIGNOK;
  209da8:	6021      	str	r1, [r4, #0]
	      if (width_left)
  209daa:	b11b      	cbz	r3, 209db4 <_scanf_float+0x15c>
		  width_left--;
  209dac:	3b01      	subs	r3, #1
		  pdata->width++;
  209dae:	3201      	adds	r2, #1
		  width_left--;
  209db0:	9302      	str	r3, [sp, #8]
		  pdata->width++;
  209db2:	60a2      	str	r2, [r4, #8]
      pdata->width--;
  209db4:	68a3      	ldr	r3, [r4, #8]
  209db6:	3b01      	subs	r3, #1
  209db8:	60a3      	str	r3, [r4, #8]
      ++pdata->nread;
  209dba:	6923      	ldr	r3, [r4, #16]
  209dbc:	3301      	adds	r3, #1
  209dbe:	6123      	str	r3, [r4, #16]
      if (--fp->_r > 0)
  209dc0:	687b      	ldr	r3, [r7, #4]
  209dc2:	3b01      	subs	r3, #1
  209dc4:	2b00      	cmp	r3, #0
  209dc6:	607b      	str	r3, [r7, #4]
  209dc8:	f340 8084 	ble.w	209ed4 <_scanf_float+0x27c>
	fp->_p++;
  209dcc:	683b      	ldr	r3, [r7, #0]
  209dce:	3301      	adds	r3, #1
  209dd0:	603b      	str	r3, [r7, #0]
  209dd2:	e766      	b.n	209ca2 <_scanf_float+0x4a>
	  if (nancount + infcount == 0)
  209dd4:	eb1a 0f05 	cmn.w	sl, r5
  209dd8:	f47f af70 	bne.w	209cbc <_scanf_float+0x64>
	      pdata->flags &= ~(SIGNOK | NDIGITS);
  209ddc:	6822      	ldr	r2, [r4, #0]
  209dde:	f422 72c0 	bic.w	r2, r2, #384	; 0x180
	      pdata->flags &= ~SIGNOK;
  209de2:	6022      	str	r2, [r4, #0]
      *p++ = c;
  209de4:	f806 3b01 	strb.w	r3, [r6], #1
  209de8:	e7e4      	b.n	209db4 <_scanf_float+0x15c>
	  if (pdata->flags & SIGNOK)
  209dea:	6822      	ldr	r2, [r4, #0]
  209dec:	0610      	lsls	r0, r2, #24
  209dee:	f57f af65 	bpl.w	209cbc <_scanf_float+0x64>
	      pdata->flags &= ~SIGNOK;
  209df2:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  209df6:	e7f4      	b.n	209de2 <_scanf_float+0x18a>
	  if (nancount == 0 && zeroes == 0
  209df8:	f1ba 0f00 	cmp.w	sl, #0
  209dfc:	d10e      	bne.n	209e1c <_scanf_float+0x1c4>
  209dfe:	f1b9 0f00 	cmp.w	r9, #0
  209e02:	d10e      	bne.n	209e22 <_scanf_float+0x1ca>
	      && (pdata->flags & (NDIGITS | DPTOK | EXPOK)) ==
  209e04:	6822      	ldr	r2, [r4, #0]
  209e06:	f402 61e0 	and.w	r1, r2, #1792	; 0x700
  209e0a:	f5b1 6fe0 	cmp.w	r1, #1792	; 0x700
  209e0e:	d108      	bne.n	209e22 <_scanf_float+0x1ca>
	      pdata->flags &= ~(SIGNOK | DPTOK | EXPOK | NDIGITS);
  209e10:	f422 62f0 	bic.w	r2, r2, #1920	; 0x780
	      nancount = 1;
  209e14:	f04f 0a01 	mov.w	sl, #1
	      pdata->flags &= ~(SIGNOK | DPTOK | EXPOK | NDIGITS);
  209e18:	6022      	str	r2, [r4, #0]
	      goto fok;
  209e1a:	e7e3      	b.n	209de4 <_scanf_float+0x18c>
	  if (nancount == 2)
  209e1c:	f1ba 0f02 	cmp.w	sl, #2
  209e20:	d055      	beq.n	209ece <_scanf_float+0x276>
	  if (infcount == 1 || infcount == 4)
  209e22:	2d01      	cmp	r5, #1
  209e24:	d002      	beq.n	209e2c <_scanf_float+0x1d4>
  209e26:	2d04      	cmp	r5, #4
	  if (infcount == 3 || infcount == 5)
  209e28:	f47f af48 	bne.w	209cbc <_scanf_float+0x64>
	      infcount++;
  209e2c:	3501      	adds	r5, #1
  209e2e:	b2ed      	uxtb	r5, r5
	      goto fok;
  209e30:	e7d8      	b.n	209de4 <_scanf_float+0x18c>
	  if (nancount == 1)
  209e32:	f1ba 0f01 	cmp.w	sl, #1
  209e36:	f47f af41 	bne.w	209cbc <_scanf_float+0x64>
	      nancount = 2;
  209e3a:	f04f 0a02 	mov.w	sl, #2
  209e3e:	e7d1      	b.n	209de4 <_scanf_float+0x18c>
	  if (infcount == 0 && zeroes == 0
  209e40:	b97d      	cbnz	r5, 209e62 <_scanf_float+0x20a>
  209e42:	f1b9 0f00 	cmp.w	r9, #0
  209e46:	f47f af3c 	bne.w	209cc2 <_scanf_float+0x6a>
	      && (pdata->flags & (NDIGITS | DPTOK | EXPOK)) ==
  209e4a:	6822      	ldr	r2, [r4, #0]
  209e4c:	f402 61e0 	and.w	r1, r2, #1792	; 0x700
  209e50:	f5b1 6fe0 	cmp.w	r1, #1792	; 0x700
  209e54:	f47f af39 	bne.w	209cca <_scanf_float+0x72>
	      pdata->flags &= ~(SIGNOK | DPTOK | EXPOK | NDIGITS);
  209e58:	f422 62f0 	bic.w	r2, r2, #1920	; 0x780
	      infcount = 1;
  209e5c:	2501      	movs	r5, #1
	      pdata->flags &= ~(SIGNOK | DPTOK | EXPOK | NDIGITS);
  209e5e:	6022      	str	r2, [r4, #0]
	      goto fok;
  209e60:	e7c0      	b.n	209de4 <_scanf_float+0x18c>
	  if (infcount == 3 || infcount == 5)
  209e62:	2d03      	cmp	r5, #3
  209e64:	d0e2      	beq.n	209e2c <_scanf_float+0x1d4>
  209e66:	2d05      	cmp	r5, #5
  209e68:	e7de      	b.n	209e28 <_scanf_float+0x1d0>
	  if (infcount == 2)
  209e6a:	2d02      	cmp	r5, #2
  209e6c:	f47f af26 	bne.w	209cbc <_scanf_float+0x64>
	      infcount = 3;
  209e70:	2503      	movs	r5, #3
  209e72:	e7b7      	b.n	209de4 <_scanf_float+0x18c>
	  if (infcount == 6)
  209e74:	2d06      	cmp	r5, #6
  209e76:	f47f af21 	bne.w	209cbc <_scanf_float+0x64>
	      infcount = 7;
  209e7a:	2507      	movs	r5, #7
  209e7c:	e7b2      	b.n	209de4 <_scanf_float+0x18c>
	  if (pdata->flags & DPTOK)
  209e7e:	6822      	ldr	r2, [r4, #0]
  209e80:	0591      	lsls	r1, r2, #22
  209e82:	f57f af1b 	bpl.w	209cbc <_scanf_float+0x64>
	      pdata->flags &= ~(SIGNOK | DPTOK);
  209e86:	f422 7220 	bic.w	r2, r2, #640	; 0x280
	      goto fok;
  209e8a:	f8cd 9004 	str.w	r9, [sp, #4]
	      pdata->flags &= ~(SIGNOK | DPTOK);
  209e8e:	6022      	str	r2, [r4, #0]
	      goto fok;
  209e90:	e7a8      	b.n	209de4 <_scanf_float+0x18c>
	  if ((pdata->flags & (NDIGITS | EXPOK)) == EXPOK
  209e92:	6822      	ldr	r2, [r4, #0]
  209e94:	f402 61a0 	and.w	r1, r2, #1280	; 0x500
  209e98:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
  209e9c:	d006      	beq.n	209eac <_scanf_float+0x254>
	      || ((pdata->flags & EXPOK) && zeroes))
  209e9e:	0550      	lsls	r0, r2, #21
  209ea0:	f57f af0c 	bpl.w	209cbc <_scanf_float+0x64>
  209ea4:	f1b9 0f00 	cmp.w	r9, #0
  209ea8:	f43f af0f 	beq.w	209cca <_scanf_float+0x72>
	      if (! (pdata->flags & DPTOK))
  209eac:	0591      	lsls	r1, r2, #22
		(pdata->flags & ~(EXPOK | DPTOK)) | SIGNOK | NDIGITS;
  209eae:	f422 62f0 	bic.w	r2, r2, #1920	; 0x780
		  exp_adjust = zeroes - leading_zeroes;
  209eb2:	bf58      	it	pl
  209eb4:	9901      	ldrpl	r1, [sp, #4]
		(pdata->flags & ~(EXPOK | DPTOK)) | SIGNOK | NDIGITS;
  209eb6:	f442 72c0 	orr.w	r2, r2, #384	; 0x180
		  exp_adjust = zeroes - leading_zeroes;
  209eba:	bf58      	it	pl
  209ebc:	eba9 0101 	subpl.w	r1, r9, r1
	      pdata->flags =
  209ec0:	6022      	str	r2, [r4, #0]
	      zeroes = 0;
  209ec2:	f04f 0900 	mov.w	r9, #0
		  exp_adjust = zeroes - leading_zeroes;
  209ec6:	bf58      	it	pl
  209ec8:	e9cd 1604 	strdpl	r1, r6, [sp, #16]
	      goto fok;
  209ecc:	e78a      	b.n	209de4 <_scanf_float+0x18c>
	      nancount = 3;
  209ece:	f04f 0a03 	mov.w	sl, #3
  209ed2:	e787      	b.n	209de4 <_scanf_float+0x18c>
      else if (pdata->pfn_refill (rptr, fp))
  209ed4:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
  209ed8:	4639      	mov	r1, r7
  209eda:	4640      	mov	r0, r8
  209edc:	4798      	blx	r3
  209ede:	2800      	cmp	r0, #0
  209ee0:	f43f aedf 	beq.w	209ca2 <_scanf_float+0x4a>
  209ee4:	e6ea      	b.n	209cbc <_scanf_float+0x64>
	  pdata->pfn_ungetc (rptr, *--p, fp); /* "[-+nNaA]".  */
  209ee6:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
  209eea:	463a      	mov	r2, r7
  209eec:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
  209ef0:	4640      	mov	r0, r8
  209ef2:	4798      	blx	r3
	  --pdata->nread;
  209ef4:	6923      	ldr	r3, [r4, #16]
  209ef6:	3b01      	subs	r3, #1
  209ef8:	6123      	str	r3, [r4, #16]
  209efa:	e6ec      	b.n	209cd6 <_scanf_float+0x7e>
  if (infcount - 1U < 7U)
  209efc:	1e6b      	subs	r3, r5, #1
  209efe:	2b06      	cmp	r3, #6
  209f00:	d825      	bhi.n	209f4e <_scanf_float+0x2f6>
      if (infcount >= 3) /* valid 'inf', but short of 'infinity'.  */
  209f02:	2d02      	cmp	r5, #2
  209f04:	d836      	bhi.n	209f74 <_scanf_float+0x31c>
	  while (p > pdata->buf)
  209f06:	455e      	cmp	r6, fp
  209f08:	f67f aee8 	bls.w	209cdc <_scanf_float+0x84>
	      pdata->pfn_ungetc (rptr, *--p, fp); /* "[-+iInN]".  */
  209f0c:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
  209f10:	463a      	mov	r2, r7
  209f12:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
  209f16:	4640      	mov	r0, r8
  209f18:	4798      	blx	r3
	      --pdata->nread;
  209f1a:	6923      	ldr	r3, [r4, #16]
  209f1c:	3b01      	subs	r3, #1
  209f1e:	6123      	str	r3, [r4, #16]
  209f20:	e7f1      	b.n	209f06 <_scanf_float+0x2ae>
	    pdata->pfn_ungetc (rptr, *--p, fp); /* "[iInNtT]".  */
  209f22:	9802      	ldr	r0, [sp, #8]
  209f24:	463a      	mov	r2, r7
  209f26:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
  209f2a:	f810 1d01 	ldrb.w	r1, [r0, #-1]!
  209f2e:	9002      	str	r0, [sp, #8]
  209f30:	4640      	mov	r0, r8
  209f32:	4798      	blx	r3
	    --pdata->nread;
  209f34:	6923      	ldr	r3, [r4, #16]
  209f36:	3b01      	subs	r3, #1
  209f38:	6123      	str	r3, [r4, #16]
	while (infcount-- > 3)
  209f3a:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
  209f3e:	fa5f fa8a 	uxtb.w	sl, sl
  209f42:	f1ba 0f02 	cmp.w	sl, #2
  209f46:	d1ec      	bne.n	209f22 <_scanf_float+0x2ca>
  209f48:	3d03      	subs	r5, #3
  209f4a:	b2ed      	uxtb	r5, r5
  209f4c:	1b76      	subs	r6, r6, r5
  if (pdata->flags & NDIGITS)
  209f4e:	6823      	ldr	r3, [r4, #0]
  209f50:	05da      	lsls	r2, r3, #23
  209f52:	d52e      	bpl.n	209fb2 <_scanf_float+0x35a>
      if (pdata->flags & EXPOK)
  209f54:	055b      	lsls	r3, r3, #21
  209f56:	d510      	bpl.n	209f7a <_scanf_float+0x322>
	  while (p > pdata->buf)
  209f58:	455e      	cmp	r6, fp
  209f5a:	f67f aebf 	bls.w	209cdc <_scanf_float+0x84>
	      pdata->pfn_ungetc (rptr, *--p, fp); /* "[-+.]".  */
  209f5e:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
  209f62:	463a      	mov	r2, r7
  209f64:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
  209f68:	4640      	mov	r0, r8
  209f6a:	4798      	blx	r3
	      --pdata->nread;
  209f6c:	6923      	ldr	r3, [r4, #16]
  209f6e:	3b01      	subs	r3, #1
  209f70:	6123      	str	r3, [r4, #16]
  209f72:	e7f1      	b.n	209f58 <_scanf_float+0x300>
  209f74:	46aa      	mov	sl, r5
  209f76:	9602      	str	r6, [sp, #8]
  209f78:	e7df      	b.n	209f3a <_scanf_float+0x2e2>
      c = *--p;
  209f7a:	f816 1c01 	ldrb.w	r1, [r6, #-1]
  209f7e:	1e75      	subs	r5, r6, #1
      --pdata->nread;
  209f80:	6923      	ldr	r3, [r4, #16]
      if (c != 'e' && c != 'E')
  209f82:	2965      	cmp	r1, #101	; 0x65
      --pdata->nread;
  209f84:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  209f88:	6123      	str	r3, [r4, #16]
      if (c != 'e' && c != 'E')
  209f8a:	d00c      	beq.n	209fa6 <_scanf_float+0x34e>
  209f8c:	2945      	cmp	r1, #69	; 0x45
  209f8e:	d00a      	beq.n	209fa6 <_scanf_float+0x34e>
	  pdata->pfn_ungetc (rptr, c, fp); /* "[-+]".  */
  209f90:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
  209f94:	463a      	mov	r2, r7
  209f96:	4640      	mov	r0, r8
	  c = *--p;
  209f98:	1eb5      	subs	r5, r6, #2
	  pdata->pfn_ungetc (rptr, c, fp); /* "[-+]".  */
  209f9a:	4798      	blx	r3
	  --pdata->nread;
  209f9c:	6923      	ldr	r3, [r4, #16]
	  c = *--p;
  209f9e:	f816 1c02 	ldrb.w	r1, [r6, #-2]
	  --pdata->nread;
  209fa2:	3b01      	subs	r3, #1
  209fa4:	6123      	str	r3, [r4, #16]
      pdata->pfn_ungetc (rptr, c, fp); /* "[eE]".  */
  209fa6:	462e      	mov	r6, r5
  209fa8:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
  209fac:	463a      	mov	r2, r7
  209fae:	4640      	mov	r0, r8
  209fb0:	4798      	blx	r3
  if ((pdata->flags & SUPPRESS) == 0)
  209fb2:	6825      	ldr	r5, [r4, #0]
  209fb4:	f015 0510 	ands.w	r5, r5, #16
  209fb8:	d14d      	bne.n	20a056 <_scanf_float+0x3fe>
      *p = 0;
  209fba:	7035      	strb	r5, [r6, #0]
      if ((pdata->flags & (DPTOK | EXPOK)) == EXPOK)
  209fbc:	6823      	ldr	r3, [r4, #0]
  209fbe:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
  209fc2:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
  209fc6:	d11a      	bne.n	209ffe <_scanf_float+0x3a6>
	  new_exp = -exp_adjust;
  209fc8:	9b01      	ldr	r3, [sp, #4]
      if (exp_adjust)
  209fca:	454b      	cmp	r3, r9
	  new_exp = -exp_adjust;
  209fcc:	eba3 0209 	sub.w	r2, r3, r9
      if (exp_adjust)
  209fd0:	d122      	bne.n	20a018 <_scanf_float+0x3c0>
      fp = _strtod_r (rptr, pdata->buf, NULL);
  209fd2:	2200      	movs	r2, #0
  209fd4:	4659      	mov	r1, fp
  209fd6:	4640      	mov	r0, r8
  209fd8:	f000 fe64 	bl	20aca4 <_strtod_r>
      if (pdata->flags & LONG)
  209fdc:	6821      	ldr	r1, [r4, #0]
  209fde:	9b03      	ldr	r3, [sp, #12]
  209fe0:	f011 0f02 	tst.w	r1, #2
  209fe4:	681b      	ldr	r3, [r3, #0]
	*GET_ARG (N, *ap, double *) = fp;
  209fe6:	f103 0204 	add.w	r2, r3, #4
      if (pdata->flags & LONG)
  209fea:	d020      	beq.n	20a02e <_scanf_float+0x3d6>
	*GET_ARG (N, *ap, double *) = fp;
  209fec:	9903      	ldr	r1, [sp, #12]
  209fee:	600a      	str	r2, [r1, #0]
	  *ldp = fp;
  209ff0:	681b      	ldr	r3, [r3, #0]
  209ff2:	ed83 0b00 	vstr	d0, [r3]
      pdata->nassigned++;
  209ff6:	68e3      	ldr	r3, [r4, #12]
  209ff8:	3301      	adds	r3, #1
  209ffa:	60e3      	str	r3, [r4, #12]
  209ffc:	e66f      	b.n	209cde <_scanf_float+0x86>
      else if (exp_adjust)
  209ffe:	9b04      	ldr	r3, [sp, #16]
  20a000:	2b00      	cmp	r3, #0
  20a002:	d0e6      	beq.n	209fd2 <_scanf_float+0x37a>
	new_exp = _strtol_r (rptr, (exp_start + 1), NULL, 10) - exp_adjust;
  20a004:	9905      	ldr	r1, [sp, #20]
  20a006:	230a      	movs	r3, #10
  20a008:	462a      	mov	r2, r5
  20a00a:	4640      	mov	r0, r8
  20a00c:	3101      	adds	r1, #1
  20a00e:	f000 fec7 	bl	20ada0 <_strtol_r>
  20a012:	9b04      	ldr	r3, [sp, #16]
  20a014:	9e05      	ldr	r6, [sp, #20]
  20a016:	1ac2      	subs	r2, r0, r3
	  if (exp_start >= pdata->buf + BUF - MAX_LONG_LEN)
  20a018:	f204 136f 	addw	r3, r4, #367	; 0x16f
	  sprintf (exp_start, "e%ld", new_exp);
  20a01c:	490f      	ldr	r1, [pc, #60]	; (20a05c <_scanf_float+0x404>)
	  if (exp_start >= pdata->buf + BUF - MAX_LONG_LEN)
  20a01e:	429e      	cmp	r6, r3
	    exp_start = pdata->buf + BUF - MAX_LONG_LEN - 1;
  20a020:	bf28      	it	cs
  20a022:	f504 76b7 	addcs.w	r6, r4, #366	; 0x16e
	  sprintf (exp_start, "e%ld", new_exp);
  20a026:	4630      	mov	r0, r6
  20a028:	f000 f832 	bl	20a090 <siprintf>
  20a02c:	e7d1      	b.n	209fd2 <_scanf_float+0x37a>
      else if (pdata->flags & LONGDBL)
  20a02e:	f011 0f04 	tst.w	r1, #4
	  ldp = GET_ARG (N, *ap, _LONG_DOUBLE *);
  20a032:	9903      	ldr	r1, [sp, #12]
  20a034:	600a      	str	r2, [r1, #0]
      else if (pdata->flags & LONGDBL)
  20a036:	d1db      	bne.n	209ff0 <_scanf_float+0x398>
	  if (isnan (fp))
  20a038:	eeb4 0b40 	vcmp.f64	d0, d0
	  flp = GET_ARG (N, *ap, float *);
  20a03c:	681e      	ldr	r6, [r3, #0]
	  if (isnan (fp))
  20a03e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20a042:	d705      	bvc.n	20a050 <_scanf_float+0x3f8>
	    *flp = nanf ("");
  20a044:	4806      	ldr	r0, [pc, #24]	; (20a060 <_scanf_float+0x408>)
  20a046:	f000 f81d 	bl	20a084 <nanf>
	    *flp = fp;
  20a04a:	ed86 0a00 	vstr	s0, [r6]
  20a04e:	e7d2      	b.n	209ff6 <_scanf_float+0x39e>
  20a050:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
  20a054:	e7f9      	b.n	20a04a <_scanf_float+0x3f2>
  return 0;
  20a056:	2500      	movs	r5, #0
  20a058:	e641      	b.n	209cde <_scanf_float+0x86>
  20a05a:	bf00      	nop
  20a05c:	0800ebe9 	.word	0x0800ebe9
  20a060:	0800dc16 	.word	0x0800dc16

0020a064 <_sbrk_r>:
*/

void *
_sbrk_r (struct _reent *ptr,
     ptrdiff_t incr)
{
  20a064:	b538      	push	{r3, r4, r5, lr}
  char *ret;
  void *_sbrk(ptrdiff_t);

  errno = 0;
  20a066:	2300      	movs	r3, #0
  20a068:	4d05      	ldr	r5, [pc, #20]	; (20a080 <_sbrk_r+0x1c>)
{
  20a06a:	4604      	mov	r4, r0
  if ((ret = (char *)(_sbrk (incr))) == (void *) -1 && errno != 0)
  20a06c:	4608      	mov	r0, r1
  errno = 0;
  20a06e:	602b      	str	r3, [r5, #0]
  if ((ret = (char *)(_sbrk (incr))) == (void *) -1 && errno != 0)
  20a070:	f7f9 ff30 	bl	203ed4 <_sbrk>
  20a074:	1c43      	adds	r3, r0, #1
  20a076:	d102      	bne.n	20a07e <_sbrk_r+0x1a>
  20a078:	682b      	ldr	r3, [r5, #0]
  20a07a:	b103      	cbz	r3, 20a07e <_sbrk_r+0x1a>
    ptr->_errno = errno;
  20a07c:	6023      	str	r3, [r4, #0]
  return ret;
}
  20a07e:	bd38      	pop	{r3, r4, r5, pc}
  20a080:	200040a0 	.word	0x200040a0

0020a084 <nanf>:
	x = __builtin_nanf("");
#else
	SET_FLOAT_WORD(x,0x7fc00000);
#endif
	return x;
}
  20a084:	ed9f 0a01 	vldr	s0, [pc, #4]	; 20a08c <nanf+0x8>
  20a088:	4770      	bx	lr
  20a08a:	bf00      	nop
  20a08c:	7fc00000 	.word	0x7fc00000

0020a090 <siprintf>:
#ifndef _REENT_ONLY

int
sprintf (char *__restrict str,
       const char *__restrict fmt, ...)
{
  20a090:	b40e      	push	{r1, r2, r3}
  20a092:	b500      	push	{lr}
  20a094:	b09c      	sub	sp, #112	; 0x70
  va_list ap;
  FILE f;

  f._flags = __SWR | __SSTR;
  f._bf._base = f._p = (unsigned char *) str;
  f._bf._size = f._w = INT_MAX;
  20a096:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
{
  20a09a:	ab1d      	add	r3, sp, #116	; 0x74
  f._bf._base = f._p = (unsigned char *) str;
  20a09c:	9002      	str	r0, [sp, #8]
  20a09e:	9006      	str	r0, [sp, #24]
  f._bf._size = f._w = INT_MAX;
  20a0a0:	9107      	str	r1, [sp, #28]
  20a0a2:	9104      	str	r1, [sp, #16]
  f._file = -1;  /* No file. */
  va_start (ap, fmt);
  ret = _svfprintf_r (_REENT, &f, fmt, ap);
  20a0a4:	4808      	ldr	r0, [pc, #32]	; (20a0c8 <siprintf+0x38>)
  f._flags = __SWR | __SSTR;
  20a0a6:	4909      	ldr	r1, [pc, #36]	; (20a0cc <siprintf+0x3c>)
{
  20a0a8:	f853 2b04 	ldr.w	r2, [r3], #4
  f._flags = __SWR | __SSTR;
  20a0ac:	9105      	str	r1, [sp, #20]
  ret = _svfprintf_r (_REENT, &f, fmt, ap);
  20a0ae:	a902      	add	r1, sp, #8
  20a0b0:	6800      	ldr	r0, [r0, #0]
  va_start (ap, fmt);
  20a0b2:	9301      	str	r3, [sp, #4]
  ret = _svfprintf_r (_REENT, &f, fmt, ap);
  20a0b4:	f002 fde2 	bl	20cc7c <_svfiprintf_r>
  va_end (ap);
  *f._p = '\0';	/* terminate the string */
  20a0b8:	9b02      	ldr	r3, [sp, #8]
  20a0ba:	2200      	movs	r2, #0
  20a0bc:	701a      	strb	r2, [r3, #0]
  return (ret);
}
  20a0be:	b01c      	add	sp, #112	; 0x70
  20a0c0:	f85d eb04 	ldr.w	lr, [sp], #4
  20a0c4:	b003      	add	sp, #12
  20a0c6:	4770      	bx	lr
  20a0c8:	20010060 	.word	0x20010060
  20a0cc:	ffff0208 	.word	0xffff0208

0020a0d0 <sulp>:

#ifdef Avoid_Underflow /*{*/
 static double
sulp (U x,
	int scale)
{
  20a0d0:	b570      	push	{r4, r5, r6, lr}
  20a0d2:	4604      	mov	r4, r0
  20a0d4:	460d      	mov	r5, r1
  20a0d6:	4616      	mov	r6, r2
        U u;
        double rv;
        int i;

        rv = ulp(dval(x));
  20a0d8:	ec45 4b10 	vmov	d0, r4, r5
  20a0dc:	f002 fbd0 	bl	20c880 <__ulp>
        if (!scale || (i = 2*P + 1 - ((dword0(x) & Exp_mask) >> Exp_shift)) <= 0)
  20a0e0:	b17e      	cbz	r6, 20a102 <sulp+0x32>
  20a0e2:	f3c5 530a 	ubfx	r3, r5, #20, #11
  20a0e6:	f1c3 036b 	rsb	r3, r3, #107	; 0x6b
  20a0ea:	2b00      	cmp	r3, #0
  20a0ec:	dd09      	ble.n	20a102 <sulp+0x32>
                return rv; /* Is there an example where i <= 0 ? */
        dword0(u) = Exp_1 + ((__int32_t)i << Exp_shift);
  20a0ee:	051b      	lsls	r3, r3, #20
  20a0f0:	2000      	movs	r0, #0
  20a0f2:	f103 517f 	add.w	r1, r3, #1069547520	; 0x3fc00000
  20a0f6:	f501 1140 	add.w	r1, r1, #3145728	; 0x300000
#ifndef _DOUBLE_IS_32BITS
        dword1(u) = 0;
#endif
        return rv * u.d;
  20a0fa:	ec41 0b17 	vmov	d7, r0, r1
  20a0fe:	ee20 0b07 	vmul.f64	d0, d0, d7
        }
  20a102:	bd70      	pop	{r4, r5, r6, pc}
  20a104:	0000      	movs	r0, r0
	...

0020a108 <_strtod_l>:
#endif /* !NO_HEX_FP */

double
_strtod_l (struct _reent *ptr, const char *__restrict s00, char **__restrict se,
	   locale_t loc)
{
  20a108:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  20a10c:	461f      	mov	r7, r3
	const char *s, *s0, *s1;
	double aadj, adj;
	U aadj1, rv, rv0;
	Long L;
	__ULong y, z;
	_Bigint *bb = NULL, *bb1, *bd = NULL, *bd0, *bs = NULL, *delta = NULL;
  20a10e:	2300      	movs	r3, #0
{
  20a110:	4604      	mov	r4, r0
  20a112:	468a      	mov	sl, r1
	const char *decimal_point = __get_numeric_locale(loc)->decimal_point;
	int dec_len = strlen (decimal_point);

	delta = bs = bd = NULL;
	sign = nz0 = nz = decpt = 0;
	dval(rv) = 0.;
  20a114:	f04f 0800 	mov.w	r8, #0
  20a118:	f04f 0900 	mov.w	r9, #0
{
  20a11c:	ed2d 8b0c 	vpush	{d8-d13}
  20a120:	b09d      	sub	sp, #116	; 0x74
	_Bigint *bb = NULL, *bb1, *bd = NULL, *bd0, *bs = NULL, *delta = NULL;
  20a122:	9318      	str	r3, [sp, #96]	; 0x60
	const char *decimal_point = __get_numeric_locale(loc)->decimal_point;
  20a124:	4ba0      	ldr	r3, [pc, #640]	; (20a3a8 <_strtod_l+0x2a0>)
{
  20a126:	9213      	str	r2, [sp, #76]	; 0x4c
	const char *decimal_point = __get_numeric_locale(loc)->decimal_point;
  20a128:	681b      	ldr	r3, [r3, #0]
	int dec_len = strlen (decimal_point);
  20a12a:	4618      	mov	r0, r3
	const char *decimal_point = __get_numeric_locale(loc)->decimal_point;
  20a12c:	9308      	str	r3, [sp, #32]
	int dec_len = strlen (decimal_point);
  20a12e:	f7f6 f932 	bl	200396 <strlen>
  20a132:	4605      	mov	r5, r0
	for(s = s00;;s++) switch(*s) {
  20a134:	f8cd a05c 	str.w	sl, [sp, #92]	; 0x5c
  20a138:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  20a13a:	781a      	ldrb	r2, [r3, #0]
  20a13c:	2a2b      	cmp	r2, #43	; 0x2b
  20a13e:	d04d      	beq.n	20a1dc <_strtod_l+0xd4>
  20a140:	d83a      	bhi.n	20a1b8 <_strtod_l+0xb0>
  20a142:	2a0d      	cmp	r2, #13
  20a144:	d833      	bhi.n	20a1ae <_strtod_l+0xa6>
  20a146:	2a08      	cmp	r2, #8
  20a148:	d833      	bhi.n	20a1b2 <_strtod_l+0xaa>
  20a14a:	2a00      	cmp	r2, #0
  20a14c:	d03d      	beq.n	20a1ca <_strtod_l+0xc2>
  20a14e:	2300      	movs	r3, #0
  20a150:	930b      	str	r3, [sp, #44]	; 0x2c
			continue;
		default:
			goto break2;
		}
 break2:
	if (*s == '0') {
  20a152:	9e17      	ldr	r6, [sp, #92]	; 0x5c
  20a154:	7833      	ldrb	r3, [r6, #0]
  20a156:	2b30      	cmp	r3, #48	; 0x30
  20a158:	f040 80b0 	bne.w	20a2bc <_strtod_l+0x1b4>
#ifndef NO_HEX_FP
		{
		static const FPI fpi = { 53, 1-1023-53+1, 2046-1023-53+1, 1, SI };
		Long exp;
		__ULong bits[2];
		switch(s[1]) {
  20a15c:	7873      	ldrb	r3, [r6, #1]
  20a15e:	f003 03df 	and.w	r3, r3, #223	; 0xdf
  20a162:	2b58      	cmp	r3, #88	; 0x58
  20a164:	d167      	bne.n	20a236 <_strtod_l+0x12e>
			  case FE_DOWNWARD:	fpi1.rounding = 3;
			  }
#else
#define fpi1 fpi
#endif
			switch((i = gethex(ptr, &s, &fpi1, &exp, &bb, sign, loc)) & STRTOG_Retmask) {
  20a166:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  20a168:	a917      	add	r1, sp, #92	; 0x5c
  20a16a:	9702      	str	r7, [sp, #8]
  20a16c:	4620      	mov	r0, r4
  20a16e:	9301      	str	r3, [sp, #4]
  20a170:	ab18      	add	r3, sp, #96	; 0x60
  20a172:	4a8e      	ldr	r2, [pc, #568]	; (20a3ac <_strtod_l+0x2a4>)
  20a174:	9300      	str	r3, [sp, #0]
  20a176:	ab19      	add	r3, sp, #100	; 0x64
  20a178:	f001 fd52 	bl	20bc20 <__gethex>
  20a17c:	f010 0507 	ands.w	r5, r0, #7
  20a180:	4607      	mov	r7, r0
  20a182:	d005      	beq.n	20a190 <_strtod_l+0x88>
  20a184:	2d06      	cmp	r5, #6
  20a186:	d12b      	bne.n	20a1e0 <_strtod_l+0xd8>
			  case STRTOG_NoNumber:
				s = s00;
  20a188:	3601      	adds	r6, #1
				sign = 0;
  20a18a:	2300      	movs	r3, #0
				s = s00;
  20a18c:	9617      	str	r6, [sp, #92]	; 0x5c
				sign = 0;
  20a18e:	930b      	str	r3, [sp, #44]	; 0x2c
	Bfree(ptr,bd);
	Bfree(ptr,bs);
	Bfree(ptr,bd0);
	Bfree(ptr,delta);
 ret:
	if (se)
  20a190:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  20a192:	2b00      	cmp	r3, #0
  20a194:	f040 8566 	bne.w	20ac64 <_strtod_l+0xb5c>
		*se = (char *)s;
	return sign ? -dval(rv) : dval(rv);
  20a198:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  20a19a:	b1e3      	cbz	r3, 20a1d6 <_strtod_l+0xce>
  20a19c:	ec49 8b17 	vmov	d7, r8, r9
  20a1a0:	eeb1 0b47 	vneg.f64	d0, d7
}
  20a1a4:	b01d      	add	sp, #116	; 0x74
  20a1a6:	ecbd 8b0c 	vpop	{d8-d13}
  20a1aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for(s = s00;;s++) switch(*s) {
  20a1ae:	2a20      	cmp	r2, #32
  20a1b0:	d1cd      	bne.n	20a14e <_strtod_l+0x46>
  20a1b2:	3301      	adds	r3, #1
  20a1b4:	9317      	str	r3, [sp, #92]	; 0x5c
  20a1b6:	e7bf      	b.n	20a138 <_strtod_l+0x30>
  20a1b8:	2a2d      	cmp	r2, #45	; 0x2d
  20a1ba:	d1c8      	bne.n	20a14e <_strtod_l+0x46>
			sign = 1;
  20a1bc:	2201      	movs	r2, #1
	for(s = s00;;s++) switch(*s) {
  20a1be:	920b      	str	r2, [sp, #44]	; 0x2c
			if (*++s)
  20a1c0:	1c5a      	adds	r2, r3, #1
  20a1c2:	9217      	str	r2, [sp, #92]	; 0x5c
  20a1c4:	785b      	ldrb	r3, [r3, #1]
  20a1c6:	2b00      	cmp	r3, #0
  20a1c8:	d1c3      	bne.n	20a152 <_strtod_l+0x4a>
	if (se)
  20a1ca:	9b13      	ldr	r3, [sp, #76]	; 0x4c
			s = s00;
  20a1cc:	f8cd a05c 	str.w	sl, [sp, #92]	; 0x5c
	if (se)
  20a1d0:	2b00      	cmp	r3, #0
  20a1d2:	f040 8545 	bne.w	20ac60 <_strtod_l+0xb58>
	return sign ? -dval(rv) : dval(rv);
  20a1d6:	ec49 8b10 	vmov	d0, r8, r9
  20a1da:	e7e3      	b.n	20a1a4 <_strtod_l+0x9c>
	for(s = s00;;s++) switch(*s) {
  20a1dc:	2200      	movs	r2, #0
  20a1de:	e7ee      	b.n	20a1be <_strtod_l+0xb6>
				if (bb) {
  20a1e0:	9a18      	ldr	r2, [sp, #96]	; 0x60
  20a1e2:	b13a      	cbz	r2, 20a1f4 <_strtod_l+0xec>
					copybits(bits, fpi.nbits, bb);
  20a1e4:	2135      	movs	r1, #53	; 0x35
  20a1e6:	a81a      	add	r0, sp, #104	; 0x68
  20a1e8:	f002 fc48 	bl	20ca7c <__copybits>
					Bfree(ptr,bb);
  20a1ec:	9918      	ldr	r1, [sp, #96]	; 0x60
  20a1ee:	4620      	mov	r0, r4
  20a1f0:	f002 f87b 	bl	20c2ea <_Bfree>
	switch(k & STRTOG_Retmask) {
  20a1f4:	3d01      	subs	r5, #1
  20a1f6:	2d04      	cmp	r5, #4
  20a1f8:	d806      	bhi.n	20a208 <_strtod_l+0x100>
  20a1fa:	e8df f005 	tbb	[pc, r5]
  20a1fe:	030a      	.short	0x030a
  20a200:	1714      	.short	0x1714
  20a202:	0a          	.byte	0x0a
  20a203:	00          	.byte	0x00
		L[_0] = bits[1];
  20a204:	e9dd 891a 	ldrd	r8, r9, [sp, #104]	; 0x68
	if (k & STRTOG_Neg)
  20a208:	073b      	lsls	r3, r7, #28
  20a20a:	d5c1      	bpl.n	20a190 <_strtod_l+0x88>
		L[_0] |= 0x80000000L;
  20a20c:	f049 4900 	orr.w	r9, r9, #2147483648	; 0x80000000
			goto ret;
  20a210:	e7be      	b.n	20a190 <_strtod_l+0x88>
		L[_0] = (bits[1] & ~0x100000) | ((exp + 0x3ff + 52) << 20);
  20a212:	e9dd 831a 	ldrd	r8, r3, [sp, #104]	; 0x68
  20a216:	9a19      	ldr	r2, [sp, #100]	; 0x64
  20a218:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
  20a21c:	f202 4233 	addw	r2, r2, #1075	; 0x433
  20a220:	ea43 5902 	orr.w	r9, r3, r2, lsl #20
		break;
  20a224:	e7f0      	b.n	20a208 <_strtod_l+0x100>
		L[_0] = 0x7ff00000;
  20a226:	f8df 9188 	ldr.w	r9, [pc, #392]	; 20a3b0 <_strtod_l+0x2a8>
		break;
  20a22a:	e7ed      	b.n	20a208 <_strtod_l+0x100>
		L[_0] = 0x7fffffff;
  20a22c:	f06f 4900 	mvn.w	r9, #2147483648	; 0x80000000
		L[_1] = (__ULong)-1;
  20a230:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
  20a234:	e7e8      	b.n	20a208 <_strtod_l+0x100>
		while(*++s == '0') ;
  20a236:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  20a238:	1c5a      	adds	r2, r3, #1
  20a23a:	9217      	str	r2, [sp, #92]	; 0x5c
  20a23c:	785b      	ldrb	r3, [r3, #1]
  20a23e:	2b30      	cmp	r3, #48	; 0x30
  20a240:	d0f9      	beq.n	20a236 <_strtod_l+0x12e>
		if (!*s)
  20a242:	2b00      	cmp	r3, #0
  20a244:	d0a4      	beq.n	20a190 <_strtod_l+0x88>
		nz0 = 1;
  20a246:	2301      	movs	r3, #1
	sign = nz0 = nz = decpt = 0;
  20a248:	9306      	str	r3, [sp, #24]
	s0 = s;
  20a24a:	220a      	movs	r2, #10
  20a24c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  20a24e:	930c      	str	r3, [sp, #48]	; 0x30
	y = z = 0;
  20a250:	2300      	movs	r3, #0
	for(nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)
  20a252:	461e      	mov	r6, r3
	y = z = 0;
  20a254:	9304      	str	r3, [sp, #16]
  20a256:	930a      	str	r3, [sp, #40]	; 0x28
	for(nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)
  20a258:	9817      	ldr	r0, [sp, #92]	; 0x5c
  20a25a:	f890 b000 	ldrb.w	fp, [r0]
  20a25e:	f1ab 0330 	sub.w	r3, fp, #48	; 0x30
  20a262:	b2d9      	uxtb	r1, r3
  20a264:	2909      	cmp	r1, #9
  20a266:	d92b      	bls.n	20a2c0 <_strtod_l+0x1b8>
	if (strncmp (s, decimal_point, dec_len) == 0)
  20a268:	462a      	mov	r2, r5
  20a26a:	9908      	ldr	r1, [sp, #32]
  20a26c:	f002 ff93 	bl	20d196 <strncmp>
  20a270:	2800      	cmp	r0, #0
  20a272:	d036      	beq.n	20a2e2 <_strtod_l+0x1da>
	sign = nz0 = nz = decpt = 0;
  20a274:	2000      	movs	r0, #0
	for(nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)
  20a276:	465a      	mov	r2, fp
  20a278:	4633      	mov	r3, r6
  20a27a:	4683      	mov	fp, r0
	sign = nz0 = nz = decpt = 0;
  20a27c:	4601      	mov	r1, r0
	if (c == 'e' || c == 'E') {
  20a27e:	2a65      	cmp	r2, #101	; 0x65
  20a280:	d001      	beq.n	20a286 <_strtod_l+0x17e>
  20a282:	2a45      	cmp	r2, #69	; 0x45
  20a284:	d118      	bne.n	20a2b8 <_strtod_l+0x1b0>
		if (!nd && !nz && !nz0) {
  20a286:	b91b      	cbnz	r3, 20a290 <_strtod_l+0x188>
  20a288:	9b06      	ldr	r3, [sp, #24]
  20a28a:	4303      	orrs	r3, r0
  20a28c:	d09d      	beq.n	20a1ca <_strtod_l+0xc2>
  20a28e:	2300      	movs	r3, #0
		s00 = s;
  20a290:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
		switch(c = *++s) {
  20a294:	f10a 0201 	add.w	r2, sl, #1
  20a298:	9217      	str	r2, [sp, #92]	; 0x5c
  20a29a:	f89a 2001 	ldrb.w	r2, [sl, #1]
  20a29e:	2a2b      	cmp	r2, #43	; 0x2b
  20a2a0:	d077      	beq.n	20a392 <_strtod_l+0x28a>
  20a2a2:	2a2d      	cmp	r2, #45	; 0x2d
  20a2a4:	d07d      	beq.n	20a3a2 <_strtod_l+0x29a>
		esign = 0;
  20a2a6:	f04f 0e00 	mov.w	lr, #0
		if (c >= '0' && c <= '9') {
  20a2aa:	f1a2 0530 	sub.w	r5, r2, #48	; 0x30
  20a2ae:	2d09      	cmp	r5, #9
  20a2b0:	f240 8084 	bls.w	20a3bc <_strtod_l+0x2b4>
			s = s00;
  20a2b4:	f8cd a05c 	str.w	sl, [sp, #92]	; 0x5c
				e = 0;
  20a2b8:	2500      	movs	r5, #0
  20a2ba:	e09f      	b.n	20a3fc <_strtod_l+0x2f4>
	sign = nz0 = nz = decpt = 0;
  20a2bc:	2300      	movs	r3, #0
  20a2be:	e7c3      	b.n	20a248 <_strtod_l+0x140>
		if (nd < 9)
  20a2c0:	2e08      	cmp	r6, #8
	for(nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)
  20a2c2:	f100 0001 	add.w	r0, r0, #1
  20a2c6:	f106 0601 	add.w	r6, r6, #1
			y = 10*y + c - '0';
  20a2ca:	bfd5      	itete	le
  20a2cc:	990a      	ldrle	r1, [sp, #40]	; 0x28
			z = 10*z + c - '0';
  20a2ce:	9904      	ldrgt	r1, [sp, #16]
			y = 10*y + c - '0';
  20a2d0:	fb02 3301 	mlale	r3, r2, r1, r3
			z = 10*z + c - '0';
  20a2d4:	fb02 3301 	mlagt	r3, r2, r1, r3
			y = 10*y + c - '0';
  20a2d8:	bfd4      	ite	le
  20a2da:	930a      	strle	r3, [sp, #40]	; 0x28
			z = 10*z + c - '0';
  20a2dc:	9304      	strgt	r3, [sp, #16]
	for(nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)
  20a2de:	9017      	str	r0, [sp, #92]	; 0x5c
  20a2e0:	e7ba      	b.n	20a258 <_strtod_l+0x150>
		c = *(s += dec_len);
  20a2e2:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  20a2e4:	195a      	adds	r2, r3, r5
  20a2e6:	9217      	str	r2, [sp, #92]	; 0x5c
  20a2e8:	5d5a      	ldrb	r2, [r3, r5]
		if (!nd) {
  20a2ea:	b3a6      	cbz	r6, 20a356 <_strtod_l+0x24e>
	for(nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)
  20a2ec:	4683      	mov	fp, r0
  20a2ee:	4633      	mov	r3, r6
		for(; c >= '0' && c <= '9'; c = *++s) {
  20a2f0:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
  20a2f4:	2909      	cmp	r1, #9
  20a2f6:	d912      	bls.n	20a31e <_strtod_l+0x216>
		decpt = 1;
  20a2f8:	2101      	movs	r1, #1
  20a2fa:	e7c0      	b.n	20a27e <_strtod_l+0x176>
			for(; c == '0'; c = *++s)
  20a2fc:	9b17      	ldr	r3, [sp, #92]	; 0x5c
				nz++;
  20a2fe:	3001      	adds	r0, #1
			for(; c == '0'; c = *++s)
  20a300:	1c5a      	adds	r2, r3, #1
  20a302:	9217      	str	r2, [sp, #92]	; 0x5c
  20a304:	785a      	ldrb	r2, [r3, #1]
  20a306:	2a30      	cmp	r2, #48	; 0x30
  20a308:	d0f8      	beq.n	20a2fc <_strtod_l+0x1f4>
			if (c > '0' && c <= '9') {
  20a30a:	f1a2 0331 	sub.w	r3, r2, #49	; 0x31
  20a30e:	2b08      	cmp	r3, #8
  20a310:	f200 84ad 	bhi.w	20ac6e <_strtod_l+0xb66>
				s0 = s;
  20a314:	9b17      	ldr	r3, [sp, #92]	; 0x5c
				goto have_dig;
  20a316:	4683      	mov	fp, r0
				nz = 0;
  20a318:	2000      	movs	r0, #0
				s0 = s;
  20a31a:	930c      	str	r3, [sp, #48]	; 0x30
				goto have_dig;
  20a31c:	4603      	mov	r3, r0
			if (c -= '0') {
  20a31e:	3a30      	subs	r2, #48	; 0x30
			nz++;
  20a320:	f100 0101 	add.w	r1, r0, #1
			if (c -= '0') {
  20a324:	d011      	beq.n	20a34a <_strtod_l+0x242>
				nf += nz;
  20a326:	448b      	add	fp, r1
				for(i = 1; i < nz; i++)
  20a328:	eb00 0c03 	add.w	ip, r0, r3
  20a32c:	4619      	mov	r1, r3
						z *= 10;
  20a32e:	250a      	movs	r5, #10
				for(i = 1; i < nz; i++)
  20a330:	458c      	cmp	ip, r1
  20a332:	d112      	bne.n	20a35a <_strtod_l+0x252>
  20a334:	1819      	adds	r1, r3, r0
  20a336:	3301      	adds	r3, #1
				if (nd++ < 9)
  20a338:	2908      	cmp	r1, #8
  20a33a:	4403      	add	r3, r0
  20a33c:	dc1d      	bgt.n	20a37a <_strtod_l+0x272>
					y = 10*y + c;
  20a33e:	980a      	ldr	r0, [sp, #40]	; 0x28
  20a340:	210a      	movs	r1, #10
  20a342:	fb01 2200 	mla	r2, r1, r0, r2
  20a346:	920a      	str	r2, [sp, #40]	; 0x28
				nz = 0;
  20a348:	2100      	movs	r1, #0
		for(; c >= '0' && c <= '9'; c = *++s) {
  20a34a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
  20a34c:	1c50      	adds	r0, r2, #1
  20a34e:	9017      	str	r0, [sp, #92]	; 0x5c
  20a350:	4608      	mov	r0, r1
  20a352:	7852      	ldrb	r2, [r2, #1]
  20a354:	e7cc      	b.n	20a2f0 <_strtod_l+0x1e8>
	sign = nz0 = nz = decpt = 0;
  20a356:	4630      	mov	r0, r6
  20a358:	e7d5      	b.n	20a306 <_strtod_l+0x1fe>
					if (nd++ < 9)
  20a35a:	2908      	cmp	r1, #8
  20a35c:	dc04      	bgt.n	20a368 <_strtod_l+0x260>
						y *= 10;
  20a35e:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  20a360:	436f      	muls	r7, r5
  20a362:	970a      	str	r7, [sp, #40]	; 0x28
  20a364:	3101      	adds	r1, #1
  20a366:	e7e3      	b.n	20a330 <_strtod_l+0x228>
					else if (nd <= DBL_DIG + 1)
  20a368:	f101 0e01 	add.w	lr, r1, #1
  20a36c:	f1be 0f10 	cmp.w	lr, #16
						z *= 10;
  20a370:	bfde      	ittt	le
  20a372:	9f04      	ldrle	r7, [sp, #16]
  20a374:	436f      	mulle	r7, r5
  20a376:	9704      	strle	r7, [sp, #16]
  20a378:	e7f4      	b.n	20a364 <_strtod_l+0x25c>
				else if (nd <= DBL_DIG + 1)
  20a37a:	2b10      	cmp	r3, #16
					z = 10*z + c;
  20a37c:	bfdf      	itttt	le
  20a37e:	9804      	ldrle	r0, [sp, #16]
  20a380:	210a      	movle	r1, #10
  20a382:	fb01 2200 	mlale	r2, r1, r0, r2
  20a386:	9204      	strle	r2, [sp, #16]
  20a388:	e7de      	b.n	20a348 <_strtod_l+0x240>
	for(nd = nf = 0; (c = *s) >= '0' && c <= '9'; nd++, s++)
  20a38a:	f04f 0b00 	mov.w	fp, #0
		decpt = 1;
  20a38e:	2101      	movs	r1, #1
  20a390:	e77a      	b.n	20a288 <_strtod_l+0x180>
		switch(c = *++s) {
  20a392:	f04f 0e00 	mov.w	lr, #0
				c = *++s;
  20a396:	f10a 0202 	add.w	r2, sl, #2
  20a39a:	9217      	str	r2, [sp, #92]	; 0x5c
  20a39c:	f89a 2002 	ldrb.w	r2, [sl, #2]
  20a3a0:	e783      	b.n	20a2aa <_strtod_l+0x1a2>
				esign = 1;
  20a3a2:	f04f 0e01 	mov.w	lr, #1
  20a3a6:	e7f6      	b.n	20a396 <_strtod_l+0x28e>
  20a3a8:	0800edb0 	.word	0x0800edb0
  20a3ac:	0800ebf0 	.word	0x0800ebf0
  20a3b0:	7ff00000 	.word	0x7ff00000
				c = *++s;
  20a3b4:	9a17      	ldr	r2, [sp, #92]	; 0x5c
  20a3b6:	1c55      	adds	r5, r2, #1
  20a3b8:	9517      	str	r5, [sp, #92]	; 0x5c
  20a3ba:	7852      	ldrb	r2, [r2, #1]
			while(c == '0')
  20a3bc:	2a30      	cmp	r2, #48	; 0x30
  20a3be:	d0f9      	beq.n	20a3b4 <_strtod_l+0x2ac>
			if (c > '0' && c <= '9') {
  20a3c0:	f1a2 0531 	sub.w	r5, r2, #49	; 0x31
  20a3c4:	2d08      	cmp	r5, #8
  20a3c6:	f63f af77 	bhi.w	20a2b8 <_strtod_l+0x1b0>
				L = c - '0';
  20a3ca:	f1a2 0c30 	sub.w	ip, r2, #48	; 0x30
				s1 = s;
  20a3ce:	9a17      	ldr	r2, [sp, #92]	; 0x5c
  20a3d0:	9208      	str	r2, [sp, #32]
				while((c = *++s) >= '0' && c <= '9')
  20a3d2:	9a17      	ldr	r2, [sp, #92]	; 0x5c
  20a3d4:	1c55      	adds	r5, r2, #1
  20a3d6:	9517      	str	r5, [sp, #92]	; 0x5c
  20a3d8:	7852      	ldrb	r2, [r2, #1]
  20a3da:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
  20a3de:	2f09      	cmp	r7, #9
  20a3e0:	d937      	bls.n	20a452 <_strtod_l+0x34a>
				if (s - s1 > 8 || L > 19999)
  20a3e2:	9f08      	ldr	r7, [sp, #32]
  20a3e4:	1bed      	subs	r5, r5, r7
  20a3e6:	2d08      	cmp	r5, #8
  20a3e8:	f644 651f 	movw	r5, #19999	; 0x4e1f
  20a3ec:	dc02      	bgt.n	20a3f4 <_strtod_l+0x2ec>
  20a3ee:	4565      	cmp	r5, ip
  20a3f0:	bfa8      	it	ge
  20a3f2:	4665      	movge	r5, ip
				if (esign)
  20a3f4:	f1be 0f00 	cmp.w	lr, #0
  20a3f8:	d000      	beq.n	20a3fc <_strtod_l+0x2f4>
					e = -e;
  20a3fa:	426d      	negs	r5, r5
	if (!nd) {
  20a3fc:	2b00      	cmp	r3, #0
  20a3fe:	d14d      	bne.n	20a49c <_strtod_l+0x394>
		if (!nz && !nz0) {
  20a400:	9b06      	ldr	r3, [sp, #24]
  20a402:	4303      	orrs	r3, r0
  20a404:	f47f aec4 	bne.w	20a190 <_strtod_l+0x88>
			if (!decpt)
  20a408:	2900      	cmp	r1, #0
  20a40a:	f47f aede 	bne.w	20a1ca <_strtod_l+0xc2>
			 switch(c) {
  20a40e:	2a69      	cmp	r2, #105	; 0x69
  20a410:	d027      	beq.n	20a462 <_strtod_l+0x35a>
  20a412:	dc24      	bgt.n	20a45e <_strtod_l+0x356>
  20a414:	2a49      	cmp	r2, #73	; 0x49
  20a416:	d024      	beq.n	20a462 <_strtod_l+0x35a>
  20a418:	2a4e      	cmp	r2, #78	; 0x4e
  20a41a:	f47f aed6 	bne.w	20a1ca <_strtod_l+0xc2>
				if (match(&s, "an")) {
  20a41e:	499a      	ldr	r1, [pc, #616]	; (20a688 <_strtod_l+0x580>)
  20a420:	a817      	add	r0, sp, #92	; 0x5c
  20a422:	f001 fe43 	bl	20c0ac <__match>
  20a426:	2800      	cmp	r0, #0
  20a428:	f43f aecf 	beq.w	20a1ca <_strtod_l+0xc2>
					if (*s == '(' /*)*/
  20a42c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  20a42e:	781b      	ldrb	r3, [r3, #0]
  20a430:	2b28      	cmp	r3, #40	; 0x28
  20a432:	d12b      	bne.n	20a48c <_strtod_l+0x384>
					 && hexnan(&s, &fpinan, bits)
  20a434:	aa1a      	add	r2, sp, #104	; 0x68
  20a436:	4995      	ldr	r1, [pc, #596]	; (20a68c <_strtod_l+0x584>)
  20a438:	a817      	add	r0, sp, #92	; 0x5c
  20a43a:	f001 fe4b 	bl	20c0d4 <__hexnan>
  20a43e:	2805      	cmp	r0, #5
  20a440:	d124      	bne.n	20a48c <_strtod_l+0x384>
						dword0(rv) = 0x7ff00000 | bits[1];
  20a442:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
						dword1(rv) = bits[0];
  20a444:	f8dd 8068 	ldr.w	r8, [sp, #104]	; 0x68
						dword0(rv) = 0x7ff00000 | bits[1];
  20a448:	f043 49ff 	orr.w	r9, r3, #2139095040	; 0x7f800000
  20a44c:	f449 09e0 	orr.w	r9, r9, #7340032	; 0x700000
						dword1(rv) = bits[0];
  20a450:	e69e      	b.n	20a190 <_strtod_l+0x88>
					L = 10*L + c - '0';
  20a452:	250a      	movs	r5, #10
  20a454:	fb05 250c 	mla	r5, r5, ip, r2
  20a458:	f1a5 0c30 	sub.w	ip, r5, #48	; 0x30
  20a45c:	e7b9      	b.n	20a3d2 <_strtod_l+0x2ca>
			 switch(c) {
  20a45e:	2a6e      	cmp	r2, #110	; 0x6e
  20a460:	e7db      	b.n	20a41a <_strtod_l+0x312>
				if (match(&s,"nf")) {
  20a462:	498b      	ldr	r1, [pc, #556]	; (20a690 <_strtod_l+0x588>)
  20a464:	a817      	add	r0, sp, #92	; 0x5c
  20a466:	f001 fe21 	bl	20c0ac <__match>
  20a46a:	2800      	cmp	r0, #0
  20a46c:	f43f aead 	beq.w	20a1ca <_strtod_l+0xc2>
					--s;
  20a470:	9b17      	ldr	r3, [sp, #92]	; 0x5c
					if (!match(&s,"inity"))
  20a472:	a817      	add	r0, sp, #92	; 0x5c
  20a474:	4987      	ldr	r1, [pc, #540]	; (20a694 <_strtod_l+0x58c>)
					--s;
  20a476:	3b01      	subs	r3, #1
  20a478:	9317      	str	r3, [sp, #92]	; 0x5c
					if (!match(&s,"inity"))
  20a47a:	f001 fe17 	bl	20c0ac <__match>
  20a47e:	b910      	cbnz	r0, 20a486 <_strtod_l+0x37e>
						++s;
  20a480:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  20a482:	3301      	adds	r3, #1
  20a484:	9317      	str	r3, [sp, #92]	; 0x5c
					dword0(rv) = 0x7ff00000;
  20a486:	f8df 9220 	ldr.w	r9, [pc, #544]	; 20a6a8 <_strtod_l+0x5a0>
					goto ret;
  20a48a:	e681      	b.n	20a190 <_strtod_l+0x88>
						dval(rv) = nan ("");
  20a48c:	4882      	ldr	r0, [pc, #520]	; (20a698 <_strtod_l+0x590>)
  20a48e:	f002 fe37 	bl	20d100 <nan>
  20a492:	ed8d 0b04 	vstr	d0, [sp, #16]
  20a496:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
  20a49a:	e679      	b.n	20a190 <_strtod_l+0x88>
	dval(rv) = y;
  20a49c:	eddd 7a0a 	vldr	s15, [sp, #40]	; 0x28
	e1 = e -= nf;
  20a4a0:	eba5 020b 	sub.w	r2, r5, fp
	if (!nd0)
  20a4a4:	2e00      	cmp	r6, #0
  20a4a6:	bf08      	it	eq
  20a4a8:	461e      	moveq	r6, r3
	k = nd < DBL_DIG + 1 ? nd : DBL_DIG + 1;
  20a4aa:	2b10      	cmp	r3, #16
	dval(rv) = y;
  20a4ac:	eeb8 7b67 	vcvt.f64.u32	d7, s15
	e1 = e -= nf;
  20a4b0:	9206      	str	r2, [sp, #24]
	k = nd < DBL_DIG + 1 ? nd : DBL_DIG + 1;
  20a4b2:	461a      	mov	r2, r3
  20a4b4:	bfa8      	it	ge
  20a4b6:	2210      	movge	r2, #16
	if (k > 9) {
  20a4b8:	2b09      	cmp	r3, #9
	dval(rv) = y;
  20a4ba:	ed8d 7b08 	vstr	d7, [sp, #32]
  20a4be:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
	if (k > 9) {
  20a4c2:	dd0e      	ble.n	20a4e2 <_strtod_l+0x3da>
		dval(rv) = tens[k - 9] * dval(rv) + z;
  20a4c4:	4975      	ldr	r1, [pc, #468]	; (20a69c <_strtod_l+0x594>)
  20a4c6:	eddd 7a04 	vldr	s15, [sp, #16]
  20a4ca:	eb01 01c2 	add.w	r1, r1, r2, lsl #3
  20a4ce:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  20a4d2:	ed11 6b12 	vldr	d6, [r1, #-72]	; 0xffffffb8
  20a4d6:	ed9d 5b08 	vldr	d5, [sp, #32]
  20a4da:	eea5 7b06 	vfma.f64	d7, d5, d6
  20a4de:	ec59 8b17 	vmov	r8, r9, d7
	if (nd <= DBL_DIG
  20a4e2:	2b0f      	cmp	r3, #15
  20a4e4:	dc37      	bgt.n	20a556 <_strtod_l+0x44e>
		if (!e)
  20a4e6:	9906      	ldr	r1, [sp, #24]
  20a4e8:	2900      	cmp	r1, #0
  20a4ea:	f43f ae51 	beq.w	20a190 <_strtod_l+0x88>
		if (e > 0) {
  20a4ee:	dd23      	ble.n	20a538 <_strtod_l+0x430>
			if (e <= Ten_pmax) {
  20a4f0:	2916      	cmp	r1, #22
  20a4f2:	dc0b      	bgt.n	20a50c <_strtod_l+0x404>
				/* rv = */ rounded_product(dval(rv), tens[e]);
  20a4f4:	4b69      	ldr	r3, [pc, #420]	; (20a69c <_strtod_l+0x594>)
  20a4f6:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
  20a4fa:	ed93 7b00 	vldr	d7, [r3]
  20a4fe:	ec49 8b16 	vmov	d6, r8, r9
				/* rv = */ rounded_product(dval(rv), tens[e]);
  20a502:	ee27 7b06 	vmul.f64	d7, d7, d6
  20a506:	ec59 8b17 	vmov	r8, r9, d7
				goto ret;
  20a50a:	e641      	b.n	20a190 <_strtod_l+0x88>
			if (e <= Ten_pmax + i) {
  20a50c:	f1c3 0125 	rsb	r1, r3, #37	; 0x25
  20a510:	9806      	ldr	r0, [sp, #24]
  20a512:	4281      	cmp	r1, r0
  20a514:	db1f      	blt.n	20a556 <_strtod_l+0x44e>
			i = DBL_DIG - nd;
  20a516:	f1c3 030f 	rsb	r3, r3, #15
				dval(rv) *= tens[i];
  20a51a:	4a60      	ldr	r2, [pc, #384]	; (20a69c <_strtod_l+0x594>)
  20a51c:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
				e -= i;
  20a520:	1ac3      	subs	r3, r0, r3
				dval(rv) *= tens[i];
  20a522:	ed91 7b00 	vldr	d7, [r1]
				/* rv = */ rounded_product(dval(rv), tens[e]);
  20a526:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
				dval(rv) *= tens[i];
  20a52a:	ec49 8b16 	vmov	d6, r8, r9
  20a52e:	ee27 7b06 	vmul.f64	d7, d7, d6
				/* rv = */ rounded_product(dval(rv), tens[e]);
  20a532:	ed92 6b00 	vldr	d6, [r2]
  20a536:	e7e4      	b.n	20a502 <_strtod_l+0x3fa>
		else if (e >= -Ten_pmax) {
  20a538:	9906      	ldr	r1, [sp, #24]
  20a53a:	3116      	adds	r1, #22
  20a53c:	db0b      	blt.n	20a556 <_strtod_l+0x44e>
			/* rv = */ rounded_quotient(dval(rv), tens[-e]);
  20a53e:	ebab 0505 	sub.w	r5, fp, r5
  20a542:	4b56      	ldr	r3, [pc, #344]	; (20a69c <_strtod_l+0x594>)
  20a544:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
  20a548:	ed95 7b00 	vldr	d7, [r5]
  20a54c:	ec49 8b16 	vmov	d6, r8, r9
  20a550:	ee86 7b07 	vdiv.f64	d7, d6, d7
  20a554:	e7d7      	b.n	20a506 <_strtod_l+0x3fe>
	e1 += nd - k;
  20a556:	1a9a      	subs	r2, r3, r2
  20a558:	9906      	ldr	r1, [sp, #24]
  20a55a:	440a      	add	r2, r1
	if (e1 > 0) {
  20a55c:	2a00      	cmp	r2, #0
  20a55e:	dd74      	ble.n	20a64a <_strtod_l+0x542>
		if ( (i = e1 & 15) !=0)
  20a560:	f012 000f 	ands.w	r0, r2, #15
  20a564:	d00a      	beq.n	20a57c <_strtod_l+0x474>
			dval(rv) *= tens[i];
  20a566:	494d      	ldr	r1, [pc, #308]	; (20a69c <_strtod_l+0x594>)
  20a568:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
  20a56c:	ed91 7b00 	vldr	d7, [r1]
  20a570:	ec49 8b16 	vmov	d6, r8, r9
  20a574:	ee27 7b06 	vmul.f64	d7, d7, d6
  20a578:	ec59 8b17 	vmov	r8, r9, d7
		if (e1 &= ~15) {
  20a57c:	f032 020f 	bics.w	r2, r2, #15
  20a580:	d04f      	beq.n	20a622 <_strtod_l+0x51a>
			if (e1 > DBL_MAX_10_EXP) {
  20a582:	f5b2 7f9a 	cmp.w	r2, #308	; 0x134
  20a586:	dd22      	ble.n	20a5ce <_strtod_l+0x4c6>
	delta = bs = bd = NULL;
  20a588:	2500      	movs	r5, #0
  20a58a:	462e      	mov	r6, r5
  20a58c:	462f      	mov	r7, r5
	bd0 = 0;
  20a58e:	950a      	str	r5, [sp, #40]	; 0x28
				ptr->_errno = ERANGE;
  20a590:	2322      	movs	r3, #34	; 0x22
				dword0(rv) = Exp_mask;
  20a592:	f8df 9114 	ldr.w	r9, [pc, #276]	; 20a6a8 <_strtod_l+0x5a0>
				dword1(rv) = 0;
  20a596:	f04f 0800 	mov.w	r8, #0
				ptr->_errno = ERANGE;
  20a59a:	6023      	str	r3, [r4, #0]
					if (bd0)
  20a59c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  20a59e:	2b00      	cmp	r3, #0
  20a5a0:	f43f adf6 	beq.w	20a190 <_strtod_l+0x88>
	Bfree(ptr,bb);
  20a5a4:	9918      	ldr	r1, [sp, #96]	; 0x60
  20a5a6:	4620      	mov	r0, r4
  20a5a8:	f001 fe9f 	bl	20c2ea <_Bfree>
	Bfree(ptr,bd);
  20a5ac:	4639      	mov	r1, r7
  20a5ae:	4620      	mov	r0, r4
  20a5b0:	f001 fe9b 	bl	20c2ea <_Bfree>
	Bfree(ptr,bs);
  20a5b4:	4631      	mov	r1, r6
  20a5b6:	4620      	mov	r0, r4
  20a5b8:	f001 fe97 	bl	20c2ea <_Bfree>
	Bfree(ptr,bd0);
  20a5bc:	990a      	ldr	r1, [sp, #40]	; 0x28
  20a5be:	4620      	mov	r0, r4
  20a5c0:	f001 fe93 	bl	20c2ea <_Bfree>
	Bfree(ptr,delta);
  20a5c4:	4629      	mov	r1, r5
  20a5c6:	4620      	mov	r0, r4
  20a5c8:	f001 fe8f 	bl	20c2ea <_Bfree>
  20a5cc:	e5e0      	b.n	20a190 <_strtod_l+0x88>
			for(j = 0; e1 > 1; j++, e1 >>= 1)
  20a5ce:	2000      	movs	r0, #0
			e1 >>= 4;
  20a5d0:	1112      	asrs	r2, r2, #4
					dval(rv) *= bigtens[j];
  20a5d2:	4f33      	ldr	r7, [pc, #204]	; (20a6a0 <_strtod_l+0x598>)
			for(j = 0; e1 > 1; j++, e1 >>= 1)
  20a5d4:	4601      	mov	r1, r0
  20a5d6:	e9cd 8904 	strd	r8, r9, [sp, #16]
  20a5da:	2a01      	cmp	r2, #1
  20a5dc:	dc24      	bgt.n	20a628 <_strtod_l+0x520>
  20a5de:	b108      	cbz	r0, 20a5e4 <_strtod_l+0x4dc>
  20a5e0:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
			dval(rv) *= bigtens[j];
  20a5e4:	4a2e      	ldr	r2, [pc, #184]	; (20a6a0 <_strtod_l+0x598>)
			dword0(rv) -= P*Exp_msk1;
  20a5e6:	f1a9 7954 	sub.w	r9, r9, #55574528	; 0x3500000
			if ((z = dword0(rv) & Exp_mask)
  20a5ea:	482e      	ldr	r0, [pc, #184]	; (20a6a4 <_strtod_l+0x59c>)
			dval(rv) *= bigtens[j];
  20a5ec:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
			if ((z = dword0(rv) & Exp_mask)
  20a5f0:	4a2d      	ldr	r2, [pc, #180]	; (20a6a8 <_strtod_l+0x5a0>)
			dval(rv) *= bigtens[j];
  20a5f2:	ed91 7b00 	vldr	d7, [r1]
  20a5f6:	ec49 8b16 	vmov	d6, r8, r9
  20a5fa:	ee27 7b06 	vmul.f64	d7, d7, d6
  20a5fe:	ed8d 7b04 	vstr	d7, [sp, #16]
  20a602:	9905      	ldr	r1, [sp, #20]
			if ((z = dword0(rv) & Exp_mask)
  20a604:	400a      	ands	r2, r1
  20a606:	4282      	cmp	r2, r0
			dval(rv) *= bigtens[j];
  20a608:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
			if ((z = dword0(rv) & Exp_mask)
  20a60c:	d8bc      	bhi.n	20a588 <_strtod_l+0x480>
			if (z > Exp_msk1*(DBL_MAX_EXP+Bias-1-P)) {
  20a60e:	f5a0 1080 	sub.w	r0, r0, #1048576	; 0x100000
  20a612:	4282      	cmp	r2, r0
				dword0(rv) = Big0;
  20a614:	bf86      	itte	hi
  20a616:	f8df 9094 	ldrhi.w	r9, [pc, #148]	; 20a6ac <_strtod_l+0x5a4>
				dword1(rv) = Big1;
  20a61a:	f04f 38ff 	movhi.w	r8, #4294967295	; 0xffffffff
				dword0(rv) += P*Exp_msk1;
  20a61e:	f101 7954 	addls.w	r9, r1, #55574528	; 0x3500000
	scale = 0;
  20a622:	2200      	movs	r2, #0
  20a624:	9204      	str	r2, [sp, #16]
  20a626:	e080      	b.n	20a72a <_strtod_l+0x622>
				if (e1 & 1)
  20a628:	f012 0f01 	tst.w	r2, #1
  20a62c:	d00a      	beq.n	20a644 <_strtod_l+0x53c>
					dval(rv) *= bigtens[j];
  20a62e:	eb07 00c1 	add.w	r0, r7, r1, lsl #3
  20a632:	ed9d 6b04 	vldr	d6, [sp, #16]
  20a636:	ed90 7b00 	vldr	d7, [r0]
  20a63a:	2001      	movs	r0, #1
  20a63c:	ee26 7b07 	vmul.f64	d7, d6, d7
  20a640:	ed8d 7b04 	vstr	d7, [sp, #16]
			for(j = 0; e1 > 1; j++, e1 >>= 1)
  20a644:	3101      	adds	r1, #1
  20a646:	1052      	asrs	r2, r2, #1
  20a648:	e7c7      	b.n	20a5da <_strtod_l+0x4d2>
	else if (e1 < 0) {
  20a64a:	d0ea      	beq.n	20a622 <_strtod_l+0x51a>
		e1 = -e1;
  20a64c:	4252      	negs	r2, r2
		if ( (i = e1 & 15) !=0)
  20a64e:	f012 000f 	ands.w	r0, r2, #15
  20a652:	d00a      	beq.n	20a66a <_strtod_l+0x562>
			dval(rv) /= tens[i];
  20a654:	4911      	ldr	r1, [pc, #68]	; (20a69c <_strtod_l+0x594>)
  20a656:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
  20a65a:	ed91 7b00 	vldr	d7, [r1]
  20a65e:	ec49 8b16 	vmov	d6, r8, r9
  20a662:	ee86 7b07 	vdiv.f64	d7, d6, d7
  20a666:	ec59 8b17 	vmov	r8, r9, d7
		if (e1 >>= 4) {
  20a66a:	1112      	asrs	r2, r2, #4
  20a66c:	d0d9      	beq.n	20a622 <_strtod_l+0x51a>
			if (e1 >= 1 << n_bigtens)
  20a66e:	2a1f      	cmp	r2, #31
  20a670:	dd1e      	ble.n	20a6b0 <_strtod_l+0x5a8>
	delta = bs = bd = NULL;
  20a672:	2500      	movs	r5, #0
  20a674:	462e      	mov	r6, r5
  20a676:	462f      	mov	r7, r5
	bd0 = 0;
  20a678:	950a      	str	r5, [sp, #40]	; 0x28
					ptr->_errno = ERANGE;
  20a67a:	2322      	movs	r3, #34	; 0x22
					dval(rv) = 0.;
  20a67c:	f04f 0800 	mov.w	r8, #0
  20a680:	f04f 0900 	mov.w	r9, #0
					ptr->_errno = ERANGE;
  20a684:	6023      	str	r3, [r4, #0]
  20a686:	e789      	b.n	20a59c <_strtod_l+0x494>
  20a688:	0800ebc4 	.word	0x0800ebc4
  20a68c:	0800ec04 	.word	0x0800ec04
  20a690:	0800ebbc 	.word	0x0800ebbc
  20a694:	0800ed44 	.word	0x0800ed44
  20a698:	0800dc16 	.word	0x0800dc16
  20a69c:	0800edf0 	.word	0x0800edf0
  20a6a0:	0800edc8 	.word	0x0800edc8
  20a6a4:	7ca00000 	.word	0x7ca00000
  20a6a8:	7ff00000 	.word	0x7ff00000
  20a6ac:	7fefffff 	.word	0x7fefffff
				scale = 2*P;
  20a6b0:	f012 0110 	ands.w	r1, r2, #16
  20a6b4:	f04f 0000 	mov.w	r0, #0
  20a6b8:	bf18      	it	ne
  20a6ba:	216a      	movne	r1, #106	; 0x6a
  20a6bc:	9104      	str	r1, [sp, #16]
			for(j = 0; e1 > 0; j++, e1 >>= 1)
  20a6be:	49c0      	ldr	r1, [pc, #768]	; (20a9c0 <_strtod_l+0x8b8>)
  20a6c0:	e9cd 8908 	strd	r8, r9, [sp, #32]
				if (e1 & 1)
  20a6c4:	07d7      	lsls	r7, r2, #31
  20a6c6:	d508      	bpl.n	20a6da <_strtod_l+0x5d2>
					dval(rv) *= tinytens[j];
  20a6c8:	2001      	movs	r0, #1
  20a6ca:	ed9d 6b08 	vldr	d6, [sp, #32]
  20a6ce:	ed91 7b00 	vldr	d7, [r1]
  20a6d2:	ee26 7b07 	vmul.f64	d7, d6, d7
  20a6d6:	ed8d 7b08 	vstr	d7, [sp, #32]
			for(j = 0; e1 > 0; j++, e1 >>= 1)
  20a6da:	1052      	asrs	r2, r2, #1
  20a6dc:	f101 0108 	add.w	r1, r1, #8
  20a6e0:	d1f0      	bne.n	20a6c4 <_strtod_l+0x5bc>
  20a6e2:	b108      	cbz	r0, 20a6e8 <_strtod_l+0x5e0>
  20a6e4:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
			if (scale && (j = 2*P + 1 - ((dword0(rv) & Exp_mask)
  20a6e8:	9a04      	ldr	r2, [sp, #16]
  20a6ea:	b1ba      	cbz	r2, 20a71c <_strtod_l+0x614>
						>> Exp_shift)) > 0) {
  20a6ec:	f3c9 520a 	ubfx	r2, r9, #20, #11
			if (scale && (j = 2*P + 1 - ((dword0(rv) & Exp_mask)
  20a6f0:	4649      	mov	r1, r9
  20a6f2:	f1c2 026b 	rsb	r2, r2, #107	; 0x6b
  20a6f6:	2a00      	cmp	r2, #0
  20a6f8:	dd10      	ble.n	20a71c <_strtod_l+0x614>
				if (j >= 32) {
  20a6fa:	2a1f      	cmp	r2, #31
  20a6fc:	f340 8131 	ble.w	20a962 <_strtod_l+0x85a>
					if (j >= 53)
  20a700:	2a34      	cmp	r2, #52	; 0x34
					dword1(rv) = 0;
  20a702:	f04f 0800 	mov.w	r8, #0
					 dword0(rv) &= 0xffffffff << (j-32);
  20a706:	bfdb      	ittet	le
  20a708:	3a20      	suble	r2, #32
  20a70a:	f04f 30ff 	movle.w	r0, #4294967295	; 0xffffffff
					 dword0(rv) = (P+2)*Exp_msk1;
  20a70e:	f04f 795c 	movgt.w	r9, #57671680	; 0x3700000
					 dword0(rv) &= 0xffffffff << (j-32);
  20a712:	fa00 f202 	lslle.w	r2, r0, r2
  20a716:	bfd8      	it	le
  20a718:	ea02 0901 	andle.w	r9, r2, r1
				if (!dval(rv)) {
  20a71c:	ec49 8b17 	vmov	d7, r8, r9
  20a720:	eeb5 7b40 	vcmp.f64	d7, #0.0
  20a724:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20a728:	d0a3      	beq.n	20a672 <_strtod_l+0x56a>
	bd0 = s2b(ptr, s0, nd0, nd, y);
  20a72a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  20a72c:	4620      	mov	r0, r4
  20a72e:	990c      	ldr	r1, [sp, #48]	; 0x30
  20a730:	9200      	str	r2, [sp, #0]
  20a732:	4632      	mov	r2, r6
  20a734:	f001 fe2f 	bl	20c396 <__s2b>
	if (bd0 == NULL)
  20a738:	900a      	str	r0, [sp, #40]	; 0x28
  20a73a:	2800      	cmp	r0, #0
  20a73c:	f43f af24 	beq.w	20a588 <_strtod_l+0x480>
  20a740:	9b06      	ldr	r3, [sp, #24]
			bb2 = bb5 = -e;
  20a742:	ebab 0505 	sub.w	r5, fp, r5
  20a746:	2b00      	cmp	r3, #0
  20a748:	bfb4      	ite	lt
  20a74a:	462b      	movlt	r3, r5
  20a74c:	2300      	movge	r3, #0
	delta = bs = bd = NULL;
  20a74e:	2500      	movs	r5, #0
  20a750:	930c      	str	r3, [sp, #48]	; 0x30
  20a752:	9b06      	ldr	r3, [sp, #24]
  20a754:	462e      	mov	r6, r5
			else if (aadj < .4999999/FLT_RADIX)
  20a756:	ed9f 9b94 	vldr	d9, [pc, #592]	; 20a9a8 <_strtod_l+0x8a0>
				if (aadj < .4999999 || aadj > .5000001)
  20a75a:	ed9f ab95 	vldr	d10, [pc, #596]	; 20a9b0 <_strtod_l+0x8a8>
  20a75e:	ed9f bb96 	vldr	d11, [pc, #600]	; 20a9b8 <_strtod_l+0x8b0>
  20a762:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  20a766:	9312      	str	r3, [sp, #72]	; 0x48
		bd = Balloc(ptr,bd0->_k);
  20a768:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  20a76a:	4620      	mov	r0, r4
  20a76c:	6859      	ldr	r1, [r3, #4]
  20a76e:	f001 fd88 	bl	20c282 <_Balloc>
		if (bd == NULL)
  20a772:	4607      	mov	r7, r0
  20a774:	2800      	cmp	r0, #0
  20a776:	f43f af0b 	beq.w	20a590 <_strtod_l+0x488>
		Bcopy(bd, bd0);
  20a77a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  20a77c:	300c      	adds	r0, #12
  20a77e:	691a      	ldr	r2, [r3, #16]
  20a780:	f103 010c 	add.w	r1, r3, #12
  20a784:	3202      	adds	r2, #2
  20a786:	0092      	lsls	r2, r2, #2
  20a788:	f001 fd66 	bl	20c258 <memcpy>
		bb = d2b(ptr,dval(rv), &bbe, &bbbits);	/* rv = bb * 2^bbe */
  20a78c:	aa1a      	add	r2, sp, #104	; 0x68
  20a78e:	a919      	add	r1, sp, #100	; 0x64
  20a790:	4620      	mov	r0, r4
  20a792:	ec49 8b10 	vmov	d0, r8, r9
  20a796:	e9cd 8908 	strd	r8, r9, [sp, #32]
  20a79a:	f002 f8eb 	bl	20c974 <__d2b>
  20a79e:	9018      	str	r0, [sp, #96]	; 0x60
		if (bb == NULL)
  20a7a0:	2800      	cmp	r0, #0
  20a7a2:	f43f aef5 	beq.w	20a590 <_strtod_l+0x488>
		bs = i2b(ptr,1);
  20a7a6:	2101      	movs	r1, #1
  20a7a8:	4620      	mov	r0, r4
  20a7aa:	f001 fe82 	bl	20c4b2 <__i2b>
		if (bs == NULL)
  20a7ae:	4606      	mov	r6, r0
  20a7b0:	2800      	cmp	r0, #0
  20a7b2:	f43f aeed 	beq.w	20a590 <_strtod_l+0x488>
		if (bbe >= 0)
  20a7b6:	9b19      	ldr	r3, [sp, #100]	; 0x64
		i = j + bbbits - 1;	/* logb(rv) */
  20a7b8:	991a      	ldr	r1, [sp, #104]	; 0x68
		if (bbe >= 0)
  20a7ba:	2b00      	cmp	r3, #0
			bb2 += bbe;
  20a7bc:	bfa9      	itett	ge
  20a7be:	9a0c      	ldrge	r2, [sp, #48]	; 0x30
			bd2 -= bbe;
  20a7c0:	9a12      	ldrlt	r2, [sp, #72]	; 0x48
			bb2 += bbe;
  20a7c2:	eb03 0b02 	addge.w	fp, r3, r2
  20a7c6:	f8dd a048 	ldrge.w	sl, [sp, #72]	; 0x48
			bd2 -= bbe;
  20a7ca:	bfb8      	it	lt
  20a7cc:	eba2 0a03 	sublt.w	sl, r2, r3
		j = bbe - scale;
  20a7d0:	9a04      	ldr	r2, [sp, #16]
			bd2 -= bbe;
  20a7d2:	bfb8      	it	lt
  20a7d4:	f8dd b030 	ldrlt.w	fp, [sp, #48]	; 0x30
		j = bbe - scale;
  20a7d8:	1a9b      	subs	r3, r3, r2
		if (i < Emin) {	/* denormal */
  20a7da:	4a7a      	ldr	r2, [pc, #488]	; (20a9c4 <_strtod_l+0x8bc>)
		i = j + bbbits - 1;	/* logb(rv) */
  20a7dc:	440b      	add	r3, r1
		j = P + 1 - bbbits;
  20a7de:	f1c1 0136 	rsb	r1, r1, #54	; 0x36
		i = j + bbbits - 1;	/* logb(rv) */
  20a7e2:	3b01      	subs	r3, #1
		if (i < Emin) {	/* denormal */
  20a7e4:	4293      	cmp	r3, r2
  20a7e6:	f280 80cf 	bge.w	20a988 <_strtod_l+0x880>
			i = Emin - i;
  20a7ea:	1ad2      	subs	r2, r2, r3
			j -= i;
  20a7ec:	2001      	movs	r0, #1
			if (i < 32)
  20a7ee:	2a1f      	cmp	r2, #31
			j -= i;
  20a7f0:	eba1 0102 	sub.w	r1, r1, r2
			if (i < 32)
  20a7f4:	f300 80bc 	bgt.w	20a970 <_strtod_l+0x868>
				Lsb <<= i;
  20a7f8:	fa00 f302 	lsl.w	r3, r0, r2
  20a7fc:	930e      	str	r3, [sp, #56]	; 0x38
		Lsb1 = 0;
  20a7fe:	2300      	movs	r3, #0
  20a800:	930d      	str	r3, [sp, #52]	; 0x34
		bb2 += j;
  20a802:	eb0b 0301 	add.w	r3, fp, r1
		bd2 += scale;
  20a806:	9a04      	ldr	r2, [sp, #16]
		bd2 += j;
  20a808:	448a      	add	sl, r1
		bd2 += scale;
  20a80a:	459b      	cmp	fp, r3
  20a80c:	4492      	add	sl, r2
		if (i > bs2)
  20a80e:	465a      	mov	r2, fp
  20a810:	bfa8      	it	ge
  20a812:	461a      	movge	r2, r3
  20a814:	4552      	cmp	r2, sl
  20a816:	bfa8      	it	ge
  20a818:	4652      	movge	r2, sl
		if (i > 0) {
  20a81a:	2a00      	cmp	r2, #0
			bb2 -= i;
  20a81c:	bfc2      	ittt	gt
  20a81e:	1a9b      	subgt	r3, r3, r2
			bd2 -= i;
  20a820:	ebaa 0a02 	subgt.w	sl, sl, r2
			bs2 -= i;
  20a824:	ebab 0b02 	subgt.w	fp, fp, r2
		if (bb5 > 0) {
  20a828:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  20a82a:	2a00      	cmp	r2, #0
  20a82c:	dd18      	ble.n	20a860 <_strtod_l+0x758>
			bs = pow5mult(ptr, bs, bb5);
  20a82e:	4631      	mov	r1, r6
  20a830:	4620      	mov	r0, r4
  20a832:	9315      	str	r3, [sp, #84]	; 0x54
  20a834:	f001 fee2 	bl	20c5fc <__pow5mult>
			if (bs == NULL)
  20a838:	4606      	mov	r6, r0
  20a83a:	2800      	cmp	r0, #0
  20a83c:	f43f aea8 	beq.w	20a590 <_strtod_l+0x488>
			bb1 = mult(ptr, bs, bb);
  20a840:	4601      	mov	r1, r0
  20a842:	9a18      	ldr	r2, [sp, #96]	; 0x60
  20a844:	4620      	mov	r0, r4
  20a846:	f001 fe3d 	bl	20c4c4 <__multiply>
			if (bb1 == NULL)
  20a84a:	9014      	str	r0, [sp, #80]	; 0x50
  20a84c:	2800      	cmp	r0, #0
  20a84e:	f43f ae9f 	beq.w	20a590 <_strtod_l+0x488>
			Bfree(ptr, bb);
  20a852:	9918      	ldr	r1, [sp, #96]	; 0x60
  20a854:	4620      	mov	r0, r4
  20a856:	f001 fd48 	bl	20c2ea <_Bfree>
			bb = bb1;
  20a85a:	9a14      	ldr	r2, [sp, #80]	; 0x50
  20a85c:	9b15      	ldr	r3, [sp, #84]	; 0x54
  20a85e:	9218      	str	r2, [sp, #96]	; 0x60
		if (bb2 > 0) {
  20a860:	2b00      	cmp	r3, #0
  20a862:	f300 8096 	bgt.w	20a992 <_strtod_l+0x88a>
		if (bd5 > 0) {
  20a866:	9b06      	ldr	r3, [sp, #24]
  20a868:	2b00      	cmp	r3, #0
  20a86a:	dd08      	ble.n	20a87e <_strtod_l+0x776>
			bd = pow5mult(ptr, bd, bd5);
  20a86c:	4639      	mov	r1, r7
  20a86e:	9a12      	ldr	r2, [sp, #72]	; 0x48
  20a870:	4620      	mov	r0, r4
  20a872:	f001 fec3 	bl	20c5fc <__pow5mult>
			if (bd == NULL)
  20a876:	4607      	mov	r7, r0
  20a878:	2800      	cmp	r0, #0
  20a87a:	f43f ae89 	beq.w	20a590 <_strtod_l+0x488>
		if (bd2 > 0) {
  20a87e:	f1ba 0f00 	cmp.w	sl, #0
  20a882:	dd08      	ble.n	20a896 <_strtod_l+0x78e>
			bd = lshift(ptr, bd, bd2);
  20a884:	4639      	mov	r1, r7
  20a886:	4652      	mov	r2, sl
  20a888:	4620      	mov	r0, r4
  20a88a:	f001 ff05 	bl	20c698 <__lshift>
			if (bd == NULL)
  20a88e:	4607      	mov	r7, r0
  20a890:	2800      	cmp	r0, #0
  20a892:	f43f ae7d 	beq.w	20a590 <_strtod_l+0x488>
		if (bs2 > 0) {
  20a896:	f1bb 0f00 	cmp.w	fp, #0
  20a89a:	dd08      	ble.n	20a8ae <_strtod_l+0x7a6>
			bs = lshift(ptr, bs, bs2);
  20a89c:	4631      	mov	r1, r6
  20a89e:	465a      	mov	r2, fp
  20a8a0:	4620      	mov	r0, r4
  20a8a2:	f001 fef9 	bl	20c698 <__lshift>
			if (bs == NULL)
  20a8a6:	4606      	mov	r6, r0
  20a8a8:	2800      	cmp	r0, #0
  20a8aa:	f43f ae71 	beq.w	20a590 <_strtod_l+0x488>
		delta = diff(ptr, bb, bd);
  20a8ae:	463a      	mov	r2, r7
  20a8b0:	9918      	ldr	r1, [sp, #96]	; 0x60
  20a8b2:	4620      	mov	r0, r4
  20a8b4:	f001 ff6b 	bl	20c78e <__mdiff>
		if (delta == NULL)
  20a8b8:	4605      	mov	r5, r0
  20a8ba:	2800      	cmp	r0, #0
  20a8bc:	f43f ae68 	beq.w	20a590 <_strtod_l+0x488>
		delta->_sign = 0;
  20a8c0:	2300      	movs	r3, #0
		dsign = delta->_sign;
  20a8c2:	f8d0 a00c 	ldr.w	sl, [r0, #12]
		i = cmp(delta, bs);
  20a8c6:	4631      	mov	r1, r6
		delta->_sign = 0;
  20a8c8:	60c3      	str	r3, [r0, #12]
		i = cmp(delta, bs);
  20a8ca:	f001 ff44 	bl	20c756 <__mcmp>
		if (i < 0) {
  20a8ce:	2800      	cmp	r0, #0
  20a8d0:	da7e      	bge.n	20a9d0 <_strtod_l+0x8c8>
			if (dsign || dword1(rv) || dword0(rv) & Bndry_mask
  20a8d2:	ea5a 0308 	orrs.w	r3, sl, r8
  20a8d6:	f040 80a4 	bne.w	20aa22 <_strtod_l+0x91a>
  20a8da:	f3c9 0313 	ubfx	r3, r9, #0, #20
  20a8de:	2b00      	cmp	r3, #0
  20a8e0:	f040 809f 	bne.w	20aa22 <_strtod_l+0x91a>
			 || (dword0(rv) & Exp_mask) <= (2*P+1)*Exp_msk1
  20a8e4:	f029 4300 	bic.w	r3, r9, #2147483648	; 0x80000000
  20a8e8:	0d1b      	lsrs	r3, r3, #20
  20a8ea:	051b      	lsls	r3, r3, #20
  20a8ec:	f1b3 6fd6 	cmp.w	r3, #112197632	; 0x6b00000
  20a8f0:	f240 8097 	bls.w	20aa22 <_strtod_l+0x91a>
			if (!delta->_x[0] && delta->_wds <= 1) {
  20a8f4:	696b      	ldr	r3, [r5, #20]
  20a8f6:	b91b      	cbnz	r3, 20a900 <_strtod_l+0x7f8>
  20a8f8:	692b      	ldr	r3, [r5, #16]
  20a8fa:	2b01      	cmp	r3, #1
  20a8fc:	f340 8091 	ble.w	20aa22 <_strtod_l+0x91a>
			delta = lshift(ptr,delta,Log2P);
  20a900:	4629      	mov	r1, r5
  20a902:	2201      	movs	r2, #1
  20a904:	4620      	mov	r0, r4
  20a906:	f001 fec7 	bl	20c698 <__lshift>
			if (cmp(delta, bs) > 0)
  20a90a:	4631      	mov	r1, r6
			delta = lshift(ptr,delta,Log2P);
  20a90c:	4605      	mov	r5, r0
			if (cmp(delta, bs) > 0)
  20a90e:	f001 ff22 	bl	20c756 <__mcmp>
  20a912:	2800      	cmp	r0, #0
  20a914:	f340 8085 	ble.w	20aa22 <_strtod_l+0x91a>
				if (scale) {
  20a918:	9904      	ldr	r1, [sp, #16]
  20a91a:	464b      	mov	r3, r9
  20a91c:	4a2a      	ldr	r2, [pc, #168]	; (20a9c8 <_strtod_l+0x8c0>)
  20a91e:	2900      	cmp	r1, #0
  20a920:	f000 80a0 	beq.w	20aa64 <_strtod_l+0x95c>
					L = dword0(rv) & Exp_mask;
  20a924:	ea02 0109 	and.w	r1, r2, r9
					if (L <= (2*P+1)*Exp_msk1) {
  20a928:	f1b1 6fd6 	cmp.w	r1, #112197632	; 0x6b00000
  20a92c:	f300 809a 	bgt.w	20aa64 <_strtod_l+0x95c>
						if (L > (P+2)*Exp_msk1)
  20a930:	f1b1 7f5c 	cmp.w	r1, #57671680	; 0x3700000
  20a934:	f77f aea1 	ble.w	20a67a <_strtod_l+0x572>
		dword1(rv0) = 0;
  20a938:	2300      	movs	r3, #0
  20a93a:	4a24      	ldr	r2, [pc, #144]	; (20a9cc <_strtod_l+0x8c4>)
  20a93c:	e9cd 3210 	strd	r3, r2, [sp, #64]	; 0x40
		dval(rv) *= dval(rv0);
  20a940:	ed9d 6b10 	vldr	d6, [sp, #64]	; 0x40
  20a944:	ec49 8b17 	vmov	d7, r8, r9
  20a948:	ee27 7b06 	vmul.f64	d7, d7, d6
  20a94c:	ed8d 7b04 	vstr	d7, [sp, #16]
		if (dword0(rv) == 0 && dword1(rv) == 0)
  20a950:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
		dval(rv) *= dval(rv0);
  20a954:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
		if (dword0(rv) == 0 && dword1(rv) == 0)
  20a958:	4313      	orrs	r3, r2
			ptr->_errno = ERANGE;
  20a95a:	bf04      	itt	eq
  20a95c:	2322      	moveq	r3, #34	; 0x22
  20a95e:	6023      	streq	r3, [r4, #0]
  20a960:	e620      	b.n	20a5a4 <_strtod_l+0x49c>
					dword1(rv) &= 0xffffffff << j;
  20a962:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  20a966:	fa01 f202 	lsl.w	r2, r1, r2
  20a96a:	ea02 0808 	and.w	r8, r2, r8
  20a96e:	e6d5      	b.n	20a71c <_strtod_l+0x614>
				Lsb1 = Lsb << (i-32);
  20a970:	f1c3 437f 	rsb	r3, r3, #4278190080	; 0xff000000
  20a974:	f503 037f 	add.w	r3, r3, #16711680	; 0xff0000
  20a978:	f503 437b 	add.w	r3, r3, #64256	; 0xfb00
  20a97c:	33e2      	adds	r3, #226	; 0xe2
  20a97e:	fa00 f303 	lsl.w	r3, r0, r3
		Lsb = LSB;
  20a982:	e9cd 300d 	strd	r3, r0, [sp, #52]	; 0x34
  20a986:	e73c      	b.n	20a802 <_strtod_l+0x6fa>
  20a988:	2000      	movs	r0, #0
  20a98a:	2301      	movs	r3, #1
  20a98c:	e9cd 030d 	strd	r0, r3, [sp, #52]	; 0x34
  20a990:	e737      	b.n	20a802 <_strtod_l+0x6fa>
			bb = lshift(ptr, bb, bb2);
  20a992:	461a      	mov	r2, r3
  20a994:	9918      	ldr	r1, [sp, #96]	; 0x60
  20a996:	4620      	mov	r0, r4
  20a998:	f001 fe7e 	bl	20c698 <__lshift>
  20a99c:	9018      	str	r0, [sp, #96]	; 0x60
			if (bb == NULL)
  20a99e:	2800      	cmp	r0, #0
  20a9a0:	f47f af61 	bne.w	20a866 <_strtod_l+0x75e>
  20a9a4:	e5f4      	b.n	20a590 <_strtod_l+0x488>
  20a9a6:	bf00      	nop
  20a9a8:	94a03595 	.word	0x94a03595
  20a9ac:	3fcfffff 	.word	0x3fcfffff
  20a9b0:	94a03595 	.word	0x94a03595
  20a9b4:	3fdfffff 	.word	0x3fdfffff
  20a9b8:	35afe535 	.word	0x35afe535
  20a9bc:	3fe00000 	.word	0x3fe00000
  20a9c0:	0800ec18 	.word	0x0800ec18
  20a9c4:	fffffc02 	.word	0xfffffc02
  20a9c8:	7ff00000 	.word	0x7ff00000
  20a9cc:	39500000 	.word	0x39500000
		if (i == 0) {
  20a9d0:	46cb      	mov	fp, r9
  20a9d2:	d165      	bne.n	20aaa0 <_strtod_l+0x998>
			if (dsign) {
  20a9d4:	f3c9 0313 	ubfx	r3, r9, #0, #20
  20a9d8:	f1ba 0f00 	cmp.w	sl, #0
  20a9dc:	d02a      	beq.n	20aa34 <_strtod_l+0x92c>
				if ((dword0(rv) & Bndry_mask1) == Bndry_mask1
  20a9de:	4aaa      	ldr	r2, [pc, #680]	; (20ac88 <_strtod_l+0xb80>)
  20a9e0:	4293      	cmp	r3, r2
  20a9e2:	d12b      	bne.n	20aa3c <_strtod_l+0x934>
		? (0xffffffff & (0xffffffff << (2*P+1-(y>>Exp_shift)))) :
  20a9e4:	9b04      	ldr	r3, [sp, #16]
				 &&  dword1(rv) == (
  20a9e6:	4641      	mov	r1, r8
		? (0xffffffff & (0xffffffff << (2*P+1-(y>>Exp_shift)))) :
  20a9e8:	b1fb      	cbz	r3, 20aa2a <_strtod_l+0x922>
			(scale && (y = dword0(rv) & Exp_mask) <= 2*P*Exp_msk1)
  20a9ea:	4aa8      	ldr	r2, [pc, #672]	; (20ac8c <_strtod_l+0xb84>)
  20a9ec:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  20a9f0:	ea09 0202 	and.w	r2, r9, r2
  20a9f4:	f1b2 6fd4 	cmp.w	r2, #111149056	; 0x6a00000
  20a9f8:	d81a      	bhi.n	20aa30 <_strtod_l+0x928>
		? (0xffffffff & (0xffffffff << (2*P+1-(y>>Exp_shift)))) :
  20a9fa:	0d12      	lsrs	r2, r2, #20
  20a9fc:	f1c2 036b 	rsb	r3, r2, #107	; 0x6b
  20aa00:	fa00 f303 	lsl.w	r3, r0, r3
				 &&  dword1(rv) == (
  20aa04:	4299      	cmp	r1, r3
  20aa06:	d119      	bne.n	20aa3c <_strtod_l+0x934>
					if (dword0(rv) == Big0 && dword1(rv) == Big1)
  20aa08:	4ba1      	ldr	r3, [pc, #644]	; (20ac90 <_strtod_l+0xb88>)
  20aa0a:	459b      	cmp	fp, r3
  20aa0c:	d102      	bne.n	20aa14 <_strtod_l+0x90c>
  20aa0e:	3101      	adds	r1, #1
  20aa10:	f43f adbe 	beq.w	20a590 <_strtod_l+0x488>
					dword0(rv) = (dword0(rv) & Exp_mask)
  20aa14:	4b9d      	ldr	r3, [pc, #628]	; (20ac8c <_strtod_l+0xb84>)
					dword1(rv) = 0;
  20aa16:	f04f 0800 	mov.w	r8, #0
					dword0(rv) = (dword0(rv) & Exp_mask)
  20aa1a:	ea0b 0303 	and.w	r3, fp, r3
  20aa1e:	f503 1980 	add.w	r9, r3, #1048576	; 0x100000
	if (scale) {
  20aa22:	9b04      	ldr	r3, [sp, #16]
  20aa24:	2b00      	cmp	r3, #0
  20aa26:	d187      	bne.n	20a938 <_strtod_l+0x830>
 retfree:
  20aa28:	e5bc      	b.n	20a5a4 <_strtod_l+0x49c>
		? (0xffffffff & (0xffffffff << (2*P+1-(y>>Exp_shift)))) :
  20aa2a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  20aa2e:	e7e9      	b.n	20aa04 <_strtod_l+0x8fc>
  20aa30:	4603      	mov	r3, r0
  20aa32:	e7e7      	b.n	20aa04 <_strtod_l+0x8fc>
			else if (!(dword0(rv) & Bndry_mask) && !dword1(rv)) {
  20aa34:	ea53 0308 	orrs.w	r3, r3, r8
  20aa38:	f43f af6e 	beq.w	20a918 <_strtod_l+0x810>
			if (Lsb1) {
  20aa3c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  20aa3e:	b1db      	cbz	r3, 20aa78 <_strtod_l+0x970>
				if (!(dword0(rv) & Lsb1))
  20aa40:	ea13 0f0b 	tst.w	r3, fp
			else if (!(dword1(rv) & Lsb))
  20aa44:	d0ed      	beq.n	20aa22 <_strtod_l+0x91a>
				dval(rv) += sulp(rv, scale);
  20aa46:	9a04      	ldr	r2, [sp, #16]
  20aa48:	4640      	mov	r0, r8
  20aa4a:	4649      	mov	r1, r9
			if (dsign)
  20aa4c:	f1ba 0f00 	cmp.w	sl, #0
  20aa50:	d016      	beq.n	20aa80 <_strtod_l+0x978>
				dval(rv) += sulp(rv, scale);
  20aa52:	f7ff fb3d 	bl	20a0d0 <sulp>
  20aa56:	ed9d 7b08 	vldr	d7, [sp, #32]
  20aa5a:	ee37 7b00 	vadd.f64	d7, d7, d0
  20aa5e:	ec59 8b17 	vmov	r8, r9, d7
  20aa62:	e7de      	b.n	20aa22 <_strtod_l+0x91a>
				L = (dword0(rv) & Exp_mask) - Exp_msk1;
  20aa64:	4013      	ands	r3, r2
				dword1(rv) = 0xffffffff;
  20aa66:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
				L = (dword0(rv) & Exp_mask) - Exp_msk1;
  20aa6a:	f5a3 1380 	sub.w	r3, r3, #1048576	; 0x100000
				dword0(rv) = L | Bndry_mask1;
  20aa6e:	ea6f 5913 	mvn.w	r9, r3, lsr #20
  20aa72:	ea6f 5909 	mvn.w	r9, r9, lsl #20
				break;
  20aa76:	e7d4      	b.n	20aa22 <_strtod_l+0x91a>
			else if (!(dword1(rv) & Lsb))
  20aa78:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  20aa7a:	ea13 0f08 	tst.w	r3, r8
  20aa7e:	e7e1      	b.n	20aa44 <_strtod_l+0x93c>
				dval(rv) -= sulp(rv, scale);
  20aa80:	f7ff fb26 	bl	20a0d0 <sulp>
  20aa84:	ed9d 7b08 	vldr	d7, [sp, #32]
  20aa88:	ee37 7b40 	vsub.f64	d7, d7, d0
				if (!dval(rv))
  20aa8c:	eeb5 7b40 	vcmp.f64	d7, #0.0
				dval(rv) -= sulp(rv, scale);
  20aa90:	ed8d 7b06 	vstr	d7, [sp, #24]
				if (!dval(rv))
  20aa94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
				dval(rv) -= sulp(rv, scale);
  20aa98:	e9dd 8906 	ldrd	r8, r9, [sp, #24]
				if (!dval(rv))
  20aa9c:	d1c1      	bne.n	20aa22 <_strtod_l+0x91a>
  20aa9e:	e5ec      	b.n	20a67a <_strtod_l+0x572>
		if ((aadj = ratio(delta, bs)) <= 2.) {
  20aaa0:	4631      	mov	r1, r6
  20aaa2:	4628      	mov	r0, r5
  20aaa4:	f001 ffb6 	bl	20ca14 <__ratio>
  20aaa8:	eeb0 7b00 	vmov.f64	d7, #0	; 0x40000000  2.0
  20aaac:	eeb4 0bc7 	vcmpe.f64	d0, d7
  20aab0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20aab4:	d867      	bhi.n	20ab86 <_strtod_l+0xa7e>
			if (dsign)
  20aab6:	f1ba 0f00 	cmp.w	sl, #0
  20aaba:	d044      	beq.n	20ab46 <_strtod_l+0xa3e>
				aadj = dval(aadj1) = 1.;
  20aabc:	2200      	movs	r2, #0
  20aabe:	4b75      	ldr	r3, [pc, #468]	; (20ac94 <_strtod_l+0xb8c>)
				aadj = 1.;
  20aac0:	eeb7 8b00 	vmov.f64	d8, #112	; 0x3f800000  1.0
		y = dword0(rv) & Exp_mask;
  20aac4:	4971      	ldr	r1, [pc, #452]	; (20ac8c <_strtod_l+0xb84>)
		if (y == Exp_msk1*(DBL_MAX_EXP+Bias-1)) {
  20aac6:	f8df c1d8 	ldr.w	ip, [pc, #472]	; 20aca0 <_strtod_l+0xb98>
		y = dword0(rv) & Exp_mask;
  20aaca:	ea0b 0001 	and.w	r0, fp, r1
		if (y == Exp_msk1*(DBL_MAX_EXP+Bias-1)) {
  20aace:	4560      	cmp	r0, ip
		y = dword0(rv) & Exp_mask;
  20aad0:	900d      	str	r0, [sp, #52]	; 0x34
		if (y == Exp_msk1*(DBL_MAX_EXP+Bias-1)) {
  20aad2:	f040 808b 	bne.w	20abec <_strtod_l+0xae4>
			dword0(rv) -= P*Exp_msk1;
  20aad6:	f1ab 7954 	sub.w	r9, fp, #55574528	; 0x3500000
			dval(rv0) = dval(rv);
  20aada:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
			adj = dval(aadj1) * ulp(dval(rv));
  20aade:	ec43 2b1c 	vmov	d12, r2, r3
  20aae2:	ec49 8b1d 	vmov	d13, r8, r9
  20aae6:	ec49 8b10 	vmov	d0, r8, r9
			dval(rv0) = dval(rv);
  20aaea:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
			adj = dval(aadj1) * ulp(dval(rv));
  20aaee:	f001 fec7 	bl	20c880 <__ulp>
			dval(rv) += adj;
  20aaf2:	eeac db00 	vfma.f64	d13, d12, d0
			if ((dword0(rv) & Exp_mask) >=
  20aaf6:	4965      	ldr	r1, [pc, #404]	; (20ac8c <_strtod_l+0xb84>)
  20aaf8:	4a67      	ldr	r2, [pc, #412]	; (20ac98 <_strtod_l+0xb90>)
			dval(rv) += adj;
  20aafa:	ed8d db0e 	vstr	d13, [sp, #56]	; 0x38
  20aafe:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
			if ((dword0(rv) & Exp_mask) >=
  20ab00:	4019      	ands	r1, r3
  20ab02:	4291      	cmp	r1, r2
			dval(rv) += adj;
  20ab04:	e9dd 890e 	ldrd	r8, r9, [sp, #56]	; 0x38
			if ((dword0(rv) & Exp_mask) >=
  20ab08:	d947      	bls.n	20ab9a <_strtod_l+0xa92>
				if (dword0(rv0) == Big0 && dword1(rv0) == Big1)
  20ab0a:	f102 7254 	add.w	r2, r2, #55574528	; 0x3500000
  20ab0e:	9b09      	ldr	r3, [sp, #36]	; 0x24
  20ab10:	4293      	cmp	r3, r2
  20ab12:	d103      	bne.n	20ab1c <_strtod_l+0xa14>
  20ab14:	9b08      	ldr	r3, [sp, #32]
  20ab16:	3301      	adds	r3, #1
  20ab18:	f43f ad3a 	beq.w	20a590 <_strtod_l+0x488>
				dword0(rv) = Big0;
  20ab1c:	f8df 9170 	ldr.w	r9, [pc, #368]	; 20ac90 <_strtod_l+0xb88>
				dword1(rv) = Big1;
  20ab20:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
		Bfree(ptr,bb);
  20ab24:	9918      	ldr	r1, [sp, #96]	; 0x60
  20ab26:	4620      	mov	r0, r4
  20ab28:	f001 fbdf 	bl	20c2ea <_Bfree>
		Bfree(ptr,bd);
  20ab2c:	4639      	mov	r1, r7
  20ab2e:	4620      	mov	r0, r4
  20ab30:	f001 fbdb 	bl	20c2ea <_Bfree>
		Bfree(ptr,bs);
  20ab34:	4631      	mov	r1, r6
  20ab36:	4620      	mov	r0, r4
  20ab38:	f001 fbd7 	bl	20c2ea <_Bfree>
		Bfree(ptr,delta);
  20ab3c:	4629      	mov	r1, r5
  20ab3e:	4620      	mov	r0, r4
  20ab40:	f001 fbd3 	bl	20c2ea <_Bfree>
		bd = Balloc(ptr,bd0->_k);
  20ab44:	e610      	b.n	20a768 <_strtod_l+0x660>
			else if (dword1(rv) || dword0(rv) & Bndry_mask) {
  20ab46:	f1b8 0f00 	cmp.w	r8, #0
  20ab4a:	d112      	bne.n	20ab72 <_strtod_l+0xa6a>
  20ab4c:	f3c9 0313 	ubfx	r3, r9, #0, #20
  20ab50:	b9b3      	cbnz	r3, 20ab80 <_strtod_l+0xa78>
				if (aadj < 2./FLT_RADIX)
  20ab52:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
  20ab56:	eeb6 8b00 	vmov.f64	d8, #96	; 0x3f000000  0.5
  20ab5a:	eeb4 0bc7 	vcmpe.f64	d0, d7
  20ab5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20ab62:	d401      	bmi.n	20ab68 <_strtod_l+0xa60>
					aadj *= 0.5;
  20ab64:	ee20 8b08 	vmul.f64	d8, d0, d8
			dval(aadj1) = dsign ? aadj : -aadj;
  20ab68:	eeb1 7b48 	vneg.f64	d7, d8
  20ab6c:	ec53 2b17 	vmov	r2, r3, d7
  20ab70:	e7a8      	b.n	20aac4 <_strtod_l+0x9bc>
				if (dword1(rv) == Tiny1 && !dword0(rv))
  20ab72:	f1b8 0f01 	cmp.w	r8, #1
  20ab76:	d103      	bne.n	20ab80 <_strtod_l+0xa78>
  20ab78:	f1b9 0f00 	cmp.w	r9, #0
  20ab7c:	f43f ad7d 	beq.w	20a67a <_strtod_l+0x572>
				dval(aadj1) = -1.;
  20ab80:	2200      	movs	r2, #0
  20ab82:	4b46      	ldr	r3, [pc, #280]	; (20ac9c <_strtod_l+0xb94>)
  20ab84:	e79c      	b.n	20aac0 <_strtod_l+0x9b8>
			aadj *= 0.5;
  20ab86:	eeb6 8b00 	vmov.f64	d8, #96	; 0x3f000000  0.5
  20ab8a:	ee20 8b08 	vmul.f64	d8, d0, d8
			dval(aadj1) = dsign ? aadj : -aadj;
  20ab8e:	f1ba 0f00 	cmp.w	sl, #0
  20ab92:	d0e9      	beq.n	20ab68 <_strtod_l+0xa60>
  20ab94:	ec53 2b18 	vmov	r2, r3, d8
			if (Flt_Rounds == 0)
  20ab98:	e794      	b.n	20aac4 <_strtod_l+0x9bc>
				dword0(rv) += P*Exp_msk1;
  20ab9a:	f103 7954 	add.w	r9, r3, #55574528	; 0x3500000
		if (!scale)
  20ab9e:	9b04      	ldr	r3, [sp, #16]
  20aba0:	2b00      	cmp	r3, #0
  20aba2:	d1bf      	bne.n	20ab24 <_strtod_l+0xa1c>
		z = dword0(rv) & Exp_mask;
  20aba4:	f029 4300 	bic.w	r3, r9, #2147483648	; 0x80000000
		if (y == z) {
  20aba8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
		z = dword0(rv) & Exp_mask;
  20abaa:	0d1b      	lsrs	r3, r3, #20
  20abac:	051b      	lsls	r3, r3, #20
		if (y == z) {
  20abae:	429a      	cmp	r2, r3
  20abb0:	d1b8      	bne.n	20ab24 <_strtod_l+0xa1c>
			__int64_t L = (__int64_t)aadj;
  20abb2:	ec51 0b18 	vmov	r0, r1, d8
  20abb6:	f002 fe4e 	bl	20d856 <__aeabi_d2lz>
			aadj -= L;
  20abba:	f7f5 fde1 	bl	200780 <__aeabi_l2d>
			if (dsign || dword1(rv) || dword0(rv) & Bndry_mask) {
  20abbe:	f3c9 0313 	ubfx	r3, r9, #0, #20
  20abc2:	ea43 0308 	orr.w	r3, r3, r8
  20abc6:	ea53 030a 	orrs.w	r3, r3, sl
			aadj -= L;
  20abca:	ec41 0b17 	vmov	d7, r0, r1
  20abce:	ee38 8b47 	vsub.f64	d8, d8, d7
			if (dsign || dword1(rv) || dword0(rv) & Bndry_mask) {
  20abd2:	d03e      	beq.n	20ac52 <_strtod_l+0xb4a>
				if (aadj < .4999999 || aadj > .5000001)
  20abd4:	eeb4 8bca 	vcmpe.f64	d8, d10
  20abd8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20abdc:	f53f ace2 	bmi.w	20a5a4 <_strtod_l+0x49c>
  20abe0:	eeb4 8bcb 	vcmpe.f64	d8, d11
  20abe4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20abe8:	dd9c      	ble.n	20ab24 <_strtod_l+0xa1c>
  20abea:	e4db      	b.n	20a5a4 <_strtod_l+0x49c>
			if (scale && y <= 2*P*Exp_msk1) {
  20abec:	9904      	ldr	r1, [sp, #16]
  20abee:	b301      	cbz	r1, 20ac32 <_strtod_l+0xb2a>
  20abf0:	990d      	ldr	r1, [sp, #52]	; 0x34
  20abf2:	f1b1 6fd4 	cmp.w	r1, #111149056	; 0x6a00000
  20abf6:	d81c      	bhi.n	20ac32 <_strtod_l+0xb2a>
				if (aadj <= 0x7fffffff) {
  20abf8:	ed9f 7b21 	vldr	d7, [pc, #132]	; 20ac80 <_strtod_l+0xb78>
  20abfc:	eeb4 8bc7 	vcmpe.f64	d8, d7
  20ac00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20ac04:	d811      	bhi.n	20ac2a <_strtod_l+0xb22>
					if ((z = aadj) == 0)
  20ac06:	eebc 8bc8 	vcvt.u32.f64	s16, d8
					aadj = z;
  20ac0a:	ee18 3a10 	vmov	r3, s16
  20ac0e:	2b01      	cmp	r3, #1
  20ac10:	bf38      	it	cc
  20ac12:	2301      	movcc	r3, #1
  20ac14:	ee08 3a10 	vmov	s16, r3
  20ac18:	eeb8 8b48 	vcvt.f64.u32	d8, s16
					dval(aadj1) = dsign ? aadj : -aadj;
  20ac1c:	f1ba 0f00 	cmp.w	sl, #0
  20ac20:	d114      	bne.n	20ac4c <_strtod_l+0xb44>
  20ac22:	eeb1 7b48 	vneg.f64	d7, d8
  20ac26:	ec53 2b17 	vmov	r2, r3, d7
				dword0(aadj1) += (2*P+1)*Exp_msk1 - y;
  20ac2a:	f103 61d6 	add.w	r1, r3, #112197632	; 0x6b00000
  20ac2e:	980d      	ldr	r0, [sp, #52]	; 0x34
  20ac30:	1a0b      	subs	r3, r1, r0
			adj = dval(aadj1) * ulp(dval(rv));
  20ac32:	ed9d 0b08 	vldr	d0, [sp, #32]
  20ac36:	ec43 2b1c 	vmov	d12, r2, r3
  20ac3a:	f001 fe21 	bl	20c880 <__ulp>
			dval(rv) += adj;
  20ac3e:	ed9d 7b08 	vldr	d7, [sp, #32]
  20ac42:	eeac 7b00 	vfma.f64	d7, d12, d0
  20ac46:	ec59 8b17 	vmov	r8, r9, d7
  20ac4a:	e7a8      	b.n	20ab9e <_strtod_l+0xa96>
					dval(aadj1) = dsign ? aadj : -aadj;
  20ac4c:	ec53 2b18 	vmov	r2, r3, d8
  20ac50:	e7eb      	b.n	20ac2a <_strtod_l+0xb22>
			else if (aadj < .4999999/FLT_RADIX)
  20ac52:	eeb4 8bc9 	vcmpe.f64	d8, d9
  20ac56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20ac5a:	f57f af63 	bpl.w	20ab24 <_strtod_l+0xa1c>
  20ac5e:	e4a1      	b.n	20a5a4 <_strtod_l+0x49c>
			sign = 0;
  20ac60:	2300      	movs	r3, #0
  20ac62:	930b      	str	r3, [sp, #44]	; 0x2c
		*se = (char *)s;
  20ac64:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  20ac66:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  20ac68:	6013      	str	r3, [r2, #0]
  20ac6a:	f7ff ba95 	b.w	20a198 <_strtod_l+0x90>
	if (c == 'e' || c == 'E') {
  20ac6e:	2a65      	cmp	r2, #101	; 0x65
  20ac70:	f43f ab8b 	beq.w	20a38a <_strtod_l+0x282>
  20ac74:	2a45      	cmp	r2, #69	; 0x45
  20ac76:	f43f ab88 	beq.w	20a38a <_strtod_l+0x282>
		decpt = 1;
  20ac7a:	2101      	movs	r1, #1
  20ac7c:	f7ff bbc0 	b.w	20a400 <_strtod_l+0x2f8>
  20ac80:	ffc00000 	.word	0xffc00000
  20ac84:	41dfffff 	.word	0x41dfffff
  20ac88:	000fffff 	.word	0x000fffff
  20ac8c:	7ff00000 	.word	0x7ff00000
  20ac90:	7fefffff 	.word	0x7fefffff
  20ac94:	3ff00000 	.word	0x3ff00000
  20ac98:	7c9fffff 	.word	0x7c9fffff
  20ac9c:	bff00000 	.word	0xbff00000
  20aca0:	7fe00000 	.word	0x7fe00000

0020aca4 <_strtod_r>:
double
_strtod_r (struct _reent *ptr,
	const char *__restrict s00,
	char **__restrict se)
{
  return _strtod_l (ptr, s00, se, __get_current_locale ());
  20aca4:	4b01      	ldr	r3, [pc, #4]	; (20acac <_strtod_r+0x8>)
  20aca6:	f7ff ba2f 	b.w	20a108 <_strtod_l>
  20acaa:	bf00      	nop
  20acac:	200100c8 	.word	0x200100c8

0020acb0 <_strtol_l.isra.0>:

/*
 * Convert a string to a long integer.
 */
static long
_strtol_l (struct _reent *rptr, const char *__restrict nptr,
  20acb0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	   char **__restrict endptr, int base, locale_t loc)
{
	register const unsigned char *s = (const unsigned char *)nptr;
  20acb4:	468c      	mov	ip, r1
_strtol_l (struct _reent *rptr, const char *__restrict nptr,
  20acb6:	4686      	mov	lr, r0
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
	} while (isspace_l(c, loc));
  20acb8:	4e38      	ldr	r6, [pc, #224]	; (20ad9c <_strtol_l.isra.0+0xec>)
		c = *s++;
  20acba:	4660      	mov	r0, ip
  20acbc:	f81c 4b01 	ldrb.w	r4, [ip], #1
	} while (isspace_l(c, loc));
  20acc0:	5da5      	ldrb	r5, [r4, r6]
  20acc2:	f015 0508 	ands.w	r5, r5, #8
  20acc6:	d1f8      	bne.n	20acba <_strtol_l.isra.0+0xa>
	if (c == '-') {
  20acc8:	2c2d      	cmp	r4, #45	; 0x2d
  20acca:	d133      	bne.n	20ad34 <_strtol_l.isra.0+0x84>
		neg = 1;
		c = *s++;
  20accc:	f89c 4000 	ldrb.w	r4, [ip]
		neg = 1;
  20acd0:	f04f 0801 	mov.w	r8, #1
		c = *s++;
  20acd4:	f100 0c02 	add.w	ip, r0, #2
	} else if (c == '+')
		c = *s++;
	if ((base == 0 || base == 16) &&
  20acd8:	2b00      	cmp	r3, #0
  20acda:	d05b      	beq.n	20ad94 <_strtol_l.isra.0+0xe4>
  20acdc:	2b10      	cmp	r3, #16
  20acde:	d10c      	bne.n	20acfa <_strtol_l.isra.0+0x4a>
  20ace0:	2c30      	cmp	r4, #48	; 0x30
  20ace2:	d10a      	bne.n	20acfa <_strtol_l.isra.0+0x4a>
	    c == '0' && (*s == 'x' || *s == 'X')) {
  20ace4:	f89c 0000 	ldrb.w	r0, [ip]
  20ace8:	f000 00df 	and.w	r0, r0, #223	; 0xdf
  20acec:	2858      	cmp	r0, #88	; 0x58
  20acee:	d14c      	bne.n	20ad8a <_strtol_l.isra.0+0xda>
		c = s[1];
  20acf0:	f89c 4001 	ldrb.w	r4, [ip, #1]
		s += 2;
		base = 16;
  20acf4:	2310      	movs	r3, #16
		s += 2;
  20acf6:	f10c 0c02 	add.w	ip, ip, #2
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
  20acfa:	f108 4700 	add.w	r7, r8, #2147483648	; 0x80000000
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
  20acfe:	2600      	movs	r6, #0
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
  20ad00:	3f01      	subs	r7, #1
	for (acc = 0, any = 0;; c = *s++) {
  20ad02:	4630      	mov	r0, r6
	cutlim = cutoff % (unsigned long)base;
  20ad04:	fbb7 f9f3 	udiv	r9, r7, r3
  20ad08:	fb03 7a19 	mls	sl, r3, r9, r7
		if (c >= '0' && c <= '9')
  20ad0c:	f1a4 0530 	sub.w	r5, r4, #48	; 0x30
  20ad10:	2d09      	cmp	r5, #9
  20ad12:	d817      	bhi.n	20ad44 <_strtol_l.isra.0+0x94>
			c -= '0';
  20ad14:	462c      	mov	r4, r5
			c -= 'A' - 10;
		else if (c >= 'a' && c <= 'z')
			c -= 'a' - 10;
		else
			break;
		if (c >= base)
  20ad16:	42a3      	cmp	r3, r4
  20ad18:	dd23      	ble.n	20ad62 <_strtol_l.isra.0+0xb2>
			break;
               if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))
  20ad1a:	1c75      	adds	r5, r6, #1
  20ad1c:	d007      	beq.n	20ad2e <_strtol_l.isra.0+0x7e>
  20ad1e:	4581      	cmp	r9, r0
  20ad20:	d31c      	bcc.n	20ad5c <_strtol_l.isra.0+0xac>
  20ad22:	d101      	bne.n	20ad28 <_strtol_l.isra.0+0x78>
  20ad24:	45a2      	cmp	sl, r4
  20ad26:	db19      	blt.n	20ad5c <_strtol_l.isra.0+0xac>
			any = -1;
		else {
			any = 1;
			acc *= base;
			acc += c;
  20ad28:	fb00 4003 	mla	r0, r0, r3, r4
			any = 1;
  20ad2c:	2601      	movs	r6, #1
	for (acc = 0, any = 0;; c = *s++) {
  20ad2e:	f81c 4b01 	ldrb.w	r4, [ip], #1
		if (c >= '0' && c <= '9')
  20ad32:	e7eb      	b.n	20ad0c <_strtol_l.isra.0+0x5c>
	} else if (c == '+')
  20ad34:	2c2b      	cmp	r4, #43	; 0x2b
	register int neg = 0, any, cutlim;
  20ad36:	46a8      	mov	r8, r5
		c = *s++;
  20ad38:	bf04      	itt	eq
  20ad3a:	f89c 4000 	ldrbeq.w	r4, [ip]
  20ad3e:	f100 0c02 	addeq.w	ip, r0, #2
  20ad42:	e7c9      	b.n	20acd8 <_strtol_l.isra.0+0x28>
		else if (c >= 'A' && c <= 'Z')
  20ad44:	f1a4 0541 	sub.w	r5, r4, #65	; 0x41
  20ad48:	2d19      	cmp	r5, #25
  20ad4a:	d801      	bhi.n	20ad50 <_strtol_l.isra.0+0xa0>
			c -= 'A' - 10;
  20ad4c:	3c37      	subs	r4, #55	; 0x37
  20ad4e:	e7e2      	b.n	20ad16 <_strtol_l.isra.0+0x66>
		else if (c >= 'a' && c <= 'z')
  20ad50:	f1a4 0561 	sub.w	r5, r4, #97	; 0x61
  20ad54:	2d19      	cmp	r5, #25
  20ad56:	d804      	bhi.n	20ad62 <_strtol_l.isra.0+0xb2>
			c -= 'a' - 10;
  20ad58:	3c57      	subs	r4, #87	; 0x57
  20ad5a:	e7dc      	b.n	20ad16 <_strtol_l.isra.0+0x66>
			any = -1;
  20ad5c:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
  20ad60:	e7e5      	b.n	20ad2e <_strtol_l.isra.0+0x7e>
		}
	}
	if (any < 0) {
  20ad62:	1c73      	adds	r3, r6, #1
  20ad64:	d106      	bne.n	20ad74 <_strtol_l.isra.0+0xc4>
		acc = neg ? LONG_MIN : LONG_MAX;
		rptr->_errno = ERANGE;
  20ad66:	2322      	movs	r3, #34	; 0x22
		acc = neg ? LONG_MIN : LONG_MAX;
  20ad68:	4638      	mov	r0, r7
		rptr->_errno = ERANGE;
  20ad6a:	f8ce 3000 	str.w	r3, [lr]
	} else if (neg)
		acc = -acc;
	if (endptr != 0)
  20ad6e:	b942      	cbnz	r2, 20ad82 <_strtol_l.isra.0+0xd2>
		*endptr = (char *) (any ? (char *)s - 1 : nptr);
	return (acc);
}
  20ad70:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	} else if (neg)
  20ad74:	f1b8 0f00 	cmp.w	r8, #0
  20ad78:	d000      	beq.n	20ad7c <_strtol_l.isra.0+0xcc>
		acc = -acc;
  20ad7a:	4240      	negs	r0, r0
	if (endptr != 0)
  20ad7c:	2a00      	cmp	r2, #0
  20ad7e:	d0f7      	beq.n	20ad70 <_strtol_l.isra.0+0xc0>
		*endptr = (char *) (any ? (char *)s - 1 : nptr);
  20ad80:	b10e      	cbz	r6, 20ad86 <_strtol_l.isra.0+0xd6>
  20ad82:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
  20ad86:	6011      	str	r1, [r2, #0]
	return (acc);
  20ad88:	e7f2      	b.n	20ad70 <_strtol_l.isra.0+0xc0>
	if (base == 0)
  20ad8a:	2430      	movs	r4, #48	; 0x30
  20ad8c:	2b00      	cmp	r3, #0
  20ad8e:	d1b4      	bne.n	20acfa <_strtol_l.isra.0+0x4a>
		base = c == '0' ? 8 : 10;
  20ad90:	2308      	movs	r3, #8
  20ad92:	e7b2      	b.n	20acfa <_strtol_l.isra.0+0x4a>
	if ((base == 0 || base == 16) &&
  20ad94:	2c30      	cmp	r4, #48	; 0x30
  20ad96:	d0a5      	beq.n	20ace4 <_strtol_l.isra.0+0x34>
		base = c == '0' ? 8 : 10;
  20ad98:	230a      	movs	r3, #10
  20ad9a:	e7ae      	b.n	20acfa <_strtol_l.isra.0+0x4a>
  20ad9c:	0800ec41 	.word	0x0800ec41

0020ada0 <_strtol_r>:
_strtol_r (struct _reent *rptr,
	const char *__restrict nptr,
	char **__restrict endptr,
	int base)
{
	return _strtol_l (rptr, nptr, endptr, base, __get_current_locale ());
  20ada0:	f7ff bf86 	b.w	20acb0 <_strtol_l.isra.0>

0020ada4 <quorem>:
#include <string.h>
#include "mprec.h"

static int
quorem (_Bigint * b, _Bigint * S)
{
  20ada4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  n = S->_wds;
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
  20ada8:	6903      	ldr	r3, [r0, #16]
{
  20adaa:	4607      	mov	r7, r0
  n = S->_wds;
  20adac:	690c      	ldr	r4, [r1, #16]
  if (b->_wds < n)
  20adae:	42a3      	cmp	r3, r4
  20adb0:	f2c0 8083 	blt.w	20aeba <quorem+0x116>
    return 0;
  sx = S->_x;
  sxe = sx + --n;
  20adb4:	3c01      	subs	r4, #1
  bx = b->_x;
  20adb6:	f100 0514 	add.w	r5, r0, #20
  sx = S->_x;
  20adba:	f101 0814 	add.w	r8, r1, #20
  bxe = bx + n;
  20adbe:	eb05 0384 	add.w	r3, r5, r4, lsl #2
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
  20adc2:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
  sxe = sx + --n;
  20adc6:	ea4f 0b84 	mov.w	fp, r4, lsl #2
  bxe = bx + n;
  20adca:	9301      	str	r3, [sp, #4]
  sxe = sx + --n;
  20adcc:	eb08 0984 	add.w	r9, r8, r4, lsl #2
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
  20add0:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
  20add4:	3301      	adds	r3, #1
#ifdef DEBUG
  /*debug*/ if (q > 9)
    /*debug*/ Bug ("oversized quotient in quorem");
#endif
  if (q)
  20add6:	429a      	cmp	r2, r3
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
  20add8:	fbb2 f6f3 	udiv	r6, r2, r3
  if (q)
  20addc:	d332      	bcc.n	20ae44 <quorem+0xa0>
    {
      borrow = 0;
      carry = 0;
  20adde:	f04f 0e00 	mov.w	lr, #0
  sx = S->_x;
  20ade2:	4640      	mov	r0, r8
  bx = b->_x;
  20ade4:	46ac      	mov	ip, r5
      borrow = 0;
  20ade6:	46f2      	mov	sl, lr
      do
	{
#ifdef Pack_32
	  si = *sx++;
  20ade8:	f850 2b04 	ldr.w	r2, [r0], #4
	  ys = (si & 0xffff) * q + carry;
  20adec:	b293      	uxth	r3, r2
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
  20adee:	4581      	cmp	r9, r0
	  zs = (si >> 16) * q + (ys >> 16);
  20adf0:	ea4f 4212 	mov.w	r2, r2, lsr #16
	  ys = (si & 0xffff) * q + carry;
  20adf4:	fb06 e303 	mla	r3, r6, r3, lr
	  zs = (si >> 16) * q + (ys >> 16);
  20adf8:	ea4f 4e13 	mov.w	lr, r3, lsr #16
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
  20adfc:	b29b      	uxth	r3, r3
	  zs = (si >> 16) * q + (ys >> 16);
  20adfe:	fb06 e202 	mla	r2, r6, r2, lr
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
  20ae02:	ebaa 0303 	sub.w	r3, sl, r3
  20ae06:	f8dc a000 	ldr.w	sl, [ip]
	  carry = zs >> 16;
  20ae0a:	ea4f 4e12 	mov.w	lr, r2, lsr #16
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
  20ae0e:	fa13 f38a 	uxtah	r3, r3, sl
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
  20ae12:	fa1f fa82 	uxth.w	sl, r2
  20ae16:	f8dc 2000 	ldr.w	r2, [ip]
  20ae1a:	ebca 4212 	rsb	r2, sl, r2, lsr #16
  20ae1e:	eb02 4223 	add.w	r2, r2, r3, asr #16
	  Storeinc (bx, z, y);
  20ae22:	b29b      	uxth	r3, r3
	  borrow = z >> 16;
  20ae24:	ea4f 4a22 	mov.w	sl, r2, asr #16
	  Storeinc (bx, z, y);
  20ae28:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  20ae2c:	f84c 3b04 	str.w	r3, [ip], #4
      while (sx <= sxe);
  20ae30:	d2da      	bcs.n	20ade8 <quorem+0x44>
      if (!*bxe)
  20ae32:	f855 300b 	ldr.w	r3, [r5, fp]
  20ae36:	b92b      	cbnz	r3, 20ae44 <quorem+0xa0>
  20ae38:	9b01      	ldr	r3, [sp, #4]
  20ae3a:	3b04      	subs	r3, #4
	{
	  bx = b->_x;
	  while (--bxe > bx && !*bxe)
  20ae3c:	429d      	cmp	r5, r3
  20ae3e:	461a      	mov	r2, r3
  20ae40:	d32f      	bcc.n	20aea2 <quorem+0xfe>
	    --n;
	  b->_wds = n;
  20ae42:	613c      	str	r4, [r7, #16]
	}
    }
  if (cmp (b, S) >= 0)
  20ae44:	4638      	mov	r0, r7
  20ae46:	f001 fc86 	bl	20c756 <__mcmp>
  20ae4a:	2800      	cmp	r0, #0
  20ae4c:	db25      	blt.n	20ae9a <quorem+0xf6>
    {
      q++;
  20ae4e:	3601      	adds	r6, #1
  bx = b->_x;
  20ae50:	4628      	mov	r0, r5
      borrow = 0;
  20ae52:	f04f 0c00 	mov.w	ip, #0
      bx = b->_x;
      sx = S->_x;
      do
	{
#ifdef Pack_32
	  si = *sx++;
  20ae56:	f858 2b04 	ldr.w	r2, [r8], #4
	  ys = (si & 0xffff) + carry;
	  zs = (si >> 16) + (ys >> 16);
	  carry = zs >> 16;
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
  20ae5a:	f8d0 e000 	ldr.w	lr, [r0]
	  ys = (si & 0xffff) + carry;
  20ae5e:	b293      	uxth	r3, r2
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
  20ae60:	45c1      	cmp	r9, r8
	  zs = (si >> 16) + (ys >> 16);
  20ae62:	ea4f 4212 	mov.w	r2, r2, lsr #16
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
  20ae66:	ebac 0303 	sub.w	r3, ip, r3
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
  20ae6a:	ebc2 421e 	rsb	r2, r2, lr, lsr #16
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
  20ae6e:	fa13 f38e 	uxtah	r3, r3, lr
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
  20ae72:	eb02 4223 	add.w	r2, r2, r3, asr #16
	  Storeinc (bx, z, y);
  20ae76:	b29b      	uxth	r3, r3
	  borrow = z >> 16;
  20ae78:	ea4f 4c22 	mov.w	ip, r2, asr #16
	  Storeinc (bx, z, y);
  20ae7c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  20ae80:	f840 3b04 	str.w	r3, [r0], #4
      while (sx <= sxe);
  20ae84:	d2e7      	bcs.n	20ae56 <quorem+0xb2>
      bx = b->_x;
      bxe = bx + n;
      if (!*bxe)
  20ae86:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
      bxe = bx + n;
  20ae8a:	eb05 0384 	add.w	r3, r5, r4, lsl #2
      if (!*bxe)
  20ae8e:	b922      	cbnz	r2, 20ae9a <quorem+0xf6>
  20ae90:	3b04      	subs	r3, #4
	{
	  while (--bxe > bx && !*bxe)
  20ae92:	429d      	cmp	r5, r3
  20ae94:	461a      	mov	r2, r3
  20ae96:	d30a      	bcc.n	20aeae <quorem+0x10a>
	    --n;
	  b->_wds = n;
  20ae98:	613c      	str	r4, [r7, #16]
	}
    }
  return q;
  20ae9a:	4630      	mov	r0, r6
}
  20ae9c:	b003      	add	sp, #12
  20ae9e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	  while (--bxe > bx && !*bxe)
  20aea2:	6812      	ldr	r2, [r2, #0]
  20aea4:	3b04      	subs	r3, #4
  20aea6:	2a00      	cmp	r2, #0
  20aea8:	d1cb      	bne.n	20ae42 <quorem+0x9e>
	    --n;
  20aeaa:	3c01      	subs	r4, #1
  20aeac:	e7c6      	b.n	20ae3c <quorem+0x98>
	  while (--bxe > bx && !*bxe)
  20aeae:	6812      	ldr	r2, [r2, #0]
  20aeb0:	3b04      	subs	r3, #4
  20aeb2:	2a00      	cmp	r2, #0
  20aeb4:	d1f0      	bne.n	20ae98 <quorem+0xf4>
	    --n;
  20aeb6:	3c01      	subs	r4, #1
  20aeb8:	e7eb      	b.n	20ae92 <quorem+0xee>
    return 0;
  20aeba:	2000      	movs	r0, #0
  20aebc:	e7ee      	b.n	20ae9c <quorem+0xf8>
	...

0020aec0 <_dtoa_r>:
	int mode,
	int ndigits,
	int *decpt,
	int *sign,
	char **rve)
{
  20aec0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  double ds;
  char *s, *s0;

  d.d = _d;

  _REENT_CHECK_MP(ptr);
  20aec4:	6a47      	ldr	r7, [r0, #36]	; 0x24
{
  20aec6:	b095      	sub	sp, #84	; 0x54
  20aec8:	4606      	mov	r6, r0
  20aeca:	f8dd 8078 	ldr.w	r8, [sp, #120]	; 0x78
  20aece:	9107      	str	r1, [sp, #28]
  20aed0:	9209      	str	r2, [sp, #36]	; 0x24
  20aed2:	9310      	str	r3, [sp, #64]	; 0x40
  20aed4:	ec55 4b10 	vmov	r4, r5, d0
  d.d = _d;
  20aed8:	e9cd 4500 	strd	r4, r5, [sp]
  _REENT_CHECK_MP(ptr);
  20aedc:	b93f      	cbnz	r7, 20aeee <_dtoa_r+0x2e>
  20aede:	2010      	movs	r0, #16
  20aee0:	f001 f998 	bl	20c214 <malloc>
  20aee4:	6270      	str	r0, [r6, #36]	; 0x24
  20aee6:	6007      	str	r7, [r0, #0]
  20aee8:	60c7      	str	r7, [r0, #12]
  20aeea:	e9c0 7701 	strd	r7, r7, [r0, #4]
  if (_REENT_MP_RESULT(ptr))
  20aeee:	6a73      	ldr	r3, [r6, #36]	; 0x24
  20aef0:	6819      	ldr	r1, [r3, #0]
  20aef2:	b151      	cbz	r1, 20af0a <_dtoa_r+0x4a>
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
  20aef4:	685a      	ldr	r2, [r3, #4]
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
  20aef6:	2301      	movs	r3, #1
      Bfree (ptr, _REENT_MP_RESULT(ptr));
  20aef8:	4630      	mov	r0, r6
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
  20aefa:	4093      	lsls	r3, r2
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
  20aefc:	604a      	str	r2, [r1, #4]
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
  20aefe:	608b      	str	r3, [r1, #8]
      Bfree (ptr, _REENT_MP_RESULT(ptr));
  20af00:	f001 f9f3 	bl	20c2ea <_Bfree>
      _REENT_MP_RESULT(ptr) = 0;
  20af04:	6a73      	ldr	r3, [r6, #36]	; 0x24
  20af06:	2200      	movs	r2, #0
  20af08:	601a      	str	r2, [r3, #0]
    }

  if (word0 (d) & Sign_bit)
  20af0a:	1e2b      	subs	r3, r5, #0
    {
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
  20af0c:	bfb7      	itett	lt
  20af0e:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
    }
  else
    *sign = 0;
  20af12:	2300      	movge	r3, #0
      *sign = 1;
  20af14:	2201      	movlt	r2, #1
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
  20af16:	9301      	strlt	r3, [sp, #4]
    *sign = 0;
  20af18:	bfa8      	it	ge
  20af1a:	f8c8 3000 	strge.w	r3, [r8]

#if defined(IEEE_Arith) + defined(VAX)
#ifdef IEEE_Arith
  if ((word0 (d) & Exp_mask) == Exp_mask)
  20af1e:	9c01      	ldr	r4, [sp, #4]
  20af20:	4b77      	ldr	r3, [pc, #476]	; (20b100 <_dtoa_r+0x240>)
      *sign = 1;
  20af22:	bfb8      	it	lt
  20af24:	f8c8 2000 	strlt.w	r2, [r8]
  if ((word0 (d) & Exp_mask) == Exp_mask)
  20af28:	43a3      	bics	r3, r4
  20af2a:	d11a      	bne.n	20af62 <_dtoa_r+0xa2>
#else
  if (word0 (d) == 0x8000)
#endif
    {
      /* Infinity or NaN */
      *decpt = 9999;
  20af2c:	f242 730f 	movw	r3, #9999	; 0x270f
  20af30:	9a10      	ldr	r2, [sp, #64]	; 0x40
  20af32:	6013      	str	r3, [r2, #0]
      s =
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
  20af34:	f3c4 0313 	ubfx	r3, r4, #0, #20
  20af38:	9a00      	ldr	r2, [sp, #0]
  20af3a:	4313      	orrs	r3, r2
  20af3c:	f000 8502 	beq.w	20b944 <_dtoa_r+0xa84>
#endif
	"NaN";
      if (rve)
  20af40:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
  20af42:	b953      	cbnz	r3, 20af5a <_dtoa_r+0x9a>
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
  20af44:	4b6f      	ldr	r3, [pc, #444]	; (20b104 <_dtoa_r+0x244>)
  20af46:	e020      	b.n	20af8a <_dtoa_r+0xca>
  20af48:	4b6f      	ldr	r3, [pc, #444]	; (20b108 <_dtoa_r+0x248>)
  20af4a:	9302      	str	r3, [sp, #8]
	*rve =
#ifdef IEEE_Arith
	  s[3] ? s + 8 :
  20af4c:	3308      	adds	r3, #8
	*rve =
  20af4e:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
  20af50:	6013      	str	r3, [r2, #0]
  *s = 0;
  *decpt = k + 1;
  if (rve)
    *rve = s;
  return s0;
}
  20af52:	9802      	ldr	r0, [sp, #8]
  20af54:	b015      	add	sp, #84	; 0x54
  20af56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
  20af5a:	4b6a      	ldr	r3, [pc, #424]	; (20b104 <_dtoa_r+0x244>)
  20af5c:	9302      	str	r3, [sp, #8]
	  s[3] ? s + 8 :
  20af5e:	3303      	adds	r3, #3
  20af60:	e7f5      	b.n	20af4e <_dtoa_r+0x8e>
  if (!d.d)
  20af62:	ed9d 7b00 	vldr	d7, [sp]
  20af66:	eeb5 7b40 	vcmp.f64	d7, #0.0
  20af6a:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
  20af6e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20af72:	d10c      	bne.n	20af8e <_dtoa_r+0xce>
      *decpt = 1;
  20af74:	2301      	movs	r3, #1
  20af76:	9a10      	ldr	r2, [sp, #64]	; 0x40
  20af78:	6013      	str	r3, [r2, #0]
      if (rve)
  20af7a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
  20af7c:	2b00      	cmp	r3, #0
  20af7e:	f000 84de 	beq.w	20b93e <_dtoa_r+0xa7e>
	*rve = s + 1;
  20af82:	4b62      	ldr	r3, [pc, #392]	; (20b10c <_dtoa_r+0x24c>)
  20af84:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
  20af86:	6013      	str	r3, [r2, #0]
      return s;
  20af88:	3b01      	subs	r3, #1
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
  20af8a:	9302      	str	r3, [sp, #8]
  20af8c:	e7e1      	b.n	20af52 <_dtoa_r+0x92>
  b = d2b (ptr, d.d, &be, &bbits);
  20af8e:	a913      	add	r1, sp, #76	; 0x4c
  20af90:	aa12      	add	r2, sp, #72	; 0x48
  20af92:	4630      	mov	r0, r6
  20af94:	ed9d 0b0a 	vldr	d0, [sp, #40]	; 0x28
  20af98:	f001 fcec 	bl	20c974 <__d2b>
  20af9c:	4605      	mov	r5, r0
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
  20af9e:	f3c4 500a 	ubfx	r0, r4, #20, #11
  20afa2:	9912      	ldr	r1, [sp, #72]	; 0x48
  20afa4:	2800      	cmp	r0, #0
  20afa6:	d047      	beq.n	20b038 <_dtoa_r+0x178>
      word0 (d2) &= Frac_mask1;
  20afa8:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
      i -= Bias;
  20afaa:	f2a0 30ff 	subw	r0, r0, #1023	; 0x3ff
      word0 (d2) &= Frac_mask1;
  20afae:	f3c4 0413 	ubfx	r4, r4, #0, #20
      d2.d = d.d;
  20afb2:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
      word0 (d2) |= Exp_11;
  20afb6:	f044 537f 	orr.w	r3, r4, #1069547520	; 0x3fc00000
      denorm = 0;
  20afba:	2400      	movs	r4, #0
      word0 (d2) |= Exp_11;
  20afbc:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
  20afc0:	eeb7 7b08 	vmov.f64	d7, #120	; 0x3fc00000  1.5
      denorm = 1;
  20afc4:	9411      	str	r4, [sp, #68]	; 0x44
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
  20afc6:	ec43 2b16 	vmov	d6, r2, r3
  20afca:	ee36 7b47 	vsub.f64	d7, d6, d7
  20afce:	ed9f 5b46 	vldr	d5, [pc, #280]	; 20b0e8 <_dtoa_r+0x228>
  20afd2:	ed9f 6b47 	vldr	d6, [pc, #284]	; 20b0f0 <_dtoa_r+0x230>
  20afd6:	eea7 6b05 	vfma.f64	d6, d7, d5
  20afda:	eeb0 7b46 	vmov.f64	d7, d6
  20afde:	ee06 0a90 	vmov	s13, r0
  20afe2:	eeb8 5be6 	vcvt.f64.s32	d5, s13
  20afe6:	ed9f 6b44 	vldr	d6, [pc, #272]	; 20b0f8 <_dtoa_r+0x238>
  20afea:	eea5 7b06 	vfma.f64	d7, d5, d6
  if (ds < 0. && ds != k)
  20afee:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
  k = (int) ds;
  20aff2:	eefd 6bc7 	vcvt.s32.f64	s13, d7
  if (ds < 0. && ds != k)
  20aff6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  k = (int) ds;
  20affa:	ee16 ba90 	vmov	fp, s13
  if (ds < 0. && ds != k)
  20affe:	d508      	bpl.n	20b012 <_dtoa_r+0x152>
  20b000:	eeb8 6be6 	vcvt.f64.s32	d6, s13
  20b004:	eeb4 6b47 	vcmp.f64	d6, d7
  20b008:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    k--;			/* want k = floor(ds) */
  20b00c:	bf18      	it	ne
  20b00e:	f10b 3bff 	addne.w	fp, fp, #4294967295	; 0xffffffff
  if (k >= 0 && k <= Ten_pmax)
  20b012:	f1bb 0f16 	cmp.w	fp, #22
  20b016:	d832      	bhi.n	20b07e <_dtoa_r+0x1be>
      if (d.d < tens[k])
  20b018:	4b3d      	ldr	r3, [pc, #244]	; (20b110 <_dtoa_r+0x250>)
  20b01a:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
  20b01e:	ed9d 6b0a 	vldr	d6, [sp, #40]	; 0x28
  20b022:	ed93 7b00 	vldr	d7, [r3]
  20b026:	eeb4 6bc7 	vcmpe.f64	d6, d7
  20b02a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20b02e:	d501      	bpl.n	20b034 <_dtoa_r+0x174>
	k--;
  20b030:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
      k_check = 0;
  20b034:	2300      	movs	r3, #0
  20b036:	e023      	b.n	20b080 <_dtoa_r+0x1c0>
      i = bbits + be + (Bias + (P - 1) - 1);
  20b038:	9813      	ldr	r0, [sp, #76]	; 0x4c
  20b03a:	4408      	add	r0, r1
  20b03c:	f200 4232 	addw	r2, r0, #1074	; 0x432
       : (word1 (d) << (32 - i));
  20b040:	2a20      	cmp	r2, #32
  20b042:	dd16      	ble.n	20b072 <_dtoa_r+0x1b2>
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
  20b044:	f1c2 0240 	rsb	r2, r2, #64	; 0x40
  20b048:	9b00      	ldr	r3, [sp, #0]
  20b04a:	4094      	lsls	r4, r2
  20b04c:	f200 4212 	addw	r2, r0, #1042	; 0x412
  20b050:	fa23 f202 	lsr.w	r2, r3, r2
       : (word1 (d) << (32 - i));
  20b054:	4322      	orrs	r2, r4
      d2.d = x;
  20b056:	ee07 2a90 	vmov	s15, r2
      i -= (Bias + (P - 1) - 1) + 1;
  20b05a:	3801      	subs	r0, #1
      d2.d = x;
  20b05c:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  20b060:	ed8d 7b02 	vstr	d7, [sp, #8]
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
  20b064:	9c03      	ldr	r4, [sp, #12]
      d2.d = x;
  20b066:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
  20b06a:	f1a4 73f8 	sub.w	r3, r4, #32505856	; 0x1f00000
      denorm = 1;
  20b06e:	2401      	movs	r4, #1
  20b070:	e7a6      	b.n	20afc0 <_dtoa_r+0x100>
       : (word1 (d) << (32 - i));
  20b072:	f1c2 0220 	rsb	r2, r2, #32
  20b076:	9b00      	ldr	r3, [sp, #0]
  20b078:	fa03 f202 	lsl.w	r2, r3, r2
  20b07c:	e7eb      	b.n	20b056 <_dtoa_r+0x196>
  k_check = 1;
  20b07e:	2301      	movs	r3, #1
      k_check = 0;
  20b080:	930f      	str	r3, [sp, #60]	; 0x3c
  j = bbits - i - 1;
  20b082:	1a0b      	subs	r3, r1, r0
  if (j >= 0)
  20b084:	1e5a      	subs	r2, r3, #1
      b2 = -j;
  20b086:	bf4c      	ite	mi
  20b088:	f1c3 0301 	rsbmi	r3, r3, #1
      b2 = 0;
  20b08c:	2300      	movpl	r3, #0
  if (j >= 0)
  20b08e:	9206      	str	r2, [sp, #24]
      b2 = -j;
  20b090:	bf45      	ittet	mi
  20b092:	9305      	strmi	r3, [sp, #20]
      s2 = 0;
  20b094:	2300      	movmi	r3, #0
      b2 = 0;
  20b096:	9305      	strpl	r3, [sp, #20]
      s2 = 0;
  20b098:	9306      	strmi	r3, [sp, #24]
  if (k >= 0)
  20b09a:	f1bb 0f00 	cmp.w	fp, #0
  20b09e:	db1a      	blt.n	20b0d6 <_dtoa_r+0x216>
      s2 += k;
  20b0a0:	9b06      	ldr	r3, [sp, #24]
  20b0a2:	f8cd b038 	str.w	fp, [sp, #56]	; 0x38
  20b0a6:	445b      	add	r3, fp
  20b0a8:	9306      	str	r3, [sp, #24]
      b5 = 0;
  20b0aa:	2300      	movs	r3, #0
  if (mode < 0 || mode > 9)
  20b0ac:	9a07      	ldr	r2, [sp, #28]
  20b0ae:	2a09      	cmp	r2, #9
  20b0b0:	f200 8103 	bhi.w	20b2ba <_dtoa_r+0x3fa>
  if (mode > 5)
  20b0b4:	2a05      	cmp	r2, #5
      mode -= 4;
  20b0b6:	bfc5      	ittet	gt
  20b0b8:	3a04      	subgt	r2, #4
      try_quick = 0;
  20b0ba:	2400      	movgt	r4, #0
  try_quick = 1;
  20b0bc:	2401      	movle	r4, #1
      mode -= 4;
  20b0be:	9207      	strgt	r2, [sp, #28]
  switch (mode)
  20b0c0:	9a07      	ldr	r2, [sp, #28]
  20b0c2:	3a02      	subs	r2, #2
  20b0c4:	2a03      	cmp	r2, #3
  20b0c6:	f200 8103 	bhi.w	20b2d0 <_dtoa_r+0x410>
  20b0ca:	e8df f012 	tbh	[pc, r2, lsl #1]
  20b0ce:	0023      	.short	0x0023
  20b0d0:	00e600e8 	.word	0x00e600e8
  20b0d4:	00f4      	.short	0x00f4
      b2 -= k;
  20b0d6:	9b05      	ldr	r3, [sp, #20]
      s5 = 0;
  20b0d8:	2200      	movs	r2, #0
      b2 -= k;
  20b0da:	eba3 030b 	sub.w	r3, r3, fp
      s5 = 0;
  20b0de:	920e      	str	r2, [sp, #56]	; 0x38
      b2 -= k;
  20b0e0:	9305      	str	r3, [sp, #20]
      b5 = -k;
  20b0e2:	f1cb 0300 	rsb	r3, fp, #0
      s5 = 0;
  20b0e6:	e7e1      	b.n	20b0ac <_dtoa_r+0x1ec>
  20b0e8:	636f4361 	.word	0x636f4361
  20b0ec:	3fd287a7 	.word	0x3fd287a7
  20b0f0:	8b60c8b3 	.word	0x8b60c8b3
  20b0f4:	3fc68a28 	.word	0x3fc68a28
  20b0f8:	509f79fb 	.word	0x509f79fb
  20b0fc:	3fd34413 	.word	0x3fd34413
  20b100:	7ff00000 	.word	0x7ff00000
  20b104:	0800ed4a 	.word	0x0800ed4a
  20b108:	0800ed41 	.word	0x0800ed41
  20b10c:	0800dc51 	.word	0x0800dc51
  20b110:	0800edf0 	.word	0x0800edf0
      leftright = 0;
  20b114:	2200      	movs	r2, #0
  try_quick = 1;
  20b116:	9208      	str	r2, [sp, #32]
      if (ndigits <= 0)
  20b118:	9a09      	ldr	r2, [sp, #36]	; 0x24
  20b11a:	2a00      	cmp	r2, #0
  20b11c:	f300 80db 	bgt.w	20b2d6 <_dtoa_r+0x416>
	ndigits = 1;
  20b120:	f04f 0a01 	mov.w	sl, #1
  20b124:	46d1      	mov	r9, sl
  20b126:	4652      	mov	r2, sl
  20b128:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
  20b12c:	6a77      	ldr	r7, [r6, #36]	; 0x24
  20b12e:	2100      	movs	r1, #0
  j = sizeof (__ULong);
  20b130:	2004      	movs	r0, #4
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
  20b132:	6079      	str	r1, [r7, #4]
  20b134:	f100 0c14 	add.w	ip, r0, #20
  20b138:	6879      	ldr	r1, [r7, #4]
  20b13a:	4594      	cmp	ip, r2
  20b13c:	f240 80d0 	bls.w	20b2e0 <_dtoa_r+0x420>
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
  20b140:	4630      	mov	r0, r6
  20b142:	930c      	str	r3, [sp, #48]	; 0x30
  20b144:	f001 f89d 	bl	20c282 <_Balloc>
  s = s0 = (char *) _REENT_MP_RESULT(ptr);
  20b148:	6a72      	ldr	r2, [r6, #36]	; 0x24
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
  20b14a:	6038      	str	r0, [r7, #0]
  if (ilim >= 0 && ilim <= Quick_max && try_quick)
  20b14c:	f1b9 0f0e 	cmp.w	r9, #14
  s = s0 = (char *) _REENT_MP_RESULT(ptr);
  20b150:	6813      	ldr	r3, [r2, #0]
  20b152:	9302      	str	r3, [sp, #8]
  if (ilim >= 0 && ilim <= Quick_max && try_quick)
  20b154:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  20b156:	d873      	bhi.n	20b240 <_dtoa_r+0x380>
  20b158:	2c00      	cmp	r4, #0
  20b15a:	d071      	beq.n	20b240 <_dtoa_r+0x380>
      if (k > 0)
  20b15c:	f1bb 0f00 	cmp.w	fp, #0
  20b160:	f340 80ce 	ble.w	20b300 <_dtoa_r+0x440>
	  ds = tens[k & 0xf];
  20b164:	49d1      	ldr	r1, [pc, #836]	; (20b4ac <_dtoa_r+0x5ec>)
  20b166:	f00b 020f 	and.w	r2, fp, #15
	  if (j & Bletch)
  20b16a:	f41b 7f80 	tst.w	fp, #256	; 0x100
	  ds = tens[k & 0xf];
  20b16e:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
	  j = k >> 4;
  20b172:	ea4f 112b 	mov.w	r1, fp, asr #4
	  ds = tens[k & 0xf];
  20b176:	ed92 7b00 	vldr	d7, [r2]
	  if (j & Bletch)
  20b17a:	f000 80b5 	beq.w	20b2e8 <_dtoa_r+0x428>
	      d.d /= bigtens[n_bigtens - 1];
  20b17e:	4acc      	ldr	r2, [pc, #816]	; (20b4b0 <_dtoa_r+0x5f0>)
	      j &= Bletch - 1;
  20b180:	f001 010f 	and.w	r1, r1, #15
	      d.d /= bigtens[n_bigtens - 1];
  20b184:	ed92 6b08 	vldr	d6, [r2, #32]
  20b188:	ed9d 5b0a 	vldr	d5, [sp, #40]	; 0x28
	      ieps++;
  20b18c:	2203      	movs	r2, #3
	      d.d /= bigtens[n_bigtens - 1];
  20b18e:	ee85 6b06 	vdiv.f64	d6, d5, d6
  20b192:	ed8d 6b00 	vstr	d6, [sp]
	      ieps++;
  20b196:	48c6      	ldr	r0, [pc, #792]	; (20b4b0 <_dtoa_r+0x5f0>)
	  for (; j; j >>= 1, i++)
  20b198:	2900      	cmp	r1, #0
  20b19a:	f040 80a7 	bne.w	20b2ec <_dtoa_r+0x42c>
	  d.d /= ds;
  20b19e:	ed9d 6b00 	vldr	d6, [sp]
  20b1a2:	ee86 7b07 	vdiv.f64	d7, d6, d7
  20b1a6:	ed8d 7b00 	vstr	d7, [sp]
      if (k_check && d.d < 1. && ilim > 0)
  20b1aa:	990f      	ldr	r1, [sp, #60]	; 0x3c
  20b1ac:	2900      	cmp	r1, #0
  20b1ae:	f000 80d9 	beq.w	20b364 <_dtoa_r+0x4a4>
  20b1b2:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
  20b1b6:	ed9d 7b00 	vldr	d7, [sp]
  20b1ba:	eeb4 7bc6 	vcmpe.f64	d7, d6
  20b1be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20b1c2:	f140 80cf 	bpl.w	20b364 <_dtoa_r+0x4a4>
  20b1c6:	f1b9 0f00 	cmp.w	r9, #0
  20b1ca:	f000 80cb 	beq.w	20b364 <_dtoa_r+0x4a4>
	  if (ilim1 <= 0)
  20b1ce:	f1ba 0f00 	cmp.w	sl, #0
  20b1d2:	dd31      	ble.n	20b238 <_dtoa_r+0x378>
	  d.d *= 10.;
  20b1d4:	eeb2 6b04 	vmov.f64	d6, #36	; 0x41200000  10.0
	  k--;
  20b1d8:	f10b 37ff 	add.w	r7, fp, #4294967295	; 0xffffffff
	  ieps++;
  20b1dc:	3201      	adds	r2, #1
  20b1de:	4650      	mov	r0, sl
	  d.d *= 10.;
  20b1e0:	ee27 7b06 	vmul.f64	d7, d7, d6
  20b1e4:	ed8d 7b00 	vstr	d7, [sp]
      eps.d = ieps * d.d + 7.;
  20b1e8:	ee07 2a90 	vmov	s15, r2
  20b1ec:	eeb1 5b0c 	vmov.f64	d5, #28	; 0x40e00000  7.0
  20b1f0:	ed9d 6b00 	vldr	d6, [sp]
  20b1f4:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  20b1f8:	eea7 5b06 	vfma.f64	d5, d7, d6
  20b1fc:	ed8d 5b00 	vstr	d5, [sp]
      word0 (eps) -= (P - 1) * Exp_msk1;
  20b200:	9c01      	ldr	r4, [sp, #4]
      eps.d = ieps * d.d + 7.;
  20b202:	e9dd 1200 	ldrd	r1, r2, [sp]
      word0 (eps) -= (P - 1) * Exp_msk1;
  20b206:	f1a4 7250 	sub.w	r2, r4, #54525952	; 0x3400000
      if (ilim == 0)
  20b20a:	2800      	cmp	r0, #0
  20b20c:	f040 80ad 	bne.w	20b36a <_dtoa_r+0x4aa>
	  d.d -= 5.;
  20b210:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
  20b214:	ee36 6b47 	vsub.f64	d6, d6, d7
	  if (d.d > eps.d)
  20b218:	ec42 1b17 	vmov	d7, r1, r2
  20b21c:	eeb4 6bc7 	vcmpe.f64	d6, d7
  20b220:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20b224:	f300 829a 	bgt.w	20b75c <_dtoa_r+0x89c>
	  if (d.d < -eps.d)
  20b228:	eeb1 7b47 	vneg.f64	d7, d7
  20b22c:	eeb4 6bc7 	vcmpe.f64	d6, d7
  20b230:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20b234:	f100 828f 	bmi.w	20b756 <_dtoa_r+0x896>
      d.d = d2.d;
  20b238:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
  20b23c:	e9cd 1200 	strd	r1, r2, [sp]
  if (be >= 0 && k <= Int_max)
  20b240:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  20b242:	2a00      	cmp	r2, #0
  20b244:	f2c0 8150 	blt.w	20b4e8 <_dtoa_r+0x628>
  20b248:	f1bb 0f0e 	cmp.w	fp, #14
  20b24c:	f300 814c 	bgt.w	20b4e8 <_dtoa_r+0x628>
      ds = tens[k];
  20b250:	4b96      	ldr	r3, [pc, #600]	; (20b4ac <_dtoa_r+0x5ec>)
  20b252:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
  20b256:	ed93 6b00 	vldr	d6, [r3]
      if (ndigits < 0 && ilim <= 0)
  20b25a:	9b09      	ldr	r3, [sp, #36]	; 0x24
  20b25c:	2b00      	cmp	r3, #0
  20b25e:	f280 80ea 	bge.w	20b436 <_dtoa_r+0x576>
  20b262:	f1b9 0f00 	cmp.w	r9, #0
  20b266:	f300 80e6 	bgt.w	20b436 <_dtoa_r+0x576>
	  if (ilim < 0 || d.d <= 5 * ds)
  20b26a:	f040 8274 	bne.w	20b756 <_dtoa_r+0x896>
  20b26e:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
	  S = mhi = 0;
  20b272:	464c      	mov	r4, r9
  20b274:	464f      	mov	r7, r9
	  if (ilim < 0 || d.d <= 5 * ds)
  20b276:	ee26 6b07 	vmul.f64	d6, d6, d7
  20b27a:	ed9d 7b00 	vldr	d7, [sp]
  20b27e:	eeb4 6bc7 	vcmpe.f64	d6, d7
  20b282:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20b286:	f280 824a 	bge.w	20b71e <_dtoa_r+0x85e>
      *s++ = '1';
  20b28a:	f8dd 8008 	ldr.w	r8, [sp, #8]
  20b28e:	2331      	movs	r3, #49	; 0x31
      k++;
  20b290:	f10b 0b01 	add.w	fp, fp, #1
      *s++ = '1';
  20b294:	f808 3b01 	strb.w	r3, [r8], #1
      k++;
  20b298:	e246      	b.n	20b728 <_dtoa_r+0x868>
  try_quick = 1;
  20b29a:	2201      	movs	r2, #1
  20b29c:	e73b      	b.n	20b116 <_dtoa_r+0x256>
      leftright = 0;
  20b29e:	2200      	movs	r2, #0
      leftright = 0;
  20b2a0:	9208      	str	r2, [sp, #32]
      i = ndigits + k + 1;
  20b2a2:	9a09      	ldr	r2, [sp, #36]	; 0x24
  20b2a4:	eb0b 0a02 	add.w	sl, fp, r2
  20b2a8:	f10a 0901 	add.w	r9, sl, #1
      if (i <= 0)
  20b2ac:	464a      	mov	r2, r9
  20b2ae:	2a01      	cmp	r2, #1
  20b2b0:	bfb8      	it	lt
  20b2b2:	2201      	movlt	r2, #1
  20b2b4:	e73a      	b.n	20b12c <_dtoa_r+0x26c>
      leftright = 0;
  20b2b6:	2201      	movs	r2, #1
  20b2b8:	e7f2      	b.n	20b2a0 <_dtoa_r+0x3e0>
  try_quick = 1;
  20b2ba:	2401      	movs	r4, #1
    mode = 0;
  20b2bc:	2200      	movs	r2, #0
  leftright = 1;
  20b2be:	e9cd 2407 	strd	r2, r4, [sp, #28]
  20b2c2:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
  20b2c6:	2100      	movs	r1, #0
  20b2c8:	2212      	movs	r2, #18
  20b2ca:	46d1      	mov	r9, sl
  20b2cc:	9109      	str	r1, [sp, #36]	; 0x24
  20b2ce:	e72d      	b.n	20b12c <_dtoa_r+0x26c>
  20b2d0:	2201      	movs	r2, #1
  20b2d2:	9208      	str	r2, [sp, #32]
  20b2d4:	e7f5      	b.n	20b2c2 <_dtoa_r+0x402>
  20b2d6:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
  20b2da:	46d1      	mov	r9, sl
  20b2dc:	4652      	mov	r2, sl
  20b2de:	e725      	b.n	20b12c <_dtoa_r+0x26c>
    _REENT_MP_RESULT_K(ptr)++;
  20b2e0:	3101      	adds	r1, #1
       j <<= 1)
  20b2e2:	0040      	lsls	r0, r0, #1
    _REENT_MP_RESULT_K(ptr)++;
  20b2e4:	6079      	str	r1, [r7, #4]
  20b2e6:	e725      	b.n	20b134 <_dtoa_r+0x274>
      ieps = 2;			/* conservative */
  20b2e8:	2202      	movs	r2, #2
  20b2ea:	e754      	b.n	20b196 <_dtoa_r+0x2d6>
	    if (j & 1)
  20b2ec:	07cc      	lsls	r4, r1, #31
  20b2ee:	d504      	bpl.n	20b2fa <_dtoa_r+0x43a>
		ieps++;
  20b2f0:	3201      	adds	r2, #1
		ds *= bigtens[i];
  20b2f2:	ed90 6b00 	vldr	d6, [r0]
  20b2f6:	ee27 7b06 	vmul.f64	d7, d7, d6
	  for (; j; j >>= 1, i++)
  20b2fa:	1049      	asrs	r1, r1, #1
  20b2fc:	3008      	adds	r0, #8
  20b2fe:	e74b      	b.n	20b198 <_dtoa_r+0x2d8>
      else if ((j1 = -k) != 0)
  20b300:	d02e      	beq.n	20b360 <_dtoa_r+0x4a0>
  20b302:	f1cb 0100 	rsb	r1, fp, #0
	  d.d *= tens[j1 & 0xf];
  20b306:	4a69      	ldr	r2, [pc, #420]	; (20b4ac <_dtoa_r+0x5ec>)
	  for (j = j1 >> 4; j; j >>= 1, i++)
  20b308:	2400      	movs	r4, #0
	  d.d *= tens[j1 & 0xf];
  20b30a:	f001 000f 	and.w	r0, r1, #15
	  for (j = j1 >> 4; j; j >>= 1, i++)
  20b30e:	1109      	asrs	r1, r1, #4
	  d.d *= tens[j1 & 0xf];
  20b310:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
  20b314:	4866      	ldr	r0, [pc, #408]	; (20b4b0 <_dtoa_r+0x5f0>)
  20b316:	ed92 7b00 	vldr	d7, [r2]
  20b31a:	ed9d 6b0a 	vldr	d6, [sp, #40]	; 0x28
      ieps = 2;			/* conservative */
  20b31e:	2202      	movs	r2, #2
	  d.d *= tens[j1 & 0xf];
  20b320:	ee26 7b07 	vmul.f64	d7, d6, d7
  20b324:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
  20b328:	e9dd 780c 	ldrd	r7, r8, [sp, #48]	; 0x30
  20b32c:	e9cd 7800 	strd	r7, r8, [sp]
	  for (j = j1 >> 4; j; j >>= 1, i++)
  20b330:	b939      	cbnz	r1, 20b342 <_dtoa_r+0x482>
  20b332:	2c00      	cmp	r4, #0
  20b334:	f43f af39 	beq.w	20b1aa <_dtoa_r+0x2ea>
  20b338:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
  20b33c:	e9cd 0100 	strd	r0, r1, [sp]
  20b340:	e733      	b.n	20b1aa <_dtoa_r+0x2ea>
	    if (j & 1)
  20b342:	07cf      	lsls	r7, r1, #31
  20b344:	d509      	bpl.n	20b35a <_dtoa_r+0x49a>
		ieps++;
  20b346:	3201      	adds	r2, #1
		d.d *= bigtens[i];
  20b348:	2401      	movs	r4, #1
  20b34a:	ed9d 6b0c 	vldr	d6, [sp, #48]	; 0x30
  20b34e:	ed90 7b00 	vldr	d7, [r0]
  20b352:	ee26 7b07 	vmul.f64	d7, d6, d7
  20b356:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
	  for (j = j1 >> 4; j; j >>= 1, i++)
  20b35a:	1049      	asrs	r1, r1, #1
  20b35c:	3008      	adds	r0, #8
  20b35e:	e7e7      	b.n	20b330 <_dtoa_r+0x470>
      ieps = 2;			/* conservative */
  20b360:	2202      	movs	r2, #2
  20b362:	e722      	b.n	20b1aa <_dtoa_r+0x2ea>
  20b364:	465f      	mov	r7, fp
  20b366:	4648      	mov	r0, r9
  20b368:	e73e      	b.n	20b1e8 <_dtoa_r+0x328>
      if (leftright)
  20b36a:	ec42 1b17 	vmov	d7, r1, r2
  20b36e:	4a4f      	ldr	r2, [pc, #316]	; (20b4ac <_dtoa_r+0x5ec>)
  20b370:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
  20b374:	ed12 4b02 	vldr	d4, [r2, #-8]
  20b378:	9a02      	ldr	r2, [sp, #8]
  20b37a:	1814      	adds	r4, r2, r0
  20b37c:	9a08      	ldr	r2, [sp, #32]
  20b37e:	b352      	cbz	r2, 20b3d6 <_dtoa_r+0x516>
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
  20b380:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
  s = s0 = (char *) _REENT_MP_RESULT(ptr);
  20b384:	f8dd 8008 	ldr.w	r8, [sp, #8]
	      if (1. - d.d < eps.d)
  20b388:	eeb7 2b00 	vmov.f64	d2, #112	; 0x3f800000  1.0
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
  20b38c:	ee83 5b04 	vdiv.f64	d5, d3, d4
	      eps.d *= 10.;
  20b390:	eeb2 3b04 	vmov.f64	d3, #36	; 0x41200000  10.0
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
  20b394:	ee35 7b47 	vsub.f64	d7, d5, d7
	      L = d.d;
  20b398:	eefd 4bc6 	vcvt.s32.f64	s9, d6
	      d.d -= L;
  20b39c:	eeb8 5be4 	vcvt.f64.s32	d5, s9
	      *s++ = '0' + (int) L;
  20b3a0:	ee14 2a90 	vmov	r2, s9
  20b3a4:	3230      	adds	r2, #48	; 0x30
	      d.d -= L;
  20b3a6:	ee36 6b45 	vsub.f64	d6, d6, d5
	      *s++ = '0' + (int) L;
  20b3aa:	f808 2b01 	strb.w	r2, [r8], #1
	      if (d.d < eps.d)
  20b3ae:	eeb4 6bc7 	vcmpe.f64	d6, d7
  20b3b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20b3b6:	d439      	bmi.n	20b42c <_dtoa_r+0x56c>
	      if (1. - d.d < eps.d)
  20b3b8:	ee32 5b46 	vsub.f64	d5, d2, d6
  20b3bc:	eeb4 5bc7 	vcmpe.f64	d5, d7
  20b3c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20b3c4:	d477      	bmi.n	20b4b6 <_dtoa_r+0x5f6>
	      if (++i >= ilim)
  20b3c6:	45a0      	cmp	r8, r4
  20b3c8:	f43f af36 	beq.w	20b238 <_dtoa_r+0x378>
	      eps.d *= 10.;
  20b3cc:	ee27 7b03 	vmul.f64	d7, d7, d3
	      d.d *= 10.;
  20b3d0:	ee26 6b03 	vmul.f64	d6, d6, d3
	      L = d.d;
  20b3d4:	e7e0      	b.n	20b398 <_dtoa_r+0x4d8>
	  eps.d *= tens[ilim - 1];
  20b3d6:	ee27 7b04 	vmul.f64	d7, d7, d4
	  for (i = 1;; i++, d.d *= 10.)
  20b3da:	4621      	mov	r1, r4
  s = s0 = (char *) _REENT_MP_RESULT(ptr);
  20b3dc:	f8dd 8008 	ldr.w	r8, [sp, #8]
	  for (i = 1;; i++, d.d *= 10.)
  20b3e0:	eeb2 3b04 	vmov.f64	d3, #36	; 0x41200000  10.0
	      L = d.d;
  20b3e4:	eefd 4bc6 	vcvt.s32.f64	s9, d6
	      *s++ = '0' + (int) L;
  20b3e8:	ee14 2a90 	vmov	r2, s9
	      d.d -= L;
  20b3ec:	eeb8 5be4 	vcvt.f64.s32	d5, s9
	      *s++ = '0' + (int) L;
  20b3f0:	3230      	adds	r2, #48	; 0x30
	      d.d -= L;
  20b3f2:	ee36 6b45 	vsub.f64	d6, d6, d5
	      *s++ = '0' + (int) L;
  20b3f6:	f808 2b01 	strb.w	r2, [r8], #1
	      if (i == ilim)
  20b3fa:	45a0      	cmp	r8, r4
  20b3fc:	d118      	bne.n	20b430 <_dtoa_r+0x570>
		  if (d.d > 0.5 + eps.d)
  20b3fe:	eeb6 5b00 	vmov.f64	d5, #96	; 0x3f000000  0.5
  20b402:	ee37 4b05 	vadd.f64	d4, d7, d5
  20b406:	eeb4 6bc4 	vcmpe.f64	d6, d4
  20b40a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20b40e:	dc52      	bgt.n	20b4b6 <_dtoa_r+0x5f6>
		  else if (d.d < 0.5 - eps.d)
  20b410:	ee35 7b47 	vsub.f64	d7, d5, d7
  20b414:	eeb4 6bc7 	vcmpe.f64	d6, d7
  20b418:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20b41c:	f57f af0c 	bpl.w	20b238 <_dtoa_r+0x378>
		      while (*--s == '0');
  20b420:	4688      	mov	r8, r1
  20b422:	3901      	subs	r1, #1
  20b424:	f818 3c01 	ldrb.w	r3, [r8, #-1]
  20b428:	2b30      	cmp	r3, #48	; 0x30
  20b42a:	d0f9      	beq.n	20b420 <_dtoa_r+0x560>
  20b42c:	46bb      	mov	fp, r7
  20b42e:	e02a      	b.n	20b486 <_dtoa_r+0x5c6>
	  for (i = 1;; i++, d.d *= 10.)
  20b430:	ee26 6b03 	vmul.f64	d6, d6, d3
	      L = d.d;
  20b434:	e7d6      	b.n	20b3e4 <_dtoa_r+0x524>
  20b436:	ed9d 7b00 	vldr	d7, [sp]
	  if (!(d.d *= 10.))
  20b43a:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
  s = s0 = (char *) _REENT_MP_RESULT(ptr);
  20b43e:	f8dd 8008 	ldr.w	r8, [sp, #8]
	  L = d.d / ds;
  20b442:	ee87 5b06 	vdiv.f64	d5, d7, d6
  20b446:	eebd 5bc5 	vcvt.s32.f64	s10, d5
	  *s++ = '0' + (int) L;
  20b44a:	ee15 3a10 	vmov	r3, s10
	  d.d -= L * ds;
  20b44e:	eeb8 3bc5 	vcvt.f64.s32	d3, s10
	  *s++ = '0' + (int) L;
  20b452:	3330      	adds	r3, #48	; 0x30
	  d.d -= L * ds;
  20b454:	eea3 7b46 	vfms.f64	d7, d3, d6
	  *s++ = '0' + (int) L;
  20b458:	f808 3b01 	strb.w	r3, [r8], #1
	  if (i == ilim)
  20b45c:	9b02      	ldr	r3, [sp, #8]
  20b45e:	eba8 0303 	sub.w	r3, r8, r3
  20b462:	4599      	cmp	r9, r3
  20b464:	d138      	bne.n	20b4d8 <_dtoa_r+0x618>
	      d.d += d.d;
  20b466:	ee37 7b07 	vadd.f64	d7, d7, d7
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
  20b46a:	eeb4 7bc6 	vcmpe.f64	d7, d6
  20b46e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20b472:	dc1f      	bgt.n	20b4b4 <_dtoa_r+0x5f4>
  20b474:	eeb4 7b46 	vcmp.f64	d7, d6
  20b478:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20b47c:	d103      	bne.n	20b486 <_dtoa_r+0x5c6>
  20b47e:	ee15 3a10 	vmov	r3, s10
  20b482:	07d9      	lsls	r1, r3, #31
  20b484:	d416      	bmi.n	20b4b4 <_dtoa_r+0x5f4>
  Bfree (ptr, b);
  20b486:	4629      	mov	r1, r5
  20b488:	4630      	mov	r0, r6
  20b48a:	f000 ff2e 	bl	20c2ea <_Bfree>
  *s = 0;
  20b48e:	2300      	movs	r3, #0
  *decpt = k + 1;
  20b490:	9a10      	ldr	r2, [sp, #64]	; 0x40
  *s = 0;
  20b492:	f888 3000 	strb.w	r3, [r8]
  *decpt = k + 1;
  20b496:	f10b 0301 	add.w	r3, fp, #1
  20b49a:	6013      	str	r3, [r2, #0]
  if (rve)
  20b49c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
  20b49e:	2b00      	cmp	r3, #0
  20b4a0:	f43f ad57 	beq.w	20af52 <_dtoa_r+0x92>
    *rve = s;
  20b4a4:	f8c3 8000 	str.w	r8, [r3]
  20b4a8:	e553      	b.n	20af52 <_dtoa_r+0x92>
  20b4aa:	bf00      	nop
  20b4ac:	0800edf0 	.word	0x0800edf0
  20b4b0:	0800edc8 	.word	0x0800edc8
		bump_up:
  20b4b4:	465f      	mov	r7, fp
  20b4b6:	4643      	mov	r3, r8
  20b4b8:	4698      	mov	r8, r3
		  while (*--s == '9')
  20b4ba:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
  20b4be:	2a39      	cmp	r2, #57	; 0x39
  20b4c0:	d106      	bne.n	20b4d0 <_dtoa_r+0x610>
		    if (s == s0)
  20b4c2:	9a02      	ldr	r2, [sp, #8]
  20b4c4:	429a      	cmp	r2, r3
  20b4c6:	d1f7      	bne.n	20b4b8 <_dtoa_r+0x5f8>
			*s = '0';
  20b4c8:	2230      	movs	r2, #48	; 0x30
  20b4ca:	9902      	ldr	r1, [sp, #8]
			k++;
  20b4cc:	3701      	adds	r7, #1
			*s = '0';
  20b4ce:	700a      	strb	r2, [r1, #0]
		  ++*s++;
  20b4d0:	781a      	ldrb	r2, [r3, #0]
  20b4d2:	3201      	adds	r2, #1
  20b4d4:	701a      	strb	r2, [r3, #0]
  20b4d6:	e7a9      	b.n	20b42c <_dtoa_r+0x56c>
	  if (!(d.d *= 10.))
  20b4d8:	ee27 7b04 	vmul.f64	d7, d7, d4
  20b4dc:	eeb5 7b40 	vcmp.f64	d7, #0.0
  20b4e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20b4e4:	d1ad      	bne.n	20b442 <_dtoa_r+0x582>
  20b4e6:	e7ce      	b.n	20b486 <_dtoa_r+0x5c6>
  if (leftright)
  20b4e8:	9908      	ldr	r1, [sp, #32]
  20b4ea:	2900      	cmp	r1, #0
  20b4ec:	f000 80d2 	beq.w	20b694 <_dtoa_r+0x7d4>
      if (mode < 2)
  20b4f0:	9907      	ldr	r1, [sp, #28]
  20b4f2:	2901      	cmp	r1, #1
  20b4f4:	f300 80b5 	bgt.w	20b662 <_dtoa_r+0x7a2>
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
  20b4f8:	9911      	ldr	r1, [sp, #68]	; 0x44
  20b4fa:	2900      	cmp	r1, #0
  20b4fc:	f000 80ad 	beq.w	20b65a <_dtoa_r+0x79a>
  20b500:	f202 4233 	addw	r2, r2, #1075	; 0x433
  20b504:	461c      	mov	r4, r3
  m2 = b2;
  20b506:	f8dd 8014 	ldr.w	r8, [sp, #20]
  20b50a:	930a      	str	r3, [sp, #40]	; 0x28
      mhi = i2b (ptr, 1);
  20b50c:	2101      	movs	r1, #1
      b2 += i;
  20b50e:	9b05      	ldr	r3, [sp, #20]
      mhi = i2b (ptr, 1);
  20b510:	4630      	mov	r0, r6
      b2 += i;
  20b512:	4413      	add	r3, r2
  20b514:	9305      	str	r3, [sp, #20]
      s2 += i;
  20b516:	9b06      	ldr	r3, [sp, #24]
  20b518:	4413      	add	r3, r2
  20b51a:	9306      	str	r3, [sp, #24]
      mhi = i2b (ptr, 1);
  20b51c:	f000 ffc9 	bl	20c4b2 <__i2b>
  20b520:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  20b522:	4607      	mov	r7, r0
  if (m2 > 0 && s2 > 0)
  20b524:	f1b8 0f00 	cmp.w	r8, #0
  20b528:	dd0d      	ble.n	20b546 <_dtoa_r+0x686>
  20b52a:	9a06      	ldr	r2, [sp, #24]
  20b52c:	2a00      	cmp	r2, #0
  20b52e:	dd0a      	ble.n	20b546 <_dtoa_r+0x686>
      i = m2 < s2 ? m2 : s2;
  20b530:	4542      	cmp	r2, r8
      b2 -= i;
  20b532:	9905      	ldr	r1, [sp, #20]
      i = m2 < s2 ? m2 : s2;
  20b534:	bfa8      	it	ge
  20b536:	4642      	movge	r2, r8
      b2 -= i;
  20b538:	1a89      	subs	r1, r1, r2
      m2 -= i;
  20b53a:	eba8 0802 	sub.w	r8, r8, r2
      b2 -= i;
  20b53e:	9105      	str	r1, [sp, #20]
      s2 -= i;
  20b540:	9906      	ldr	r1, [sp, #24]
  20b542:	1a8a      	subs	r2, r1, r2
  20b544:	9206      	str	r2, [sp, #24]
  if (b5 > 0)
  20b546:	b303      	cbz	r3, 20b58a <_dtoa_r+0x6ca>
      if (leftright)
  20b548:	9a08      	ldr	r2, [sp, #32]
  20b54a:	2a00      	cmp	r2, #0
  20b54c:	f000 80a7 	beq.w	20b69e <_dtoa_r+0x7de>
	  if (m5 > 0)
  20b550:	2c00      	cmp	r4, #0
  20b552:	dd13      	ble.n	20b57c <_dtoa_r+0x6bc>
	      mhi = pow5mult (ptr, mhi, m5);
  20b554:	4639      	mov	r1, r7
  20b556:	4622      	mov	r2, r4
  20b558:	4630      	mov	r0, r6
  20b55a:	930c      	str	r3, [sp, #48]	; 0x30
  20b55c:	f001 f84e 	bl	20c5fc <__pow5mult>
	      b1 = mult (ptr, mhi, b);
  20b560:	462a      	mov	r2, r5
  20b562:	4601      	mov	r1, r0
	      mhi = pow5mult (ptr, mhi, m5);
  20b564:	4607      	mov	r7, r0
	      b1 = mult (ptr, mhi, b);
  20b566:	4630      	mov	r0, r6
  20b568:	f000 ffac 	bl	20c4c4 <__multiply>
	      Bfree (ptr, b);
  20b56c:	4629      	mov	r1, r5
	      b1 = mult (ptr, mhi, b);
  20b56e:	900a      	str	r0, [sp, #40]	; 0x28
	      Bfree (ptr, b);
  20b570:	4630      	mov	r0, r6
  20b572:	f000 feba 	bl	20c2ea <_Bfree>
	      b = b1;
  20b576:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  20b578:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  20b57a:	4615      	mov	r5, r2
         if ((j = b5 - m5) != 0)
  20b57c:	1b1a      	subs	r2, r3, r4
  20b57e:	d004      	beq.n	20b58a <_dtoa_r+0x6ca>
	b = pow5mult (ptr, b, b5);
  20b580:	4629      	mov	r1, r5
  20b582:	4630      	mov	r0, r6
  20b584:	f001 f83a 	bl	20c5fc <__pow5mult>
  20b588:	4605      	mov	r5, r0
  S = i2b (ptr, 1);
  20b58a:	2101      	movs	r1, #1
  20b58c:	4630      	mov	r0, r6
  20b58e:	f000 ff90 	bl	20c4b2 <__i2b>
  if (s5 > 0)
  20b592:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  S = i2b (ptr, 1);
  20b594:	4604      	mov	r4, r0
  if (s5 > 0)
  20b596:	2b00      	cmp	r3, #0
  20b598:	f340 8083 	ble.w	20b6a2 <_dtoa_r+0x7e2>
    S = pow5mult (ptr, S, s5);
  20b59c:	461a      	mov	r2, r3
  20b59e:	4601      	mov	r1, r0
  20b5a0:	4630      	mov	r0, r6
  20b5a2:	f001 f82b 	bl	20c5fc <__pow5mult>
  if (mode < 2)
  20b5a6:	9b07      	ldr	r3, [sp, #28]
    S = pow5mult (ptr, S, s5);
  20b5a8:	4604      	mov	r4, r0
  if (mode < 2)
  20b5aa:	2b01      	cmp	r3, #1
  20b5ac:	dd7c      	ble.n	20b6a8 <_dtoa_r+0x7e8>
  spec_case = 0;
  20b5ae:	2300      	movs	r3, #0
  20b5b0:	930a      	str	r3, [sp, #40]	; 0x28
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
  20b5b2:	6922      	ldr	r2, [r4, #16]
  20b5b4:	eb04 0282 	add.w	r2, r4, r2, lsl #2
  20b5b8:	6910      	ldr	r0, [r2, #16]
  20b5ba:	f000 ff2a 	bl	20c412 <__hi0bits>
  20b5be:	f1c0 0020 	rsb	r0, r0, #32
  20b5c2:	9b06      	ldr	r3, [sp, #24]
  20b5c4:	4418      	add	r0, r3
  20b5c6:	f010 001f 	ands.w	r0, r0, #31
  20b5ca:	f000 808e 	beq.w	20b6ea <_dtoa_r+0x82a>
    i = 32 - i;
  20b5ce:	f1c0 0220 	rsb	r2, r0, #32
  if (i > 4)
  20b5d2:	2a04      	cmp	r2, #4
  20b5d4:	f340 8087 	ble.w	20b6e6 <_dtoa_r+0x826>
      i -= 4;
  20b5d8:	f1c0 001c 	rsb	r0, r0, #28
      b2 += i;
  20b5dc:	9b05      	ldr	r3, [sp, #20]
      m2 += i;
  20b5de:	4480      	add	r8, r0
      b2 += i;
  20b5e0:	4403      	add	r3, r0
  20b5e2:	9305      	str	r3, [sp, #20]
      s2 += i;
  20b5e4:	9b06      	ldr	r3, [sp, #24]
  20b5e6:	4403      	add	r3, r0
  20b5e8:	9306      	str	r3, [sp, #24]
  if (b2 > 0)
  20b5ea:	9b05      	ldr	r3, [sp, #20]
  20b5ec:	2b00      	cmp	r3, #0
  20b5ee:	dd05      	ble.n	20b5fc <_dtoa_r+0x73c>
    b = lshift (ptr, b, b2);
  20b5f0:	4629      	mov	r1, r5
  20b5f2:	461a      	mov	r2, r3
  20b5f4:	4630      	mov	r0, r6
  20b5f6:	f001 f84f 	bl	20c698 <__lshift>
  20b5fa:	4605      	mov	r5, r0
  if (s2 > 0)
  20b5fc:	9b06      	ldr	r3, [sp, #24]
  20b5fe:	2b00      	cmp	r3, #0
  20b600:	dd05      	ble.n	20b60e <_dtoa_r+0x74e>
    S = lshift (ptr, S, s2);
  20b602:	4621      	mov	r1, r4
  20b604:	461a      	mov	r2, r3
  20b606:	4630      	mov	r0, r6
  20b608:	f001 f846 	bl	20c698 <__lshift>
  20b60c:	4604      	mov	r4, r0
  if (k_check)
  20b60e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  20b610:	2b00      	cmp	r3, #0
  20b612:	d06c      	beq.n	20b6ee <_dtoa_r+0x82e>
      if (cmp (b, S) < 0)
  20b614:	4621      	mov	r1, r4
  20b616:	4628      	mov	r0, r5
  20b618:	f001 f89d 	bl	20c756 <__mcmp>
  20b61c:	2800      	cmp	r0, #0
  20b61e:	da66      	bge.n	20b6ee <_dtoa_r+0x82e>
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
  20b620:	2300      	movs	r3, #0
  20b622:	4629      	mov	r1, r5
  20b624:	220a      	movs	r2, #10
  20b626:	4630      	mov	r0, r6
  20b628:	f000 fe76 	bl	20c318 <__multadd>
	  if (leftright)
  20b62c:	9b08      	ldr	r3, [sp, #32]
	  k--;
  20b62e:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
  20b632:	4605      	mov	r5, r0
	  if (leftright)
  20b634:	2b00      	cmp	r3, #0
  20b636:	f000 818c 	beq.w	20b952 <_dtoa_r+0xa92>
	    mhi = multadd (ptr, mhi, 10, 0);
  20b63a:	4639      	mov	r1, r7
  20b63c:	2300      	movs	r3, #0
  20b63e:	220a      	movs	r2, #10
  20b640:	4630      	mov	r0, r6
  20b642:	f000 fe69 	bl	20c318 <__multadd>
  if (ilim <= 0 && mode > 2)
  20b646:	f1ba 0f00 	cmp.w	sl, #0
	    mhi = multadd (ptr, mhi, 10, 0);
  20b64a:	4607      	mov	r7, r0
  if (ilim <= 0 && mode > 2)
  20b64c:	f300 808f 	bgt.w	20b76e <_dtoa_r+0x8ae>
  20b650:	9b07      	ldr	r3, [sp, #28]
  20b652:	2b02      	cmp	r3, #2
  20b654:	f340 808b 	ble.w	20b76e <_dtoa_r+0x8ae>
  20b658:	e050      	b.n	20b6fc <_dtoa_r+0x83c>
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
  20b65a:	9a12      	ldr	r2, [sp, #72]	; 0x48
  20b65c:	f1c2 0236 	rsb	r2, r2, #54	; 0x36
  20b660:	e750      	b.n	20b504 <_dtoa_r+0x644>
	  j = ilim - 1;
  20b662:	f109 34ff 	add.w	r4, r9, #4294967295	; 0xffffffff
	  if (m5 >= j)
  20b666:	42a3      	cmp	r3, r4
	      s5 += j -= m5;
  20b668:	bfbb      	ittet	lt
  20b66a:	9a0e      	ldrlt	r2, [sp, #56]	; 0x38
  20b66c:	1ae3      	sublt	r3, r4, r3
	    m5 -= j;
  20b66e:	1b1c      	subge	r4, r3, r4
	      s5 += j -= m5;
  20b670:	18d2      	addlt	r2, r2, r3
  20b672:	bfbf      	itttt	lt
  20b674:	4613      	movlt	r3, r2
  20b676:	930e      	strlt	r3, [sp, #56]	; 0x38
  20b678:	4623      	movlt	r3, r4
	      m5 = 0;
  20b67a:	2400      	movlt	r4, #0
	  if ((i = ilim) < 0)
  20b67c:	f1b9 0f00 	cmp.w	r9, #0
	      m2 -= i;
  20b680:	bfb3      	iteet	lt
  20b682:	9a05      	ldrlt	r2, [sp, #20]
  20b684:	464a      	movge	r2, r9
  m2 = b2;
  20b686:	f8dd 8014 	ldrge.w	r8, [sp, #20]
	      m2 -= i;
  20b68a:	eba2 0809 	sublt.w	r8, r2, r9
	      i = 0;
  20b68e:	bfb8      	it	lt
  20b690:	2200      	movlt	r2, #0
  20b692:	e73a      	b.n	20b50a <_dtoa_r+0x64a>
  20b694:	461c      	mov	r4, r3
  m2 = b2;
  20b696:	f8dd 8014 	ldr.w	r8, [sp, #20]
  mhi = mlo = 0;
  20b69a:	9f08      	ldr	r7, [sp, #32]
  20b69c:	e742      	b.n	20b524 <_dtoa_r+0x664>
	b = pow5mult (ptr, b, b5);
  20b69e:	461a      	mov	r2, r3
  20b6a0:	e76e      	b.n	20b580 <_dtoa_r+0x6c0>
  if (mode < 2)
  20b6a2:	9b07      	ldr	r3, [sp, #28]
  20b6a4:	2b01      	cmp	r3, #1
  20b6a6:	dc18      	bgt.n	20b6da <_dtoa_r+0x81a>
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
  20b6a8:	9b00      	ldr	r3, [sp, #0]
  20b6aa:	b9b3      	cbnz	r3, 20b6da <_dtoa_r+0x81a>
  20b6ac:	9b01      	ldr	r3, [sp, #4]
  20b6ae:	f3c3 0213 	ubfx	r2, r3, #0, #20
  20b6b2:	b9a2      	cbnz	r2, 20b6de <_dtoa_r+0x81e>
	  && word0 (d) & Exp_mask
  20b6b4:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
  20b6b8:	0d12      	lsrs	r2, r2, #20
  20b6ba:	0512      	lsls	r2, r2, #20
  20b6bc:	b18a      	cbz	r2, 20b6e2 <_dtoa_r+0x822>
	  b2 += Log2P;
  20b6be:	9b05      	ldr	r3, [sp, #20]
  20b6c0:	3301      	adds	r3, #1
  20b6c2:	9305      	str	r3, [sp, #20]
	  s2 += Log2P;
  20b6c4:	9b06      	ldr	r3, [sp, #24]
  20b6c6:	3301      	adds	r3, #1
  20b6c8:	9306      	str	r3, [sp, #24]
	  spec_case = 1;
  20b6ca:	2301      	movs	r3, #1
  spec_case = 0;
  20b6cc:	930a      	str	r3, [sp, #40]	; 0x28
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
  20b6ce:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  20b6d0:	2b00      	cmp	r3, #0
  20b6d2:	f47f af6e 	bne.w	20b5b2 <_dtoa_r+0x6f2>
  20b6d6:	2001      	movs	r0, #1
  20b6d8:	e773      	b.n	20b5c2 <_dtoa_r+0x702>
  spec_case = 0;
  20b6da:	2300      	movs	r3, #0
  20b6dc:	e7f6      	b.n	20b6cc <_dtoa_r+0x80c>
  20b6de:	9b00      	ldr	r3, [sp, #0]
  20b6e0:	e7f4      	b.n	20b6cc <_dtoa_r+0x80c>
  20b6e2:	920a      	str	r2, [sp, #40]	; 0x28
  20b6e4:	e7f3      	b.n	20b6ce <_dtoa_r+0x80e>
  else if (i < 4)
  20b6e6:	d080      	beq.n	20b5ea <_dtoa_r+0x72a>
  20b6e8:	4610      	mov	r0, r2
      i += 28;
  20b6ea:	301c      	adds	r0, #28
  20b6ec:	e776      	b.n	20b5dc <_dtoa_r+0x71c>
  if (ilim <= 0 && mode > 2)
  20b6ee:	f1b9 0f00 	cmp.w	r9, #0
  20b6f2:	dc37      	bgt.n	20b764 <_dtoa_r+0x8a4>
  20b6f4:	9b07      	ldr	r3, [sp, #28]
  20b6f6:	2b02      	cmp	r3, #2
  20b6f8:	dd34      	ble.n	20b764 <_dtoa_r+0x8a4>
  20b6fa:	46ca      	mov	sl, r9
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
  20b6fc:	f1ba 0f00 	cmp.w	sl, #0
  20b700:	d10d      	bne.n	20b71e <_dtoa_r+0x85e>
  20b702:	4621      	mov	r1, r4
  20b704:	4653      	mov	r3, sl
  20b706:	2205      	movs	r2, #5
  20b708:	4630      	mov	r0, r6
  20b70a:	f000 fe05 	bl	20c318 <__multadd>
  20b70e:	4601      	mov	r1, r0
  20b710:	4604      	mov	r4, r0
  20b712:	4628      	mov	r0, r5
  20b714:	f001 f81f 	bl	20c756 <__mcmp>
  20b718:	2800      	cmp	r0, #0
  20b71a:	f73f adb6 	bgt.w	20b28a <_dtoa_r+0x3ca>
	  k = -1 - ndigits;
  20b71e:	9b09      	ldr	r3, [sp, #36]	; 0x24
  s = s0 = (char *) _REENT_MP_RESULT(ptr);
  20b720:	f8dd 8008 	ldr.w	r8, [sp, #8]
	  k = -1 - ndigits;
  20b724:	ea6f 0b03 	mvn.w	fp, r3
      goto ret;
  20b728:	f04f 0900 	mov.w	r9, #0
  Bfree (ptr, S);
  20b72c:	4621      	mov	r1, r4
  20b72e:	4630      	mov	r0, r6
  20b730:	f000 fddb 	bl	20c2ea <_Bfree>
  if (mhi)
  20b734:	2f00      	cmp	r7, #0
  20b736:	f43f aea6 	beq.w	20b486 <_dtoa_r+0x5c6>
      if (mlo && mlo != mhi)
  20b73a:	f1b9 0f00 	cmp.w	r9, #0
  20b73e:	d005      	beq.n	20b74c <_dtoa_r+0x88c>
  20b740:	45b9      	cmp	r9, r7
  20b742:	d003      	beq.n	20b74c <_dtoa_r+0x88c>
	Bfree (ptr, mlo);
  20b744:	4649      	mov	r1, r9
  20b746:	4630      	mov	r0, r6
  20b748:	f000 fdcf 	bl	20c2ea <_Bfree>
      Bfree (ptr, mhi);
  20b74c:	4639      	mov	r1, r7
  20b74e:	4630      	mov	r0, r6
  20b750:	f000 fdcb 	bl	20c2ea <_Bfree>
  20b754:	e697      	b.n	20b486 <_dtoa_r+0x5c6>
	  S = mhi = 0;
  20b756:	2400      	movs	r4, #0
  20b758:	4627      	mov	r7, r4
  20b75a:	e7e0      	b.n	20b71e <_dtoa_r+0x85e>
  20b75c:	46bb      	mov	fp, r7
	  S = mhi = 0;
  20b75e:	4604      	mov	r4, r0
  20b760:	4607      	mov	r7, r0
  20b762:	e592      	b.n	20b28a <_dtoa_r+0x3ca>
  if (leftright)
  20b764:	9b08      	ldr	r3, [sp, #32]
  20b766:	46ca      	mov	sl, r9
  20b768:	2b00      	cmp	r3, #0
  20b76a:	f000 80f9 	beq.w	20b960 <_dtoa_r+0xaa0>
      if (m2 > 0)
  20b76e:	f1b8 0f00 	cmp.w	r8, #0
  20b772:	dd05      	ble.n	20b780 <_dtoa_r+0x8c0>
	mhi = lshift (ptr, mhi, m2);
  20b774:	4639      	mov	r1, r7
  20b776:	4642      	mov	r2, r8
  20b778:	4630      	mov	r0, r6
  20b77a:	f000 ff8d 	bl	20c698 <__lshift>
  20b77e:	4607      	mov	r7, r0
      if (spec_case)
  20b780:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  20b782:	2b00      	cmp	r3, #0
  20b784:	d056      	beq.n	20b834 <_dtoa_r+0x974>
	  mhi = Balloc (ptr, mhi->_k);
  20b786:	6879      	ldr	r1, [r7, #4]
  20b788:	4630      	mov	r0, r6
  20b78a:	f000 fd7a 	bl	20c282 <_Balloc>
	  Bcopy (mhi, mlo);
  20b78e:	693a      	ldr	r2, [r7, #16]
	  mhi = Balloc (ptr, mhi->_k);
  20b790:	4680      	mov	r8, r0
	  Bcopy (mhi, mlo);
  20b792:	f107 010c 	add.w	r1, r7, #12
  20b796:	3202      	adds	r2, #2
  20b798:	300c      	adds	r0, #12
  20b79a:	0092      	lsls	r2, r2, #2
  20b79c:	f000 fd5c 	bl	20c258 <memcpy>
	  mhi = lshift (ptr, mhi, Log2P);
  20b7a0:	2201      	movs	r2, #1
  20b7a2:	4641      	mov	r1, r8
  20b7a4:	4630      	mov	r0, r6
  20b7a6:	f000 ff77 	bl	20c698 <__lshift>
  20b7aa:	9b02      	ldr	r3, [sp, #8]
  20b7ac:	46b9      	mov	r9, r7
  20b7ae:	4607      	mov	r7, r0
  20b7b0:	3301      	adds	r3, #1
  20b7b2:	9305      	str	r3, [sp, #20]
  20b7b4:	9b02      	ldr	r3, [sp, #8]
  20b7b6:	4453      	add	r3, sl
  20b7b8:	9309      	str	r3, [sp, #36]	; 0x24
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
  20b7ba:	9b00      	ldr	r3, [sp, #0]
  20b7bc:	f003 0301 	and.w	r3, r3, #1
  20b7c0:	9308      	str	r3, [sp, #32]
  20b7c2:	9b05      	ldr	r3, [sp, #20]
	  dig = quorem (b, S) + '0';
  20b7c4:	4621      	mov	r1, r4
  20b7c6:	4628      	mov	r0, r5
  20b7c8:	3b01      	subs	r3, #1
  20b7ca:	9300      	str	r3, [sp, #0]
  20b7cc:	f7ff faea 	bl	20ada4 <quorem>
  20b7d0:	4603      	mov	r3, r0
	  j = cmp (b, mlo);
  20b7d2:	4649      	mov	r1, r9
	  dig = quorem (b, S) + '0';
  20b7d4:	9006      	str	r0, [sp, #24]
	  j = cmp (b, mlo);
  20b7d6:	4628      	mov	r0, r5
	  dig = quorem (b, S) + '0';
  20b7d8:	3330      	adds	r3, #48	; 0x30
  20b7da:	930a      	str	r3, [sp, #40]	; 0x28
	  j = cmp (b, mlo);
  20b7dc:	f000 ffbb 	bl	20c756 <__mcmp>
	  delta = diff (ptr, S, mhi);
  20b7e0:	463a      	mov	r2, r7
	  j = cmp (b, mlo);
  20b7e2:	4682      	mov	sl, r0
	  delta = diff (ptr, S, mhi);
  20b7e4:	4621      	mov	r1, r4
  20b7e6:	4630      	mov	r0, r6
  20b7e8:	f000 ffd1 	bl	20c78e <__mdiff>
	  j1 = delta->_sign ? 1 : cmp (b, delta);
  20b7ec:	68c2      	ldr	r2, [r0, #12]
	  delta = diff (ptr, S, mhi);
  20b7ee:	4680      	mov	r8, r0
	  j1 = delta->_sign ? 1 : cmp (b, delta);
  20b7f0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  20b7f2:	bb0a      	cbnz	r2, 20b838 <_dtoa_r+0x978>
  20b7f4:	4601      	mov	r1, r0
  20b7f6:	4628      	mov	r0, r5
  20b7f8:	f000 ffad 	bl	20c756 <__mcmp>
  20b7fc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  20b7fe:	4602      	mov	r2, r0
	  Bfree (ptr, delta);
  20b800:	4641      	mov	r1, r8
  20b802:	4630      	mov	r0, r6
  20b804:	920e      	str	r2, [sp, #56]	; 0x38
  20b806:	930a      	str	r3, [sp, #40]	; 0x28
  20b808:	f000 fd6f 	bl	20c2ea <_Bfree>
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
  20b80c:	9b07      	ldr	r3, [sp, #28]
  20b80e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  20b810:	f8dd 8014 	ldr.w	r8, [sp, #20]
  20b814:	ea43 0102 	orr.w	r1, r3, r2
  20b818:	9b08      	ldr	r3, [sp, #32]
  20b81a:	430b      	orrs	r3, r1
  20b81c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  20b81e:	d10d      	bne.n	20b83c <_dtoa_r+0x97c>
	      if (dig == '9')
  20b820:	2b39      	cmp	r3, #57	; 0x39
  20b822:	d029      	beq.n	20b878 <_dtoa_r+0x9b8>
	      if (j > 0)
  20b824:	f1ba 0f00 	cmp.w	sl, #0
  20b828:	dd01      	ble.n	20b82e <_dtoa_r+0x96e>
		      && dig++ == '9')
  20b82a:	9b06      	ldr	r3, [sp, #24]
  20b82c:	3331      	adds	r3, #49	; 0x31
	      *s++ = dig + 1;
  20b82e:	9a00      	ldr	r2, [sp, #0]
	    *s++ = '1';
  20b830:	7013      	strb	r3, [r2, #0]
	    goto ret;
  20b832:	e77b      	b.n	20b72c <_dtoa_r+0x86c>
  20b834:	4638      	mov	r0, r7
  20b836:	e7b8      	b.n	20b7aa <_dtoa_r+0x8ea>
	  j1 = delta->_sign ? 1 : cmp (b, delta);
  20b838:	2201      	movs	r2, #1
  20b83a:	e7e1      	b.n	20b800 <_dtoa_r+0x940>
         if ((j < 0) || ((j == 0) && !mode
  20b83c:	f1ba 0f00 	cmp.w	sl, #0
  20b840:	db06      	blt.n	20b850 <_dtoa_r+0x990>
	      && !(word1 (d) & 1)
  20b842:	9907      	ldr	r1, [sp, #28]
  20b844:	ea41 0a0a 	orr.w	sl, r1, sl
  20b848:	9908      	ldr	r1, [sp, #32]
  20b84a:	ea5a 0101 	orrs.w	r1, sl, r1
  20b84e:	d120      	bne.n	20b892 <_dtoa_r+0x9d2>
	      if (j1 > 0)
  20b850:	2a00      	cmp	r2, #0
  20b852:	ddec      	ble.n	20b82e <_dtoa_r+0x96e>
		  b = lshift (ptr, b, 1);
  20b854:	4629      	mov	r1, r5
  20b856:	2201      	movs	r2, #1
  20b858:	4630      	mov	r0, r6
  20b85a:	9305      	str	r3, [sp, #20]
  20b85c:	f000 ff1c 	bl	20c698 <__lshift>
		  j1 = cmp (b, S);
  20b860:	4621      	mov	r1, r4
		  b = lshift (ptr, b, 1);
  20b862:	4605      	mov	r5, r0
		  j1 = cmp (b, S);
  20b864:	f000 ff77 	bl	20c756 <__mcmp>
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
  20b868:	2800      	cmp	r0, #0
  20b86a:	9b05      	ldr	r3, [sp, #20]
  20b86c:	dc02      	bgt.n	20b874 <_dtoa_r+0x9b4>
  20b86e:	d1de      	bne.n	20b82e <_dtoa_r+0x96e>
  20b870:	07da      	lsls	r2, r3, #31
  20b872:	d5dc      	bpl.n	20b82e <_dtoa_r+0x96e>
		      && dig++ == '9')
  20b874:	2b39      	cmp	r3, #57	; 0x39
  20b876:	d1d8      	bne.n	20b82a <_dtoa_r+0x96a>
		  *s++ = '9';
  20b878:	2339      	movs	r3, #57	; 0x39
  20b87a:	9a00      	ldr	r2, [sp, #0]
  20b87c:	7013      	strb	r3, [r2, #0]
    roundoff:
  20b87e:	4643      	mov	r3, r8
  20b880:	4698      	mov	r8, r3
      while (*--s == '9')
  20b882:	3b01      	subs	r3, #1
  20b884:	f818 2c01 	ldrb.w	r2, [r8, #-1]
  20b888:	2a39      	cmp	r2, #57	; 0x39
  20b88a:	d051      	beq.n	20b930 <_dtoa_r+0xa70>
      ++*s++;
  20b88c:	3201      	adds	r2, #1
  20b88e:	701a      	strb	r2, [r3, #0]
  20b890:	e74c      	b.n	20b72c <_dtoa_r+0x86c>
	  if (j1 > 0)
  20b892:	2a00      	cmp	r2, #0
  20b894:	dd03      	ble.n	20b89e <_dtoa_r+0x9de>
	      if (dig == '9')
  20b896:	2b39      	cmp	r3, #57	; 0x39
  20b898:	d0ee      	beq.n	20b878 <_dtoa_r+0x9b8>
	      *s++ = dig + 1;
  20b89a:	3301      	adds	r3, #1
  20b89c:	e7c7      	b.n	20b82e <_dtoa_r+0x96e>
	  *s++ = dig;
  20b89e:	9a05      	ldr	r2, [sp, #20]
	  if (i == ilim)
  20b8a0:	9909      	ldr	r1, [sp, #36]	; 0x24
	  *s++ = dig;
  20b8a2:	f802 3c01 	strb.w	r3, [r2, #-1]
	  if (i == ilim)
  20b8a6:	428a      	cmp	r2, r1
  20b8a8:	d02b      	beq.n	20b902 <_dtoa_r+0xa42>
	  b = multadd (ptr, b, 10, 0);
  20b8aa:	4629      	mov	r1, r5
  20b8ac:	2300      	movs	r3, #0
  20b8ae:	220a      	movs	r2, #10
  20b8b0:	4630      	mov	r0, r6
  20b8b2:	f000 fd31 	bl	20c318 <__multadd>
	  if (mlo == mhi)
  20b8b6:	45b9      	cmp	r9, r7
	  b = multadd (ptr, b, 10, 0);
  20b8b8:	4605      	mov	r5, r0
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
  20b8ba:	f04f 0300 	mov.w	r3, #0
  20b8be:	f04f 020a 	mov.w	r2, #10
  20b8c2:	4649      	mov	r1, r9
  20b8c4:	4630      	mov	r0, r6
	  if (mlo == mhi)
  20b8c6:	d107      	bne.n	20b8d8 <_dtoa_r+0xa18>
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
  20b8c8:	f000 fd26 	bl	20c318 <__multadd>
  20b8cc:	4681      	mov	r9, r0
  20b8ce:	4607      	mov	r7, r0
  20b8d0:	9b05      	ldr	r3, [sp, #20]
  20b8d2:	3301      	adds	r3, #1
  20b8d4:	9305      	str	r3, [sp, #20]
	  dig = quorem (b, S) + '0';
  20b8d6:	e774      	b.n	20b7c2 <_dtoa_r+0x902>
	      mlo = multadd (ptr, mlo, 10, 0);
  20b8d8:	f000 fd1e 	bl	20c318 <__multadd>
	      mhi = multadd (ptr, mhi, 10, 0);
  20b8dc:	4639      	mov	r1, r7
	      mlo = multadd (ptr, mlo, 10, 0);
  20b8de:	4681      	mov	r9, r0
	      mhi = multadd (ptr, mhi, 10, 0);
  20b8e0:	2300      	movs	r3, #0
  20b8e2:	220a      	movs	r2, #10
  20b8e4:	4630      	mov	r0, r6
  20b8e6:	f000 fd17 	bl	20c318 <__multadd>
  20b8ea:	4607      	mov	r7, r0
  20b8ec:	e7f0      	b.n	20b8d0 <_dtoa_r+0xa10>
  20b8ee:	f1ba 0f00 	cmp.w	sl, #0
  20b8f2:	9a02      	ldr	r2, [sp, #8]
  mhi = mlo = 0;
  20b8f4:	f04f 0900 	mov.w	r9, #0
  20b8f8:	bfcc      	ite	gt
  20b8fa:	46d0      	movgt	r8, sl
  20b8fc:	f04f 0801 	movle.w	r8, #1
  20b900:	4490      	add	r8, r2
  b = lshift (ptr, b, 1);
  20b902:	4629      	mov	r1, r5
  20b904:	2201      	movs	r2, #1
  20b906:	4630      	mov	r0, r6
  20b908:	9300      	str	r3, [sp, #0]
  20b90a:	f000 fec5 	bl	20c698 <__lshift>
  j = cmp (b, S);
  20b90e:	4621      	mov	r1, r4
  b = lshift (ptr, b, 1);
  20b910:	4605      	mov	r5, r0
  j = cmp (b, S);
  20b912:	f000 ff20 	bl	20c756 <__mcmp>
  if ((j > 0) || ((j == 0) && (dig & 1)))
  20b916:	2800      	cmp	r0, #0
  20b918:	dcb1      	bgt.n	20b87e <_dtoa_r+0x9be>
  20b91a:	d102      	bne.n	20b922 <_dtoa_r+0xa62>
  20b91c:	9b00      	ldr	r3, [sp, #0]
  20b91e:	07db      	lsls	r3, r3, #31
  20b920:	d4ad      	bmi.n	20b87e <_dtoa_r+0x9be>
    roundoff:
  20b922:	4643      	mov	r3, r8
      while (*--s == '0');
  20b924:	4698      	mov	r8, r3
  20b926:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
  20b92a:	2a30      	cmp	r2, #48	; 0x30
  20b92c:	d0fa      	beq.n	20b924 <_dtoa_r+0xa64>
  20b92e:	e6fd      	b.n	20b72c <_dtoa_r+0x86c>
	if (s == s0)
  20b930:	9a02      	ldr	r2, [sp, #8]
  20b932:	429a      	cmp	r2, r3
  20b934:	d1a4      	bne.n	20b880 <_dtoa_r+0x9c0>
	    k++;
  20b936:	f10b 0b01 	add.w	fp, fp, #1
	    *s++ = '1';
  20b93a:	2331      	movs	r3, #49	; 0x31
  20b93c:	e778      	b.n	20b830 <_dtoa_r+0x970>
      return s;
  20b93e:	4b14      	ldr	r3, [pc, #80]	; (20b990 <_dtoa_r+0xad0>)
  20b940:	f7ff bb23 	b.w	20af8a <_dtoa_r+0xca>
      if (rve)
  20b944:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
  20b946:	2b00      	cmp	r3, #0
  20b948:	f47f aafe 	bne.w	20af48 <_dtoa_r+0x88>
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
  20b94c:	4b11      	ldr	r3, [pc, #68]	; (20b994 <_dtoa_r+0xad4>)
  20b94e:	f7ff bb1c 	b.w	20af8a <_dtoa_r+0xca>
  if (ilim <= 0 && mode > 2)
  20b952:	f1ba 0f00 	cmp.w	sl, #0
  20b956:	dc03      	bgt.n	20b960 <_dtoa_r+0xaa0>
  20b958:	9b07      	ldr	r3, [sp, #28]
  20b95a:	2b02      	cmp	r3, #2
  20b95c:	f73f aece 	bgt.w	20b6fc <_dtoa_r+0x83c>
  s = s0 = (char *) _REENT_MP_RESULT(ptr);
  20b960:	f8dd 8008 	ldr.w	r8, [sp, #8]
	*s++ = dig = quorem (b, S) + '0';
  20b964:	4621      	mov	r1, r4
  20b966:	4628      	mov	r0, r5
  20b968:	f7ff fa1c 	bl	20ada4 <quorem>
	if (i >= ilim)
  20b96c:	9a02      	ldr	r2, [sp, #8]
	*s++ = dig = quorem (b, S) + '0';
  20b96e:	f100 0330 	add.w	r3, r0, #48	; 0x30
  20b972:	f808 3b01 	strb.w	r3, [r8], #1
	if (i >= ilim)
  20b976:	eba8 0202 	sub.w	r2, r8, r2
  20b97a:	4592      	cmp	sl, r2
  20b97c:	ddb7      	ble.n	20b8ee <_dtoa_r+0xa2e>
	b = multadd (ptr, b, 10, 0);
  20b97e:	4629      	mov	r1, r5
  20b980:	2300      	movs	r3, #0
  20b982:	220a      	movs	r2, #10
  20b984:	4630      	mov	r0, r6
  20b986:	f000 fcc7 	bl	20c318 <__multadd>
  20b98a:	4605      	mov	r5, r0
	*s++ = dig = quorem (b, S) + '0';
  20b98c:	e7ea      	b.n	20b964 <_dtoa_r+0xaa4>
  20b98e:	bf00      	nop
  20b990:	0800dc50 	.word	0x0800dc50
  20b994:	0800ed41 	.word	0x0800ed41

0020b998 <std>:
#endif
std (FILE *ptr,
            int flags,
            int file)
{
  ptr->_p = 0;
  20b998:	2300      	movs	r3, #0
{
  20b99a:	b510      	push	{r4, lr}
  20b99c:	4604      	mov	r4, r0
  ptr->_r = 0;
  ptr->_w = 0;
  20b99e:	6083      	str	r3, [r0, #8]
  ptr->_flags = flags;
  20b9a0:	8181      	strh	r1, [r0, #12]
  ptr->_flags2 = 0;
  ptr->_file = file;
  ptr->_bf._base = 0;
  ptr->_bf._size = 0;
  ptr->_lbfsize = 0;
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  20b9a2:	4619      	mov	r1, r3
  ptr->_flags2 = 0;
  20b9a4:	6643      	str	r3, [r0, #100]	; 0x64
  ptr->_file = file;
  20b9a6:	81c2      	strh	r2, [r0, #14]
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  20b9a8:	2208      	movs	r2, #8
  ptr->_lbfsize = 0;
  20b9aa:	6183      	str	r3, [r0, #24]
  ptr->_r = 0;
  20b9ac:	e9c0 3300 	strd	r3, r3, [r0]
  ptr->_bf._size = 0;
  20b9b0:	e9c0 3304 	strd	r3, r3, [r0, #16]
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
  20b9b4:	305c      	adds	r0, #92	; 0x5c
  20b9b6:	f000 fc5c 	bl	20c272 <memset>
  ptr->_cookie = ptr;
  ptr->_read = __sread;
  20b9ba:	4b05      	ldr	r3, [pc, #20]	; (20b9d0 <std+0x38>)
  ptr->_cookie = ptr;
  20b9bc:	6224      	str	r4, [r4, #32]
  ptr->_read = __sread;
  20b9be:	6263      	str	r3, [r4, #36]	; 0x24
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
  20b9c0:	4b04      	ldr	r3, [pc, #16]	; (20b9d4 <std+0x3c>)
  20b9c2:	62a3      	str	r3, [r4, #40]	; 0x28
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
  20b9c4:	4b04      	ldr	r3, [pc, #16]	; (20b9d8 <std+0x40>)
  20b9c6:	62e3      	str	r3, [r4, #44]	; 0x2c
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
  20b9c8:	4b04      	ldr	r3, [pc, #16]	; (20b9dc <std+0x44>)
  20b9ca:	6323      	str	r3, [r4, #48]	; 0x30

#ifdef __SCLE
  if (__stextmode (ptr->_file))
    ptr->_flags |= __SCLE;
#endif
}
  20b9cc:	bd10      	pop	{r4, pc}
  20b9ce:	bf00      	nop
  20b9d0:	0020d111 	.word	0x0020d111
  20b9d4:	0020d133 	.word	0x0020d133
  20b9d8:	0020d16b 	.word	0x0020d16b
  20b9dc:	0020d18f 	.word	0x0020d18f

0020b9e0 <_cleanup_r>:
  if (ptr->_stdout != &__sf[1])
    (*cleanup_func) (ptr, ptr->_stdout);
  if (ptr->_stderr != &__sf[2])
    (*cleanup_func) (ptr, ptr->_stderr);
#endif
  (void) _fwalk_reent (ptr, cleanup_func);
  20b9e0:	4901      	ldr	r1, [pc, #4]	; (20b9e8 <_cleanup_r+0x8>)
  20b9e2:	f000 b897 	b.w	20bb14 <_fwalk_reent>
  20b9e6:	bf00      	nop
  20b9e8:	0020d4a9 	.word	0x0020d4a9

0020b9ec <__sfmoreglue>:
{
  20b9ec:	b570      	push	{r4, r5, r6, lr}
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  20b9ee:	1e4a      	subs	r2, r1, #1
  20b9f0:	2568      	movs	r5, #104	; 0x68
{
  20b9f2:	460e      	mov	r6, r1
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  20b9f4:	4355      	muls	r5, r2
  20b9f6:	f105 0174 	add.w	r1, r5, #116	; 0x74
  20b9fa:	f7fd fc65 	bl	2092c8 <_malloc_r>
  if (g == NULL)
  20b9fe:	4604      	mov	r4, r0
  20ba00:	b140      	cbz	r0, 20ba14 <__sfmoreglue+0x28>
  g->glue._next = NULL;
  20ba02:	2100      	movs	r1, #0
  memset (&g->file, 0, n * sizeof (FILE));
  20ba04:	f105 0268 	add.w	r2, r5, #104	; 0x68
  g->glue._niobs = n;
  20ba08:	e9c0 1600 	strd	r1, r6, [r0]
  g->glue._iobs = &g->file;
  20ba0c:	300c      	adds	r0, #12
  20ba0e:	60a0      	str	r0, [r4, #8]
  memset (&g->file, 0, n * sizeof (FILE));
  20ba10:	f000 fc2f 	bl	20c272 <memset>
}
  20ba14:	4620      	mov	r0, r4
  20ba16:	bd70      	pop	{r4, r5, r6, pc}

0020ba18 <__sinit>:
void
__sinit (struct _reent *s)
{
  __sinit_lock_acquire ();

  if (s->__sdidinit)
  20ba18:	6983      	ldr	r3, [r0, #24]
{
  20ba1a:	b510      	push	{r4, lr}
  20ba1c:	4604      	mov	r4, r0
  if (s->__sdidinit)
  20ba1e:	bb33      	cbnz	r3, 20ba6e <__sinit+0x56>
  s->__sglue._niobs = 3;
  s->__sglue._iobs = &s->__sf[0];
# endif /* _REENT_GLOBAL_STDIO_STREAMS */
#else
  s->__sglue._niobs = 0;
  s->__sglue._iobs = NULL;
  20ba20:	6503      	str	r3, [r0, #80]	; 0x50
  s->__cleanup = _cleanup_r;	/* conservative */
  20ba22:	4a13      	ldr	r2, [pc, #76]	; (20ba70 <__sinit+0x58>)
  s->__sglue._niobs = 0;
  20ba24:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
  /* Avoid infinite recursion when calling __sfp  for _GLOBAL_REENT.  The
     problem is that __sfp checks for _GLOBAL_REENT->__sdidinit and calls
     __sinit if it's 0. */
  if (s == _GLOBAL_REENT)
  20ba28:	4b12      	ldr	r3, [pc, #72]	; (20ba74 <__sinit+0x5c>)
  s->__cleanup = _cleanup_r;	/* conservative */
  20ba2a:	6282      	str	r2, [r0, #40]	; 0x28
  if (s == _GLOBAL_REENT)
  20ba2c:	681b      	ldr	r3, [r3, #0]
  20ba2e:	4298      	cmp	r0, r3
    s->__sdidinit = 1;
  20ba30:	bf04      	itt	eq
  20ba32:	2301      	moveq	r3, #1
  20ba34:	6183      	streq	r3, [r0, #24]
# ifndef _REENT_GLOBAL_STDIO_STREAMS
  s->_stdin = __sfp(s);
  20ba36:	f000 f81f 	bl	20ba78 <__sfp>
  20ba3a:	6060      	str	r0, [r4, #4]
  s->_stdout = __sfp(s);
  20ba3c:	4620      	mov	r0, r4
  20ba3e:	f000 f81b 	bl	20ba78 <__sfp>
  20ba42:	60a0      	str	r0, [r4, #8]
  s->_stderr = __sfp(s);
  20ba44:	4620      	mov	r0, r4
  20ba46:	f000 f817 	bl	20ba78 <__sfp>
  std (ptr,  __SRD, 0);
  20ba4a:	2200      	movs	r2, #0
  20ba4c:	2104      	movs	r1, #4
  s->_stderr = __sfp(s);
  20ba4e:	60e0      	str	r0, [r4, #12]
  std (ptr,  __SRD, 0);
  20ba50:	6860      	ldr	r0, [r4, #4]
  20ba52:	f7ff ffa1 	bl	20b998 <std>
  std (ptr, __SWR | __SLBF, 1);
  20ba56:	2201      	movs	r2, #1
  20ba58:	2109      	movs	r1, #9
  20ba5a:	68a0      	ldr	r0, [r4, #8]
  20ba5c:	f7ff ff9c 	bl	20b998 <std>
  std (ptr, __SRW | __SNBF, 2);
  20ba60:	2202      	movs	r2, #2
  20ba62:	2112      	movs	r1, #18
  20ba64:	68e0      	ldr	r0, [r4, #12]
  20ba66:	f7ff ff97 	bl	20b998 <std>
  stdin_init (s->_stdin);
  stdout_init (s->_stdout);
  stderr_init (s->_stderr);
#endif /* _REENT_GLOBAL_STDIO_STREAMS */

  s->__sdidinit = 1;
  20ba6a:	2301      	movs	r3, #1
  20ba6c:	61a3      	str	r3, [r4, #24]

  __sinit_lock_release ();
}
  20ba6e:	bd10      	pop	{r4, pc}
  20ba70:	0020b9e1 	.word	0x0020b9e1
  20ba74:	0800eb68 	.word	0x0800eb68

0020ba78 <__sfp>:
{
  20ba78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (!_GLOBAL_REENT->__sdidinit)
  20ba7a:	4b1b      	ldr	r3, [pc, #108]	; (20bae8 <__sfp+0x70>)
{
  20ba7c:	4607      	mov	r7, r0
  if (!_GLOBAL_REENT->__sdidinit)
  20ba7e:	681e      	ldr	r6, [r3, #0]
  20ba80:	69b3      	ldr	r3, [r6, #24]
  20ba82:	b913      	cbnz	r3, 20ba8a <__sfp+0x12>
    __sinit (_GLOBAL_REENT);
  20ba84:	4630      	mov	r0, r6
  20ba86:	f7ff ffc7 	bl	20ba18 <__sinit>
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
  20ba8a:	3648      	adds	r6, #72	; 0x48
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
  20ba8c:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
  20ba90:	3b01      	subs	r3, #1
  20ba92:	d503      	bpl.n	20ba9c <__sfp+0x24>
      if (g->_next == NULL &&
  20ba94:	6833      	ldr	r3, [r6, #0]
  20ba96:	b1db      	cbz	r3, 20bad0 <__sfp+0x58>
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
  20ba98:	6836      	ldr	r6, [r6, #0]
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
  20ba9a:	e7f7      	b.n	20ba8c <__sfp+0x14>
	if (fp->_flags == 0)
  20ba9c:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
  20baa0:	b9a5      	cbnz	r5, 20bacc <__sfp+0x54>
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
  20baa2:	4b12      	ldr	r3, [pc, #72]	; (20baec <__sfp+0x74>)
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
  20baa4:	2208      	movs	r2, #8
  20baa6:	4629      	mov	r1, r5
  20baa8:	f104 005c 	add.w	r0, r4, #92	; 0x5c
  fp->_flags2 = 0;
  20baac:	6665      	str	r5, [r4, #100]	; 0x64
  fp->_w = 0;			/* nothing to read or write */
  20baae:	60a5      	str	r5, [r4, #8]
  fp->_r = 0;
  20bab0:	e9c4 5500 	strd	r5, r5, [r4]
  fp->_bf._base = NULL;		/* no buffer */
  20bab4:	e9c4 3503 	strd	r3, r5, [r4, #12]
  fp->_lbfsize = 0;		/* not line buffered */
  20bab8:	e9c4 5505 	strd	r5, r5, [r4, #20]
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
  20babc:	f000 fbd9 	bl	20c272 <memset>
  fp->_ub._size = 0;
  20bac0:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
  fp->_lb._size = 0;
  20bac4:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
}
  20bac8:	4620      	mov	r0, r4
  20baca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
  20bacc:	3468      	adds	r4, #104	; 0x68
  20bace:	e7df      	b.n	20ba90 <__sfp+0x18>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
  20bad0:	2104      	movs	r1, #4
  20bad2:	4638      	mov	r0, r7
  20bad4:	f7ff ff8a 	bl	20b9ec <__sfmoreglue>
  20bad8:	4604      	mov	r4, r0
  20bada:	6030      	str	r0, [r6, #0]
      if (g->_next == NULL &&
  20badc:	2800      	cmp	r0, #0
  20bade:	d1db      	bne.n	20ba98 <__sfp+0x20>
  d->_errno = ENOMEM;
  20bae0:	230c      	movs	r3, #12
  20bae2:	603b      	str	r3, [r7, #0]
  return NULL;
  20bae4:	e7f0      	b.n	20bac8 <__sfp+0x50>
  20bae6:	bf00      	nop
  20bae8:	0800eb68 	.word	0x0800eb68
  20baec:	ffff0001 	.word	0xffff0001

0020baf0 <fiprintf>:
#ifndef _REENT_ONLY

int
fprintf (FILE *__restrict fp,
       const char *__restrict fmt, ...)
{
  20baf0:	b40e      	push	{r1, r2, r3}
  20baf2:	b503      	push	{r0, r1, lr}
  20baf4:	ab03      	add	r3, sp, #12
  20baf6:	4601      	mov	r1, r0
  int ret;
  va_list ap;

  va_start (ap, fmt);
  ret = _vfprintf_r (_REENT, fp, fmt, ap);
  20baf8:	4805      	ldr	r0, [pc, #20]	; (20bb10 <fiprintf+0x20>)
{
  20bafa:	f853 2b04 	ldr.w	r2, [r3], #4
  ret = _vfprintf_r (_REENT, fp, fmt, ap);
  20bafe:	6800      	ldr	r0, [r0, #0]
  va_start (ap, fmt);
  20bb00:	9301      	str	r3, [sp, #4]
  ret = _vfprintf_r (_REENT, fp, fmt, ap);
  20bb02:	f001 f9e5 	bl	20ced0 <_vfiprintf_r>
  va_end (ap);
  return ret;
}
  20bb06:	b002      	add	sp, #8
  20bb08:	f85d eb04 	ldr.w	lr, [sp], #4
  20bb0c:	b003      	add	sp, #12
  20bb0e:	4770      	bx	lr
  20bb10:	20010060 	.word	0x20010060

0020bb14 <_fwalk_reent>:
/* Special version of __fwalk where the function pointer is a reentrant
   I/O function (e.g. _fclose_r).  */
int
_fwalk_reent (struct _reent *ptr,
       register int (*reent_function) (struct _reent *, FILE *))
{
  20bb14:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  20bb18:	4606      	mov	r6, r0
  20bb1a:	4688      	mov	r8, r1
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
  20bb1c:	f100 0448 	add.w	r4, r0, #72	; 0x48
  register int n, ret = 0;
  20bb20:	2700      	movs	r7, #0
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
  20bb22:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
  20bb26:	f1b9 0901 	subs.w	r9, r9, #1
  20bb2a:	d505      	bpl.n	20bb38 <_fwalk_reent+0x24>
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
  20bb2c:	6824      	ldr	r4, [r4, #0]
  20bb2e:	2c00      	cmp	r4, #0
  20bb30:	d1f7      	bne.n	20bb22 <_fwalk_reent+0xe>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*reent_function) (ptr, fp);

  return ret;
}
  20bb32:	4638      	mov	r0, r7
  20bb34:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
  20bb38:	89ab      	ldrh	r3, [r5, #12]
  20bb3a:	2b01      	cmp	r3, #1
  20bb3c:	d907      	bls.n	20bb4e <_fwalk_reent+0x3a>
  20bb3e:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
  20bb42:	3301      	adds	r3, #1
  20bb44:	d003      	beq.n	20bb4e <_fwalk_reent+0x3a>
	ret |= (*reent_function) (ptr, fp);
  20bb46:	4629      	mov	r1, r5
  20bb48:	4630      	mov	r0, r6
  20bb4a:	47c0      	blx	r8
  20bb4c:	4307      	orrs	r7, r0
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
  20bb4e:	3568      	adds	r5, #104	; 0x68
  20bb50:	e7e9      	b.n	20bb26 <_fwalk_reent+0x12>

0020bb52 <rshift>:
	__ULong *x, *x1, *xe, y;
	int n;

	x = x1 = b->_x;
	n = k >> kshift;
	if (n < b->_wds) {
  20bb52:	6903      	ldr	r3, [r0, #16]
	n = k >> kshift;
  20bb54:	114a      	asrs	r2, r1, #5
	if (n < b->_wds) {
  20bb56:	ebb3 1f61 	cmp.w	r3, r1, asr #5
{
  20bb5a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	x = x1 = b->_x;
  20bb5e:	f100 0414 	add.w	r4, r0, #20
	if (n < b->_wds) {
  20bb62:	dd45      	ble.n	20bbf0 <rshift+0x9e>
		xe = x + b->_wds;
		x += n;
		if (k &= kmask) {
  20bb64:	f011 011f 	ands.w	r1, r1, #31
		xe = x + b->_wds;
  20bb68:	eb04 0683 	add.w	r6, r4, r3, lsl #2
		x += n;
  20bb6c:	eb04 0582 	add.w	r5, r4, r2, lsl #2
		if (k &= kmask) {
  20bb70:	d10c      	bne.n	20bb8c <rshift+0x3a>
  20bb72:	f100 0710 	add.w	r7, r0, #16
		x += n;
  20bb76:	4629      	mov	r1, r5
				}
			if ((*x1 = y) !=0)
				x1++;
			}
		else
			while(x < xe)
  20bb78:	42b1      	cmp	r1, r6
  20bb7a:	d334      	bcc.n	20bbe6 <rshift+0x94>
  20bb7c:	1a9b      	subs	r3, r3, r2
  20bb7e:	1eea      	subs	r2, r5, #3
  20bb80:	009b      	lsls	r3, r3, #2
  20bb82:	4296      	cmp	r6, r2
  20bb84:	bf38      	it	cc
  20bb86:	2300      	movcc	r3, #0
  20bb88:	4423      	add	r3, r4
  20bb8a:	e015      	b.n	20bbb8 <rshift+0x66>
			y = *x++ >> k;
  20bb8c:	f854 7022 	ldr.w	r7, [r4, r2, lsl #2]
			n = ULbits - k;
  20bb90:	f1c1 0820 	rsb	r8, r1, #32
			y = *x++ >> k;
  20bb94:	f105 0e04 	add.w	lr, r5, #4
	x = x1 = b->_x;
  20bb98:	46a1      	mov	r9, r4
			y = *x++ >> k;
  20bb9a:	40cf      	lsrs	r7, r1
			while(x < xe) {
  20bb9c:	4576      	cmp	r6, lr
  20bb9e:	46f4      	mov	ip, lr
  20bba0:	d815      	bhi.n	20bbce <rshift+0x7c>
  20bba2:	1a9b      	subs	r3, r3, r2
  20bba4:	3501      	adds	r5, #1
  20bba6:	009a      	lsls	r2, r3, #2
  20bba8:	3a04      	subs	r2, #4
  20bbaa:	42ae      	cmp	r6, r5
  20bbac:	bf38      	it	cc
  20bbae:	2200      	movcc	r2, #0
  20bbb0:	18a3      	adds	r3, r4, r2
			if ((*x1 = y) !=0)
  20bbb2:	50a7      	str	r7, [r4, r2]
  20bbb4:	b107      	cbz	r7, 20bbb8 <rshift+0x66>
				x1++;
  20bbb6:	3304      	adds	r3, #4
				*x1++ = *x++;
		}
	if ((b->_wds = x1 - b->_x) == 0)
  20bbb8:	1b1a      	subs	r2, r3, r4
  20bbba:	42a3      	cmp	r3, r4
  20bbbc:	ea4f 02a2 	mov.w	r2, r2, asr #2
		b->_x[0] = 0;
  20bbc0:	bf08      	it	eq
  20bbc2:	2300      	moveq	r3, #0
	if ((b->_wds = x1 - b->_x) == 0)
  20bbc4:	6102      	str	r2, [r0, #16]
		b->_x[0] = 0;
  20bbc6:	bf08      	it	eq
  20bbc8:	6143      	streq	r3, [r0, #20]
}
  20bbca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
				*x1++ = (y | (*x << n)) & ALL_ON;
  20bbce:	f8dc c000 	ldr.w	ip, [ip]
  20bbd2:	fa0c fc08 	lsl.w	ip, ip, r8
  20bbd6:	ea4c 0707 	orr.w	r7, ip, r7
  20bbda:	f849 7b04 	str.w	r7, [r9], #4
				y = *x++ >> k;
  20bbde:	f85e 7b04 	ldr.w	r7, [lr], #4
  20bbe2:	40cf      	lsrs	r7, r1
  20bbe4:	e7da      	b.n	20bb9c <rshift+0x4a>
				*x1++ = *x++;
  20bbe6:	f851 cb04 	ldr.w	ip, [r1], #4
  20bbea:	f847 cf04 	str.w	ip, [r7, #4]!
  20bbee:	e7c3      	b.n	20bb78 <rshift+0x26>
	x = x1 = b->_x;
  20bbf0:	4623      	mov	r3, r4
  20bbf2:	e7e1      	b.n	20bbb8 <rshift+0x66>

0020bbf4 <__hexdig_fun>:
	if(c>='0' && c<='9') return c-'0'+0x10;
  20bbf4:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
  20bbf8:	2b09      	cmp	r3, #9
  20bbfa:	d802      	bhi.n	20bc02 <__hexdig_fun+0xe>
  20bbfc:	3820      	subs	r0, #32
	else if(c>='a' && c<='f') return c-'a'+0x10+10;
  20bbfe:	b2c0      	uxtb	r0, r0
  20bc00:	4770      	bx	lr
  20bc02:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
  20bc06:	2b05      	cmp	r3, #5
  20bc08:	d801      	bhi.n	20bc0e <__hexdig_fun+0x1a>
  20bc0a:	3847      	subs	r0, #71	; 0x47
  20bc0c:	e7f7      	b.n	20bbfe <__hexdig_fun+0xa>
	else if(c>='A' && c<='F') return c-'A'+0x10+10;
  20bc0e:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
  20bc12:	2b05      	cmp	r3, #5
  20bc14:	d801      	bhi.n	20bc1a <__hexdig_fun+0x26>
  20bc16:	3827      	subs	r0, #39	; 0x27
  20bc18:	e7f1      	b.n	20bbfe <__hexdig_fun+0xa>
	else return 0;
  20bc1a:	2000      	movs	r0, #0
}
  20bc1c:	4770      	bx	lr
	...

0020bc20 <__gethex>:


int
gethex (struct _reent *ptr, const char **sp, const FPI *fpi,
	Long *exp, _Bigint **bp, int sign, locale_t loc)
{
  20bc20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  20bc24:	ed2d 8b02 	vpush	{d8}
  20bc28:	b089      	sub	sp, #36	; 0x24
  20bc2a:	ee08 0a10 	vmov	s16, r0
  20bc2e:	468b      	mov	fp, r1
  20bc30:	4690      	mov	r8, r2
  20bc32:	9304      	str	r3, [sp, #16]
	_Bigint *b;
	const unsigned char *decpt, *s0, *s, *s1;
	int esign, havedig, irv, k, n, nbits, up, zret;
	__ULong L, lostbits, *x;
	Long e, e1;
	const unsigned char *decimalpoint = (unsigned char *)
  20bc34:	4bbb      	ldr	r3, [pc, #748]	; (20bf24 <__gethex+0x304>)
  20bc36:	681b      	ldr	r3, [r3, #0]
				      __get_numeric_locale(loc)->decimal_point;
	size_t decp_len = strlen ((const char *) decimalpoint);
  20bc38:	4618      	mov	r0, r3
	const unsigned char *decimalpoint = (unsigned char *)
  20bc3a:	9301      	str	r3, [sp, #4]
	size_t decp_len = strlen ((const char *) decimalpoint);
  20bc3c:	f7f4 fbab 	bl	200396 <strlen>
	unsigned char decp_end = decimalpoint[decp_len - 1];
  20bc40:	9b01      	ldr	r3, [sp, #4]

	havedig = 0;
	s0 = *(const unsigned char **)sp + 2;
  20bc42:	f8db 2000 	ldr.w	r2, [fp]
	size_t decp_len = strlen ((const char *) decimalpoint);
  20bc46:	4682      	mov	sl, r0
	unsigned char decp_end = decimalpoint[decp_len - 1];
  20bc48:	4403      	add	r3, r0
  20bc4a:	f813 3c01 	ldrb.w	r3, [r3, #-1]
  20bc4e:	9305      	str	r3, [sp, #20]
	while(s0[havedig] == '0')
  20bc50:	1c93      	adds	r3, r2, #2
  20bc52:	f1c2 22ff 	rsb	r2, r2, #4278255360	; 0xff00ff00
  20bc56:	f502 027f 	add.w	r2, r2, #16711680	; 0xff0000
  20bc5a:	32fe      	adds	r2, #254	; 0xfe
  20bc5c:	18d1      	adds	r1, r2, r3
  20bc5e:	461f      	mov	r7, r3
  20bc60:	f813 0b01 	ldrb.w	r0, [r3], #1
  20bc64:	9100      	str	r1, [sp, #0]
  20bc66:	2830      	cmp	r0, #48	; 0x30
  20bc68:	d0f8      	beq.n	20bc5c <__gethex+0x3c>
	s0 += havedig;
	s = s0;
	decpt = 0;
	zret = 0;
	e = 0;
	if (!__get_hexdig(*s)) {
  20bc6a:	f7ff ffc3 	bl	20bbf4 <__hexdig_fun>
  20bc6e:	4604      	mov	r4, r0
  20bc70:	2800      	cmp	r0, #0
  20bc72:	d139      	bne.n	20bce8 <__gethex+0xc8>
		zret = 1;
		if (strncmp ((const char *) s, (const char *) decimalpoint,
  20bc74:	4652      	mov	r2, sl
  20bc76:	9901      	ldr	r1, [sp, #4]
  20bc78:	4638      	mov	r0, r7
  20bc7a:	f001 fa8c 	bl	20d196 <strncmp>
  20bc7e:	4605      	mov	r5, r0
  20bc80:	2800      	cmp	r0, #0
  20bc82:	d167      	bne.n	20bd54 <__gethex+0x134>
			     decp_len) != 0)
			goto pcheck;
		decpt = (s += decp_len);
		if (!__get_hexdig(*s))
  20bc84:	f817 000a 	ldrb.w	r0, [r7, sl]
		decpt = (s += decp_len);
  20bc88:	eb07 060a 	add.w	r6, r7, sl
		if (!__get_hexdig(*s))
  20bc8c:	f7ff ffb2 	bl	20bbf4 <__hexdig_fun>
  20bc90:	2800      	cmp	r0, #0
  20bc92:	d061      	beq.n	20bd58 <__gethex+0x138>
  20bc94:	4633      	mov	r3, r6
			goto pcheck;
		while(*s == '0')
  20bc96:	7818      	ldrb	r0, [r3, #0]
  20bc98:	461f      	mov	r7, r3
  20bc9a:	3301      	adds	r3, #1
  20bc9c:	2830      	cmp	r0, #48	; 0x30
  20bc9e:	d0fa      	beq.n	20bc96 <__gethex+0x76>
			s++;
		if (__get_hexdig(*s))
  20bca0:	f7ff ffa8 	bl	20bbf4 <__hexdig_fun>
  20bca4:	fab0 f480 	clz	r4, r0
			zret = 0;
		havedig = 1;
  20bca8:	2301      	movs	r3, #1
  20bcaa:	4635      	mov	r5, r6
		if (__get_hexdig(*s))
  20bcac:	0964      	lsrs	r4, r4, #5
		havedig = 1;
  20bcae:	9300      	str	r3, [sp, #0]
  20bcb0:	463a      	mov	r2, r7
  20bcb2:	4616      	mov	r6, r2
  20bcb4:	3201      	adds	r2, #1
		s0 = s;
		}
	while(__get_hexdig(*s))
  20bcb6:	7830      	ldrb	r0, [r6, #0]
  20bcb8:	f7ff ff9c 	bl	20bbf4 <__hexdig_fun>
  20bcbc:	2800      	cmp	r0, #0
  20bcbe:	d1f8      	bne.n	20bcb2 <__gethex+0x92>
		s++;
	if (strncmp ((const char *) s, (const char *) decimalpoint,
  20bcc0:	4652      	mov	r2, sl
  20bcc2:	9901      	ldr	r1, [sp, #4]
  20bcc4:	4630      	mov	r0, r6
  20bcc6:	f001 fa66 	bl	20d196 <strncmp>
  20bcca:	b980      	cbnz	r0, 20bcee <__gethex+0xce>
		     decp_len) == 0
	    && !decpt) {
  20bccc:	b94d      	cbnz	r5, 20bce2 <__gethex+0xc2>
		decpt = (s += decp_len);
  20bcce:	eb06 050a 	add.w	r5, r6, sl
		while(__get_hexdig(*s))
  20bcd2:	462a      	mov	r2, r5
  20bcd4:	4616      	mov	r6, r2
  20bcd6:	3201      	adds	r2, #1
  20bcd8:	7830      	ldrb	r0, [r6, #0]
  20bcda:	f7ff ff8b 	bl	20bbf4 <__hexdig_fun>
  20bcde:	2800      	cmp	r0, #0
  20bce0:	d1f8      	bne.n	20bcd4 <__gethex+0xb4>
			s++;
		}
	if (decpt)
		e = -(((Long)(s-decpt)) << 2);
  20bce2:	1bad      	subs	r5, r5, r6
  20bce4:	00ad      	lsls	r5, r5, #2
  20bce6:	e004      	b.n	20bcf2 <__gethex+0xd2>
	zret = 0;
  20bce8:	2400      	movs	r4, #0
	decpt = 0;
  20bcea:	4625      	mov	r5, r4
  20bcec:	e7e0      	b.n	20bcb0 <__gethex+0x90>
	if (decpt)
  20bcee:	2d00      	cmp	r5, #0
  20bcf0:	d1f7      	bne.n	20bce2 <__gethex+0xc2>
 pcheck:
	s1 = s;
	switch(*s) {
  20bcf2:	7833      	ldrb	r3, [r6, #0]
  20bcf4:	f003 03df 	and.w	r3, r3, #223	; 0xdf
  20bcf8:	2b50      	cmp	r3, #80	; 0x50
  20bcfa:	d13b      	bne.n	20bd74 <__gethex+0x154>
	  case 'p':
	  case 'P':
		esign = 0;
		switch(*++s) {
  20bcfc:	7873      	ldrb	r3, [r6, #1]
  20bcfe:	2b2b      	cmp	r3, #43	; 0x2b
  20bd00:	d02c      	beq.n	20bd5c <__gethex+0x13c>
  20bd02:	2b2d      	cmp	r3, #45	; 0x2d
  20bd04:	d02e      	beq.n	20bd64 <__gethex+0x144>
  20bd06:	1c71      	adds	r1, r6, #1
		esign = 0;
  20bd08:	f04f 0900 	mov.w	r9, #0
			esign = 1;
			/* no break */
		  case '+':
			s++;
		  }
		if ((n = __get_hexdig(*s)) == 0 || n > 0x19) {
  20bd0c:	7808      	ldrb	r0, [r1, #0]
  20bd0e:	f7ff ff71 	bl	20bbf4 <__hexdig_fun>
  20bd12:	1e43      	subs	r3, r0, #1
  20bd14:	b2db      	uxtb	r3, r3
  20bd16:	2b18      	cmp	r3, #24
  20bd18:	d82c      	bhi.n	20bd74 <__gethex+0x154>
			s = s1;
			break;
			}
		e1 = n - 0x10;
  20bd1a:	f1a0 0210 	sub.w	r2, r0, #16
		while((n = __get_hexdig(*++s)) !=0 && n <= 0x19)
  20bd1e:	f811 0f01 	ldrb.w	r0, [r1, #1]!
  20bd22:	f7ff ff67 	bl	20bbf4 <__hexdig_fun>
  20bd26:	1e43      	subs	r3, r0, #1
  20bd28:	b2db      	uxtb	r3, r3
  20bd2a:	2b18      	cmp	r3, #24
  20bd2c:	d91d      	bls.n	20bd6a <__gethex+0x14a>
			e1 = 10*e1 + n - 0x10;
		if (esign)
  20bd2e:	f1b9 0f00 	cmp.w	r9, #0
  20bd32:	d000      	beq.n	20bd36 <__gethex+0x116>
			e1 = -e1;
  20bd34:	4252      	negs	r2, r2
		e += e1;
  20bd36:	4415      	add	r5, r2
	  }
	*sp = (char*)s;
  20bd38:	f8cb 1000 	str.w	r1, [fp]
	if (zret)
  20bd3c:	b1e4      	cbz	r4, 20bd78 <__gethex+0x158>
		return havedig ? STRTOG_Zero : STRTOG_NoNumber;
  20bd3e:	9b00      	ldr	r3, [sp, #0]
  20bd40:	2b00      	cmp	r3, #0
  20bd42:	bf14      	ite	ne
  20bd44:	2700      	movne	r7, #0
  20bd46:	2706      	moveq	r7, #6
			irv |= STRTOG_Inexlo;
		}
	*bp = b;
	*exp = e;
	return irv;
}
  20bd48:	4638      	mov	r0, r7
  20bd4a:	b009      	add	sp, #36	; 0x24
  20bd4c:	ecbd 8b02 	vpop	{d8}
  20bd50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while(s0[havedig] == '0')
  20bd54:	463e      	mov	r6, r7
	e = 0;
  20bd56:	4625      	mov	r5, r4
		zret = 1;
  20bd58:	2401      	movs	r4, #1
  20bd5a:	e7ca      	b.n	20bcf2 <__gethex+0xd2>
		esign = 0;
  20bd5c:	f04f 0900 	mov.w	r9, #0
			s++;
  20bd60:	1cb1      	adds	r1, r6, #2
  20bd62:	e7d3      	b.n	20bd0c <__gethex+0xec>
  20bd64:	f04f 0901 	mov.w	r9, #1
  20bd68:	e7fa      	b.n	20bd60 <__gethex+0x140>
			e1 = 10*e1 + n - 0x10;
  20bd6a:	230a      	movs	r3, #10
  20bd6c:	fb03 0202 	mla	r2, r3, r2, r0
  20bd70:	3a10      	subs	r2, #16
  20bd72:	e7d4      	b.n	20bd1e <__gethex+0xfe>
  20bd74:	4631      	mov	r1, r6
  20bd76:	e7df      	b.n	20bd38 <__gethex+0x118>
	n = s1 - s0 - 1;
  20bd78:	1bf3      	subs	r3, r6, r7
	for(k = 0; n > 7; n >>= 1)
  20bd7a:	4621      	mov	r1, r4
	n = s1 - s0 - 1;
  20bd7c:	3b01      	subs	r3, #1
	for(k = 0; n > 7; n >>= 1)
  20bd7e:	2b07      	cmp	r3, #7
  20bd80:	dc52      	bgt.n	20be28 <__gethex+0x208>
	b = Balloc(ptr, k);
  20bd82:	ee18 0a10 	vmov	r0, s16
	n = 0;
  20bd86:	f04f 0b00 	mov.w	fp, #0
	b = Balloc(ptr, k);
  20bd8a:	f000 fa7a 	bl	20c282 <_Balloc>
		if (*--s1 == decp_end && s1 - decp_len + 1 >= s0
  20bd8e:	f1ca 0301 	rsb	r3, sl, #1
	x = b->_x;
  20bd92:	f100 0914 	add.w	r9, r0, #20
	b = Balloc(ptr, k);
  20bd96:	4604      	mov	r4, r0
	L = 0;
  20bd98:	f8cd b000 	str.w	fp, [sp]
	x = b->_x;
  20bd9c:	f8cd 9008 	str.w	r9, [sp, #8]
		if (*--s1 == decp_end && s1 - decp_len + 1 >= s0
  20bda0:	9306      	str	r3, [sp, #24]
	while(s1 > s0) {
  20bda2:	42b7      	cmp	r7, r6
  20bda4:	d343      	bcc.n	20be2e <__gethex+0x20e>
	*x++ = L;
  20bda6:	9802      	ldr	r0, [sp, #8]
  20bda8:	9b00      	ldr	r3, [sp, #0]
  20bdaa:	f840 3b04 	str.w	r3, [r0], #4
	b->_wds = n = x - b->_x;
  20bdae:	eba0 0009 	sub.w	r0, r0, r9
  20bdb2:	1080      	asrs	r0, r0, #2
	n = 32*n - hi0bits(L);
  20bdb4:	0146      	lsls	r6, r0, #5
	b->_wds = n = x - b->_x;
  20bdb6:	6120      	str	r0, [r4, #16]
	n = 32*n - hi0bits(L);
  20bdb8:	4618      	mov	r0, r3
  20bdba:	f000 fb2a 	bl	20c412 <__hi0bits>
  20bdbe:	1a30      	subs	r0, r6, r0
	nbits = fpi->nbits;
  20bdc0:	f8d8 6000 	ldr.w	r6, [r8]
	if (n > nbits) {
  20bdc4:	42b0      	cmp	r0, r6
  20bdc6:	dd66      	ble.n	20be96 <__gethex+0x276>
		n -= nbits;
  20bdc8:	1b87      	subs	r7, r0, r6
		if (any_on(b,n)) {
  20bdca:	4620      	mov	r0, r4
  20bdcc:	4639      	mov	r1, r7
  20bdce:	f000 fe78 	bl	20cac2 <__any_on>
  20bdd2:	4682      	mov	sl, r0
  20bdd4:	b1a8      	cbz	r0, 20be02 <__gethex+0x1e2>
			k = n - 1;
  20bdd6:	1e7b      	subs	r3, r7, #1
			if (x[k>>kshift] & 1 << (k & kmask)) {
  20bdd8:	f04f 0a01 	mov.w	sl, #1
  20bddc:	1159      	asrs	r1, r3, #5
  20bdde:	f003 021f 	and.w	r2, r3, #31
  20bde2:	f859 1021 	ldr.w	r1, [r9, r1, lsl #2]
  20bde6:	fa0a f202 	lsl.w	r2, sl, r2
  20bdea:	420a      	tst	r2, r1
  20bdec:	d009      	beq.n	20be02 <__gethex+0x1e2>
				if (k > 1 && any_on(b,k-1))
  20bdee:	4553      	cmp	r3, sl
  20bdf0:	dd05      	ble.n	20bdfe <__gethex+0x1de>
  20bdf2:	1eb9      	subs	r1, r7, #2
  20bdf4:	4620      	mov	r0, r4
  20bdf6:	f000 fe64 	bl	20cac2 <__any_on>
  20bdfa:	2800      	cmp	r0, #0
  20bdfc:	d148      	bne.n	20be90 <__gethex+0x270>
				lostbits = 2;
  20bdfe:	f04f 0a02 	mov.w	sl, #2
		e += n;
  20be02:	443d      	add	r5, r7
		rshift(b, n);
  20be04:	4639      	mov	r1, r7
  20be06:	4620      	mov	r0, r4
  20be08:	f7ff fea3 	bl	20bb52 <rshift>
	if (e > fpi->emax) {
  20be0c:	f8d8 3008 	ldr.w	r3, [r8, #8]
  20be10:	42ab      	cmp	r3, r5
  20be12:	da4f      	bge.n	20beb4 <__gethex+0x294>
		Bfree(ptr, b);
  20be14:	4621      	mov	r1, r4
  20be16:	ee18 0a10 	vmov	r0, s16
  20be1a:	f000 fa66 	bl	20c2ea <_Bfree>
		*bp = 0;
  20be1e:	2300      	movs	r3, #0
  20be20:	9a14      	ldr	r2, [sp, #80]	; 0x50
		return STRTOG_Infinite | STRTOG_Overflow | STRTOG_Inexhi;
  20be22:	27a3      	movs	r7, #163	; 0xa3
		*bp = 0;
  20be24:	6013      	str	r3, [r2, #0]
		return STRTOG_Infinite | STRTOG_Overflow | STRTOG_Inexhi;
  20be26:	e78f      	b.n	20bd48 <__gethex+0x128>
		k++;
  20be28:	3101      	adds	r1, #1
	for(k = 0; n > 7; n >>= 1)
  20be2a:	105b      	asrs	r3, r3, #1
  20be2c:	e7a7      	b.n	20bd7e <__gethex+0x15e>
		if (*--s1 == decp_end && s1 - decp_len + 1 >= s0
  20be2e:	1e73      	subs	r3, r6, #1
  20be30:	9a05      	ldr	r2, [sp, #20]
  20be32:	9303      	str	r3, [sp, #12]
  20be34:	f816 3c01 	ldrb.w	r3, [r6, #-1]
  20be38:	4293      	cmp	r3, r2
  20be3a:	d019      	beq.n	20be70 <__gethex+0x250>
		if (n == 32) {
  20be3c:	f1bb 0f20 	cmp.w	fp, #32
  20be40:	d107      	bne.n	20be52 <__gethex+0x232>
  20be42:	9b02      	ldr	r3, [sp, #8]
			*x++ = L;
  20be44:	9a00      	ldr	r2, [sp, #0]
  20be46:	f843 2b04 	str.w	r2, [r3], #4
  20be4a:	9302      	str	r3, [sp, #8]
			n = 0;
  20be4c:	2300      	movs	r3, #0
			L = 0;
  20be4e:	469b      	mov	fp, r3
			n = 0;
  20be50:	9300      	str	r3, [sp, #0]
		L |= (__get_hexdig(*s1) & 0x0f) << n;
  20be52:	f816 0c01 	ldrb.w	r0, [r6, #-1]
  20be56:	f7ff fecd 	bl	20bbf4 <__hexdig_fun>
  20be5a:	f000 000f 	and.w	r0, r0, #15
  20be5e:	9b00      	ldr	r3, [sp, #0]
  20be60:	fa00 f00b 	lsl.w	r0, r0, fp
		n += 4;
  20be64:	f10b 0b04 	add.w	fp, fp, #4
		L |= (__get_hexdig(*s1) & 0x0f) << n;
  20be68:	4303      	orrs	r3, r0
  20be6a:	9300      	str	r3, [sp, #0]
		if (*--s1 == decp_end && s1 - decp_len + 1 >= s0
  20be6c:	9b03      	ldr	r3, [sp, #12]
  20be6e:	e00d      	b.n	20be8c <__gethex+0x26c>
  20be70:	9b03      	ldr	r3, [sp, #12]
  20be72:	9a06      	ldr	r2, [sp, #24]
  20be74:	4413      	add	r3, r2
  20be76:	42bb      	cmp	r3, r7
  20be78:	d3e0      	bcc.n	20be3c <__gethex+0x21c>
		    && strncmp ((const char *) s1 - decp_len + 1,
  20be7a:	4618      	mov	r0, r3
  20be7c:	4652      	mov	r2, sl
  20be7e:	9901      	ldr	r1, [sp, #4]
  20be80:	9307      	str	r3, [sp, #28]
  20be82:	f001 f988 	bl	20d196 <strncmp>
  20be86:	9b07      	ldr	r3, [sp, #28]
  20be88:	2800      	cmp	r0, #0
  20be8a:	d1d7      	bne.n	20be3c <__gethex+0x21c>
		if (*--s1 == decp_end && s1 - decp_len + 1 >= s0
  20be8c:	461e      	mov	r6, r3
  20be8e:	e788      	b.n	20bda2 <__gethex+0x182>
					lostbits = 3;
  20be90:	f04f 0a03 	mov.w	sl, #3
  20be94:	e7b5      	b.n	20be02 <__gethex+0x1e2>
	else if (n < nbits) {
  20be96:	da0a      	bge.n	20beae <__gethex+0x28e>
		n = nbits - n;
  20be98:	1a37      	subs	r7, r6, r0
		b = lshift(ptr, b, n);
  20be9a:	4621      	mov	r1, r4
  20be9c:	ee18 0a10 	vmov	r0, s16
  20bea0:	463a      	mov	r2, r7
		e -= n;
  20bea2:	1bed      	subs	r5, r5, r7
		b = lshift(ptr, b, n);
  20bea4:	f000 fbf8 	bl	20c698 <__lshift>
  20bea8:	4604      	mov	r4, r0
		x = b->_x;
  20beaa:	f100 0914 	add.w	r9, r0, #20
	lostbits = 0;
  20beae:	f04f 0a00 	mov.w	sl, #0
  20beb2:	e7ab      	b.n	20be0c <__gethex+0x1ec>
	if (e < fpi->emin) {
  20beb4:	f8d8 0004 	ldr.w	r0, [r8, #4]
  20beb8:	42a8      	cmp	r0, r5
  20beba:	dd6f      	ble.n	20bf9c <__gethex+0x37c>
		n = fpi->emin - e;
  20bebc:	1b45      	subs	r5, r0, r5
		if (n >= nbits) {
  20bebe:	42ae      	cmp	r6, r5
  20bec0:	dc32      	bgt.n	20bf28 <__gethex+0x308>
			switch (fpi->rounding) {
  20bec2:	f8d8 300c 	ldr.w	r3, [r8, #12]
  20bec6:	2b02      	cmp	r3, #2
  20bec8:	d023      	beq.n	20bf12 <__gethex+0x2f2>
  20beca:	2b03      	cmp	r3, #3
  20becc:	d025      	beq.n	20bf1a <__gethex+0x2fa>
  20bece:	2b01      	cmp	r3, #1
  20bed0:	d115      	bne.n	20befe <__gethex+0x2de>
				if (n == nbits && (n < 2 || any_on(b,n-1)))
  20bed2:	42ae      	cmp	r6, r5
  20bed4:	d113      	bne.n	20befe <__gethex+0x2de>
  20bed6:	2e01      	cmp	r6, #1
  20bed8:	d10b      	bne.n	20bef2 <__gethex+0x2d2>
					*exp = fpi->emin;
  20beda:	f8d8 3004 	ldr.w	r3, [r8, #4]
					return STRTOG_Denormal | STRTOG_Inexhi
  20bede:	2762      	movs	r7, #98	; 0x62
					*exp = fpi->emin;
  20bee0:	9a04      	ldr	r2, [sp, #16]
  20bee2:	6013      	str	r3, [r2, #0]
					x[0] = b->_wds = 1;
  20bee4:	2301      	movs	r3, #1
  20bee6:	6123      	str	r3, [r4, #16]
  20bee8:	f8c9 3000 	str.w	r3, [r9]
					*bp = b;
  20beec:	9b14      	ldr	r3, [sp, #80]	; 0x50
  20beee:	601c      	str	r4, [r3, #0]
					return STRTOG_Denormal | STRTOG_Inexhi
  20bef0:	e72a      	b.n	20bd48 <__gethex+0x128>
				if (n == nbits && (n < 2 || any_on(b,n-1)))
  20bef2:	1e71      	subs	r1, r6, #1
  20bef4:	4620      	mov	r0, r4
  20bef6:	f000 fde4 	bl	20cac2 <__any_on>
  20befa:	2800      	cmp	r0, #0
  20befc:	d1ed      	bne.n	20beda <__gethex+0x2ba>
			Bfree(ptr, b);
  20befe:	4621      	mov	r1, r4
  20bf00:	ee18 0a10 	vmov	r0, s16
  20bf04:	f000 f9f1 	bl	20c2ea <_Bfree>
			*bp = 0;
  20bf08:	2300      	movs	r3, #0
  20bf0a:	9a14      	ldr	r2, [sp, #80]	; 0x50
			return STRTOG_Zero | STRTOG_Inexlo | STRTOG_Underflow;
  20bf0c:	2750      	movs	r7, #80	; 0x50
			*bp = 0;
  20bf0e:	6013      	str	r3, [r2, #0]
			return STRTOG_Zero | STRTOG_Inexlo | STRTOG_Underflow;
  20bf10:	e71a      	b.n	20bd48 <__gethex+0x128>
				if (!sign)
  20bf12:	9b15      	ldr	r3, [sp, #84]	; 0x54
  20bf14:	2b00      	cmp	r3, #0
  20bf16:	d1f2      	bne.n	20befe <__gethex+0x2de>
  20bf18:	e7df      	b.n	20beda <__gethex+0x2ba>
				if (sign) {
  20bf1a:	9b15      	ldr	r3, [sp, #84]	; 0x54
  20bf1c:	2b00      	cmp	r3, #0
  20bf1e:	d1dc      	bne.n	20beda <__gethex+0x2ba>
  20bf20:	e7ed      	b.n	20befe <__gethex+0x2de>
  20bf22:	bf00      	nop
  20bf24:	0800edb0 	.word	0x0800edb0
		k = n - 1;
  20bf28:	1e6f      	subs	r7, r5, #1
		if (lostbits)
  20bf2a:	f1ba 0f00 	cmp.w	sl, #0
  20bf2e:	d132      	bne.n	20bf96 <__gethex+0x376>
		else if (k > 0)
  20bf30:	b127      	cbz	r7, 20bf3c <__gethex+0x31c>
			lostbits = any_on(b,k);
  20bf32:	4639      	mov	r1, r7
  20bf34:	4620      	mov	r0, r4
  20bf36:	f000 fdc4 	bl	20cac2 <__any_on>
  20bf3a:	4682      	mov	sl, r0
		if (x[k>>kshift] & 1 << (k & kmask))
  20bf3c:	117b      	asrs	r3, r7, #5
  20bf3e:	2101      	movs	r1, #1
  20bf40:	f007 071f 	and.w	r7, r7, #31
		rshift(b,n);
  20bf44:	4620      	mov	r0, r4
		if (x[k>>kshift] & 1 << (k & kmask))
  20bf46:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
		nbits -= n;
  20bf4a:	1b76      	subs	r6, r6, r5
		if (x[k>>kshift] & 1 << (k & kmask))
  20bf4c:	fa01 f707 	lsl.w	r7, r1, r7
		rshift(b,n);
  20bf50:	4629      	mov	r1, r5
		if (x[k>>kshift] & 1 << (k & kmask))
  20bf52:	421f      	tst	r7, r3
		irv = STRTOG_Denormal;
  20bf54:	f04f 0702 	mov.w	r7, #2
			lostbits |= 2;
  20bf58:	bf18      	it	ne
  20bf5a:	f04a 0a02 	orrne.w	sl, sl, #2
		rshift(b,n);
  20bf5e:	f7ff fdf8 	bl	20bb52 <rshift>
		e = fpi->emin;
  20bf62:	f8d8 5004 	ldr.w	r5, [r8, #4]
	if (lostbits) {
  20bf66:	f1ba 0f00 	cmp.w	sl, #0
  20bf6a:	d048      	beq.n	20bffe <__gethex+0x3de>
		switch(fpi->rounding) {
  20bf6c:	f8d8 300c 	ldr.w	r3, [r8, #12]
  20bf70:	2b02      	cmp	r3, #2
  20bf72:	d015      	beq.n	20bfa0 <__gethex+0x380>
  20bf74:	2b03      	cmp	r3, #3
  20bf76:	d017      	beq.n	20bfa8 <__gethex+0x388>
  20bf78:	2b01      	cmp	r3, #1
  20bf7a:	d109      	bne.n	20bf90 <__gethex+0x370>
		    if ((lostbits & 2)
  20bf7c:	f01a 0f02 	tst.w	sl, #2
  20bf80:	d006      	beq.n	20bf90 <__gethex+0x370>
			    && ((lostbits & 1) | (x[0] & 1)))
  20bf82:	f8d9 0000 	ldr.w	r0, [r9]
  20bf86:	ea4a 0a00 	orr.w	sl, sl, r0
  20bf8a:	f01a 0f01 	tst.w	sl, #1
  20bf8e:	d10e      	bne.n	20bfae <__gethex+0x38e>
			irv |= STRTOG_Inexlo;
  20bf90:	f047 0710 	orr.w	r7, r7, #16
  20bf94:	e033      	b.n	20bffe <__gethex+0x3de>
			lostbits = 1;
  20bf96:	f04f 0a01 	mov.w	sl, #1
  20bf9a:	e7cf      	b.n	20bf3c <__gethex+0x31c>
	irv = STRTOG_Normal;
  20bf9c:	2701      	movs	r7, #1
  20bf9e:	e7e2      	b.n	20bf66 <__gethex+0x346>
			up = 1 - sign;
  20bfa0:	9b15      	ldr	r3, [sp, #84]	; 0x54
  20bfa2:	f1c3 0301 	rsb	r3, r3, #1
  20bfa6:	9315      	str	r3, [sp, #84]	; 0x54
		if (up) {
  20bfa8:	9b15      	ldr	r3, [sp, #84]	; 0x54
  20bfaa:	2b00      	cmp	r3, #0
  20bfac:	d0f0      	beq.n	20bf90 <__gethex+0x370>
			k = b->_wds;
  20bfae:	f8d4 9010 	ldr.w	r9, [r4, #16]
	x = b->_x;
  20bfb2:	f104 0314 	add.w	r3, r4, #20
		*x++ = 0;
  20bfb6:	f04f 0c00 	mov.w	ip, #0
	xe = x + b->_wds;
  20bfba:	ea4f 0b89 	mov.w	fp, r9, lsl #2
  20bfbe:	eb03 0189 	add.w	r1, r3, r9, lsl #2
  20bfc2:	4618      	mov	r0, r3
		if (*x < (__ULong)0xffffffffL) {
  20bfc4:	f853 2b04 	ldr.w	r2, [r3], #4
  20bfc8:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
  20bfcc:	d01c      	beq.n	20c008 <__gethex+0x3e8>
			++*x;
  20bfce:	3201      	adds	r2, #1
  20bfd0:	6002      	str	r2, [r0, #0]
			if (irv == STRTOG_Denormal) {
  20bfd2:	2f02      	cmp	r7, #2
			x = b->_x;
  20bfd4:	f104 0314 	add.w	r3, r4, #20
			if (irv == STRTOG_Denormal) {
  20bfd8:	d13a      	bne.n	20c050 <__gethex+0x430>
				if (nbits == fpi->nbits - 1
  20bfda:	f8d8 2000 	ldr.w	r2, [r8]
  20bfde:	3a01      	subs	r2, #1
  20bfe0:	42b2      	cmp	r2, r6
  20bfe2:	d10a      	bne.n	20bffa <__gethex+0x3da>
				 && x[nbits >> kshift] & 1 << (nbits & kmask))
  20bfe4:	1171      	asrs	r1, r6, #5
  20bfe6:	2201      	movs	r2, #1
  20bfe8:	f006 061f 	and.w	r6, r6, #31
  20bfec:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
  20bff0:	fa02 f606 	lsl.w	r6, r2, r6
					irv =  STRTOG_Normal;
  20bff4:	421e      	tst	r6, r3
  20bff6:	bf18      	it	ne
  20bff8:	4617      	movne	r7, r2
			irv |= STRTOG_Inexhi;
  20bffa:	f047 0720 	orr.w	r7, r7, #32
	*bp = b;
  20bffe:	9b14      	ldr	r3, [sp, #80]	; 0x50
  20c000:	601c      	str	r4, [r3, #0]
	*exp = e;
  20c002:	9b04      	ldr	r3, [sp, #16]
  20c004:	601d      	str	r5, [r3, #0]
	return irv;
  20c006:	e69f      	b.n	20bd48 <__gethex+0x128>
		} while(x < xe);
  20c008:	4299      	cmp	r1, r3
		*x++ = 0;
  20c00a:	f843 cc04 	str.w	ip, [r3, #-4]
		} while(x < xe);
  20c00e:	d8d8      	bhi.n	20bfc2 <__gethex+0x3a2>
		if (b->_wds >= b->_maxwds) {
  20c010:	68a3      	ldr	r3, [r4, #8]
  20c012:	4599      	cmp	r9, r3
  20c014:	db14      	blt.n	20c040 <__gethex+0x420>
			b1 = Balloc(ptr, b->_k+1);
  20c016:	6861      	ldr	r1, [r4, #4]
  20c018:	ee18 0a10 	vmov	r0, s16
  20c01c:	3101      	adds	r1, #1
  20c01e:	f000 f930 	bl	20c282 <_Balloc>
			Bcopy(b1, b);
  20c022:	6922      	ldr	r2, [r4, #16]
			b1 = Balloc(ptr, b->_k+1);
  20c024:	4682      	mov	sl, r0
			Bcopy(b1, b);
  20c026:	f104 010c 	add.w	r1, r4, #12
  20c02a:	3202      	adds	r2, #2
  20c02c:	300c      	adds	r0, #12
  20c02e:	0092      	lsls	r2, r2, #2
  20c030:	f000 f912 	bl	20c258 <memcpy>
			Bfree(ptr, b);
  20c034:	4621      	mov	r1, r4
			b = b1;
  20c036:	4654      	mov	r4, sl
			Bfree(ptr, b);
  20c038:	ee18 0a10 	vmov	r0, s16
  20c03c:	f000 f955 	bl	20c2ea <_Bfree>
		b->_x[b->_wds++] = 1;
  20c040:	6923      	ldr	r3, [r4, #16]
  20c042:	1c5a      	adds	r2, r3, #1
  20c044:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  20c048:	6122      	str	r2, [r4, #16]
  20c04a:	2201      	movs	r2, #1
  20c04c:	615a      	str	r2, [r3, #20]
	return b;
  20c04e:	e7c0      	b.n	20bfd2 <__gethex+0x3b2>
			else if ((b->_wds > k)
  20c050:	6922      	ldr	r2, [r4, #16]
  20c052:	454a      	cmp	r2, r9
  20c054:	dd0b      	ble.n	20c06e <__gethex+0x44e>
				rshift(b,1);
  20c056:	2101      	movs	r1, #1
  20c058:	4620      	mov	r0, r4
  20c05a:	f7ff fd7a 	bl	20bb52 <rshift>
				if (++e > fpi->emax)
  20c05e:	3501      	adds	r5, #1
  20c060:	f8d8 3008 	ldr.w	r3, [r8, #8]
  20c064:	42ab      	cmp	r3, r5
  20c066:	f6ff aed5 	blt.w	20be14 <__gethex+0x1f4>
  20c06a:	2701      	movs	r7, #1
  20c06c:	e7c5      	b.n	20bffa <__gethex+0x3da>
			 || ((n = nbits & kmask) !=0
  20c06e:	f016 061f 	ands.w	r6, r6, #31
  20c072:	d0fa      	beq.n	20c06a <__gethex+0x44a>
			     && (hi0bits(x[k-1]) < 32-n))) {
  20c074:	449b      	add	fp, r3
  20c076:	f1c6 0620 	rsb	r6, r6, #32
  20c07a:	f85b 0c04 	ldr.w	r0, [fp, #-4]
  20c07e:	f000 f9c8 	bl	20c412 <__hi0bits>
  20c082:	42b0      	cmp	r0, r6
  20c084:	dbe7      	blt.n	20c056 <__gethex+0x436>
  20c086:	e7f0      	b.n	20c06a <__gethex+0x44a>

0020c088 <L_shift>:
	__ULong *x1,
	int i)
{
	int j;

	i = 8 - i;
  20c088:	f1c2 0208 	rsb	r2, r2, #8
	i <<= 2;
  20c08c:	0092      	lsls	r2, r2, #2
{
  20c08e:	b570      	push	{r4, r5, r6, lr}
	j = ULbits - i;
  20c090:	f1c2 0620 	rsb	r6, r2, #32
	do {
		*x |= x[1] << j;
  20c094:	6843      	ldr	r3, [r0, #4]
  20c096:	6804      	ldr	r4, [r0, #0]
  20c098:	fa03 f506 	lsl.w	r5, r3, r6
		x[1] >>= i;
  20c09c:	40d3      	lsrs	r3, r2
		*x |= x[1] << j;
  20c09e:	432c      	orrs	r4, r5
  20c0a0:	6004      	str	r4, [r0, #0]
		x[1] >>= i;
  20c0a2:	f840 3f04 	str.w	r3, [r0, #4]!
		} while(++x < x1);
  20c0a6:	4288      	cmp	r0, r1
  20c0a8:	d3f4      	bcc.n	20c094 <L_shift+0xc>
}
  20c0aa:	bd70      	pop	{r4, r5, r6, pc}

0020c0ac <__match>:
	while( (d = *t++) !=0) {
  20c0ac:	6803      	ldr	r3, [r0, #0]
  20c0ae:	3301      	adds	r3, #1
{
  20c0b0:	b530      	push	{r4, r5, lr}
	while( (d = *t++) !=0) {
  20c0b2:	f811 4b01 	ldrb.w	r4, [r1], #1
  20c0b6:	b914      	cbnz	r4, 20c0be <__match+0x12>
	*sp = s + 1;
  20c0b8:	6003      	str	r3, [r0, #0]
	return 1;
  20c0ba:	2001      	movs	r0, #1
}
  20c0bc:	bd30      	pop	{r4, r5, pc}
		if ((c = *++s) >= 'A' && c <= 'Z')
  20c0be:	f813 2b01 	ldrb.w	r2, [r3], #1
  20c0c2:	f1a2 0541 	sub.w	r5, r2, #65	; 0x41
  20c0c6:	2d19      	cmp	r5, #25
			c += 'a' - 'A';
  20c0c8:	bf98      	it	ls
  20c0ca:	3220      	addls	r2, #32
		if (c != d)
  20c0cc:	42a2      	cmp	r2, r4
  20c0ce:	d0f0      	beq.n	20c0b2 <__match+0x6>
			return 0;
  20c0d0:	2000      	movs	r0, #0
  20c0d2:	e7f3      	b.n	20c0bc <__match+0x10>

0020c0d4 <__hexnan>:
{
	__ULong c, h, *x, *x1, *xe;
	const char *s;
	int havedig, hd0, i, nbits;

	nbits = fpi->nbits;
  20c0d4:	680b      	ldr	r3, [r1, #0]
	if (nbits & kmask)
		x++;
	*--x = 0;
	x1 = xe = x;
	havedig = hd0 = i = 0;
	s = *sp;
  20c0d6:	6801      	ldr	r1, [r0, #0]
{
  20c0d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	x = x0 + (nbits >> kshift);
  20c0dc:	115e      	asrs	r6, r3, #5
	if (nbits & kmask)
  20c0de:	f013 031f 	ands.w	r3, r3, #31
	*--x = 0;
  20c0e2:	f04f 0500 	mov.w	r5, #0
{
  20c0e6:	b087      	sub	sp, #28
	x = x0 + (nbits >> kshift);
  20c0e8:	eb02 0686 	add.w	r6, r2, r6, lsl #2
{
  20c0ec:	4682      	mov	sl, r0
  20c0ee:	4690      	mov	r8, r2
	havedig = hd0 = i = 0;
  20c0f0:	46ab      	mov	fp, r5
		x++;
  20c0f2:	bf18      	it	ne
  20c0f4:	3604      	addne	r6, #4
	if (nbits & kmask)
  20c0f6:	9301      	str	r3, [sp, #4]
	havedig = hd0 = i = 0;
  20c0f8:	9502      	str	r5, [sp, #8]
	*--x = 0;
  20c0fa:	1f37      	subs	r7, r6, #4
  20c0fc:	f846 5c04 	str.w	r5, [r6, #-4]
  20c100:	46b9      	mov	r9, r7
  20c102:	463c      	mov	r4, r7
	while((c = *(const unsigned char*)++s)) {
  20c104:	1c4b      	adds	r3, r1, #1
  20c106:	784a      	ldrb	r2, [r1, #1]
  20c108:	9303      	str	r3, [sp, #12]
  20c10a:	b342      	cbz	r2, 20c15e <__hexnan+0x8a>
		if (!(h = __get_hexdig(c))) {
  20c10c:	4610      	mov	r0, r2
  20c10e:	9105      	str	r1, [sp, #20]
  20c110:	9204      	str	r2, [sp, #16]
  20c112:	f7ff fd6f 	bl	20bbf4 <__hexdig_fun>
  20c116:	2800      	cmp	r0, #0
  20c118:	d14f      	bne.n	20c1ba <__hexnan+0xe6>
			if (c <= ' ') {
  20c11a:	9a04      	ldr	r2, [sp, #16]
  20c11c:	9905      	ldr	r1, [sp, #20]
  20c11e:	2a20      	cmp	r2, #32
  20c120:	d818      	bhi.n	20c154 <__hexnan+0x80>
				if (hd0 < havedig) {
  20c122:	9b02      	ldr	r3, [sp, #8]
  20c124:	459b      	cmp	fp, r3
  20c126:	dd13      	ble.n	20c150 <__hexnan+0x7c>
					if (x < x1 && i < 8)
  20c128:	454c      	cmp	r4, r9
  20c12a:	d206      	bcs.n	20c13a <__hexnan+0x66>
  20c12c:	2d07      	cmp	r5, #7
  20c12e:	dc04      	bgt.n	20c13a <__hexnan+0x66>
						L_shift(x, x1, i);
  20c130:	462a      	mov	r2, r5
  20c132:	4649      	mov	r1, r9
  20c134:	4620      	mov	r0, r4
  20c136:	f7ff ffa7 	bl	20c088 <L_shift>
					if (x <= x0) {
  20c13a:	4544      	cmp	r4, r8
  20c13c:	d94f      	bls.n	20c1de <__hexnan+0x10a>
						i = 8;
						continue;
						}
					hd0 = havedig;
					*--x = 0;
  20c13e:	2300      	movs	r3, #0
  20c140:	f1a4 0904 	sub.w	r9, r4, #4
  20c144:	f8cd b008 	str.w	fp, [sp, #8]
  20c148:	f844 3c04 	str.w	r3, [r4, #-4]
					x1 = x;
					i = 0;
  20c14c:	461d      	mov	r5, r3
					*--x = 0;
  20c14e:	464c      	mov	r4, r9
						i = 8;
  20c150:	9903      	ldr	r1, [sp, #12]
  20c152:	e7d7      	b.n	20c104 <__hexnan+0x30>
					}
				continue;
				}
			if (/*(*/ c == ')') {
  20c154:	2a29      	cmp	r2, #41	; 0x29
  20c156:	d155      	bne.n	20c204 <__hexnan+0x130>
				*sp = s + 1;
  20c158:	3102      	adds	r1, #2
  20c15a:	f8ca 1000 	str.w	r1, [sl]
			i = 1;
			*--x = 0;
			}
		*x = ((*x << 4) | (h & 0xf));
		}
	if (!havedig)
  20c15e:	f1bb 0f00 	cmp.w	fp, #0
  20c162:	d04f      	beq.n	20c204 <__hexnan+0x130>
		return STRTOG_NaN;
	if (x < x1 && i < 8)
  20c164:	454c      	cmp	r4, r9
  20c166:	d206      	bcs.n	20c176 <__hexnan+0xa2>
  20c168:	2d07      	cmp	r5, #7
  20c16a:	dc04      	bgt.n	20c176 <__hexnan+0xa2>
		L_shift(x, x1, i);
  20c16c:	462a      	mov	r2, r5
  20c16e:	4649      	mov	r1, r9
  20c170:	4620      	mov	r0, r4
  20c172:	f7ff ff89 	bl	20c088 <L_shift>
	if (x > x0) {
  20c176:	4544      	cmp	r4, r8
  20c178:	d933      	bls.n	20c1e2 <__hexnan+0x10e>
  20c17a:	f1a8 0204 	sub.w	r2, r8, #4
  20c17e:	4623      	mov	r3, r4
		x1 = x0;
		do *x1++ = *x++;
  20c180:	f853 1b04 	ldr.w	r1, [r3], #4
			while(x <= xe);
  20c184:	429f      	cmp	r7, r3
		do *x1++ = *x++;
  20c186:	f842 1f04 	str.w	r1, [r2, #4]!
			while(x <= xe);
  20c18a:	d2f9      	bcs.n	20c180 <__hexnan+0xac>
  20c18c:	1b3b      	subs	r3, r7, r4
  20c18e:	3e03      	subs	r6, #3
  20c190:	3401      	adds	r4, #1
		do *x1++ = 0;
  20c192:	2200      	movs	r2, #0
  20c194:	f023 0303 	bic.w	r3, r3, #3
  20c198:	3304      	adds	r3, #4
  20c19a:	42b4      	cmp	r4, r6
  20c19c:	bf88      	it	hi
  20c19e:	2304      	movhi	r3, #4
  20c1a0:	4443      	add	r3, r8
  20c1a2:	f843 2b04 	str.w	r2, [r3], #4
			while(x1 <= xe);
  20c1a6:	429f      	cmp	r7, r3
  20c1a8:	d2fb      	bcs.n	20c1a2 <__hexnan+0xce>
		/* truncate high-order word if necessary */
		if ( (i = nbits & (ULbits-1)) !=0)
			*xe &= ((__ULong)0xffffffff) >> (ULbits - i);
		}
	for(x1 = xe;; --x1) {
		if (*x1 != 0)
  20c1aa:	683b      	ldr	r3, [r7, #0]
  20c1ac:	b91b      	cbnz	r3, 20c1b6 <__hexnan+0xe2>
			break;
		if (x1 == x0) {
  20c1ae:	4547      	cmp	r7, r8
  20c1b0:	d126      	bne.n	20c200 <__hexnan+0x12c>
			*x1 = 1;
  20c1b2:	2301      	movs	r3, #1
  20c1b4:	603b      	str	r3, [r7, #0]
			break;
			}
		}
	return STRTOG_NaNbits;
  20c1b6:	2005      	movs	r0, #5
  20c1b8:	e025      	b.n	20c206 <__hexnan+0x132>
		if (++i > 8) {
  20c1ba:	3501      	adds	r5, #1
		havedig++;
  20c1bc:	f10b 0b01 	add.w	fp, fp, #1
		if (++i > 8) {
  20c1c0:	2d08      	cmp	r5, #8
  20c1c2:	dd05      	ble.n	20c1d0 <__hexnan+0xfc>
			if (x <= x0)
  20c1c4:	4544      	cmp	r4, r8
  20c1c6:	d9c3      	bls.n	20c150 <__hexnan+0x7c>
			*--x = 0;
  20c1c8:	2300      	movs	r3, #0
  20c1ca:	3c04      	subs	r4, #4
			i = 1;
  20c1cc:	2501      	movs	r5, #1
			*--x = 0;
  20c1ce:	6023      	str	r3, [r4, #0]
		*x = ((*x << 4) | (h & 0xf));
  20c1d0:	6822      	ldr	r2, [r4, #0]
  20c1d2:	f000 000f 	and.w	r0, r0, #15
  20c1d6:	ea40 1202 	orr.w	r2, r0, r2, lsl #4
  20c1da:	6022      	str	r2, [r4, #0]
  20c1dc:	e7b8      	b.n	20c150 <__hexnan+0x7c>
						i = 8;
  20c1de:	2508      	movs	r5, #8
  20c1e0:	e7b6      	b.n	20c150 <__hexnan+0x7c>
		if ( (i = nbits & (ULbits-1)) !=0)
  20c1e2:	9b01      	ldr	r3, [sp, #4]
  20c1e4:	2b00      	cmp	r3, #0
  20c1e6:	d0e0      	beq.n	20c1aa <__hexnan+0xd6>
			*xe &= ((__ULong)0xffffffff) >> (ULbits - i);
  20c1e8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  20c1ec:	f1c3 0320 	rsb	r3, r3, #32
  20c1f0:	fa22 f303 	lsr.w	r3, r2, r3
  20c1f4:	f856 2c04 	ldr.w	r2, [r6, #-4]
  20c1f8:	401a      	ands	r2, r3
  20c1fa:	f846 2c04 	str.w	r2, [r6, #-4]
	for(x1 = xe;; --x1) {
  20c1fe:	e7d4      	b.n	20c1aa <__hexnan+0xd6>
  20c200:	3f04      	subs	r7, #4
		if (*x1 != 0)
  20c202:	e7d2      	b.n	20c1aa <__hexnan+0xd6>
			return STRTOG_NaN;
  20c204:	2004      	movs	r0, #4
}
  20c206:	b007      	add	sp, #28
  20c208:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0020c20c <_localeconv_r>:
{
  /* Note that we always fall back to the global locale, even in case
     of specifying a reent.  Otherwise a call to _localeconv_r would just
     crash if the reent locale pointer is NULL. */
  return __localeconv_l (__get_current_locale ());
}
  20c20c:	4800      	ldr	r0, [pc, #0]	; (20c210 <_localeconv_r+0x4>)
  20c20e:	4770      	bx	lr
  20c210:	200101b8 	.word	0x200101b8

0020c214 <malloc>:
#ifndef _REENT_ONLY

void *
malloc (size_t nbytes)		/* get a block */
{
  return _malloc_r (_REENT, nbytes);
  20c214:	4b02      	ldr	r3, [pc, #8]	; (20c220 <malloc+0xc>)
{
  20c216:	4601      	mov	r1, r0
  return _malloc_r (_REENT, nbytes);
  20c218:	6818      	ldr	r0, [r3, #0]
  20c21a:	f7fd b855 	b.w	2092c8 <_malloc_r>
  20c21e:	bf00      	nop
  20c220:	20010060 	.word	0x20010060

0020c224 <free>:
}

void
free (void *aptr)
{
  _free_r (_REENT, aptr);
  20c224:	4b02      	ldr	r3, [pc, #8]	; (20c230 <free+0xc>)
{
  20c226:	4601      	mov	r1, r0
  _free_r (_REENT, aptr);
  20c228:	6818      	ldr	r0, [r3, #0]
  20c22a:	f000 bc7b 	b.w	20cb24 <_free_r>
  20c22e:	bf00      	nop
  20c230:	20010060 	.word	0x20010060

0020c234 <__ascii_mbtowc>:
__ascii_mbtowc (struct _reent *r,
        wchar_t       *pwc,
        const char    *s,
        size_t         n,
        mbstate_t      *state)
{
  20c234:	b082      	sub	sp, #8
  wchar_t dummy;
  unsigned char *t = (unsigned char *)s;

  if (pwc == NULL)
  20c236:	b901      	cbnz	r1, 20c23a <__ascii_mbtowc+0x6>
    pwc = &dummy;
  20c238:	a901      	add	r1, sp, #4

  if (s == NULL)
  20c23a:	b142      	cbz	r2, 20c24e <__ascii_mbtowc+0x1a>
    return 0;

  if (n == 0)
  20c23c:	b14b      	cbz	r3, 20c252 <__ascii_mbtowc+0x1e>
      r->_errno = EILSEQ;
      return -1;
    }
#endif

  *pwc = (wchar_t)*t;
  20c23e:	7813      	ldrb	r3, [r2, #0]
  20c240:	600b      	str	r3, [r1, #0]
  
  if (*t == '\0')
  20c242:	7812      	ldrb	r2, [r2, #0]
  20c244:	1e10      	subs	r0, r2, #0
  20c246:	bf18      	it	ne
  20c248:	2001      	movne	r0, #1
    return 0;

  return 1;
}
  20c24a:	b002      	add	sp, #8
  20c24c:	4770      	bx	lr
    return 0;
  20c24e:	4610      	mov	r0, r2
  20c250:	e7fb      	b.n	20c24a <__ascii_mbtowc+0x16>
    return -2;
  20c252:	f06f 0001 	mvn.w	r0, #1
  20c256:	e7f8      	b.n	20c24a <__ascii_mbtowc+0x16>

0020c258 <memcpy>:
  char *dst = (char *) dst0;
  char *src = (char *) src0;

  void *save = dst0;

  while (len0--)
  20c258:	440a      	add	r2, r1
  20c25a:	1e43      	subs	r3, r0, #1
  20c25c:	4291      	cmp	r1, r2
  20c25e:	d100      	bne.n	20c262 <memcpy+0xa>
  20c260:	4770      	bx	lr
{
  20c262:	b510      	push	{r4, lr}
    {
      *dst++ = *src++;
  20c264:	f811 4b01 	ldrb.w	r4, [r1], #1
  while (len0--)
  20c268:	4291      	cmp	r1, r2
      *dst++ = *src++;
  20c26a:	f803 4f01 	strb.w	r4, [r3, #1]!
  while (len0--)
  20c26e:	d1f9      	bne.n	20c264 <memcpy+0xc>
  while (len0--)
    *dst++ = *src++;

  return dst0;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
  20c270:	bd10      	pop	{r4, pc}

0020c272 <memset>:
      s = (char*)aligned_addr;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
  20c272:	4402      	add	r2, r0
  char *s = (char *) m;
  20c274:	4603      	mov	r3, r0
  while (n--)
  20c276:	4293      	cmp	r3, r2
  20c278:	d100      	bne.n	20c27c <memset+0xa>
    *s++ = (char) c;

  return m;
}
  20c27a:	4770      	bx	lr
    *s++ = (char) c;
  20c27c:	f803 1b01 	strb.w	r1, [r3], #1
  20c280:	e7f9      	b.n	20c276 <memset+0x4>

0020c282 <_Balloc>:
#define _Kmax 15
*/

_Bigint *
Balloc (struct _reent *ptr, int k)
{
  20c282:	b570      	push	{r4, r5, r6, lr}
  int x;
  _Bigint *rv ;

  _REENT_CHECK_MP(ptr);
  20c284:	6a46      	ldr	r6, [r0, #36]	; 0x24
{
  20c286:	4604      	mov	r4, r0
  20c288:	460d      	mov	r5, r1
  _REENT_CHECK_MP(ptr);
  20c28a:	b93e      	cbnz	r6, 20c29c <_Balloc+0x1a>
  20c28c:	2010      	movs	r0, #16
  20c28e:	f7ff ffc1 	bl	20c214 <malloc>
  20c292:	6260      	str	r0, [r4, #36]	; 0x24
  20c294:	6006      	str	r6, [r0, #0]
  20c296:	60c6      	str	r6, [r0, #12]
  20c298:	e9c0 6601 	strd	r6, r6, [r0, #4]
  if (_REENT_MP_FREELIST(ptr) == NULL)
  20c29c:	6a66      	ldr	r6, [r4, #36]	; 0x24
  20c29e:	68f3      	ldr	r3, [r6, #12]
  20c2a0:	b183      	cbz	r3, 20c2c4 <_Balloc+0x42>
	{
	  return NULL;
	}
    }

  if ((rv = _REENT_MP_FREELIST(ptr)[k]) != 0)
  20c2a2:	6a63      	ldr	r3, [r4, #36]	; 0x24
  20c2a4:	68db      	ldr	r3, [r3, #12]
  20c2a6:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
  20c2aa:	b9b8      	cbnz	r0, 20c2dc <_Balloc+0x5a>
    {
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
    }
  else
    {
      x = 1 << k;
  20c2ac:	2101      	movs	r1, #1
      /* Allocate an mprec Bigint and stick in in the freelist */
      rv = (_Bigint *) _calloc_r (ptr,
  20c2ae:	4620      	mov	r0, r4
      x = 1 << k;
  20c2b0:	fa01 f605 	lsl.w	r6, r1, r5
      rv = (_Bigint *) _calloc_r (ptr,
  20c2b4:	1d72      	adds	r2, r6, #5
  20c2b6:	0092      	lsls	r2, r2, #2
  20c2b8:	f000 fc24 	bl	20cb04 <_calloc_r>
				  1,
				  sizeof (_Bigint) +
				  (x-1) * sizeof(rv->_x));
      if (rv == NULL) return NULL;
  20c2bc:	b160      	cbz	r0, 20c2d8 <_Balloc+0x56>
      rv->_k = k;
      rv->_maxwds = x;
  20c2be:	e9c0 5601 	strd	r5, r6, [r0, #4]
  20c2c2:	e00e      	b.n	20c2e2 <_Balloc+0x60>
      _REENT_MP_FREELIST(ptr) = (struct _Bigint **) _calloc_r (ptr, 
  20c2c4:	2221      	movs	r2, #33	; 0x21
  20c2c6:	2104      	movs	r1, #4
  20c2c8:	4620      	mov	r0, r4
  20c2ca:	f000 fc1b 	bl	20cb04 <_calloc_r>
      if (_REENT_MP_FREELIST(ptr) == NULL)
  20c2ce:	6a63      	ldr	r3, [r4, #36]	; 0x24
      _REENT_MP_FREELIST(ptr) = (struct _Bigint **) _calloc_r (ptr, 
  20c2d0:	60f0      	str	r0, [r6, #12]
      if (_REENT_MP_FREELIST(ptr) == NULL)
  20c2d2:	68db      	ldr	r3, [r3, #12]
  20c2d4:	2b00      	cmp	r3, #0
  20c2d6:	d1e4      	bne.n	20c2a2 <_Balloc+0x20>
	  return NULL;
  20c2d8:	2000      	movs	r0, #0
    }
  rv->_sign = rv->_wds = 0;
  return rv;
}
  20c2da:	bd70      	pop	{r4, r5, r6, pc}
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
  20c2dc:	6802      	ldr	r2, [r0, #0]
  20c2de:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
  rv->_sign = rv->_wds = 0;
  20c2e2:	2300      	movs	r3, #0
  20c2e4:	e9c0 3303 	strd	r3, r3, [r0, #12]
  return rv;
  20c2e8:	e7f7      	b.n	20c2da <_Balloc+0x58>

0020c2ea <_Bfree>:

void
Bfree (struct _reent *ptr, _Bigint * v)
{
  20c2ea:	b570      	push	{r4, r5, r6, lr}
  _REENT_CHECK_MP(ptr);
  20c2ec:	6a46      	ldr	r6, [r0, #36]	; 0x24
{
  20c2ee:	4605      	mov	r5, r0
  20c2f0:	460c      	mov	r4, r1
  _REENT_CHECK_MP(ptr);
  20c2f2:	b93e      	cbnz	r6, 20c304 <_Bfree+0x1a>
  20c2f4:	2010      	movs	r0, #16
  20c2f6:	f7ff ff8d 	bl	20c214 <malloc>
  20c2fa:	6268      	str	r0, [r5, #36]	; 0x24
  20c2fc:	6006      	str	r6, [r0, #0]
  20c2fe:	60c6      	str	r6, [r0, #12]
  20c300:	e9c0 6601 	strd	r6, r6, [r0, #4]
  if (v)
  20c304:	b13c      	cbz	r4, 20c316 <_Bfree+0x2c>
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
  20c306:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  20c308:	6862      	ldr	r2, [r4, #4]
  20c30a:	68db      	ldr	r3, [r3, #12]
  20c30c:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
  20c310:	6021      	str	r1, [r4, #0]
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
  20c312:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
    }
}
  20c316:	bd70      	pop	{r4, r5, r6, pc}

0020c318 <__multadd>:
_Bigint *
multadd (struct _reent *ptr,
	_Bigint * b,
	int m,
	int a)
{
  20c318:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  20c31c:	4607      	mov	r7, r0
  20c31e:	4698      	mov	r8, r3
  20c320:	460c      	mov	r4, r1
#ifdef Pack_32
  __ULong xi, z;
#endif
  _Bigint *b1;

  wds = b->_wds;
  20c322:	690e      	ldr	r6, [r1, #16]
  x = b->_x;
  20c324:	f101 0014 	add.w	r0, r1, #20
  i = 0;
  20c328:	2300      	movs	r3, #0
  do
    {
#ifdef Pack_32
      xi = *x;
  20c32a:	6805      	ldr	r5, [r0, #0]
      y = *x * m + a;
      a = (int) (y >> 16);
      *x++ = y & 0xffff;
#endif
    }
  while (++i < wds);
  20c32c:	3301      	adds	r3, #1
      y = (xi & 0xffff) * m + a;
  20c32e:	b2a9      	uxth	r1, r5
  while (++i < wds);
  20c330:	429e      	cmp	r6, r3
      z = (xi >> 16) * m + (y >> 16);
  20c332:	ea4f 4515 	mov.w	r5, r5, lsr #16
      y = (xi & 0xffff) * m + a;
  20c336:	fb02 8101 	mla	r1, r2, r1, r8
      z = (xi >> 16) * m + (y >> 16);
  20c33a:	ea4f 4c11 	mov.w	ip, r1, lsr #16
      *x++ = (z << 16) + (y & 0xffff);
  20c33e:	b289      	uxth	r1, r1
      z = (xi >> 16) * m + (y >> 16);
  20c340:	fb02 c505 	mla	r5, r2, r5, ip
      *x++ = (z << 16) + (y & 0xffff);
  20c344:	eb01 4105 	add.w	r1, r1, r5, lsl #16
      a = (int) (z >> 16);
  20c348:	ea4f 4815 	mov.w	r8, r5, lsr #16
      *x++ = (z << 16) + (y & 0xffff);
  20c34c:	f840 1b04 	str.w	r1, [r0], #4
  while (++i < wds);
  20c350:	dceb      	bgt.n	20c32a <__multadd+0x12>
  if (a)
  20c352:	f1b8 0f00 	cmp.w	r8, #0
  20c356:	d01b      	beq.n	20c390 <__multadd+0x78>
    {
      if (wds >= b->_maxwds)
  20c358:	68a3      	ldr	r3, [r4, #8]
  20c35a:	42b3      	cmp	r3, r6
  20c35c:	dc12      	bgt.n	20c384 <__multadd+0x6c>
	{
	  b1 = Balloc (ptr, b->_k + 1);
  20c35e:	6861      	ldr	r1, [r4, #4]
  20c360:	4638      	mov	r0, r7
  20c362:	3101      	adds	r1, #1
  20c364:	f7ff ff8d 	bl	20c282 <_Balloc>
	  Bcopy (b1, b);
  20c368:	6922      	ldr	r2, [r4, #16]
	  b1 = Balloc (ptr, b->_k + 1);
  20c36a:	4605      	mov	r5, r0
	  Bcopy (b1, b);
  20c36c:	f104 010c 	add.w	r1, r4, #12
  20c370:	3202      	adds	r2, #2
  20c372:	300c      	adds	r0, #12
  20c374:	0092      	lsls	r2, r2, #2
  20c376:	f7ff ff6f 	bl	20c258 <memcpy>
	  Bfree (ptr, b);
  20c37a:	4621      	mov	r1, r4
	  b = b1;
  20c37c:	462c      	mov	r4, r5
	  Bfree (ptr, b);
  20c37e:	4638      	mov	r0, r7
  20c380:	f7ff ffb3 	bl	20c2ea <_Bfree>
	}
      b->_x[wds++] = a;
  20c384:	eb04 0386 	add.w	r3, r4, r6, lsl #2
  20c388:	3601      	adds	r6, #1
  20c38a:	f8c3 8014 	str.w	r8, [r3, #20]
      b->_wds = wds;
  20c38e:	6126      	str	r6, [r4, #16]
    }
  return b;
}
  20c390:	4620      	mov	r0, r4
  20c392:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0020c396 <__s2b>:
s2b (struct _reent * ptr,
	const char *s,
	int nd0,
	int nd,
	__ULong y9)
{
  20c396:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  20c39a:	4615      	mov	r5, r2
  20c39c:	461f      	mov	r7, r3
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
  20c39e:	2209      	movs	r2, #9
  20c3a0:	3308      	adds	r3, #8
{
  20c3a2:	460c      	mov	r4, r1
  20c3a4:	4606      	mov	r6, r0
  for (k = 0, y = 1; x > y; y <<= 1, k++);
  20c3a6:	2100      	movs	r1, #0
  x = (nd + 8) / 9;
  20c3a8:	fb93 f3f2 	sdiv	r3, r3, r2
  for (k = 0, y = 1; x > y; y <<= 1, k++);
  20c3ac:	2201      	movs	r2, #1
  20c3ae:	429a      	cmp	r2, r3
  20c3b0:	db20      	blt.n	20c3f4 <__s2b+0x5e>
#ifdef Pack_32
  b = Balloc (ptr, k);
  20c3b2:	4630      	mov	r0, r6
  20c3b4:	f7ff ff65 	bl	20c282 <_Balloc>
  b->_x[0] = y9;
  20c3b8:	9b08      	ldr	r3, [sp, #32]
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
  if (9 < nd0)
  20c3ba:	2d09      	cmp	r5, #9
  b->_x[0] = y9;
  20c3bc:	6143      	str	r3, [r0, #20]
  b->_wds = 1;
  20c3be:	f04f 0301 	mov.w	r3, #1
  20c3c2:	6103      	str	r3, [r0, #16]
  if (9 < nd0)
  20c3c4:	dd19      	ble.n	20c3fa <__s2b+0x64>
    {
      s += 9;
  20c3c6:	f104 0909 	add.w	r9, r4, #9
  20c3ca:	442c      	add	r4, r5
  20c3cc:	46c8      	mov	r8, r9
      do
	b = multadd (ptr, b, 10, *s++ - '0');
  20c3ce:	f818 3b01 	ldrb.w	r3, [r8], #1
  20c3d2:	4601      	mov	r1, r0
  20c3d4:	220a      	movs	r2, #10
  20c3d6:	4630      	mov	r0, r6
  20c3d8:	3b30      	subs	r3, #48	; 0x30
  20c3da:	f7ff ff9d 	bl	20c318 <__multadd>
      while (++i < nd0);
  20c3de:	45a0      	cmp	r8, r4
  20c3e0:	d1f5      	bne.n	20c3ce <__s2b+0x38>
      s++;
  20c3e2:	f1a5 0408 	sub.w	r4, r5, #8
  20c3e6:	444c      	add	r4, r9
  20c3e8:	1b2d      	subs	r5, r5, r4
  20c3ea:	1963      	adds	r3, r4, r5
    }
  else
    s += 10;
  for (; i < nd; i++)
  20c3ec:	42bb      	cmp	r3, r7
  20c3ee:	db07      	blt.n	20c400 <__s2b+0x6a>
    b = multadd (ptr, b, 10, *s++ - '0');
  return b;
}
  20c3f0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  for (k = 0, y = 1; x > y; y <<= 1, k++);
  20c3f4:	0052      	lsls	r2, r2, #1
  20c3f6:	3101      	adds	r1, #1
  20c3f8:	e7d9      	b.n	20c3ae <__s2b+0x18>
    s += 10;
  20c3fa:	340a      	adds	r4, #10
  i = 9;
  20c3fc:	2509      	movs	r5, #9
  20c3fe:	e7f3      	b.n	20c3e8 <__s2b+0x52>
    b = multadd (ptr, b, 10, *s++ - '0');
  20c400:	f814 3b01 	ldrb.w	r3, [r4], #1
  20c404:	4601      	mov	r1, r0
  20c406:	220a      	movs	r2, #10
  20c408:	4630      	mov	r0, r6
  20c40a:	3b30      	subs	r3, #48	; 0x30
  20c40c:	f7ff ff84 	bl	20c318 <__multadd>
  20c410:	e7eb      	b.n	20c3ea <__s2b+0x54>

0020c412 <__hi0bits>:
int
hi0bits (register __ULong x)
{
  register int k = 0;

  if (!(x & 0xffff0000))
  20c412:	0c03      	lsrs	r3, r0, #16
  20c414:	041b      	lsls	r3, r3, #16
  20c416:	b9d3      	cbnz	r3, 20c44e <__hi0bits+0x3c>
    {
      k = 16;
      x <<= 16;
  20c418:	0400      	lsls	r0, r0, #16
      k = 16;
  20c41a:	2310      	movs	r3, #16
    }
  if (!(x & 0xff000000))
  20c41c:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
    {
      k += 8;
      x <<= 8;
  20c420:	bf04      	itt	eq
  20c422:	0200      	lsleq	r0, r0, #8
      k += 8;
  20c424:	3308      	addeq	r3, #8
    }
  if (!(x & 0xf0000000))
  20c426:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
    {
      k += 4;
      x <<= 4;
  20c42a:	bf04      	itt	eq
  20c42c:	0100      	lsleq	r0, r0, #4
      k += 4;
  20c42e:	3304      	addeq	r3, #4
    }
  if (!(x & 0xc0000000))
  20c430:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
    {
      k += 2;
      x <<= 2;
  20c434:	bf04      	itt	eq
  20c436:	0080      	lsleq	r0, r0, #2
      k += 2;
  20c438:	3302      	addeq	r3, #2
    }
  if (!(x & 0x80000000))
  20c43a:	2800      	cmp	r0, #0
  20c43c:	db05      	blt.n	20c44a <__hi0bits+0x38>
    {
      k++;
      if (!(x & 0x40000000))
  20c43e:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
      k++;
  20c442:	f103 0301 	add.w	r3, r3, #1
	return 32;
  20c446:	bf08      	it	eq
  20c448:	2320      	moveq	r3, #32
    }
  return k;
}
  20c44a:	4618      	mov	r0, r3
  20c44c:	4770      	bx	lr
  register int k = 0;
  20c44e:	2300      	movs	r3, #0
  20c450:	e7e4      	b.n	20c41c <__hi0bits+0xa>

0020c452 <__lo0bits>:

int
lo0bits (__ULong *y)
{
  register int k;
  register __ULong x = *y;
  20c452:	6803      	ldr	r3, [r0, #0]
{
  20c454:	4601      	mov	r1, r0

  if (x & 7)
  20c456:	f013 0207 	ands.w	r2, r3, #7
  20c45a:	d00b      	beq.n	20c474 <__lo0bits+0x22>
    {
      if (x & 1)
  20c45c:	07da      	lsls	r2, r3, #31
  20c45e:	d424      	bmi.n	20c4aa <__lo0bits+0x58>
	return 0;
      if (x & 2)
  20c460:	0798      	lsls	r0, r3, #30
	{
	  *y = x >> 1;
  20c462:	bf47      	ittee	mi
  20c464:	085b      	lsrmi	r3, r3, #1
	  return 1;
  20c466:	2001      	movmi	r0, #1
	}
      *y = x >> 2;
  20c468:	089b      	lsrpl	r3, r3, #2
      return 2;
  20c46a:	2002      	movpl	r0, #2
	  *y = x >> 1;
  20c46c:	bf4c      	ite	mi
  20c46e:	600b      	strmi	r3, [r1, #0]
      *y = x >> 2;
  20c470:	600b      	strpl	r3, [r1, #0]
      return 2;
  20c472:	4770      	bx	lr
    }
  k = 0;
  if (!(x & 0xffff))
  20c474:	b298      	uxth	r0, r3
  20c476:	b9b0      	cbnz	r0, 20c4a6 <__lo0bits+0x54>
    {
      k = 16;
      x >>= 16;
  20c478:	0c1b      	lsrs	r3, r3, #16
      k = 16;
  20c47a:	2010      	movs	r0, #16
    }
  if (!(x & 0xff))
  20c47c:	f013 0fff 	tst.w	r3, #255	; 0xff
    {
      k += 8;
      x >>= 8;
  20c480:	bf04      	itt	eq
  20c482:	0a1b      	lsreq	r3, r3, #8
      k += 8;
  20c484:	3008      	addeq	r0, #8
    }
  if (!(x & 0xf))
  20c486:	071a      	lsls	r2, r3, #28
    {
      k += 4;
      x >>= 4;
  20c488:	bf04      	itt	eq
  20c48a:	091b      	lsreq	r3, r3, #4
      k += 4;
  20c48c:	3004      	addeq	r0, #4
    }
  if (!(x & 0x3))
  20c48e:	079a      	lsls	r2, r3, #30
    {
      k += 2;
      x >>= 2;
  20c490:	bf04      	itt	eq
  20c492:	089b      	lsreq	r3, r3, #2
      k += 2;
  20c494:	3002      	addeq	r0, #2
    }
  if (!(x & 1))
  20c496:	07da      	lsls	r2, r3, #31
  20c498:	d403      	bmi.n	20c4a2 <__lo0bits+0x50>
    {
      k++;
      x >>= 1;
      if (!x & 1)
  20c49a:	085b      	lsrs	r3, r3, #1
      k++;
  20c49c:	f100 0001 	add.w	r0, r0, #1
      if (!x & 1)
  20c4a0:	d005      	beq.n	20c4ae <__lo0bits+0x5c>
	return 32;
    }
  *y = x;
  20c4a2:	600b      	str	r3, [r1, #0]
  return k;
  20c4a4:	4770      	bx	lr
  k = 0;
  20c4a6:	4610      	mov	r0, r2
  20c4a8:	e7e8      	b.n	20c47c <__lo0bits+0x2a>
	return 0;
  20c4aa:	2000      	movs	r0, #0
  20c4ac:	4770      	bx	lr
	return 32;
  20c4ae:	2020      	movs	r0, #32
}
  20c4b0:	4770      	bx	lr

0020c4b2 <__i2b>:

_Bigint *
i2b (struct _reent * ptr, int i)
{
  20c4b2:	b510      	push	{r4, lr}
  20c4b4:	460c      	mov	r4, r1
  _Bigint *b;

  b = Balloc (ptr, 1);
  20c4b6:	2101      	movs	r1, #1
  20c4b8:	f7ff fee3 	bl	20c282 <_Balloc>
  b->_x[0] = i;
  b->_wds = 1;
  20c4bc:	2201      	movs	r2, #1
  b->_x[0] = i;
  20c4be:	6144      	str	r4, [r0, #20]
  b->_wds = 1;
  20c4c0:	6102      	str	r2, [r0, #16]
  return b;
}
  20c4c2:	bd10      	pop	{r4, pc}

0020c4c4 <__multiply>:

_Bigint *
mult (struct _reent * ptr, _Bigint * a, _Bigint * b)
{
  20c4c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  20c4c8:	4615      	mov	r5, r2
  __ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
#ifdef Pack_32
  __ULong z2;
#endif

  if (a->_wds < b->_wds)
  20c4ca:	690a      	ldr	r2, [r1, #16]
{
  20c4cc:	460c      	mov	r4, r1
  20c4ce:	b085      	sub	sp, #20
  if (a->_wds < b->_wds)
  20c4d0:	692b      	ldr	r3, [r5, #16]
  20c4d2:	429a      	cmp	r2, r3
  20c4d4:	bfbe      	ittt	lt
  20c4d6:	460b      	movlt	r3, r1
  20c4d8:	462c      	movlt	r4, r5
  20c4da:	461d      	movlt	r5, r3
      c = a;
      a = b;
      b = c;
    }
  k = a->_k;
  wa = a->_wds;
  20c4dc:	6927      	ldr	r7, [r4, #16]
  wb = b->_wds;
  wc = wa + wb;
  if (wc > a->_maxwds)
  20c4de:	68a3      	ldr	r3, [r4, #8]
  wb = b->_wds;
  20c4e0:	f8d5 9010 	ldr.w	r9, [r5, #16]
  k = a->_k;
  20c4e4:	6861      	ldr	r1, [r4, #4]
  wc = wa + wb;
  20c4e6:	eb07 0609 	add.w	r6, r7, r9
  if (wc > a->_maxwds)
  20c4ea:	42b3      	cmp	r3, r6
    k++;
  20c4ec:	bfb8      	it	lt
  20c4ee:	3101      	addlt	r1, #1
  c = Balloc (ptr, k);
  20c4f0:	f7ff fec7 	bl	20c282 <_Balloc>
  for (x = c->_x, xa = x + wc; x < xa; x++)
  20c4f4:	f100 0114 	add.w	r1, r0, #20
    *x = 0;
  20c4f8:	2200      	movs	r2, #0
  for (x = c->_x, xa = x + wc; x < xa; x++)
  20c4fa:	eb01 0886 	add.w	r8, r1, r6, lsl #2
  20c4fe:	460b      	mov	r3, r1
  20c500:	4543      	cmp	r3, r8
  20c502:	d31d      	bcc.n	20c540 <__multiply+0x7c>
  xa = a->_x;
  20c504:	f104 0314 	add.w	r3, r4, #20
  xae = xa + wa;
  xb = b->_x;
  20c508:	f105 0214 	add.w	r2, r5, #20
  20c50c:	f104 0515 	add.w	r5, r4, #21
  xae = xa + wa;
  20c510:	eb03 0787 	add.w	r7, r3, r7, lsl #2
  xbe = xb + wb;
  20c514:	eb02 0389 	add.w	r3, r2, r9, lsl #2
  20c518:	9302      	str	r3, [sp, #8]
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
  20c51a:	1b3b      	subs	r3, r7, r4
  20c51c:	3b15      	subs	r3, #21
  20c51e:	f023 0303 	bic.w	r3, r3, #3
  20c522:	3304      	adds	r3, #4
  20c524:	42af      	cmp	r7, r5
  20c526:	bf38      	it	cc
  20c528:	2304      	movcc	r3, #4
  20c52a:	9301      	str	r3, [sp, #4]
  20c52c:	9b02      	ldr	r3, [sp, #8]
  20c52e:	9203      	str	r2, [sp, #12]
  20c530:	4293      	cmp	r3, r2
  20c532:	d808      	bhi.n	20c546 <__multiply+0x82>
	  while (x < xae);
	  *xc = carry;
	}
    }
#endif
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
  20c534:	2e00      	cmp	r6, #0
  20c536:	dc5a      	bgt.n	20c5ee <__multiply+0x12a>
  c->_wds = wc;
  20c538:	6106      	str	r6, [r0, #16]
  return c;
}
  20c53a:	b005      	add	sp, #20
  20c53c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    *x = 0;
  20c540:	f843 2b04 	str.w	r2, [r3], #4
  20c544:	e7dc      	b.n	20c500 <__multiply+0x3c>
      if ((y = *xb & 0xffff) != 0)
  20c546:	f8b2 a000 	ldrh.w	sl, [r2]
  20c54a:	f1ba 0f00 	cmp.w	sl, #0
  20c54e:	d024      	beq.n	20c59a <__multiply+0xd6>
  20c550:	f104 0e14 	add.w	lr, r4, #20
  20c554:	4689      	mov	r9, r1
	  carry = 0;
  20c556:	f04f 0c00 	mov.w	ip, #0
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
  20c55a:	f85e 5b04 	ldr.w	r5, [lr], #4
  20c55e:	f8d9 b000 	ldr.w	fp, [r9]
  20c562:	b2ab      	uxth	r3, r5
	  while (x < xae);
  20c564:	4577      	cmp	r7, lr
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
  20c566:	fa1f fb8b 	uxth.w	fp, fp
  20c56a:	fb0a b303 	mla	r3, sl, r3, fp
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
  20c56e:	ea4f 4b15 	mov.w	fp, r5, lsr #16
  20c572:	f8d9 5000 	ldr.w	r5, [r9]
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
  20c576:	4463      	add	r3, ip
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
  20c578:	ea4f 4c15 	mov.w	ip, r5, lsr #16
  20c57c:	fb0a c50b 	mla	r5, sl, fp, ip
  20c580:	eb05 4513 	add.w	r5, r5, r3, lsr #16
	      Storeinc (xc, z2, z);
  20c584:	b29b      	uxth	r3, r3
	      carry = z2 >> 16;
  20c586:	ea4f 4c15 	mov.w	ip, r5, lsr #16
	      Storeinc (xc, z2, z);
  20c58a:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
  20c58e:	f849 3b04 	str.w	r3, [r9], #4
	  while (x < xae);
  20c592:	d8e2      	bhi.n	20c55a <__multiply+0x96>
	  *xc = carry;
  20c594:	9b01      	ldr	r3, [sp, #4]
  20c596:	f841 c003 	str.w	ip, [r1, r3]
      if ((y = *xb >> 16) != 0)
  20c59a:	9b03      	ldr	r3, [sp, #12]
  20c59c:	3204      	adds	r2, #4
  20c59e:	f8b3 9002 	ldrh.w	r9, [r3, #2]
  20c5a2:	f1b9 0f00 	cmp.w	r9, #0
  20c5a6:	d020      	beq.n	20c5ea <__multiply+0x126>
	  z2 = *xc;
  20c5a8:	680b      	ldr	r3, [r1, #0]
  20c5aa:	f104 0c14 	add.w	ip, r4, #20
  20c5ae:	468e      	mov	lr, r1
	  carry = 0;
  20c5b0:	f04f 0a00 	mov.w	sl, #0
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
  20c5b4:	f8bc 5000 	ldrh.w	r5, [ip]
	      Storeinc (xc, z, z2);
  20c5b8:	b29b      	uxth	r3, r3
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
  20c5ba:	f8be b002 	ldrh.w	fp, [lr, #2]
  20c5be:	fb09 b505 	mla	r5, r9, r5, fp
  20c5c2:	44aa      	add	sl, r5
	      Storeinc (xc, z, z2);
  20c5c4:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
  20c5c8:	f84e 3b04 	str.w	r3, [lr], #4
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
  20c5cc:	f85c 3b04 	ldr.w	r3, [ip], #4
  20c5d0:	f8be 5000 	ldrh.w	r5, [lr]
  20c5d4:	0c1b      	lsrs	r3, r3, #16
	  while (x < xae);
  20c5d6:	4567      	cmp	r7, ip
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
  20c5d8:	fb09 5303 	mla	r3, r9, r3, r5
  20c5dc:	eb03 431a 	add.w	r3, r3, sl, lsr #16
	      carry = z2 >> 16;
  20c5e0:	ea4f 4a13 	mov.w	sl, r3, lsr #16
	  while (x < xae);
  20c5e4:	d8e6      	bhi.n	20c5b4 <__multiply+0xf0>
	  *xc = z2;
  20c5e6:	9d01      	ldr	r5, [sp, #4]
  20c5e8:	514b      	str	r3, [r1, r5]
  for (; xb < xbe; xb++, xc0++)
  20c5ea:	3104      	adds	r1, #4
  20c5ec:	e79e      	b.n	20c52c <__multiply+0x68>
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
  20c5ee:	f858 3d04 	ldr.w	r3, [r8, #-4]!
  20c5f2:	2b00      	cmp	r3, #0
  20c5f4:	d1a0      	bne.n	20c538 <__multiply+0x74>
  20c5f6:	3e01      	subs	r6, #1
  20c5f8:	e79c      	b.n	20c534 <__multiply+0x70>
	...

0020c5fc <__pow5mult>:

_Bigint *
pow5mult (struct _reent * ptr, _Bigint * b, int k)
{
  20c5fc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  20c600:	4615      	mov	r5, r2
  _Bigint *b1, *p5, *p51;
  int i;
  static const int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
  20c602:	f012 0203 	ands.w	r2, r2, #3
{
  20c606:	4606      	mov	r6, r0
  20c608:	460f      	mov	r7, r1
  if ((i = k & 3) != 0)
  20c60a:	d007      	beq.n	20c61c <__pow5mult+0x20>
    b = multadd (ptr, b, p05[i - 1], 0);
  20c60c:	3a01      	subs	r2, #1
  20c60e:	4c21      	ldr	r4, [pc, #132]	; (20c694 <__pow5mult+0x98>)
  20c610:	2300      	movs	r3, #0
  20c612:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
  20c616:	f7ff fe7f 	bl	20c318 <__multadd>
  20c61a:	4607      	mov	r7, r0

  if (!(k >>= 2))
  20c61c:	10ad      	asrs	r5, r5, #2
  20c61e:	d035      	beq.n	20c68c <__pow5mult+0x90>
    return b;
  _REENT_CHECK_MP(ptr);
  20c620:	6a74      	ldr	r4, [r6, #36]	; 0x24
  20c622:	b93c      	cbnz	r4, 20c634 <__pow5mult+0x38>
  20c624:	2010      	movs	r0, #16
  20c626:	f7ff fdf5 	bl	20c214 <malloc>
  20c62a:	6270      	str	r0, [r6, #36]	; 0x24
  20c62c:	6004      	str	r4, [r0, #0]
  20c62e:	60c4      	str	r4, [r0, #12]
  20c630:	e9c0 4401 	strd	r4, r4, [r0, #4]
  if (!(p5 = _REENT_MP_P5S(ptr)))
  20c634:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
  20c638:	f8d8 4008 	ldr.w	r4, [r8, #8]
  20c63c:	b94c      	cbnz	r4, 20c652 <__pow5mult+0x56>
    {
      /* first time */
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
  20c63e:	f240 2171 	movw	r1, #625	; 0x271
  20c642:	4630      	mov	r0, r6
  20c644:	f7ff ff35 	bl	20c4b2 <__i2b>
      p5->_next = 0;
  20c648:	2300      	movs	r3, #0
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
  20c64a:	4604      	mov	r4, r0
  20c64c:	f8c8 0008 	str.w	r0, [r8, #8]
      p5->_next = 0;
  20c650:	6003      	str	r3, [r0, #0]
      if (!(k >>= 1))
	break;
      if (!(p51 = p5->_next))
	{
	  p51 = p5->_next = mult (ptr, p5, p5);
	  p51->_next = 0;
  20c652:	f04f 0900 	mov.w	r9, #0
      if (k & 1)
  20c656:	07eb      	lsls	r3, r5, #31
  20c658:	d50a      	bpl.n	20c670 <__pow5mult+0x74>
	  b1 = mult (ptr, b, p5);
  20c65a:	4639      	mov	r1, r7
  20c65c:	4622      	mov	r2, r4
  20c65e:	4630      	mov	r0, r6
  20c660:	f7ff ff30 	bl	20c4c4 <__multiply>
  20c664:	4680      	mov	r8, r0
	  Bfree (ptr, b);
  20c666:	4639      	mov	r1, r7
  20c668:	4630      	mov	r0, r6
	  b = b1;
  20c66a:	4647      	mov	r7, r8
	  Bfree (ptr, b);
  20c66c:	f7ff fe3d 	bl	20c2ea <_Bfree>
      if (!(k >>= 1))
  20c670:	106d      	asrs	r5, r5, #1
  20c672:	d00b      	beq.n	20c68c <__pow5mult+0x90>
      if (!(p51 = p5->_next))
  20c674:	6820      	ldr	r0, [r4, #0]
  20c676:	b938      	cbnz	r0, 20c688 <__pow5mult+0x8c>
	  p51 = p5->_next = mult (ptr, p5, p5);
  20c678:	4622      	mov	r2, r4
  20c67a:	4621      	mov	r1, r4
  20c67c:	4630      	mov	r0, r6
  20c67e:	f7ff ff21 	bl	20c4c4 <__multiply>
  20c682:	6020      	str	r0, [r4, #0]
	  p51->_next = 0;
  20c684:	f8c0 9000 	str.w	r9, [r0]
{
  20c688:	4604      	mov	r4, r0
  20c68a:	e7e4      	b.n	20c656 <__pow5mult+0x5a>
	}
      p5 = p51;
    }
  return b;
}
  20c68c:	4638      	mov	r0, r7
  20c68e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  20c692:	bf00      	nop
  20c694:	0800eeb8 	.word	0x0800eeb8

0020c698 <__lshift>:

_Bigint *
lshift (struct _reent * ptr, _Bigint * b, int k)
{
  20c698:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  20c69c:	460c      	mov	r4, r1
  20c69e:	4607      	mov	r7, r0
  20c6a0:	4691      	mov	r9, r2
  int i, k1, n, n1;
  _Bigint *b1;
  __ULong *x, *x1, *xe, z;

#ifdef Pack_32
  n = k >> 5;
  20c6a2:	ea4f 1a62 	mov.w	sl, r2, asr #5
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  20c6a6:	6923      	ldr	r3, [r4, #16]
  k1 = b->_k;
  20c6a8:	6849      	ldr	r1, [r1, #4]
  n1 = n + b->_wds + 1;
  20c6aa:	eb03 1862 	add.w	r8, r3, r2, asr #5
  for (i = b->_maxwds; n1 > i; i <<= 1)
  20c6ae:	68a3      	ldr	r3, [r4, #8]
  n1 = n + b->_wds + 1;
  20c6b0:	f108 0601 	add.w	r6, r8, #1
  for (i = b->_maxwds; n1 > i; i <<= 1)
  20c6b4:	42b3      	cmp	r3, r6
  20c6b6:	db3f      	blt.n	20c738 <__lshift+0xa0>
    k1++;
  b1 = Balloc (ptr, k1);
  20c6b8:	4638      	mov	r0, r7
  20c6ba:	f7ff fde2 	bl	20c282 <_Balloc>
  x1 = b1->_x;
  for (i = 0; i < n; i++)
  20c6be:	2300      	movs	r3, #0
  b1 = Balloc (ptr, k1);
  20c6c0:	4605      	mov	r5, r0
  x1 = b1->_x;
  20c6c2:	f100 0114 	add.w	r1, r0, #20
  for (i = 0; i < n; i++)
  20c6c6:	f100 0210 	add.w	r2, r0, #16
    *x1++ = 0;
  20c6ca:	4618      	mov	r0, r3
  for (i = 0; i < n; i++)
  20c6cc:	4553      	cmp	r3, sl
  20c6ce:	db36      	blt.n	20c73e <__lshift+0xa6>
  20c6d0:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
  x = b->_x;
  20c6d4:	f104 0314 	add.w	r3, r4, #20
  xe = x + b->_wds;
  20c6d8:	6920      	ldr	r0, [r4, #16]
#ifdef Pack_32
  if (k &= 0x1f)
  20c6da:	f019 091f 	ands.w	r9, r9, #31
  20c6de:	eb01 018a 	add.w	r1, r1, sl, lsl #2
  xe = x + b->_wds;
  20c6e2:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
  if (k &= 0x1f)
  20c6e6:	d02e      	beq.n	20c746 <__lshift+0xae>
    {
      k1 = 32 - k;
  20c6e8:	f1c9 0e20 	rsb	lr, r9, #32
  20c6ec:	468a      	mov	sl, r1
      z = 0;
  20c6ee:	2200      	movs	r2, #0
      do
	{
	  *x1++ = *x << k | z;
  20c6f0:	6818      	ldr	r0, [r3, #0]
  20c6f2:	fa00 f009 	lsl.w	r0, r0, r9
  20c6f6:	4302      	orrs	r2, r0
  20c6f8:	f84a 2b04 	str.w	r2, [sl], #4
	  z = *x++ >> k1;
  20c6fc:	f853 2b04 	ldr.w	r2, [r3], #4
	}
      while (x < xe);
  20c700:	459c      	cmp	ip, r3
	  z = *x++ >> k1;
  20c702:	fa22 f20e 	lsr.w	r2, r2, lr
      while (x < xe);
  20c706:	d8f3      	bhi.n	20c6f0 <__lshift+0x58>
      if ((*x1 = z) != 0)
  20c708:	ebac 0304 	sub.w	r3, ip, r4
  20c70c:	f104 0015 	add.w	r0, r4, #21
  20c710:	3b15      	subs	r3, #21
  20c712:	f023 0303 	bic.w	r3, r3, #3
  20c716:	3304      	adds	r3, #4
  20c718:	4560      	cmp	r0, ip
  20c71a:	bf88      	it	hi
  20c71c:	2304      	movhi	r3, #4
  20c71e:	50ca      	str	r2, [r1, r3]
  20c720:	b10a      	cbz	r2, 20c726 <__lshift+0x8e>
	++n1;
  20c722:	f108 0602 	add.w	r6, r8, #2
#endif
  else
    do
      *x1++ = *x++;
    while (x < xe);
  b1->_wds = n1 - 1;
  20c726:	3e01      	subs	r6, #1
  Bfree (ptr, b);
  20c728:	4638      	mov	r0, r7
  20c72a:	4621      	mov	r1, r4
  b1->_wds = n1 - 1;
  20c72c:	612e      	str	r6, [r5, #16]
  Bfree (ptr, b);
  20c72e:	f7ff fddc 	bl	20c2ea <_Bfree>
  return b1;
}
  20c732:	4628      	mov	r0, r5
  20c734:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    k1++;
  20c738:	3101      	adds	r1, #1
  for (i = b->_maxwds; n1 > i; i <<= 1)
  20c73a:	005b      	lsls	r3, r3, #1
  20c73c:	e7ba      	b.n	20c6b4 <__lshift+0x1c>
  for (i = 0; i < n; i++)
  20c73e:	3301      	adds	r3, #1
    *x1++ = 0;
  20c740:	f842 0f04 	str.w	r0, [r2, #4]!
  20c744:	e7c2      	b.n	20c6cc <__lshift+0x34>
  20c746:	3904      	subs	r1, #4
      *x1++ = *x++;
  20c748:	f853 2b04 	ldr.w	r2, [r3], #4
    while (x < xe);
  20c74c:	459c      	cmp	ip, r3
      *x1++ = *x++;
  20c74e:	f841 2f04 	str.w	r2, [r1, #4]!
    while (x < xe);
  20c752:	d8f9      	bhi.n	20c748 <__lshift+0xb0>
  20c754:	e7e7      	b.n	20c726 <__lshift+0x8e>

0020c756 <__mcmp>:
cmp (_Bigint * a, _Bigint * b)
{
  __ULong *xa, *xa0, *xb, *xb0;
  int i, j;

  i = a->_wds;
  20c756:	6902      	ldr	r2, [r0, #16]
{
  20c758:	b530      	push	{r4, r5, lr}
  j = b->_wds;
  20c75a:	690c      	ldr	r4, [r1, #16]
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
  20c75c:	1b12      	subs	r2, r2, r4
  20c75e:	d10e      	bne.n	20c77e <__mcmp+0x28>
    return i;
  xa0 = a->_x;
  20c760:	f100 0314 	add.w	r3, r0, #20
  xa = xa0 + j;
  xb0 = b->_x;
  20c764:	3114      	adds	r1, #20
  xa = xa0 + j;
  20c766:	eb03 0084 	add.w	r0, r3, r4, lsl #2
  xb = xb0 + j;
  20c76a:	eb01 0184 	add.w	r1, r1, r4, lsl #2
  for (;;)
    {
      if (*--xa != *--xb)
  20c76e:	f850 5d04 	ldr.w	r5, [r0, #-4]!
  20c772:	f851 4d04 	ldr.w	r4, [r1, #-4]!
  20c776:	42a5      	cmp	r5, r4
  20c778:	d003      	beq.n	20c782 <__mcmp+0x2c>
	return *xa < *xb ? -1 : 1;
  20c77a:	d305      	bcc.n	20c788 <__mcmp+0x32>
  20c77c:	2201      	movs	r2, #1
      if (xa <= xa0)
	break;
    }
  return 0;
}
  20c77e:	4610      	mov	r0, r2
  20c780:	bd30      	pop	{r4, r5, pc}
      if (xa <= xa0)
  20c782:	4283      	cmp	r3, r0
  20c784:	d3f3      	bcc.n	20c76e <__mcmp+0x18>
  20c786:	e7fa      	b.n	20c77e <__mcmp+0x28>
	return *xa < *xb ? -1 : 1;
  20c788:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  20c78c:	e7f7      	b.n	20c77e <__mcmp+0x28>

0020c78e <__mdiff>:

_Bigint *
diff (struct _reent * ptr,
	_Bigint * a, _Bigint * b)
{
  20c78e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  20c792:	460c      	mov	r4, r1
  20c794:	4606      	mov	r6, r0
  __ULong *xa, *xae, *xb, *xbe, *xc;
#ifdef Pack_32
  __Long z;
#endif

  i = cmp (a, b);
  20c796:	4611      	mov	r1, r2
{
  20c798:	4617      	mov	r7, r2
  i = cmp (a, b);
  20c79a:	4620      	mov	r0, r4
  20c79c:	f7ff ffdb 	bl	20c756 <__mcmp>
  if (!i)
  20c7a0:	1e05      	subs	r5, r0, #0
  20c7a2:	d108      	bne.n	20c7b6 <__mdiff+0x28>
    {
      c = Balloc (ptr, 0);
  20c7a4:	4629      	mov	r1, r5
  20c7a6:	4630      	mov	r0, r6
  20c7a8:	f7ff fd6b 	bl	20c282 <_Balloc>
      c->_wds = 1;
  20c7ac:	2301      	movs	r3, #1
      c->_x[0] = 0;
  20c7ae:	e9c0 3504 	strd	r3, r5, [r0, #16]
#endif
  while (!*--xc)
    wa--;
  c->_wds = wa;
  return c;
}
  20c7b2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (i < 0)
  20c7b6:	bfa3      	ittte	ge
  20c7b8:	463b      	movge	r3, r7
  20c7ba:	4627      	movge	r7, r4
    i = 0;
  20c7bc:	2500      	movge	r5, #0
      i = 1;
  20c7be:	2501      	movlt	r5, #1
  if (i < 0)
  20c7c0:	bfa8      	it	ge
  20c7c2:	461c      	movge	r4, r3
  c = Balloc (ptr, a->_k);
  20c7c4:	6879      	ldr	r1, [r7, #4]
  20c7c6:	4630      	mov	r0, r6
  20c7c8:	f7ff fd5b 	bl	20c282 <_Balloc>
  xb = b->_x;
  20c7cc:	f104 0914 	add.w	r9, r4, #20
  wa = a->_wds;
  20c7d0:	693e      	ldr	r6, [r7, #16]
  xa = a->_x;
  20c7d2:	f107 0114 	add.w	r1, r7, #20
  xc = c->_x;
  20c7d6:	f100 0e14 	add.w	lr, r0, #20
  c->_sign = i;
  20c7da:	60c5      	str	r5, [r0, #12]
  xbe = xb + wb;
  20c7dc:	6925      	ldr	r5, [r4, #16]
  20c7de:	f107 0210 	add.w	r2, r7, #16
  xae = xa + wa;
  20c7e2:	eb01 0c86 	add.w	ip, r1, r6, lsl #2
  xc = c->_x;
  20c7e6:	46f2      	mov	sl, lr
  xbe = xb + wb;
  20c7e8:	eb09 0585 	add.w	r5, r9, r5, lsl #2
  borrow = 0;
  20c7ec:	2700      	movs	r7, #0
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
  20c7ee:	f859 3b04 	ldr.w	r3, [r9], #4
  20c7f2:	f852 bf04 	ldr.w	fp, [r2, #4]!
  20c7f6:	fa1f f883 	uxth.w	r8, r3
  while (xb < xbe);
  20c7fa:	454d      	cmp	r5, r9
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
  20c7fc:	fa17 f78b 	uxtah	r7, r7, fp
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
  20c800:	ea4f 4313 	mov.w	r3, r3, lsr #16
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
  20c804:	eba7 0808 	sub.w	r8, r7, r8
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
  20c808:	ebc3 431b 	rsb	r3, r3, fp, lsr #16
  20c80c:	eb03 4328 	add.w	r3, r3, r8, asr #16
      Storeinc (xc, z, y);
  20c810:	fa1f f888 	uxth.w	r8, r8
      borrow = z >> 16;
  20c814:	ea4f 4723 	mov.w	r7, r3, asr #16
      Storeinc (xc, z, y);
  20c818:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
  20c81c:	f84a 3b04 	str.w	r3, [sl], #4
  while (xb < xbe);
  20c820:	d8e5      	bhi.n	20c7ee <__mdiff+0x60>
  20c822:	1b2b      	subs	r3, r5, r4
  20c824:	3415      	adds	r4, #21
  20c826:	3b15      	subs	r3, #21
  20c828:	f023 0303 	bic.w	r3, r3, #3
  20c82c:	3304      	adds	r3, #4
  20c82e:	42a5      	cmp	r5, r4
  20c830:	bf38      	it	cc
  20c832:	2304      	movcc	r3, #4
  20c834:	4419      	add	r1, r3
  20c836:	4473      	add	r3, lr
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
  20c838:	460d      	mov	r5, r1
      Storeinc (xc, z, y);
  20c83a:	469e      	mov	lr, r3
  while (xa < xae)
  20c83c:	4565      	cmp	r5, ip
  20c83e:	d30e      	bcc.n	20c85e <__mdiff+0xd0>
  20c840:	f10c 0203 	add.w	r2, ip, #3
  20c844:	1a52      	subs	r2, r2, r1
  20c846:	3903      	subs	r1, #3
  20c848:	f022 0203 	bic.w	r2, r2, #3
  20c84c:	458c      	cmp	ip, r1
  20c84e:	bf38      	it	cc
  20c850:	2200      	movcc	r2, #0
  20c852:	441a      	add	r2, r3
  while (!*--xc)
  20c854:	f852 3d04 	ldr.w	r3, [r2, #-4]!
  20c858:	b17b      	cbz	r3, 20c87a <__mdiff+0xec>
  c->_wds = wa;
  20c85a:	6106      	str	r6, [r0, #16]
  return c;
  20c85c:	e7a9      	b.n	20c7b2 <__mdiff+0x24>
      y = (*xa & 0xffff) + borrow;
  20c85e:	f855 8b04 	ldr.w	r8, [r5], #4
  20c862:	fa17 f488 	uxtah	r4, r7, r8
      borrow = y >> 16;
  20c866:	1422      	asrs	r2, r4, #16
      Storeinc (xc, z, y);
  20c868:	b2a4      	uxth	r4, r4
      z = (*xa++ >> 16) + borrow;
  20c86a:	eb02 4218 	add.w	r2, r2, r8, lsr #16
      Storeinc (xc, z, y);
  20c86e:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
      borrow = z >> 16;
  20c872:	1417      	asrs	r7, r2, #16
      Storeinc (xc, z, y);
  20c874:	f84e 4b04 	str.w	r4, [lr], #4
  20c878:	e7e0      	b.n	20c83c <__mdiff+0xae>
    wa--;
  20c87a:	3e01      	subs	r6, #1
  20c87c:	e7ea      	b.n	20c854 <__mdiff+0xc6>
	...

0020c880 <__ulp>:

double
ulp (double _x)
{
  20c880:	b082      	sub	sp, #8
  union double_union x, a;
  register __Long L;

  x.d = _x;

  L = (word0 (x) & Exp_mask) - (P - 1) * Exp_msk1;
  20c882:	4913      	ldr	r1, [pc, #76]	; (20c8d0 <__ulp+0x50>)
{
  20c884:	ed8d 0b00 	vstr	d0, [sp]
  L = (word0 (x) & Exp_mask) - (P - 1) * Exp_msk1;
  20c888:	9b01      	ldr	r3, [sp, #4]
  20c88a:	4019      	ands	r1, r3
  20c88c:	f1a1 7150 	sub.w	r1, r1, #54525952	; 0x3400000
#ifndef Sudden_Underflow
  if (L > 0)
  20c890:	2900      	cmp	r1, #0
  20c892:	dd05      	ble.n	20c8a0 <__ulp+0x20>
    {
#endif
#ifdef IBM
      L |= Exp_msk1 >> 4;
#endif
      word0 (a) = L;
  20c894:	2200      	movs	r2, #0
  20c896:	460b      	mov	r3, r1
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
#endif
	}
    }
#endif
  return a.d;
  20c898:	ec43 2b10 	vmov	d0, r2, r3
}
  20c89c:	b002      	add	sp, #8
  20c89e:	4770      	bx	lr
      L = -L >> Exp_shift;
  20c8a0:	4249      	negs	r1, r1
	  word0 (a) = 0x80000 >> L;
  20c8a2:	2200      	movs	r2, #0
  20c8a4:	2300      	movs	r3, #0
      if (L < Exp_shift)
  20c8a6:	f1b1 7fa0 	cmp.w	r1, #20971520	; 0x1400000
      L = -L >> Exp_shift;
  20c8aa:	ea4f 5021 	mov.w	r0, r1, asr #20
      if (L < Exp_shift)
  20c8ae:	da04      	bge.n	20c8ba <__ulp+0x3a>
	  word0 (a) = 0x80000 >> L;
  20c8b0:	f44f 2100 	mov.w	r1, #524288	; 0x80000
  20c8b4:	fa41 f300 	asr.w	r3, r1, r0
	  word1 (a) = 0;
  20c8b8:	e7ee      	b.n	20c898 <__ulp+0x18>
	  L -= Exp_shift;
  20c8ba:	f1a0 0114 	sub.w	r1, r0, #20
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
  20c8be:	291e      	cmp	r1, #30
  20c8c0:	bfd6      	itet	le
  20c8c2:	f04f 4000 	movle.w	r0, #2147483648	; 0x80000000
  20c8c6:	2101      	movgt	r1, #1
  20c8c8:	fa20 f101 	lsrle.w	r1, r0, r1
  20c8cc:	460a      	mov	r2, r1
  20c8ce:	e7e3      	b.n	20c898 <__ulp+0x18>
  20c8d0:	7ff00000 	.word	0x7ff00000

0020c8d4 <__b2d>:

double
b2d (_Bigint * a, int *e)
{
  20c8d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#define d0 word0(d)
#define d1 word1(d)
#endif

  xa0 = a->_x;
  xa = xa0 + a->_wds;
  20c8d6:	6905      	ldr	r5, [r0, #16]
  xa0 = a->_x;
  20c8d8:	f100 0714 	add.w	r7, r0, #20
  xa = xa0 + a->_wds;
  20c8dc:	eb07 0585 	add.w	r5, r7, r5, lsl #2
  y = *--xa;
  20c8e0:	f855 4c04 	ldr.w	r4, [r5, #-4]
  20c8e4:	1f2e      	subs	r6, r5, #4
#ifdef DEBUG
  if (!y)
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
  20c8e6:	4620      	mov	r0, r4
  20c8e8:	f7ff fd93 	bl	20c412 <__hi0bits>
  *e = 32 - k;
  20c8ec:	f1c0 0320 	rsb	r3, r0, #32
#ifdef Pack_32
  if (k < Ebits)
  20c8f0:	280a      	cmp	r0, #10
  20c8f2:	f8df c07c 	ldr.w	ip, [pc, #124]	; 20c970 <__b2d+0x9c>
  *e = 32 - k;
  20c8f6:	600b      	str	r3, [r1, #0]
  if (k < Ebits)
  20c8f8:	dc15      	bgt.n	20c926 <__b2d+0x52>
    {
      d0 = Exp_1 | y >> (Ebits - k);
  20c8fa:	f1c0 0e0b 	rsb	lr, r0, #11
      w = xa > xa0 ? *--xa : 0;
  20c8fe:	42b7      	cmp	r7, r6
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
  20c900:	f100 0015 	add.w	r0, r0, #21
      d0 = Exp_1 | y >> (Ebits - k);
  20c904:	fa24 f10e 	lsr.w	r1, r4, lr
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
  20c908:	fa04 f000 	lsl.w	r0, r4, r0
      d0 = Exp_1 | y >> (Ebits - k);
  20c90c:	ea41 030c 	orr.w	r3, r1, ip
      w = xa > xa0 ? *--xa : 0;
  20c910:	bf34      	ite	cc
  20c912:	f855 1c08 	ldrcc.w	r1, [r5, #-8]
  20c916:	2100      	movcs	r1, #0
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
  20c918:	fa21 f10e 	lsr.w	r1, r1, lr
  20c91c:	ea40 0201 	orr.w	r2, r0, r1
  word1 (d) = d1 >> 16 | d1 << 16;
#else
#undef d0
#undef d1
#endif
  return d.d;
  20c920:	ec43 2b10 	vmov	d0, r2, r3
}
  20c924:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  z = xa > xa0 ? *--xa : 0;
  20c926:	42b7      	cmp	r7, r6
  20c928:	bf3a      	itte	cc
  20c92a:	f1a5 0608 	subcc.w	r6, r5, #8
  20c92e:	f855 1c08 	ldrcc.w	r1, [r5, #-8]
  20c932:	2100      	movcs	r1, #0
  if (k -= Ebits)
  20c934:	380b      	subs	r0, #11
  20c936:	d017      	beq.n	20c968 <__b2d+0x94>
      d0 = Exp_1 | y << k | z >> (32 - k);
  20c938:	f1c0 0c20 	rsb	ip, r0, #32
  20c93c:	fa04 f500 	lsl.w	r5, r4, r0
      y = xa > xa0 ? *--xa : 0;
  20c940:	42be      	cmp	r6, r7
      d1 = z << k | y >> (32 - k);
  20c942:	fa01 f000 	lsl.w	r0, r1, r0
      d0 = Exp_1 | y << k | z >> (32 - k);
  20c946:	fa21 f40c 	lsr.w	r4, r1, ip
  20c94a:	ea45 0504 	orr.w	r5, r5, r4
      y = xa > xa0 ? *--xa : 0;
  20c94e:	bf8c      	ite	hi
  20c950:	f856 4c04 	ldrhi.w	r4, [r6, #-4]
  20c954:	2400      	movls	r4, #0
      d0 = Exp_1 | y << k | z >> (32 - k);
  20c956:	f045 537f 	orr.w	r3, r5, #1069547520	; 0x3fc00000
      d1 = z << k | y >> (32 - k);
  20c95a:	fa24 f40c 	lsr.w	r4, r4, ip
      d0 = Exp_1 | y << k | z >> (32 - k);
  20c95e:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
      d1 = z << k | y >> (32 - k);
  20c962:	ea40 0204 	orr.w	r2, r0, r4
  20c966:	e7db      	b.n	20c920 <__b2d+0x4c>
      d0 = Exp_1 | y;
  20c968:	ea44 030c 	orr.w	r3, r4, ip
      d1 = z;
  20c96c:	460a      	mov	r2, r1
  20c96e:	e7d7      	b.n	20c920 <__b2d+0x4c>
  20c970:	3ff00000 	.word	0x3ff00000

0020c974 <__d2b>:
d2b (struct _reent * ptr,
	double _d,
	int *e,
	int *bits)

{
  20c974:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  20c978:	ec57 6b10 	vmov	r6, r7, d0
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
  20c97c:	f3c7 550a 	ubfx	r5, r7, #20, #11
{
  20c980:	4689      	mov	r9, r1
  b = Balloc (ptr, 1);
  20c982:	2101      	movs	r1, #1
{
  20c984:	4690      	mov	r8, r2
  b = Balloc (ptr, 1);
  20c986:	f7ff fc7c 	bl	20c282 <_Balloc>
  z = d0 & Frac_mask;
  20c98a:	f3c7 0313 	ubfx	r3, r7, #0, #20
  b = Balloc (ptr, 1);
  20c98e:	4604      	mov	r4, r0
  if ((de = (int) (d0 >> Exp_shift)) != 0)
  20c990:	bb35      	cbnz	r5, 20c9e0 <__d2b+0x6c>
    z |= Exp_msk1;
#endif
#ifdef Pack_32
#ifndef _DOUBLE_IS_32BITS
  if (d1)
  20c992:	2e00      	cmp	r6, #0
    z |= Exp_msk1;
  20c994:	9301      	str	r3, [sp, #4]
  if (d1)
  20c996:	d028      	beq.n	20c9ea <__d2b+0x76>
    {
      y = d1;
      k = lo0bits (&y);
  20c998:	4668      	mov	r0, sp
      y = d1;
  20c99a:	9600      	str	r6, [sp, #0]
      k = lo0bits (&y);
  20c99c:	f7ff fd59 	bl	20c452 <__lo0bits>
      if (k)
  20c9a0:	9900      	ldr	r1, [sp, #0]
  20c9a2:	b300      	cbz	r0, 20c9e6 <__d2b+0x72>
	{
         x[0] = y | z << (32 - k);
  20c9a4:	9a01      	ldr	r2, [sp, #4]
  20c9a6:	f1c0 0320 	rsb	r3, r0, #32
  20c9aa:	fa02 f303 	lsl.w	r3, r2, r3
	  z >>= k;
  20c9ae:	40c2      	lsrs	r2, r0
         x[0] = y | z << (32 - k);
  20c9b0:	430b      	orrs	r3, r1
	  z >>= k;
  20c9b2:	9201      	str	r2, [sp, #4]
         x[0] = y | z << (32 - k);
  20c9b4:	6163      	str	r3, [r4, #20]
	}
      else
	x[0] = y;
      i = b->_wds = (x[1] = z) ? 2 : 1;
  20c9b6:	9b01      	ldr	r3, [sp, #4]
  20c9b8:	2b00      	cmp	r3, #0
  20c9ba:	61a3      	str	r3, [r4, #24]
  20c9bc:	bf14      	ite	ne
  20c9be:	2202      	movne	r2, #2
  20c9c0:	2201      	moveq	r2, #1
  20c9c2:	6122      	str	r2, [r4, #16]
  while (!x[i])
    --i;
  b->_wds = i + 1;
#endif
#ifndef Sudden_Underflow
  if (de)
  20c9c4:	b1d5      	cbz	r5, 20c9fc <__d2b+0x88>
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
  20c9c6:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
  20c9ca:	4405      	add	r5, r0
      *bits = P - k;
  20c9cc:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
      *e = de - Bias - (P - 1) + k;
  20c9d0:	f8c9 5000 	str.w	r5, [r9]
    }
  else
    {
      *e = de - Bias - (P - 1) + 1 + k;
#ifdef Pack_32
      *bits = 32 * i - hi0bits (x[i - 1]);
  20c9d4:	f8c8 0000 	str.w	r0, [r8]
      *bits = (i + 2) * 16 - hi0bits (x[i]);
#endif
    }
#endif
  return b;
}
  20c9d8:	4620      	mov	r0, r4
  20c9da:	b003      	add	sp, #12
  20c9dc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    z |= Exp_msk1;
  20c9e0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  20c9e4:	e7d5      	b.n	20c992 <__d2b+0x1e>
	x[0] = y;
  20c9e6:	6161      	str	r1, [r4, #20]
  20c9e8:	e7e5      	b.n	20c9b6 <__d2b+0x42>
      k = lo0bits (&z);
  20c9ea:	a801      	add	r0, sp, #4
  20c9ec:	f7ff fd31 	bl	20c452 <__lo0bits>
      x[0] = z;
  20c9f0:	9b01      	ldr	r3, [sp, #4]
      i = b->_wds = 1;
  20c9f2:	2201      	movs	r2, #1
      k += 32;
  20c9f4:	3020      	adds	r0, #32
      x[0] = z;
  20c9f6:	6163      	str	r3, [r4, #20]
      i = b->_wds = 1;
  20c9f8:	6122      	str	r2, [r4, #16]
      k += 32;
  20c9fa:	e7e3      	b.n	20c9c4 <__d2b+0x50>
      *e = de - Bias - (P - 1) + 1 + k;
  20c9fc:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
      *bits = 32 * i - hi0bits (x[i - 1]);
  20ca00:	eb04 0382 	add.w	r3, r4, r2, lsl #2
      *e = de - Bias - (P - 1) + 1 + k;
  20ca04:	f8c9 0000 	str.w	r0, [r9]
      *bits = 32 * i - hi0bits (x[i - 1]);
  20ca08:	6918      	ldr	r0, [r3, #16]
  20ca0a:	f7ff fd02 	bl	20c412 <__hi0bits>
  20ca0e:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
  20ca12:	e7df      	b.n	20c9d4 <__d2b+0x60>

0020ca14 <__ratio>:
#undef d1

double
ratio (_Bigint * a, _Bigint * b)

{
  20ca14:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  20ca18:	468a      	mov	sl, r1
  20ca1a:	4683      	mov	fp, r0
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
  20ca1c:	4669      	mov	r1, sp
  20ca1e:	f7ff ff59 	bl	20c8d4 <__b2d>
  db.d = b2d (b, &kb);
  20ca22:	a901      	add	r1, sp, #4
  20ca24:	4650      	mov	r0, sl
  da.d = b2d (a, &ka);
  20ca26:	ee10 6a10 	vmov	r6, s0
  20ca2a:	ec59 8b10 	vmov	r8, r9, d0
  db.d = b2d (b, &kb);
  20ca2e:	f7ff ff51 	bl	20c8d4 <__b2d>
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
  20ca32:	f8db 3010 	ldr.w	r3, [fp, #16]
  20ca36:	f8da 2010 	ldr.w	r2, [sl, #16]
  da.d = b2d (a, &ka);
  20ca3a:	464f      	mov	r7, r9
  db.d = b2d (b, &kb);
  20ca3c:	ee10 0a10 	vmov	r0, s0
  k = ka - kb + 32 * (a->_wds - b->_wds);
  20ca40:	eba3 0c02 	sub.w	ip, r3, r2
  20ca44:	e9dd 3200 	ldrd	r3, r2, [sp]
  db.d = b2d (b, &kb);
  20ca48:	ec55 4b10 	vmov	r4, r5, d0
  k = ka - kb + 32 * (a->_wds - b->_wds);
  20ca4c:	1a9b      	subs	r3, r3, r2
  db.d = b2d (b, &kb);
  20ca4e:	4629      	mov	r1, r5
  k = ka - kb + 32 * (a->_wds - b->_wds);
  20ca50:	eb03 134c 	add.w	r3, r3, ip, lsl #5
      word0 (db) += (k >> 2) * Exp_msk1;
      if (k &= 3)
	db.d *= 1 << k;
    }
#else
  if (k > 0)
  20ca54:	2b00      	cmp	r3, #0
    word0 (da) += k * Exp_msk1;
  20ca56:	bfcd      	iteet	gt
  20ca58:	464a      	movgt	r2, r9
  else
    {
      k = -k;
      word0 (db) += k * Exp_msk1;
  20ca5a:	ebc3 3303 	rsble	r3, r3, r3, lsl #12
  20ca5e:	462a      	movle	r2, r5
    word0 (da) += k * Exp_msk1;
  20ca60:	eb02 5703 	addgt.w	r7, r2, r3, lsl #20
      word0 (db) += k * Exp_msk1;
  20ca64:	bfd8      	it	le
  20ca66:	eb02 5103 	addle.w	r1, r2, r3, lsl #20
    }
#endif
  return da.d / db.d;
}
  20ca6a:	ec47 6b17 	vmov	d7, r6, r7
  20ca6e:	ec41 0b16 	vmov	d6, r0, r1
  20ca72:	ee87 0b06 	vdiv.f64	d0, d7, d6
  20ca76:	b003      	add	sp, #12
  20ca78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0020ca7c <__copybits>:
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
  20ca7c:	3901      	subs	r1, #1
	x = b->_x;
  20ca7e:	f102 0314 	add.w	r3, r2, #20
	ce = c + ((n-1) >> kshift) + 1;
  20ca82:	1149      	asrs	r1, r1, #5
{
  20ca84:	b570      	push	{r4, r5, r6, lr}
	ce = c + ((n-1) >> kshift) + 1;
  20ca86:	3101      	adds	r1, #1
#ifdef Pack_32
	xe = x + b->_wds;
  20ca88:	6914      	ldr	r4, [r2, #16]
  20ca8a:	1f05      	subs	r5, r0, #4
	ce = c + ((n-1) >> kshift) + 1;
  20ca8c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	xe = x + b->_wds;
  20ca90:	eb03 0484 	add.w	r4, r3, r4, lsl #2
	while(x < xe)
  20ca94:	42a3      	cmp	r3, r4
  20ca96:	d30c      	bcc.n	20cab2 <__copybits+0x36>
  20ca98:	1aa3      	subs	r3, r4, r2
  20ca9a:	3211      	adds	r2, #17
  20ca9c:	3b11      	subs	r3, #17
  20ca9e:	f023 0303 	bic.w	r3, r3, #3
  20caa2:	42a2      	cmp	r2, r4
  20caa4:	bf88      	it	hi
  20caa6:	2300      	movhi	r3, #0
  20caa8:	4418      	add	r0, r3
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
		*c++ = 0;
  20caaa:	2300      	movs	r3, #0
	while(c < ce)
  20caac:	4288      	cmp	r0, r1
  20caae:	d305      	bcc.n	20cabc <__copybits+0x40>
}
  20cab0:	bd70      	pop	{r4, r5, r6, pc}
		*c++ = *x++;
  20cab2:	f853 6b04 	ldr.w	r6, [r3], #4
  20cab6:	f845 6f04 	str.w	r6, [r5, #4]!
  20caba:	e7eb      	b.n	20ca94 <__copybits+0x18>
		*c++ = 0;
  20cabc:	f840 3b04 	str.w	r3, [r0], #4
  20cac0:	e7f4      	b.n	20caac <__copybits+0x30>

0020cac2 <__any_on>:
	int k)
{
	int n, nwds;
	__ULong *x, *x0, x1, x2;

	x = b->_x;
  20cac2:	f100 0214 	add.w	r2, r0, #20
	nwds = b->_wds;
	n = k >> kshift;
  20cac6:	114b      	asrs	r3, r1, #5
	nwds = b->_wds;
  20cac8:	6900      	ldr	r0, [r0, #16]
	if (n > nwds)
  20caca:	4298      	cmp	r0, r3
{
  20cacc:	b510      	push	{r4, lr}
	if (n > nwds)
  20cace:	db11      	blt.n	20caf4 <__any_on+0x32>
		n = nwds;
	else if (n < nwds && (k &= kmask)) {
  20cad0:	dd0a      	ble.n	20cae8 <__any_on+0x26>
  20cad2:	f011 011f 	ands.w	r1, r1, #31
  20cad6:	d007      	beq.n	20cae8 <__any_on+0x26>
		x1 = x2 = x[n];
  20cad8:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
		x1 >>= k;
  20cadc:	fa24 f001 	lsr.w	r0, r4, r1
		x1 <<= k;
  20cae0:	fa00 f101 	lsl.w	r1, r0, r1
		if (x1 != x2)
  20cae4:	428c      	cmp	r4, r1
  20cae6:	d10b      	bne.n	20cb00 <__any_on+0x3e>
			return 1;
		}
	x0 = x;
	x += n;
  20cae8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	while(x > x0)
  20caec:	4293      	cmp	r3, r2
  20caee:	d803      	bhi.n	20caf8 <__any_on+0x36>
		if (*--x)
			return 1;
	return 0;
  20caf0:	2000      	movs	r0, #0
}
  20caf2:	bd10      	pop	{r4, pc}
  20caf4:	4603      	mov	r3, r0
  20caf6:	e7f7      	b.n	20cae8 <__any_on+0x26>
		if (*--x)
  20caf8:	f853 1d04 	ldr.w	r1, [r3, #-4]!
  20cafc:	2900      	cmp	r1, #0
  20cafe:	d0f5      	beq.n	20caec <__any_on+0x2a>
			return 1;
  20cb00:	2001      	movs	r0, #1
  20cb02:	e7f6      	b.n	20caf2 <__any_on+0x30>

0020cb04 <_calloc_r>:
    void * mem = nano_malloc(RCALL n * elem);
  20cb04:	434a      	muls	r2, r1
{
  20cb06:	b513      	push	{r0, r1, r4, lr}
    void * mem = nano_malloc(RCALL n * elem);
  20cb08:	4611      	mov	r1, r2
  20cb0a:	9201      	str	r2, [sp, #4]
  20cb0c:	f7fc fbdc 	bl	2092c8 <_malloc_r>
    if (mem != NULL) memset(mem, 0, n * elem);
  20cb10:	4604      	mov	r4, r0
  20cb12:	b118      	cbz	r0, 20cb1c <_calloc_r+0x18>
  20cb14:	9a01      	ldr	r2, [sp, #4]
  20cb16:	2100      	movs	r1, #0
  20cb18:	f7ff fbab 	bl	20c272 <memset>
}
  20cb1c:	4620      	mov	r0, r4
  20cb1e:	b002      	add	sp, #8
  20cb20:	bd10      	pop	{r4, pc}
	...

0020cb24 <_free_r>:
{
  20cb24:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if (free_p == NULL) return;
  20cb26:	2900      	cmp	r1, #0
  20cb28:	d047      	beq.n	20cbba <_free_r+0x96>
    if (c->size < 0) c = (chunk *)((char *)c + c->size);
  20cb2a:	f851 3c04 	ldr.w	r3, [r1, #-4]
    chunk * c = (chunk *)((char *)ptr - CHUNK_OFFSET);
  20cb2e:	1f0c      	subs	r4, r1, #4
    MALLOC_LOCK;
  20cb30:	9001      	str	r0, [sp, #4]
    if (c->size < 0) c = (chunk *)((char *)c + c->size);
  20cb32:	2b00      	cmp	r3, #0
  20cb34:	bfb8      	it	lt
  20cb36:	18e4      	addlt	r4, r4, r3
    MALLOC_LOCK;
  20cb38:	f7f7 fbb0 	bl	20429c <__malloc_lock>
    if (free_list == NULL)
  20cb3c:	4a20      	ldr	r2, [pc, #128]	; (20cbc0 <_free_r+0x9c>)
  20cb3e:	9801      	ldr	r0, [sp, #4]
  20cb40:	6813      	ldr	r3, [r2, #0]
  20cb42:	4615      	mov	r5, r2
  20cb44:	b933      	cbnz	r3, 20cb54 <_free_r+0x30>
        p_to_free->next = free_list;
  20cb46:	6063      	str	r3, [r4, #4]
        free_list = p_to_free;
  20cb48:	6014      	str	r4, [r2, #0]
}
  20cb4a:	b003      	add	sp, #12
  20cb4c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    MALLOC_UNLOCK;
  20cb50:	f7f9 ba7a 	b.w	206048 <__malloc_unlock>
    if (p_to_free < free_list)
  20cb54:	42a3      	cmp	r3, r4
  20cb56:	d90b      	bls.n	20cb70 <_free_r+0x4c>
        if ((char *)p_to_free + p_to_free->size == (char *)free_list)
  20cb58:	6821      	ldr	r1, [r4, #0]
  20cb5a:	1862      	adds	r2, r4, r1
  20cb5c:	4293      	cmp	r3, r2
            p_to_free->size += free_list->size;
  20cb5e:	bf02      	ittt	eq
  20cb60:	681a      	ldreq	r2, [r3, #0]
            p_to_free->next = free_list->next;
  20cb62:	685b      	ldreq	r3, [r3, #4]
            p_to_free->size += free_list->size;
  20cb64:	1852      	addeq	r2, r2, r1
            p_to_free->next = free_list;
  20cb66:	6063      	str	r3, [r4, #4]
            p_to_free->size += free_list->size;
  20cb68:	bf08      	it	eq
  20cb6a:	6022      	streq	r2, [r4, #0]
        free_list = p_to_free;
  20cb6c:	602c      	str	r4, [r5, #0]
        MALLOC_UNLOCK;
  20cb6e:	e7ec      	b.n	20cb4a <_free_r+0x26>
        q = q->next;
  20cb70:	461a      	mov	r2, r3
  20cb72:	685b      	ldr	r3, [r3, #4]
    } while (q && q <= p_to_free);
  20cb74:	b10b      	cbz	r3, 20cb7a <_free_r+0x56>
  20cb76:	42a3      	cmp	r3, r4
  20cb78:	d9fa      	bls.n	20cb70 <_free_r+0x4c>
    if ((char *)p + p->size == (char *)p_to_free)
  20cb7a:	6811      	ldr	r1, [r2, #0]
  20cb7c:	1855      	adds	r5, r2, r1
  20cb7e:	42a5      	cmp	r5, r4
  20cb80:	d10b      	bne.n	20cb9a <_free_r+0x76>
        p->size += p_to_free->size;
  20cb82:	6824      	ldr	r4, [r4, #0]
  20cb84:	4421      	add	r1, r4
        if ((char *)p + p->size == (char *) q)
  20cb86:	1854      	adds	r4, r2, r1
        p->size += p_to_free->size;
  20cb88:	6011      	str	r1, [r2, #0]
        if ((char *)p + p->size == (char *) q)
  20cb8a:	42a3      	cmp	r3, r4
  20cb8c:	d1dd      	bne.n	20cb4a <_free_r+0x26>
            p->size += q->size;
  20cb8e:	681c      	ldr	r4, [r3, #0]
            p->next = q->next;
  20cb90:	685b      	ldr	r3, [r3, #4]
            p->size += q->size;
  20cb92:	4421      	add	r1, r4
            p->next = q->next;
  20cb94:	6053      	str	r3, [r2, #4]
            p->size += q->size;
  20cb96:	6011      	str	r1, [r2, #0]
            p->next = q->next;
  20cb98:	e7d7      	b.n	20cb4a <_free_r+0x26>
    else if ((char *)p + p->size > (char *)p_to_free)
  20cb9a:	d902      	bls.n	20cba2 <_free_r+0x7e>
        RERRNO = ENOMEM;
  20cb9c:	230c      	movs	r3, #12
  20cb9e:	6003      	str	r3, [r0, #0]
        MALLOC_UNLOCK;
  20cba0:	e7d3      	b.n	20cb4a <_free_r+0x26>
    else if ((char *)p_to_free + p_to_free->size == (char *) q)
  20cba2:	6825      	ldr	r5, [r4, #0]
  20cba4:	1961      	adds	r1, r4, r5
  20cba6:	428b      	cmp	r3, r1
        p_to_free->size += q->size;
  20cba8:	bf02      	ittt	eq
  20cbaa:	6819      	ldreq	r1, [r3, #0]
        p_to_free->next = q->next;
  20cbac:	685b      	ldreq	r3, [r3, #4]
        p_to_free->size += q->size;
  20cbae:	1949      	addeq	r1, r1, r5
        p_to_free->next = q;
  20cbb0:	6063      	str	r3, [r4, #4]
        p_to_free->size += q->size;
  20cbb2:	bf08      	it	eq
  20cbb4:	6021      	streq	r1, [r4, #0]
        p->next = p_to_free;
  20cbb6:	6054      	str	r4, [r2, #4]
  20cbb8:	e7c7      	b.n	20cb4a <_free_r+0x26>
}
  20cbba:	b003      	add	sp, #12
  20cbbc:	bd30      	pop	{r4, r5, pc}
  20cbbe:	bf00      	nop
  20cbc0:	20004098 	.word	0x20004098

0020cbc4 <__ssputs_r>:
int
__ssputs_r (struct _reent *ptr,
       FILE *fp,
       const char *buf,
       size_t len)
{
  20cbc4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  register int w;

  w = fp->_w;
  20cbc8:	688e      	ldr	r6, [r1, #8]
{
  20cbca:	4682      	mov	sl, r0
  20cbcc:	460c      	mov	r4, r1
  20cbce:	4690      	mov	r8, r2
  if (len >= w && fp->_flags & (__SMBF | __SOPT))
  20cbd0:	429e      	cmp	r6, r3
{
  20cbd2:	461f      	mov	r7, r3
  if (len >= w && fp->_flags & (__SMBF | __SOPT))
  20cbd4:	d838      	bhi.n	20cc48 <__ssputs_r+0x84>
  20cbd6:	898a      	ldrh	r2, [r1, #12]
  20cbd8:	f412 6f90 	tst.w	r2, #1152	; 0x480
  20cbdc:	d032      	beq.n	20cc44 <__ssputs_r+0x80>
    {
      /* Must be asprintf family.  */
      unsigned char *str;
      int curpos = (fp->_p - fp->_bf._base);
  20cbde:	6825      	ldr	r5, [r4, #0]
       * overhead. asprintf EXPECTS us to overallocate, so
       * that it can add a trailing \0 without
       * reallocating.  The new allocation should thus be
       * max(prev_size*1.5, curpos+len+1).  */
      int newsize = fp->_bf._size * 3 / 2;
      if (newsize < curpos + len + 1)
  20cbe0:	3301      	adds	r3, #1
      int curpos = (fp->_p - fp->_bf._base);
  20cbe2:	6909      	ldr	r1, [r1, #16]
  20cbe4:	eba5 0901 	sub.w	r9, r5, r1
      int newsize = fp->_bf._size * 3 / 2;
  20cbe8:	6965      	ldr	r5, [r4, #20]
  20cbea:	eb05 0545 	add.w	r5, r5, r5, lsl #1
      if (newsize < curpos + len + 1)
  20cbee:	444b      	add	r3, r9
      int newsize = fp->_bf._size * 3 / 2;
  20cbf0:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
  20cbf4:	106d      	asrs	r5, r5, #1
	newsize = curpos + len + 1;
  20cbf6:	429d      	cmp	r5, r3
  20cbf8:	bf38      	it	cc
  20cbfa:	461d      	movcc	r5, r3
      if (fp->_flags & __SOPT)
  20cbfc:	0553      	lsls	r3, r2, #21
  20cbfe:	d531      	bpl.n	20cc64 <__ssputs_r+0xa0>
	{
	  /* asnprintf leaves original buffer alone.  */
	  str = (unsigned char *)_malloc_r (ptr, newsize);
  20cc00:	4629      	mov	r1, r5
  20cc02:	f7fc fb61 	bl	2092c8 <_malloc_r>
	  if (!str)
  20cc06:	4606      	mov	r6, r0
  20cc08:	b950      	cbnz	r0, 20cc20 <__ssputs_r+0x5c>
	  if (!str)
	    {
	      /* Free unneeded buffer.  */
	      _free_r (ptr, fp->_bf._base);
	      /* Ensure correct errno, even if free changed it.  */
	      ptr->_errno = ENOMEM;
  20cc0a:	230c      	movs	r3, #12
  fp->_p += w;
  return 0;

err:
  fp->_flags |= __SERR;
  return EOF;
  20cc0c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	      ptr->_errno = ENOMEM;
  20cc10:	f8ca 3000 	str.w	r3, [sl]
  fp->_flags |= __SERR;
  20cc14:	89a3      	ldrh	r3, [r4, #12]
  20cc16:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  20cc1a:	81a3      	strh	r3, [r4, #12]
}
  20cc1c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	  memcpy (str, fp->_bf._base, curpos);
  20cc20:	464a      	mov	r2, r9
  20cc22:	6921      	ldr	r1, [r4, #16]
  20cc24:	f7ff fb18 	bl	20c258 <memcpy>
	  fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
  20cc28:	89a3      	ldrh	r3, [r4, #12]
  20cc2a:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
  20cc2e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  20cc32:	81a3      	strh	r3, [r4, #12]
      fp->_bf._base = str;
  20cc34:	6126      	str	r6, [r4, #16]
      fp->_p = str + curpos;
  20cc36:	444e      	add	r6, r9
      fp->_bf._size = newsize;
  20cc38:	6165      	str	r5, [r4, #20]
      fp->_w = newsize - curpos;
  20cc3a:	eba5 0509 	sub.w	r5, r5, r9
      fp->_p = str + curpos;
  20cc3e:	6026      	str	r6, [r4, #0]
      w = len;
  20cc40:	463e      	mov	r6, r7
      fp->_w = newsize - curpos;
  20cc42:	60a5      	str	r5, [r4, #8]
  if (len < w)
  20cc44:	42be      	cmp	r6, r7
  20cc46:	d900      	bls.n	20cc4a <__ssputs_r+0x86>
    w = len;
  20cc48:	463e      	mov	r6, r7
  (void)memmove ((void *) fp->_p, (void *) buf, (size_t) (w));
  20cc4a:	4632      	mov	r2, r6
  20cc4c:	4641      	mov	r1, r8
  20cc4e:	6820      	ldr	r0, [r4, #0]
  20cc50:	f000 fcca 	bl	20d5e8 <memmove>
  fp->_w -= w;
  20cc54:	68a3      	ldr	r3, [r4, #8]
  fp->_p += w;
  20cc56:	6822      	ldr	r2, [r4, #0]
  return 0;
  20cc58:	2000      	movs	r0, #0
  fp->_w -= w;
  20cc5a:	1b9b      	subs	r3, r3, r6
  fp->_p += w;
  20cc5c:	4432      	add	r2, r6
  fp->_w -= w;
  20cc5e:	60a3      	str	r3, [r4, #8]
  fp->_p += w;
  20cc60:	6022      	str	r2, [r4, #0]
  return 0;
  20cc62:	e7db      	b.n	20cc1c <__ssputs_r+0x58>
	  str = (unsigned char *)_realloc_r (ptr, fp->_bf._base, newsize);
  20cc64:	462a      	mov	r2, r5
  20cc66:	f000 fcd9 	bl	20d61c <_realloc_r>
	  if (!str)
  20cc6a:	4606      	mov	r6, r0
  20cc6c:	2800      	cmp	r0, #0
  20cc6e:	d1e1      	bne.n	20cc34 <__ssputs_r+0x70>
	      _free_r (ptr, fp->_bf._base);
  20cc70:	6921      	ldr	r1, [r4, #16]
  20cc72:	4650      	mov	r0, sl
  20cc74:	f7ff ff56 	bl	20cb24 <_free_r>
  20cc78:	e7c7      	b.n	20cc0a <__ssputs_r+0x46>
	...

0020cc7c <_svfiprintf_r>:
int
_VFPRINTF_R (struct _reent *data,
       FILE * fp,
       const char *fmt0,
       va_list ap)
{
  20cc7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  20cc80:	4698      	mov	r8, r3
      return (EOF);
    }

#else
  /* Create initial buffer if we are called by asprintf family.  */
  if (fp->_flags & __SMBF && !fp->_bf._base)
  20cc82:	898b      	ldrh	r3, [r1, #12]
{
  20cc84:	b09d      	sub	sp, #116	; 0x74
  20cc86:	4607      	mov	r7, r0
  if (fp->_flags & __SMBF && !fp->_bf._base)
  20cc88:	061b      	lsls	r3, r3, #24
{
  20cc8a:	460d      	mov	r5, r1
  20cc8c:	4614      	mov	r4, r2
  if (fp->_flags & __SMBF && !fp->_bf._base)
  20cc8e:	d50e      	bpl.n	20ccae <_svfiprintf_r+0x32>
  20cc90:	690b      	ldr	r3, [r1, #16]
  20cc92:	b963      	cbnz	r3, 20ccae <_svfiprintf_r+0x32>
    {
      fp->_bf._base = fp->_p = _malloc_r (data, 64);
  20cc94:	2140      	movs	r1, #64	; 0x40
  20cc96:	f7fc fb17 	bl	2092c8 <_malloc_r>
  20cc9a:	6028      	str	r0, [r5, #0]
  20cc9c:	6128      	str	r0, [r5, #16]
      if (!fp->_p)
  20cc9e:	b920      	cbnz	r0, 20ccaa <_svfiprintf_r+0x2e>
	{
	  data->_errno = ENOMEM;
  20cca0:	230c      	movs	r3, #12
  20cca2:	603b      	str	r3, [r7, #0]
error:
#ifndef STRING_ONLY
  _newlib_flockfile_end (fp);
#endif
  va_end (ap_copy);
  return (__sferror (fp) ? EOF : prt_data.ret);
  20cca4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  20cca8:	e0d1      	b.n	20ce4e <_svfiprintf_r+0x1d2>
      fp->_bf._size = 64;
  20ccaa:	2340      	movs	r3, #64	; 0x40
  20ccac:	616b      	str	r3, [r5, #20]
  prt_data.ret = 0;
  20ccae:	2300      	movs	r3, #0
  va_copy (ap_copy, ap);
  20ccb0:	f8cd 800c 	str.w	r8, [sp, #12]
	prt_data.flags |= (1 << (cp - flag_chars));
  20ccb4:	f04f 0901 	mov.w	r9, #1
      for (; cp = memchr (flag_chars, *fmt, 5); fmt++)
  20ccb8:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 20ce68 <_svfiprintf_r+0x1ec>
  prt_data.ret = 0;
  20ccbc:	9309      	str	r3, [sp, #36]	; 0x24
  prt_data.blank = ' ';
  20ccbe:	2320      	movs	r3, #32
  20ccc0:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
  prt_data.zero = '0';
  20ccc4:	2330      	movs	r3, #48	; 0x30
  20ccc6:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
      while (*fmt != '\0' && *fmt != '%')
  20ccca:	4623      	mov	r3, r4
  20cccc:	469a      	mov	sl, r3
  20ccce:	f813 2b01 	ldrb.w	r2, [r3], #1
  20ccd2:	b10a      	cbz	r2, 20ccd8 <_svfiprintf_r+0x5c>
  20ccd4:	2a25      	cmp	r2, #37	; 0x25
  20ccd6:	d1f9      	bne.n	20cccc <_svfiprintf_r+0x50>
      if ((m = fmt - cp) != 0)
  20ccd8:	ebba 0b04 	subs.w	fp, sl, r4
  20ccdc:	d00b      	beq.n	20ccf6 <_svfiprintf_r+0x7a>
	  PRINT (cp, m);
  20ccde:	465b      	mov	r3, fp
  20cce0:	4622      	mov	r2, r4
  20cce2:	4629      	mov	r1, r5
  20cce4:	4638      	mov	r0, r7
  20cce6:	f7ff ff6d 	bl	20cbc4 <__ssputs_r>
  20ccea:	3001      	adds	r0, #1
  20ccec:	f000 80aa 	beq.w	20ce44 <_svfiprintf_r+0x1c8>
	  prt_data.ret += m;
  20ccf0:	9a09      	ldr	r2, [sp, #36]	; 0x24
  20ccf2:	445a      	add	r2, fp
  20ccf4:	9209      	str	r2, [sp, #36]	; 0x24
      if (*fmt == '\0')
  20ccf6:	f89a 3000 	ldrb.w	r3, [sl]
  20ccfa:	2b00      	cmp	r3, #0
  20ccfc:	f000 80a2 	beq.w	20ce44 <_svfiprintf_r+0x1c8>
      prt_data.flags = 0;
  20cd00:	2300      	movs	r3, #0
      prt_data.prec = -1;
  20cd02:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
      fmt++;		/* Skip over '%'.  */
  20cd06:	f10a 0a01 	add.w	sl, sl, #1
      prt_data.flags = 0;
  20cd0a:	9304      	str	r3, [sp, #16]
      prt_data.width = 0;
  20cd0c:	9307      	str	r3, [sp, #28]
      prt_data.l_buf[0] = '\0';
  20cd0e:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
      prt_data.lead = 0;
  20cd12:	931a      	str	r3, [sp, #104]	; 0x68
      prt_data.dprec = 0;
  20cd14:	e9cd 2305 	strd	r2, r3, [sp, #20]
      for (; cp = memchr (flag_chars, *fmt, 5); fmt++)
  20cd18:	4654      	mov	r4, sl
  20cd1a:	2205      	movs	r2, #5
  20cd1c:	4852      	ldr	r0, [pc, #328]	; (20ce68 <_svfiprintf_r+0x1ec>)
  20cd1e:	f814 1b01 	ldrb.w	r1, [r4], #1
  20cd22:	f7f3 fb45 	bl	2003b0 <memchr>
  20cd26:	9a04      	ldr	r2, [sp, #16]
  20cd28:	b9d8      	cbnz	r0, 20cd62 <_svfiprintf_r+0xe6>
      if (prt_data.flags & SPACESGN)
  20cd2a:	06d0      	lsls	r0, r2, #27
	prt_data.l_buf[0] = ' ';
  20cd2c:	bf44      	itt	mi
  20cd2e:	2320      	movmi	r3, #32
  20cd30:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
      if (prt_data.flags & PLUSSGN)
  20cd34:	0711      	lsls	r1, r2, #28
	prt_data.l_buf[0] = '+';
  20cd36:	bf44      	itt	mi
  20cd38:	232b      	movmi	r3, #43	; 0x2b
  20cd3a:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
      if (*fmt == '*')
  20cd3e:	f89a 3000 	ldrb.w	r3, [sl]
  20cd42:	2b2a      	cmp	r3, #42	; 0x2a
  20cd44:	d015      	beq.n	20cd72 <_svfiprintf_r+0xf6>
  20cd46:	9a07      	ldr	r2, [sp, #28]
  20cd48:	4654      	mov	r4, sl
  20cd4a:	2000      	movs	r0, #0
	    prt_data.width = 10 * prt_data.width + to_digit (*fmt);
  20cd4c:	f04f 0c0a 	mov.w	ip, #10
	  for (; is_digit (*fmt); fmt++)
  20cd50:	4621      	mov	r1, r4
  20cd52:	f811 3b01 	ldrb.w	r3, [r1], #1
  20cd56:	3b30      	subs	r3, #48	; 0x30
  20cd58:	2b09      	cmp	r3, #9
  20cd5a:	d94e      	bls.n	20cdfa <_svfiprintf_r+0x17e>
  20cd5c:	b1b0      	cbz	r0, 20cd8c <_svfiprintf_r+0x110>
  20cd5e:	9207      	str	r2, [sp, #28]
  20cd60:	e014      	b.n	20cd8c <_svfiprintf_r+0x110>
	prt_data.flags |= (1 << (cp - flag_chars));
  20cd62:	eba0 0308 	sub.w	r3, r0, r8
  20cd66:	46a2      	mov	sl, r4
  20cd68:	fa09 f303 	lsl.w	r3, r9, r3
  20cd6c:	4313      	orrs	r3, r2
  20cd6e:	9304      	str	r3, [sp, #16]
  20cd70:	e7d2      	b.n	20cd18 <_svfiprintf_r+0x9c>
	  prt_data.width = GET_ARG (n, ap_copy, int);
  20cd72:	9b03      	ldr	r3, [sp, #12]
  20cd74:	1d19      	adds	r1, r3, #4
  20cd76:	681b      	ldr	r3, [r3, #0]
	  if (prt_data.width < 0)
  20cd78:	2b00      	cmp	r3, #0
	  prt_data.width = GET_ARG (n, ap_copy, int);
  20cd7a:	9103      	str	r1, [sp, #12]
	      prt_data.width = -prt_data.width;
  20cd7c:	bfbb      	ittet	lt
  20cd7e:	425b      	neglt	r3, r3
	      prt_data.flags |= LADJUST;
  20cd80:	f042 0202 	orrlt.w	r2, r2, #2
	  prt_data.width = GET_ARG (n, ap_copy, int);
  20cd84:	9307      	strge	r3, [sp, #28]
	      prt_data.width = -prt_data.width;
  20cd86:	9307      	strlt	r3, [sp, #28]
	      prt_data.flags |= LADJUST;
  20cd88:	bfb8      	it	lt
  20cd8a:	9204      	strlt	r2, [sp, #16]
      if (*fmt == '.')
  20cd8c:	7823      	ldrb	r3, [r4, #0]
  20cd8e:	2b2e      	cmp	r3, #46	; 0x2e
  20cd90:	d10c      	bne.n	20cdac <_svfiprintf_r+0x130>
	  if (*fmt == '*')
  20cd92:	7863      	ldrb	r3, [r4, #1]
  20cd94:	2b2a      	cmp	r3, #42	; 0x2a
  20cd96:	d135      	bne.n	20ce04 <_svfiprintf_r+0x188>
	      prt_data.prec = GET_ARG (n, ap_copy, int);
  20cd98:	9b03      	ldr	r3, [sp, #12]
	      fmt++;
  20cd9a:	3402      	adds	r4, #2
	      prt_data.prec = GET_ARG (n, ap_copy, int);
  20cd9c:	1d1a      	adds	r2, r3, #4
  20cd9e:	681b      	ldr	r3, [r3, #0]
	      if (prt_data.prec < 0)
  20cda0:	2b00      	cmp	r3, #0
	      prt_data.prec = GET_ARG (n, ap_copy, int);
  20cda2:	9203      	str	r2, [sp, #12]
		prt_data.prec = -1;
  20cda4:	bfb8      	it	lt
  20cda6:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
  20cdaa:	9305      	str	r3, [sp, #20]
      if ((cp = memchr (flag_chars, *fmt, 3)) != NULL)
  20cdac:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 20ce78 <_svfiprintf_r+0x1fc>
  20cdb0:	2203      	movs	r2, #3
  20cdb2:	7821      	ldrb	r1, [r4, #0]
  20cdb4:	4650      	mov	r0, sl
  20cdb6:	f7f3 fafb 	bl	2003b0 <memchr>
  20cdba:	b140      	cbz	r0, 20cdce <_svfiprintf_r+0x152>
	  prt_data.flags |= (SHORTINT << (cp - flag_chars));
  20cdbc:	2340      	movs	r3, #64	; 0x40
  20cdbe:	eba0 000a 	sub.w	r0, r0, sl
  20cdc2:	3401      	adds	r4, #1
  20cdc4:	fa03 f000 	lsl.w	r0, r3, r0
  20cdc8:	9b04      	ldr	r3, [sp, #16]
  20cdca:	4303      	orrs	r3, r0
  20cdcc:	9304      	str	r3, [sp, #16]
      prt_data.code = *fmt++;
  20cdce:	f814 1b01 	ldrb.w	r1, [r4], #1
      cp = memchr ("efgEFG", prt_data.code, 6);
  20cdd2:	2206      	movs	r2, #6
  20cdd4:	4825      	ldr	r0, [pc, #148]	; (20ce6c <_svfiprintf_r+0x1f0>)
      prt_data.code = *fmt++;
  20cdd6:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
      cp = memchr ("efgEFG", prt_data.code, 6);
  20cdda:	f7f3 fae9 	bl	2003b0 <memchr>
      if (cp)
  20cdde:	2800      	cmp	r0, #0
  20cde0:	d038      	beq.n	20ce54 <_svfiprintf_r+0x1d8>
	  if (_printf_float == NULL)
  20cde2:	4b23      	ldr	r3, [pc, #140]	; (20ce70 <_svfiprintf_r+0x1f4>)
  20cde4:	bb1b      	cbnz	r3, 20ce2e <_svfiprintf_r+0x1b2>
		GET_ARG (N, ap_copy, double);
  20cde6:	9b03      	ldr	r3, [sp, #12]
  20cde8:	3307      	adds	r3, #7
  20cdea:	f023 0307 	bic.w	r3, r3, #7
  20cdee:	3308      	adds	r3, #8
  20cdf0:	9303      	str	r3, [sp, #12]
      prt_data.ret += n;
  20cdf2:	9b09      	ldr	r3, [sp, #36]	; 0x24
  20cdf4:	4433      	add	r3, r6
  20cdf6:	9309      	str	r3, [sp, #36]	; 0x24
      cp = fmt;
  20cdf8:	e767      	b.n	20ccca <_svfiprintf_r+0x4e>
	    prt_data.width = 10 * prt_data.width + to_digit (*fmt);
  20cdfa:	fb0c 3202 	mla	r2, ip, r2, r3
	  for (; is_digit (*fmt); fmt++)
  20cdfe:	460c      	mov	r4, r1
	    prt_data.width = 10 * prt_data.width + to_digit (*fmt);
  20ce00:	2001      	movs	r0, #1
  20ce02:	e7a5      	b.n	20cd50 <_svfiprintf_r+0xd4>
	      prt_data.prec = 0;
  20ce04:	2300      	movs	r3, #0
  20ce06:	3401      	adds	r4, #1
		prt_data.prec = 10 * prt_data.prec + to_digit (*fmt);
  20ce08:	f04f 0c0a 	mov.w	ip, #10
	      for (; is_digit (*fmt); fmt++)
  20ce0c:	4619      	mov	r1, r3
	      prt_data.prec = 0;
  20ce0e:	9305      	str	r3, [sp, #20]
	      for (; is_digit (*fmt); fmt++)
  20ce10:	4620      	mov	r0, r4
  20ce12:	f810 2b01 	ldrb.w	r2, [r0], #1
  20ce16:	3a30      	subs	r2, #48	; 0x30
  20ce18:	2a09      	cmp	r2, #9
  20ce1a:	d903      	bls.n	20ce24 <_svfiprintf_r+0x1a8>
  20ce1c:	2b00      	cmp	r3, #0
  20ce1e:	d0c5      	beq.n	20cdac <_svfiprintf_r+0x130>
  20ce20:	9105      	str	r1, [sp, #20]
  20ce22:	e7c3      	b.n	20cdac <_svfiprintf_r+0x130>
		prt_data.prec = 10 * prt_data.prec + to_digit (*fmt);
  20ce24:	fb0c 2101 	mla	r1, ip, r1, r2
	      for (; is_digit (*fmt); fmt++)
  20ce28:	4604      	mov	r4, r0
		prt_data.prec = 10 * prt_data.prec + to_digit (*fmt);
  20ce2a:	2301      	movs	r3, #1
  20ce2c:	e7f0      	b.n	20ce10 <_svfiprintf_r+0x194>
            n = _printf_float (data, &prt_data, fp, pfunc, &ap_copy);
  20ce2e:	ab03      	add	r3, sp, #12
  20ce30:	462a      	mov	r2, r5
  20ce32:	a904      	add	r1, sp, #16
  20ce34:	4638      	mov	r0, r7
  20ce36:	9300      	str	r3, [sp, #0]
  20ce38:	4b0e      	ldr	r3, [pc, #56]	; (20ce74 <_svfiprintf_r+0x1f8>)
  20ce3a:	f7fc fb59 	bl	2094f0 <_printf_float>
      if (n == -1)
  20ce3e:	1c42      	adds	r2, r0, #1
	n = _printf_i (data, &prt_data, fp, pfunc, &ap_copy);
  20ce40:	4606      	mov	r6, r0
      if (n == -1)
  20ce42:	d1d6      	bne.n	20cdf2 <_svfiprintf_r+0x176>
  return (__sferror (fp) ? EOF : prt_data.ret);
  20ce44:	89ab      	ldrh	r3, [r5, #12]
  20ce46:	065b      	lsls	r3, r3, #25
  20ce48:	f53f af2c 	bmi.w	20cca4 <_svfiprintf_r+0x28>
  20ce4c:	9809      	ldr	r0, [sp, #36]	; 0x24
}
  20ce4e:	b01d      	add	sp, #116	; 0x74
  20ce50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	n = _printf_i (data, &prt_data, fp, pfunc, &ap_copy);
  20ce54:	ab03      	add	r3, sp, #12
  20ce56:	462a      	mov	r2, r5
  20ce58:	a904      	add	r1, sp, #16
  20ce5a:	4638      	mov	r0, r7
  20ce5c:	9300      	str	r3, [sp, #0]
  20ce5e:	4b05      	ldr	r3, [pc, #20]	; (20ce74 <_svfiprintf_r+0x1f8>)
  20ce60:	f7fc fdd4 	bl	209a0c <_printf_i>
  20ce64:	e7eb      	b.n	20ce3e <_svfiprintf_r+0x1c2>
  20ce66:	bf00      	nop
  20ce68:	0800eec4 	.word	0x0800eec4
  20ce6c:	0800eece 	.word	0x0800eece
  20ce70:	002094f1 	.word	0x002094f1
  20ce74:	0020cbc5 	.word	0x0020cbc5
  20ce78:	0800eeca 	.word	0x0800eeca

0020ce7c <__sfputc_r>:
  if (--fp->_w >= 0 || (fp->_w >= fp->_lbfsize && (char)c != '\n'))
  20ce7c:	6893      	ldr	r3, [r2, #8]
  20ce7e:	3b01      	subs	r3, #1
  20ce80:	2b00      	cmp	r3, #0
  20ce82:	6093      	str	r3, [r2, #8]
{
  20ce84:	b410      	push	{r4}
  if (--fp->_w >= 0 || (fp->_w >= fp->_lbfsize && (char)c != '\n'))
  20ce86:	da08      	bge.n	20ce9a <__sfputc_r+0x1e>
  20ce88:	6994      	ldr	r4, [r2, #24]
  20ce8a:	42a3      	cmp	r3, r4
  20ce8c:	db01      	blt.n	20ce92 <__sfputc_r+0x16>
  20ce8e:	290a      	cmp	r1, #10
  20ce90:	d103      	bne.n	20ce9a <__sfputc_r+0x1e>
}
  20ce92:	f85d 4b04 	ldr.w	r4, [sp], #4
    return (__swbuf_r(ptr, c, fp));
  20ce96:	f000 b991 	b.w	20d1bc <__swbuf_r>
    return (*fp->_p++ = c);
  20ce9a:	6813      	ldr	r3, [r2, #0]
  20ce9c:	1c58      	adds	r0, r3, #1
  20ce9e:	6010      	str	r0, [r2, #0]
}
  20cea0:	4608      	mov	r0, r1
    return (*fp->_p++ = c);
  20cea2:	7019      	strb	r1, [r3, #0]
}
  20cea4:	f85d 4b04 	ldr.w	r4, [sp], #4
  20cea8:	4770      	bx	lr

0020ceaa <__sfputs_r>:
{
  20ceaa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  20ceac:	4606      	mov	r6, r0
  20ceae:	460f      	mov	r7, r1
      for (i = 0; i < len; i++)
  20ceb0:	4614      	mov	r4, r2
  20ceb2:	18d5      	adds	r5, r2, r3
  20ceb4:	42ac      	cmp	r4, r5
  20ceb6:	d101      	bne.n	20cebc <__sfputs_r+0x12>
  return (0);
  20ceb8:	2000      	movs	r0, #0
  20ceba:	e007      	b.n	20cecc <__sfputs_r+0x22>
	  if (__sfputc_r (ptr, (int)buf[i], fp) == EOF)
  20cebc:	463a      	mov	r2, r7
  20cebe:	f814 1b01 	ldrb.w	r1, [r4], #1
  20cec2:	4630      	mov	r0, r6
  20cec4:	f7ff ffda 	bl	20ce7c <__sfputc_r>
  20cec8:	1c43      	adds	r3, r0, #1
  20ceca:	d1f3      	bne.n	20ceb4 <__sfputs_r+0xa>
}
  20cecc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0020ced0 <_vfiprintf_r>:
{
  20ced0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  20ced4:	460d      	mov	r5, r1
  20ced6:	b09d      	sub	sp, #116	; 0x74
  20ced8:	4614      	mov	r4, r2
  20ceda:	4698      	mov	r8, r3
  CHECK_INIT (data, fp);
  20cedc:	4606      	mov	r6, r0
  20cede:	b118      	cbz	r0, 20cee8 <_vfiprintf_r+0x18>
  20cee0:	6983      	ldr	r3, [r0, #24]
  20cee2:	b90b      	cbnz	r3, 20cee8 <_vfiprintf_r+0x18>
  20cee4:	f7fe fd98 	bl	20ba18 <__sinit>
  20cee8:	4b7c      	ldr	r3, [pc, #496]	; (20d0dc <_vfiprintf_r+0x20c>)
  20ceea:	429d      	cmp	r5, r3
  20ceec:	d161      	bne.n	20cfb2 <_vfiprintf_r+0xe2>
  20ceee:	6875      	ldr	r5, [r6, #4]
  if (cantwrite (data, fp))
  20cef0:	89ab      	ldrh	r3, [r5, #12]
  20cef2:	071b      	lsls	r3, r3, #28
  20cef4:	d567      	bpl.n	20cfc6 <_vfiprintf_r+0xf6>
  20cef6:	692b      	ldr	r3, [r5, #16]
  20cef8:	2b00      	cmp	r3, #0
  20cefa:	d064      	beq.n	20cfc6 <_vfiprintf_r+0xf6>
  prt_data.ret = 0;
  20cefc:	2300      	movs	r3, #0
  va_copy (ap_copy, ap);
  20cefe:	f8cd 800c 	str.w	r8, [sp, #12]
	prt_data.flags |= (1 << (cp - flag_chars));
  20cf02:	f04f 0901 	mov.w	r9, #1
      for (; cp = memchr (flag_chars, *fmt, 5); fmt++)
  20cf06:	f8df 81d8 	ldr.w	r8, [pc, #472]	; 20d0e0 <_vfiprintf_r+0x210>
  prt_data.ret = 0;
  20cf0a:	9309      	str	r3, [sp, #36]	; 0x24
  prt_data.blank = ' ';
  20cf0c:	2320      	movs	r3, #32
  20cf0e:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
  prt_data.zero = '0';
  20cf12:	2330      	movs	r3, #48	; 0x30
  20cf14:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
      while (*fmt != '\0' && *fmt != '%')
  20cf18:	4623      	mov	r3, r4
  20cf1a:	469a      	mov	sl, r3
  20cf1c:	f813 2b01 	ldrb.w	r2, [r3], #1
  20cf20:	b10a      	cbz	r2, 20cf26 <_vfiprintf_r+0x56>
  20cf22:	2a25      	cmp	r2, #37	; 0x25
  20cf24:	d1f9      	bne.n	20cf1a <_vfiprintf_r+0x4a>
      if ((m = fmt - cp) != 0)
  20cf26:	ebba 0b04 	subs.w	fp, sl, r4
  20cf2a:	d00b      	beq.n	20cf44 <_vfiprintf_r+0x74>
	  PRINT (cp, m);
  20cf2c:	465b      	mov	r3, fp
  20cf2e:	4622      	mov	r2, r4
  20cf30:	4629      	mov	r1, r5
  20cf32:	4630      	mov	r0, r6
  20cf34:	f7ff ffb9 	bl	20ceaa <__sfputs_r>
  20cf38:	3001      	adds	r0, #1
  20cf3a:	f000 80c0 	beq.w	20d0be <_vfiprintf_r+0x1ee>
	  prt_data.ret += m;
  20cf3e:	9a09      	ldr	r2, [sp, #36]	; 0x24
  20cf40:	445a      	add	r2, fp
  20cf42:	9209      	str	r2, [sp, #36]	; 0x24
      if (*fmt == '\0')
  20cf44:	f89a 3000 	ldrb.w	r3, [sl]
  20cf48:	2b00      	cmp	r3, #0
  20cf4a:	f000 80b8 	beq.w	20d0be <_vfiprintf_r+0x1ee>
      prt_data.flags = 0;
  20cf4e:	2300      	movs	r3, #0
      prt_data.prec = -1;
  20cf50:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
      fmt++;		/* Skip over '%'.  */
  20cf54:	f10a 0a01 	add.w	sl, sl, #1
      prt_data.flags = 0;
  20cf58:	9304      	str	r3, [sp, #16]
      prt_data.width = 0;
  20cf5a:	9307      	str	r3, [sp, #28]
      prt_data.l_buf[0] = '\0';
  20cf5c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
      prt_data.lead = 0;
  20cf60:	931a      	str	r3, [sp, #104]	; 0x68
      prt_data.dprec = 0;
  20cf62:	e9cd 2305 	strd	r2, r3, [sp, #20]
      for (; cp = memchr (flag_chars, *fmt, 5); fmt++)
  20cf66:	4654      	mov	r4, sl
  20cf68:	2205      	movs	r2, #5
  20cf6a:	485d      	ldr	r0, [pc, #372]	; (20d0e0 <_vfiprintf_r+0x210>)
  20cf6c:	f814 1b01 	ldrb.w	r1, [r4], #1
  20cf70:	f7f3 fa1e 	bl	2003b0 <memchr>
  20cf74:	9a04      	ldr	r2, [sp, #16]
  20cf76:	2800      	cmp	r0, #0
  20cf78:	d130      	bne.n	20cfdc <_vfiprintf_r+0x10c>
      if (prt_data.flags & SPACESGN)
  20cf7a:	06d0      	lsls	r0, r2, #27
	prt_data.l_buf[0] = ' ';
  20cf7c:	bf44      	itt	mi
  20cf7e:	2320      	movmi	r3, #32
  20cf80:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
      if (prt_data.flags & PLUSSGN)
  20cf84:	0711      	lsls	r1, r2, #28
	prt_data.l_buf[0] = '+';
  20cf86:	bf44      	itt	mi
  20cf88:	232b      	movmi	r3, #43	; 0x2b
  20cf8a:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
      if (*fmt == '*')
  20cf8e:	f89a 3000 	ldrb.w	r3, [sl]
  20cf92:	2b2a      	cmp	r3, #42	; 0x2a
  20cf94:	d02a      	beq.n	20cfec <_vfiprintf_r+0x11c>
  20cf96:	9a07      	ldr	r2, [sp, #28]
  20cf98:	4654      	mov	r4, sl
  20cf9a:	2000      	movs	r0, #0
	    prt_data.width = 10 * prt_data.width + to_digit (*fmt);
  20cf9c:	f04f 0c0a 	mov.w	ip, #10
	  for (; is_digit (*fmt); fmt++)
  20cfa0:	4621      	mov	r1, r4
  20cfa2:	f811 3b01 	ldrb.w	r3, [r1], #1
  20cfa6:	3b30      	subs	r3, #48	; 0x30
  20cfa8:	2b09      	cmp	r3, #9
  20cfaa:	d963      	bls.n	20d074 <_vfiprintf_r+0x1a4>
  20cfac:	b358      	cbz	r0, 20d006 <_vfiprintf_r+0x136>
  20cfae:	9207      	str	r2, [sp, #28]
  20cfb0:	e029      	b.n	20d006 <_vfiprintf_r+0x136>
  CHECK_INIT (data, fp);
  20cfb2:	4b4c      	ldr	r3, [pc, #304]	; (20d0e4 <_vfiprintf_r+0x214>)
  20cfb4:	429d      	cmp	r5, r3
  20cfb6:	d101      	bne.n	20cfbc <_vfiprintf_r+0xec>
  20cfb8:	68b5      	ldr	r5, [r6, #8]
  20cfba:	e799      	b.n	20cef0 <_vfiprintf_r+0x20>
  20cfbc:	4b4a      	ldr	r3, [pc, #296]	; (20d0e8 <_vfiprintf_r+0x218>)
  20cfbe:	429d      	cmp	r5, r3
  20cfc0:	bf08      	it	eq
  20cfc2:	68f5      	ldreq	r5, [r6, #12]
  20cfc4:	e794      	b.n	20cef0 <_vfiprintf_r+0x20>
  if (cantwrite (data, fp))
  20cfc6:	4629      	mov	r1, r5
  20cfc8:	4630      	mov	r0, r6
  20cfca:	f000 f969 	bl	20d2a0 <__swsetup_r>
  20cfce:	2800      	cmp	r0, #0
  20cfd0:	d094      	beq.n	20cefc <_vfiprintf_r+0x2c>
      return (EOF);
  20cfd2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  20cfd6:	b01d      	add	sp, #116	; 0x74
  20cfd8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	prt_data.flags |= (1 << (cp - flag_chars));
  20cfdc:	eba0 0308 	sub.w	r3, r0, r8
  20cfe0:	46a2      	mov	sl, r4
  20cfe2:	fa09 f303 	lsl.w	r3, r9, r3
  20cfe6:	4313      	orrs	r3, r2
  20cfe8:	9304      	str	r3, [sp, #16]
  20cfea:	e7bc      	b.n	20cf66 <_vfiprintf_r+0x96>
	  prt_data.width = GET_ARG (n, ap_copy, int);
  20cfec:	9b03      	ldr	r3, [sp, #12]
  20cfee:	1d19      	adds	r1, r3, #4
  20cff0:	681b      	ldr	r3, [r3, #0]
	  if (prt_data.width < 0)
  20cff2:	2b00      	cmp	r3, #0
	  prt_data.width = GET_ARG (n, ap_copy, int);
  20cff4:	9103      	str	r1, [sp, #12]
	      prt_data.width = -prt_data.width;
  20cff6:	bfbb      	ittet	lt
  20cff8:	425b      	neglt	r3, r3
	      prt_data.flags |= LADJUST;
  20cffa:	f042 0202 	orrlt.w	r2, r2, #2
	  prt_data.width = GET_ARG (n, ap_copy, int);
  20cffe:	9307      	strge	r3, [sp, #28]
	      prt_data.width = -prt_data.width;
  20d000:	9307      	strlt	r3, [sp, #28]
	      prt_data.flags |= LADJUST;
  20d002:	bfb8      	it	lt
  20d004:	9204      	strlt	r2, [sp, #16]
      if (*fmt == '.')
  20d006:	7823      	ldrb	r3, [r4, #0]
  20d008:	2b2e      	cmp	r3, #46	; 0x2e
  20d00a:	d10c      	bne.n	20d026 <_vfiprintf_r+0x156>
	  if (*fmt == '*')
  20d00c:	7863      	ldrb	r3, [r4, #1]
  20d00e:	2b2a      	cmp	r3, #42	; 0x2a
  20d010:	d135      	bne.n	20d07e <_vfiprintf_r+0x1ae>
	      prt_data.prec = GET_ARG (n, ap_copy, int);
  20d012:	9b03      	ldr	r3, [sp, #12]
	      fmt++;
  20d014:	3402      	adds	r4, #2
	      prt_data.prec = GET_ARG (n, ap_copy, int);
  20d016:	1d1a      	adds	r2, r3, #4
  20d018:	681b      	ldr	r3, [r3, #0]
	      if (prt_data.prec < 0)
  20d01a:	2b00      	cmp	r3, #0
	      prt_data.prec = GET_ARG (n, ap_copy, int);
  20d01c:	9203      	str	r2, [sp, #12]
		prt_data.prec = -1;
  20d01e:	bfb8      	it	lt
  20d020:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
  20d024:	9305      	str	r3, [sp, #20]
      if ((cp = memchr (flag_chars, *fmt, 3)) != NULL)
  20d026:	f8df a0d0 	ldr.w	sl, [pc, #208]	; 20d0f8 <_vfiprintf_r+0x228>
  20d02a:	2203      	movs	r2, #3
  20d02c:	7821      	ldrb	r1, [r4, #0]
  20d02e:	4650      	mov	r0, sl
  20d030:	f7f3 f9be 	bl	2003b0 <memchr>
  20d034:	b140      	cbz	r0, 20d048 <_vfiprintf_r+0x178>
	  prt_data.flags |= (SHORTINT << (cp - flag_chars));
  20d036:	2340      	movs	r3, #64	; 0x40
  20d038:	eba0 000a 	sub.w	r0, r0, sl
  20d03c:	3401      	adds	r4, #1
  20d03e:	fa03 f000 	lsl.w	r0, r3, r0
  20d042:	9b04      	ldr	r3, [sp, #16]
  20d044:	4303      	orrs	r3, r0
  20d046:	9304      	str	r3, [sp, #16]
      prt_data.code = *fmt++;
  20d048:	f814 1b01 	ldrb.w	r1, [r4], #1
      cp = memchr ("efgEFG", prt_data.code, 6);
  20d04c:	2206      	movs	r2, #6
  20d04e:	4827      	ldr	r0, [pc, #156]	; (20d0ec <_vfiprintf_r+0x21c>)
      prt_data.code = *fmt++;
  20d050:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
      cp = memchr ("efgEFG", prt_data.code, 6);
  20d054:	f7f3 f9ac 	bl	2003b0 <memchr>
      if (cp)
  20d058:	2800      	cmp	r0, #0
  20d05a:	d035      	beq.n	20d0c8 <_vfiprintf_r+0x1f8>
	  if (_printf_float == NULL)
  20d05c:	4b24      	ldr	r3, [pc, #144]	; (20d0f0 <_vfiprintf_r+0x220>)
  20d05e:	bb1b      	cbnz	r3, 20d0a8 <_vfiprintf_r+0x1d8>
		GET_ARG (N, ap_copy, double);
  20d060:	9b03      	ldr	r3, [sp, #12]
  20d062:	3307      	adds	r3, #7
  20d064:	f023 0307 	bic.w	r3, r3, #7
  20d068:	3308      	adds	r3, #8
  20d06a:	9303      	str	r3, [sp, #12]
      prt_data.ret += n;
  20d06c:	9b09      	ldr	r3, [sp, #36]	; 0x24
  20d06e:	443b      	add	r3, r7
  20d070:	9309      	str	r3, [sp, #36]	; 0x24
      cp = fmt;
  20d072:	e751      	b.n	20cf18 <_vfiprintf_r+0x48>
	    prt_data.width = 10 * prt_data.width + to_digit (*fmt);
  20d074:	fb0c 3202 	mla	r2, ip, r2, r3
	  for (; is_digit (*fmt); fmt++)
  20d078:	460c      	mov	r4, r1
	    prt_data.width = 10 * prt_data.width + to_digit (*fmt);
  20d07a:	2001      	movs	r0, #1
  20d07c:	e790      	b.n	20cfa0 <_vfiprintf_r+0xd0>
	      prt_data.prec = 0;
  20d07e:	2300      	movs	r3, #0
  20d080:	3401      	adds	r4, #1
		prt_data.prec = 10 * prt_data.prec + to_digit (*fmt);
  20d082:	f04f 0c0a 	mov.w	ip, #10
	      for (; is_digit (*fmt); fmt++)
  20d086:	4619      	mov	r1, r3
	      prt_data.prec = 0;
  20d088:	9305      	str	r3, [sp, #20]
	      for (; is_digit (*fmt); fmt++)
  20d08a:	4620      	mov	r0, r4
  20d08c:	f810 2b01 	ldrb.w	r2, [r0], #1
  20d090:	3a30      	subs	r2, #48	; 0x30
  20d092:	2a09      	cmp	r2, #9
  20d094:	d903      	bls.n	20d09e <_vfiprintf_r+0x1ce>
  20d096:	2b00      	cmp	r3, #0
  20d098:	d0c5      	beq.n	20d026 <_vfiprintf_r+0x156>
  20d09a:	9105      	str	r1, [sp, #20]
  20d09c:	e7c3      	b.n	20d026 <_vfiprintf_r+0x156>
		prt_data.prec = 10 * prt_data.prec + to_digit (*fmt);
  20d09e:	fb0c 2101 	mla	r1, ip, r1, r2
	      for (; is_digit (*fmt); fmt++)
  20d0a2:	4604      	mov	r4, r0
		prt_data.prec = 10 * prt_data.prec + to_digit (*fmt);
  20d0a4:	2301      	movs	r3, #1
  20d0a6:	e7f0      	b.n	20d08a <_vfiprintf_r+0x1ba>
            n = _printf_float (data, &prt_data, fp, pfunc, &ap_copy);
  20d0a8:	ab03      	add	r3, sp, #12
  20d0aa:	462a      	mov	r2, r5
  20d0ac:	a904      	add	r1, sp, #16
  20d0ae:	4630      	mov	r0, r6
  20d0b0:	9300      	str	r3, [sp, #0]
  20d0b2:	4b10      	ldr	r3, [pc, #64]	; (20d0f4 <_vfiprintf_r+0x224>)
  20d0b4:	f7fc fa1c 	bl	2094f0 <_printf_float>
      if (n == -1)
  20d0b8:	1c42      	adds	r2, r0, #1
	n = _printf_i (data, &prt_data, fp, pfunc, &ap_copy);
  20d0ba:	4607      	mov	r7, r0
      if (n == -1)
  20d0bc:	d1d6      	bne.n	20d06c <_vfiprintf_r+0x19c>
  return (__sferror (fp) ? EOF : prt_data.ret);
  20d0be:	89ab      	ldrh	r3, [r5, #12]
  20d0c0:	065b      	lsls	r3, r3, #25
  20d0c2:	d486      	bmi.n	20cfd2 <_vfiprintf_r+0x102>
  20d0c4:	9809      	ldr	r0, [sp, #36]	; 0x24
  20d0c6:	e786      	b.n	20cfd6 <_vfiprintf_r+0x106>
	n = _printf_i (data, &prt_data, fp, pfunc, &ap_copy);
  20d0c8:	ab03      	add	r3, sp, #12
  20d0ca:	462a      	mov	r2, r5
  20d0cc:	a904      	add	r1, sp, #16
  20d0ce:	4630      	mov	r0, r6
  20d0d0:	9300      	str	r3, [sp, #0]
  20d0d2:	4b08      	ldr	r3, [pc, #32]	; (20d0f4 <_vfiprintf_r+0x224>)
  20d0d4:	f7fc fc9a 	bl	209a0c <_printf_i>
  20d0d8:	e7ee      	b.n	20d0b8 <_vfiprintf_r+0x1e8>
  20d0da:	bf00      	nop
  20d0dc:	0800ed70 	.word	0x0800ed70
  20d0e0:	0800eec4 	.word	0x0800eec4
  20d0e4:	0800ed90 	.word	0x0800ed90
  20d0e8:	0800ed50 	.word	0x0800ed50
  20d0ec:	0800eece 	.word	0x0800eece
  20d0f0:	002094f1 	.word	0x002094f1
  20d0f4:	0020ceab 	.word	0x0020ceab
  20d0f8:	0800eeca 	.word	0x0800eeca
  20d0fc:	00000000 	.word	0x00000000

0020d100 <nan>:
	x = __builtin_nan("");
#else
	INSERT_WORDS(x,0x7ff80000,0);
#endif
	return x;
}
  20d100:	ed9f 0b01 	vldr	d0, [pc, #4]	; 20d108 <nan+0x8>
  20d104:	4770      	bx	lr
  20d106:	bf00      	nop
  20d108:	00000000 	.word	0x00000000
  20d10c:	7ff80000 	.word	0x7ff80000

0020d110 <__sread>:
_READ_WRITE_RETURN_TYPE
__sread (struct _reent *ptr,
       void *cookie,
       char *buf,
       _READ_WRITE_BUFSIZE_TYPE n)
{
  20d110:	b510      	push	{r4, lr}
  20d112:	460c      	mov	r4, r1
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
  20d114:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  20d118:	f000 faa6 	bl	20d668 <_read_r>
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
  20d11c:	2800      	cmp	r0, #0
    fp->_offset += ret;
  20d11e:	bfab      	itete	ge
  20d120:	6d63      	ldrge	r3, [r4, #84]	; 0x54
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
  20d122:	89a3      	ldrhlt	r3, [r4, #12]
    fp->_offset += ret;
  20d124:	181b      	addge	r3, r3, r0
    fp->_flags &= ~__SOFF;	/* paranoia */
  20d126:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
    fp->_offset += ret;
  20d12a:	bfac      	ite	ge
  20d12c:	6563      	strge	r3, [r4, #84]	; 0x54
    fp->_flags &= ~__SOFF;	/* paranoia */
  20d12e:	81a3      	strhlt	r3, [r4, #12]
  return ret;
}
  20d130:	bd10      	pop	{r4, pc}

0020d132 <__swrite>:
_READ_WRITE_RETURN_TYPE
__swrite (struct _reent *ptr,
       void *cookie,
       char const *buf,
       _READ_WRITE_BUFSIZE_TYPE n)
{
  20d132:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  20d136:	461f      	mov	r7, r3
  ssize_t w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
  20d138:	898b      	ldrh	r3, [r1, #12]
{
  20d13a:	4605      	mov	r5, r0
  20d13c:	460c      	mov	r4, r1
  if (fp->_flags & __SAPP)
  20d13e:	05db      	lsls	r3, r3, #23
{
  20d140:	4616      	mov	r6, r2
  if (fp->_flags & __SAPP)
  20d142:	d505      	bpl.n	20d150 <__swrite+0x1e>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
  20d144:	2302      	movs	r3, #2
  20d146:	2200      	movs	r2, #0
  20d148:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  20d14c:	f000 f9d6 	bl	20d4fc <_lseek_r>
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
  20d150:	89a3      	ldrh	r3, [r4, #12]
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
  20d152:	4632      	mov	r2, r6
  20d154:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  20d158:	4628      	mov	r0, r5
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
  20d15a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  20d15e:	81a3      	strh	r3, [r4, #12]
  w = _write_r (ptr, fp->_file, buf, n);
  20d160:	463b      	mov	r3, r7
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
}
  20d162:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  w = _write_r (ptr, fp->_file, buf, n);
  20d166:	f000 b889 	b.w	20d27c <_write_r>

0020d16a <__sseek>:
_fpos_t
__sseek (struct _reent *ptr,
       void *cookie,
       _fpos_t offset,
       int whence)
{
  20d16a:	b510      	push	{r4, lr}
  20d16c:	460c      	mov	r4, r1
  register FILE *fp = (FILE *) cookie;
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
  20d16e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  20d172:	f000 f9c3 	bl	20d4fc <_lseek_r>
  if (ret == -1L)
  20d176:	1c43      	adds	r3, r0, #1
  20d178:	89a3      	ldrh	r3, [r4, #12]
    fp->_flags &= ~__SOFF;
  else
    {
      fp->_flags |= __SOFF;
      fp->_offset = ret;
  20d17a:	bf15      	itete	ne
  20d17c:	6560      	strne	r0, [r4, #84]	; 0x54
    fp->_flags &= ~__SOFF;
  20d17e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
      fp->_flags |= __SOFF;
  20d182:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
    fp->_flags &= ~__SOFF;
  20d186:	81a3      	strheq	r3, [r4, #12]
      fp->_flags |= __SOFF;
  20d188:	bf18      	it	ne
  20d18a:	81a3      	strhne	r3, [r4, #12]
    }
  return ret;
}
  20d18c:	bd10      	pop	{r4, pc}

0020d18e <__sclose>:
__sclose (struct _reent *ptr,
       void *cookie)
{
  FILE *fp = (FILE *) cookie;

  return _close_r (ptr, fp->_file);
  20d18e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  20d192:	f000 b8f5 	b.w	20d380 <_close_r>

0020d196 <strncmp>:

int 
strncmp (const char *s1,
	const char *s2,
	size_t n)
{
  20d196:	b510      	push	{r4, lr}
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  if (n == 0)
  20d198:	b16a      	cbz	r2, 20d1b6 <strncmp+0x20>
  20d19a:	3901      	subs	r1, #1
  20d19c:	1884      	adds	r4, r0, r2
    return 0;

  while (n-- != 0 && *s1 == *s2)
  20d19e:	f810 3b01 	ldrb.w	r3, [r0], #1
  20d1a2:	f811 2f01 	ldrb.w	r2, [r1, #1]!
  20d1a6:	4293      	cmp	r3, r2
  20d1a8:	d103      	bne.n	20d1b2 <strncmp+0x1c>
    {
      if (n == 0 || *s1 == '\0')
  20d1aa:	42a0      	cmp	r0, r4
  20d1ac:	d001      	beq.n	20d1b2 <strncmp+0x1c>
  20d1ae:	2b00      	cmp	r3, #0
  20d1b0:	d1f5      	bne.n	20d19e <strncmp+0x8>
	break;
      s1++;
      s2++;
    }

  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
  20d1b2:	1a98      	subs	r0, r3, r2
      s1++;
      s2++;
    }
  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
#endif /* not PREFER_SIZE_OVER_SPEED */
}
  20d1b4:	bd10      	pop	{r4, pc}
    return 0;
  20d1b6:	4610      	mov	r0, r2
  20d1b8:	e7fc      	b.n	20d1b4 <strncmp+0x1e>
	...

0020d1bc <__swbuf_r>:

int
__swbuf_r (struct _reent *ptr,
       register int c,
       register FILE *fp)
{
  20d1bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  20d1be:	460e      	mov	r6, r1
  20d1c0:	4614      	mov	r4, r2
  register int n;

  /* Ensure stdio has been initialized.  */

  CHECK_INIT (ptr, fp);
  20d1c2:	4605      	mov	r5, r0
  20d1c4:	b118      	cbz	r0, 20d1ce <__swbuf_r+0x12>
  20d1c6:	6983      	ldr	r3, [r0, #24]
  20d1c8:	b90b      	cbnz	r3, 20d1ce <__swbuf_r+0x12>
  20d1ca:	f7fe fc25 	bl	20ba18 <__sinit>
  20d1ce:	4b21      	ldr	r3, [pc, #132]	; (20d254 <__swbuf_r+0x98>)
  20d1d0:	429c      	cmp	r4, r3
  20d1d2:	d12b      	bne.n	20d22c <__swbuf_r+0x70>
  20d1d4:	686c      	ldr	r4, [r5, #4]
   * (if line buffered) so that we will get called again.
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
  20d1d6:	69a3      	ldr	r3, [r4, #24]
  20d1d8:	60a3      	str	r3, [r4, #8]
  if (cantwrite (ptr, fp))
  20d1da:	89a3      	ldrh	r3, [r4, #12]
  20d1dc:	071a      	lsls	r2, r3, #28
  20d1de:	d52f      	bpl.n	20d240 <__swbuf_r+0x84>
  20d1e0:	6923      	ldr	r3, [r4, #16]
  20d1e2:	b36b      	cbz	r3, 20d240 <__swbuf_r+0x84>
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
  20d1e4:	6923      	ldr	r3, [r4, #16]
  c = (unsigned char) c;
  20d1e6:	b2f6      	uxtb	r6, r6
  n = fp->_p - fp->_bf._base;
  20d1e8:	6820      	ldr	r0, [r4, #0]
  20d1ea:	4637      	mov	r7, r6
  20d1ec:	1ac0      	subs	r0, r0, r3
  if (n >= fp->_bf._size)
  20d1ee:	6963      	ldr	r3, [r4, #20]
  20d1f0:	4283      	cmp	r3, r0
  20d1f2:	dc04      	bgt.n	20d1fe <__swbuf_r+0x42>
    {
      if (_fflush_r (ptr, fp))
  20d1f4:	4621      	mov	r1, r4
  20d1f6:	4628      	mov	r0, r5
  20d1f8:	f000 f956 	bl	20d4a8 <_fflush_r>
  20d1fc:	bb30      	cbnz	r0, 20d24c <__swbuf_r+0x90>
	return EOF;
      n = 0;
    }
  fp->_w--;
  20d1fe:	68a3      	ldr	r3, [r4, #8]
  *fp->_p++ = c;
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
  20d200:	3001      	adds	r0, #1
  fp->_w--;
  20d202:	3b01      	subs	r3, #1
  20d204:	60a3      	str	r3, [r4, #8]
  *fp->_p++ = c;
  20d206:	6823      	ldr	r3, [r4, #0]
  20d208:	1c5a      	adds	r2, r3, #1
  20d20a:	6022      	str	r2, [r4, #0]
  20d20c:	701e      	strb	r6, [r3, #0]
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
  20d20e:	6963      	ldr	r3, [r4, #20]
  20d210:	4283      	cmp	r3, r0
  20d212:	d004      	beq.n	20d21e <__swbuf_r+0x62>
  20d214:	89a3      	ldrh	r3, [r4, #12]
  20d216:	07db      	lsls	r3, r3, #31
  20d218:	d506      	bpl.n	20d228 <__swbuf_r+0x6c>
  20d21a:	2e0a      	cmp	r6, #10
  20d21c:	d104      	bne.n	20d228 <__swbuf_r+0x6c>
    if (_fflush_r (ptr, fp))
  20d21e:	4621      	mov	r1, r4
  20d220:	4628      	mov	r0, r5
  20d222:	f000 f941 	bl	20d4a8 <_fflush_r>
  20d226:	b988      	cbnz	r0, 20d24c <__swbuf_r+0x90>
      return EOF;
  return c;
}
  20d228:	4638      	mov	r0, r7
  20d22a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  CHECK_INIT (ptr, fp);
  20d22c:	4b0a      	ldr	r3, [pc, #40]	; (20d258 <__swbuf_r+0x9c>)
  20d22e:	429c      	cmp	r4, r3
  20d230:	d101      	bne.n	20d236 <__swbuf_r+0x7a>
  20d232:	68ac      	ldr	r4, [r5, #8]
  20d234:	e7cf      	b.n	20d1d6 <__swbuf_r+0x1a>
  20d236:	4b09      	ldr	r3, [pc, #36]	; (20d25c <__swbuf_r+0xa0>)
  20d238:	429c      	cmp	r4, r3
  20d23a:	bf08      	it	eq
  20d23c:	68ec      	ldreq	r4, [r5, #12]
  20d23e:	e7ca      	b.n	20d1d6 <__swbuf_r+0x1a>
  if (cantwrite (ptr, fp))
  20d240:	4621      	mov	r1, r4
  20d242:	4628      	mov	r0, r5
  20d244:	f000 f82c 	bl	20d2a0 <__swsetup_r>
  20d248:	2800      	cmp	r0, #0
  20d24a:	d0cb      	beq.n	20d1e4 <__swbuf_r+0x28>
      return EOF;
  20d24c:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
  20d250:	e7ea      	b.n	20d228 <__swbuf_r+0x6c>
  20d252:	bf00      	nop
  20d254:	0800ed70 	.word	0x0800ed70
  20d258:	0800ed90 	.word	0x0800ed90
  20d25c:	0800ed50 	.word	0x0800ed50

0020d260 <__ascii_wctomb>:
  /* Avoids compiler warnings about comparisons that are always false
     due to limited range when sizeof(wchar_t) is 2 but sizeof(wint_t)
     is 4, as is the case on cygwin.  */
  wint_t wchar = _wchar;

  if (s == NULL)
  20d260:	b149      	cbz	r1, 20d276 <__ascii_wctomb+0x16>
    return 0;
 
#ifdef __CYGWIN__
  if ((size_t)wchar >= 0x80)
#else
  if ((size_t)wchar >= 0x100)
  20d262:	2aff      	cmp	r2, #255	; 0xff
#endif
    {
      r->_errno = EILSEQ;
  20d264:	bf8d      	iteet	hi
  20d266:	238a      	movhi	r3, #138	; 0x8a
      return -1;
    }

  *s = (char) wchar;
  return 1;
  20d268:	2001      	movls	r0, #1
  *s = (char) wchar;
  20d26a:	700a      	strbls	r2, [r1, #0]
      r->_errno = EILSEQ;
  20d26c:	6003      	strhi	r3, [r0, #0]
      return -1;
  20d26e:	bf88      	it	hi
  20d270:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
  return 1;
  20d274:	4770      	bx	lr
    return 0;
  20d276:	4608      	mov	r0, r1
}
  20d278:	4770      	bx	lr
	...

0020d27c <_write_r>:
_ssize_t
_write_r (struct _reent *ptr,
     int fd,
     const void *buf,
     size_t cnt)
{
  20d27c:	b538      	push	{r3, r4, r5, lr}
  20d27e:	4604      	mov	r4, r0
  _ssize_t ret;

  errno = 0;
  20d280:	4d06      	ldr	r5, [pc, #24]	; (20d29c <_write_r+0x20>)
{
  20d282:	4608      	mov	r0, r1
  20d284:	4611      	mov	r1, r2
  errno = 0;
  20d286:	2200      	movs	r2, #0
  20d288:	602a      	str	r2, [r5, #0]
  if ((ret = (_ssize_t)_write (fd, buf, cnt)) == -1 && errno != 0)
  20d28a:	461a      	mov	r2, r3
  20d28c:	f7f6 febe 	bl	20400c <_write>
  20d290:	1c43      	adds	r3, r0, #1
  20d292:	d102      	bne.n	20d29a <_write_r+0x1e>
  20d294:	682b      	ldr	r3, [r5, #0]
  20d296:	b103      	cbz	r3, 20d29a <_write_r+0x1e>
    ptr->_errno = errno;
  20d298:	6023      	str	r3, [r4, #0]
  return ret;
}
  20d29a:	bd38      	pop	{r3, r4, r5, pc}
  20d29c:	200040a0 	.word	0x200040a0

0020d2a0 <__swsetup_r>:
__swsetup_r (struct _reent *ptr,
       register FILE * fp)
{
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
  20d2a0:	4b33      	ldr	r3, [pc, #204]	; (20d370 <__swsetup_r+0xd0>)
{
  20d2a2:	b570      	push	{r4, r5, r6, lr}
  CHECK_INIT (_REENT, fp);
  20d2a4:	681d      	ldr	r5, [r3, #0]
{
  20d2a6:	4606      	mov	r6, r0
  20d2a8:	460c      	mov	r4, r1
  CHECK_INIT (_REENT, fp);
  20d2aa:	b125      	cbz	r5, 20d2b6 <__swsetup_r+0x16>
  20d2ac:	69ab      	ldr	r3, [r5, #24]
  20d2ae:	b913      	cbnz	r3, 20d2b6 <__swsetup_r+0x16>
  20d2b0:	4628      	mov	r0, r5
  20d2b2:	f7fe fbb1 	bl	20ba18 <__sinit>
  20d2b6:	4b2f      	ldr	r3, [pc, #188]	; (20d374 <__swsetup_r+0xd4>)
  20d2b8:	429c      	cmp	r4, r3
  20d2ba:	d10f      	bne.n	20d2dc <__swsetup_r+0x3c>
  20d2bc:	686c      	ldr	r4, [r5, #4]

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
  20d2be:	89a3      	ldrh	r3, [r4, #12]
  20d2c0:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
  20d2c4:	071d      	lsls	r5, r3, #28
  20d2c6:	d42c      	bmi.n	20d322 <__swsetup_r+0x82>
    {
      if ((fp->_flags & __SRW) == 0)
  20d2c8:	06d8      	lsls	r0, r3, #27
  20d2ca:	d411      	bmi.n	20d2f0 <__swsetup_r+0x50>
        {
	  ptr->_errno = EBADF;
  20d2cc:	2309      	movs	r3, #9
  20d2ce:	6033      	str	r3, [r6, #0]
	  fp->_flags |= __SERR;
  20d2d0:	f042 0340 	orr.w	r3, r2, #64	; 0x40

  if (!fp->_bf._base && (fp->_flags & __SMBF))
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
      return EOF;
  20d2d4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
      fp->_flags |= __SERR;
  20d2d8:	81a3      	strh	r3, [r4, #12]
    }
  return 0;
}
  20d2da:	bd70      	pop	{r4, r5, r6, pc}
  CHECK_INIT (_REENT, fp);
  20d2dc:	4b26      	ldr	r3, [pc, #152]	; (20d378 <__swsetup_r+0xd8>)
  20d2de:	429c      	cmp	r4, r3
  20d2e0:	d101      	bne.n	20d2e6 <__swsetup_r+0x46>
  20d2e2:	68ac      	ldr	r4, [r5, #8]
  20d2e4:	e7eb      	b.n	20d2be <__swsetup_r+0x1e>
  20d2e6:	4b25      	ldr	r3, [pc, #148]	; (20d37c <__swsetup_r+0xdc>)
  20d2e8:	429c      	cmp	r4, r3
  20d2ea:	bf08      	it	eq
  20d2ec:	68ec      	ldreq	r4, [r5, #12]
  20d2ee:	e7e6      	b.n	20d2be <__swsetup_r+0x1e>
      if (fp->_flags & __SRD)
  20d2f0:	0759      	lsls	r1, r3, #29
  20d2f2:	d512      	bpl.n	20d31a <__swsetup_r+0x7a>
	  if (HASUB (fp))
  20d2f4:	6b61      	ldr	r1, [r4, #52]	; 0x34
  20d2f6:	b141      	cbz	r1, 20d30a <__swsetup_r+0x6a>
	    FREEUB (ptr, fp);
  20d2f8:	f104 0344 	add.w	r3, r4, #68	; 0x44
  20d2fc:	4299      	cmp	r1, r3
  20d2fe:	d002      	beq.n	20d306 <__swsetup_r+0x66>
  20d300:	4630      	mov	r0, r6
  20d302:	f7ff fc0f 	bl	20cb24 <_free_r>
  20d306:	2300      	movs	r3, #0
  20d308:	6363      	str	r3, [r4, #52]	; 0x34
	  fp->_flags &= ~(__SRD | __SEOF);
  20d30a:	89a3      	ldrh	r3, [r4, #12]
  20d30c:	f023 0324 	bic.w	r3, r3, #36	; 0x24
  20d310:	81a3      	strh	r3, [r4, #12]
	  fp->_r = 0;
  20d312:	2300      	movs	r3, #0
  20d314:	6063      	str	r3, [r4, #4]
	  fp->_p = fp->_bf._base;
  20d316:	6923      	ldr	r3, [r4, #16]
  20d318:	6023      	str	r3, [r4, #0]
      fp->_flags |= __SWR;
  20d31a:	89a3      	ldrh	r3, [r4, #12]
  20d31c:	f043 0308 	orr.w	r3, r3, #8
  20d320:	81a3      	strh	r3, [r4, #12]
  if (fp->_bf._base == NULL
  20d322:	6923      	ldr	r3, [r4, #16]
  20d324:	b94b      	cbnz	r3, 20d33a <__swsetup_r+0x9a>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
  20d326:	89a3      	ldrh	r3, [r4, #12]
  20d328:	f403 7320 	and.w	r3, r3, #640	; 0x280
  20d32c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  20d330:	d003      	beq.n	20d33a <__swsetup_r+0x9a>
    __smakebuf_r (ptr, fp);
  20d332:	4621      	mov	r1, r4
  20d334:	4630      	mov	r0, r6
  20d336:	f000 f917 	bl	20d568 <__smakebuf_r>
  if (fp->_flags & __SLBF)
  20d33a:	89a2      	ldrh	r2, [r4, #12]
  20d33c:	f012 0301 	ands.w	r3, r2, #1
  20d340:	d00e      	beq.n	20d360 <__swsetup_r+0xc0>
      fp->_w = 0;
  20d342:	2300      	movs	r3, #0
  20d344:	60a3      	str	r3, [r4, #8]
      fp->_lbfsize = -fp->_bf._size;
  20d346:	6963      	ldr	r3, [r4, #20]
  20d348:	425b      	negs	r3, r3
  20d34a:	61a3      	str	r3, [r4, #24]
  if (!fp->_bf._base && (fp->_flags & __SMBF))
  20d34c:	6923      	ldr	r3, [r4, #16]
  20d34e:	b963      	cbnz	r3, 20d36a <__swsetup_r+0xca>
  20d350:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  20d354:	f013 0080 	ands.w	r0, r3, #128	; 0x80
  20d358:	d0bf      	beq.n	20d2da <__swsetup_r+0x3a>
      fp->_flags |= __SERR;
  20d35a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  20d35e:	e7b9      	b.n	20d2d4 <__swsetup_r+0x34>
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
  20d360:	0792      	lsls	r2, r2, #30
  20d362:	bf58      	it	pl
  20d364:	6963      	ldrpl	r3, [r4, #20]
  20d366:	60a3      	str	r3, [r4, #8]
  20d368:	e7f0      	b.n	20d34c <__swsetup_r+0xac>
  return 0;
  20d36a:	2000      	movs	r0, #0
  20d36c:	e7b5      	b.n	20d2da <__swsetup_r+0x3a>
  20d36e:	bf00      	nop
  20d370:	20010060 	.word	0x20010060
  20d374:	0800ed70 	.word	0x0800ed70
  20d378:	0800ed90 	.word	0x0800ed90
  20d37c:	0800ed50 	.word	0x0800ed50

0020d380 <_close_r>:

int
_close_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
  20d380:	b538      	push	{r3, r4, r5, lr}
  int ret;

  errno = 0;
  20d382:	2300      	movs	r3, #0
  20d384:	4d05      	ldr	r5, [pc, #20]	; (20d39c <_close_r+0x1c>)
{
  20d386:	4604      	mov	r4, r0
  if ((ret = _close (fd)) == -1 && errno != 0)
  20d388:	4608      	mov	r0, r1
  errno = 0;
  20d38a:	602b      	str	r3, [r5, #0]
  if ((ret = _close (fd)) == -1 && errno != 0)
  20d38c:	f7f6 fe1e 	bl	203fcc <_close>
  20d390:	1c43      	adds	r3, r0, #1
  20d392:	d102      	bne.n	20d39a <_close_r+0x1a>
  20d394:	682b      	ldr	r3, [r5, #0]
  20d396:	b103      	cbz	r3, 20d39a <_close_r+0x1a>
    ptr->_errno = errno;
  20d398:	6023      	str	r3, [r4, #0]
  return ret;
}
  20d39a:	bd38      	pop	{r3, r4, r5, pc}
  20d39c:	200040a0 	.word	0x200040a0

0020d3a0 <__sflush_r>:
  register _READ_WRITE_BUFSIZE_TYPE n;
  register _READ_WRITE_RETURN_TYPE t;
  short flags;

  flags = fp->_flags;
  if ((flags & __SWR) == 0)
  20d3a0:	898a      	ldrh	r2, [r1, #12]
{
  20d3a2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  20d3a6:	4605      	mov	r5, r0
  if ((flags & __SWR) == 0)
  20d3a8:	0710      	lsls	r0, r2, #28
{
  20d3aa:	460c      	mov	r4, r1
  if ((flags & __SWR) == 0)
  20d3ac:	d458      	bmi.n	20d460 <__sflush_r+0xc0>
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
  20d3ae:	684b      	ldr	r3, [r1, #4]
  20d3b0:	2b00      	cmp	r3, #0
  20d3b2:	dc05      	bgt.n	20d3c0 <__sflush_r+0x20>
  20d3b4:	6c0b      	ldr	r3, [r1, #64]	; 0x40
  20d3b6:	2b00      	cmp	r3, #0
  20d3b8:	dc02      	bgt.n	20d3c0 <__sflush_r+0x20>
	      if (curoff == -1L && ptr->_errno != 0)
		{
		  int result = EOF;
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
		    {
		      result = 0;
  20d3ba:	2000      	movs	r0, #0
	}
      p += t;
      n -= t;
    }
  return 0;
}
  20d3bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
  20d3c0:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  20d3c2:	2e00      	cmp	r6, #0
  20d3c4:	d0f9      	beq.n	20d3ba <__sflush_r+0x1a>
	  ptr->_errno = 0;
  20d3c6:	2300      	movs	r3, #0
	  if (fp->_flags & __SOFF)
  20d3c8:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
	  tmp_errno = ptr->_errno;
  20d3cc:	682f      	ldr	r7, [r5, #0]
	  ptr->_errno = 0;
  20d3ce:	602b      	str	r3, [r5, #0]
	  if (fp->_flags & __SOFF)
  20d3d0:	d032      	beq.n	20d438 <__sflush_r+0x98>
	    curoff = fp->_offset;
  20d3d2:	6d60      	ldr	r0, [r4, #84]	; 0x54
          if (fp->_flags & __SRD)
  20d3d4:	89a3      	ldrh	r3, [r4, #12]
  20d3d6:	075a      	lsls	r2, r3, #29
  20d3d8:	d505      	bpl.n	20d3e6 <__sflush_r+0x46>
              curoff -= fp->_r;
  20d3da:	6863      	ldr	r3, [r4, #4]
  20d3dc:	1ac0      	subs	r0, r0, r3
              if (HASUB (fp))
  20d3de:	6b63      	ldr	r3, [r4, #52]	; 0x34
  20d3e0:	b10b      	cbz	r3, 20d3e6 <__sflush_r+0x46>
                curoff -= fp->_ur;
  20d3e2:	6c23      	ldr	r3, [r4, #64]	; 0x40
  20d3e4:	1ac0      	subs	r0, r0, r3
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
  20d3e6:	2300      	movs	r3, #0
  20d3e8:	4602      	mov	r2, r0
  20d3ea:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  20d3ec:	4628      	mov	r0, r5
  20d3ee:	6a21      	ldr	r1, [r4, #32]
  20d3f0:	47b0      	blx	r6
	  if (curoff != -1 || ptr->_errno == 0
  20d3f2:	1c43      	adds	r3, r0, #1
  20d3f4:	89a3      	ldrh	r3, [r4, #12]
  20d3f6:	d106      	bne.n	20d406 <__sflush_r+0x66>
  20d3f8:	6829      	ldr	r1, [r5, #0]
  20d3fa:	291d      	cmp	r1, #29
  20d3fc:	d82c      	bhi.n	20d458 <__sflush_r+0xb8>
  20d3fe:	4a29      	ldr	r2, [pc, #164]	; (20d4a4 <__sflush_r+0x104>)
  20d400:	40ca      	lsrs	r2, r1
  20d402:	07d6      	lsls	r6, r2, #31
  20d404:	d528      	bpl.n	20d458 <__sflush_r+0xb8>
	      fp->_r = 0;
  20d406:	2200      	movs	r2, #0
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
  20d408:	04d9      	lsls	r1, r3, #19
	      fp->_r = 0;
  20d40a:	6062      	str	r2, [r4, #4]
	      fp->_p = fp->_bf._base;
  20d40c:	6922      	ldr	r2, [r4, #16]
  20d40e:	6022      	str	r2, [r4, #0]
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
  20d410:	d504      	bpl.n	20d41c <__sflush_r+0x7c>
  20d412:	1c42      	adds	r2, r0, #1
  20d414:	d101      	bne.n	20d41a <__sflush_r+0x7a>
  20d416:	682b      	ldr	r3, [r5, #0]
  20d418:	b903      	cbnz	r3, 20d41c <__sflush_r+0x7c>
		fp->_offset = curoff;
  20d41a:	6560      	str	r0, [r4, #84]	; 0x54
	      if (HASUB (fp))
  20d41c:	6b61      	ldr	r1, [r4, #52]	; 0x34
	      ptr->_errno = tmp_errno;
  20d41e:	602f      	str	r7, [r5, #0]
	      if (HASUB (fp))
  20d420:	2900      	cmp	r1, #0
  20d422:	d0ca      	beq.n	20d3ba <__sflush_r+0x1a>
		FREEUB (ptr, fp);
  20d424:	f104 0344 	add.w	r3, r4, #68	; 0x44
  20d428:	4299      	cmp	r1, r3
  20d42a:	d002      	beq.n	20d432 <__sflush_r+0x92>
  20d42c:	4628      	mov	r0, r5
  20d42e:	f7ff fb79 	bl	20cb24 <_free_r>
  20d432:	2000      	movs	r0, #0
  20d434:	6360      	str	r0, [r4, #52]	; 0x34
  20d436:	e7c1      	b.n	20d3bc <__sflush_r+0x1c>
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
  20d438:	6a21      	ldr	r1, [r4, #32]
  20d43a:	2301      	movs	r3, #1
  20d43c:	4628      	mov	r0, r5
  20d43e:	47b0      	blx	r6
	      if (curoff == -1L && ptr->_errno != 0)
  20d440:	1c41      	adds	r1, r0, #1
  20d442:	d1c7      	bne.n	20d3d4 <__sflush_r+0x34>
  20d444:	682b      	ldr	r3, [r5, #0]
  20d446:	2b00      	cmp	r3, #0
  20d448:	d0c4      	beq.n	20d3d4 <__sflush_r+0x34>
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
  20d44a:	2b1d      	cmp	r3, #29
  20d44c:	d001      	beq.n	20d452 <__sflush_r+0xb2>
  20d44e:	2b16      	cmp	r3, #22
  20d450:	d101      	bne.n	20d456 <__sflush_r+0xb6>
		      ptr->_errno = tmp_errno;
  20d452:	602f      	str	r7, [r5, #0]
  20d454:	e7b1      	b.n	20d3ba <__sflush_r+0x1a>
		    fp->_flags |= __SERR;
  20d456:	89a3      	ldrh	r3, [r4, #12]
	      fp->_flags |= __SERR;
  20d458:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  20d45c:	81a3      	strh	r3, [r4, #12]
	      return EOF;
  20d45e:	e7ad      	b.n	20d3bc <__sflush_r+0x1c>
  if ((p = fp->_bf._base) == NULL)
  20d460:	690f      	ldr	r7, [r1, #16]
  20d462:	2f00      	cmp	r7, #0
  20d464:	d0a9      	beq.n	20d3ba <__sflush_r+0x1a>
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
  20d466:	0793      	lsls	r3, r2, #30
  n = fp->_p - p;		/* write this much */
  20d468:	680e      	ldr	r6, [r1, #0]
  fp->_p = p;
  20d46a:	600f      	str	r7, [r1, #0]
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
  20d46c:	bf0c      	ite	eq
  20d46e:	694b      	ldreq	r3, [r1, #20]
  20d470:	2300      	movne	r3, #0
  n = fp->_p - p;		/* write this much */
  20d472:	eba6 0807 	sub.w	r8, r6, r7
  fp->_w = flags & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
  20d476:	608b      	str	r3, [r1, #8]
  while (n > 0)
  20d478:	f1b8 0f00 	cmp.w	r8, #0
  20d47c:	dd9d      	ble.n	20d3ba <__sflush_r+0x1a>
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
  20d47e:	4643      	mov	r3, r8
  20d480:	463a      	mov	r2, r7
  20d482:	6a21      	ldr	r1, [r4, #32]
  20d484:	4628      	mov	r0, r5
  20d486:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  20d488:	47b0      	blx	r6
      if (t <= 0)
  20d48a:	2800      	cmp	r0, #0
  20d48c:	dc06      	bgt.n	20d49c <__sflush_r+0xfc>
          fp->_flags |= __SERR;
  20d48e:	89a3      	ldrh	r3, [r4, #12]
          return EOF;
  20d490:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
          fp->_flags |= __SERR;
  20d494:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  20d498:	81a3      	strh	r3, [r4, #12]
          return EOF;
  20d49a:	e78f      	b.n	20d3bc <__sflush_r+0x1c>
      p += t;
  20d49c:	4407      	add	r7, r0
      n -= t;
  20d49e:	eba8 0800 	sub.w	r8, r8, r0
  20d4a2:	e7e9      	b.n	20d478 <__sflush_r+0xd8>
  20d4a4:	20400001 	.word	0x20400001

0020d4a8 <_fflush_r>:
#endif /* __IMPL_UNLOCKED__ */

int
_fflush_r (struct _reent *ptr,
       register FILE * fp)
{
  20d4a8:	b538      	push	{r3, r4, r5, lr}
     there is any data to flush on the _REENT std stream.  There
     are two alternatives to fix this:  1) make a reentrant fflush
     or 2) simply recognize that this file has nothing to flush
     and return immediately before performing a CHECK_INIT.  Choice
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
  20d4aa:	690b      	ldr	r3, [r1, #16]
{
  20d4ac:	4605      	mov	r5, r0
  20d4ae:	460c      	mov	r4, r1
  if (fp->_bf._base == NULL)
  20d4b0:	b1db      	cbz	r3, 20d4ea <_fflush_r+0x42>
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
  20d4b2:	b118      	cbz	r0, 20d4bc <_fflush_r+0x14>
  20d4b4:	6983      	ldr	r3, [r0, #24]
  20d4b6:	b90b      	cbnz	r3, 20d4bc <_fflush_r+0x14>
  20d4b8:	f7fe faae 	bl	20ba18 <__sinit>
  20d4bc:	4b0c      	ldr	r3, [pc, #48]	; (20d4f0 <_fflush_r+0x48>)
  20d4be:	429c      	cmp	r4, r3
  20d4c0:	d109      	bne.n	20d4d6 <_fflush_r+0x2e>
  20d4c2:	686c      	ldr	r4, [r5, #4]

  if (!fp->_flags)
  20d4c4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  20d4c8:	b17b      	cbz	r3, 20d4ea <_fflush_r+0x42>
    return 0;

  _newlib_flockfile_start (fp);
  ret = __sflush_r (ptr, fp);
  20d4ca:	4621      	mov	r1, r4
  20d4cc:	4628      	mov	r0, r5
  _newlib_flockfile_end (fp);
  return ret;
}
  20d4ce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  ret = __sflush_r (ptr, fp);
  20d4d2:	f7ff bf65 	b.w	20d3a0 <__sflush_r>
  CHECK_INIT (ptr, fp);
  20d4d6:	4b07      	ldr	r3, [pc, #28]	; (20d4f4 <_fflush_r+0x4c>)
  20d4d8:	429c      	cmp	r4, r3
  20d4da:	d101      	bne.n	20d4e0 <_fflush_r+0x38>
  20d4dc:	68ac      	ldr	r4, [r5, #8]
  20d4de:	e7f1      	b.n	20d4c4 <_fflush_r+0x1c>
  20d4e0:	4b05      	ldr	r3, [pc, #20]	; (20d4f8 <_fflush_r+0x50>)
  20d4e2:	429c      	cmp	r4, r3
  20d4e4:	bf08      	it	eq
  20d4e6:	68ec      	ldreq	r4, [r5, #12]
  20d4e8:	e7ec      	b.n	20d4c4 <_fflush_r+0x1c>
}
  20d4ea:	2000      	movs	r0, #0
  20d4ec:	bd38      	pop	{r3, r4, r5, pc}
  20d4ee:	bf00      	nop
  20d4f0:	0800ed70 	.word	0x0800ed70
  20d4f4:	0800ed90 	.word	0x0800ed90
  20d4f8:	0800ed50 	.word	0x0800ed50

0020d4fc <_lseek_r>:
_off_t
_lseek_r (struct _reent *ptr,
     int fd,
     _off_t pos,
     int whence)
{
  20d4fc:	b538      	push	{r3, r4, r5, lr}
  20d4fe:	4604      	mov	r4, r0
  _off_t ret;

  errno = 0;
  20d500:	4d06      	ldr	r5, [pc, #24]	; (20d51c <_lseek_r+0x20>)
{
  20d502:	4608      	mov	r0, r1
  20d504:	4611      	mov	r1, r2
  errno = 0;
  20d506:	2200      	movs	r2, #0
  20d508:	602a      	str	r2, [r5, #0]
  if ((ret = _lseek (fd, pos, whence)) == (_off_t) -1 && errno != 0)
  20d50a:	461a      	mov	r2, r3
  20d50c:	f7f6 fd30 	bl	203f70 <_lseek>
  20d510:	1c43      	adds	r3, r0, #1
  20d512:	d102      	bne.n	20d51a <_lseek_r+0x1e>
  20d514:	682b      	ldr	r3, [r5, #0]
  20d516:	b103      	cbz	r3, 20d51a <_lseek_r+0x1e>
    ptr->_errno = errno;
  20d518:	6023      	str	r3, [r4, #0]
  return ret;
}
  20d51a:	bd38      	pop	{r3, r4, r5, pc}
  20d51c:	200040a0 	.word	0x200040a0

0020d520 <__swhatbuf_r>:
int
__swhatbuf_r (struct _reent *ptr,
	FILE *fp,
	size_t *bufsize,
	int *couldbetty)
{
  20d520:	b570      	push	{r4, r5, r6, lr}
  20d522:	460e      	mov	r6, r1

  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  struct stat st;

  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
  20d524:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
{
  20d528:	b096      	sub	sp, #88	; 0x58
  20d52a:	4614      	mov	r4, r2
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
  20d52c:	2900      	cmp	r1, #0
{
  20d52e:	461d      	mov	r5, r3
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
  20d530:	da07      	bge.n	20d542 <__swhatbuf_r+0x22>
#endif
    {
      *couldbetty = 0;
  20d532:	2300      	movs	r3, #0
  20d534:	602b      	str	r3, [r5, #0]
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
  20d536:	89b3      	ldrh	r3, [r6, #12]
  20d538:	061a      	lsls	r2, r3, #24
  20d53a:	d410      	bmi.n	20d55e <__swhatbuf_r+0x3e>
      *bufsize = st.st_blksize;
      fp->_blksize = st.st_blksize;
      return ((st.st_mode & S_IFMT) == S_IFREG ?  __SOPT : snpt);
    }
#endif
  *bufsize = BUFSIZ;
  20d53c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  20d540:	e00e      	b.n	20d560 <__swhatbuf_r+0x40>
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
  20d542:	466a      	mov	r2, sp
  20d544:	f000 f8a2 	bl	20d68c <_fstat_r>
  20d548:	2800      	cmp	r0, #0
  20d54a:	dbf2      	blt.n	20d532 <__swhatbuf_r+0x12>
  *couldbetty = S_ISCHR(st.st_mode);
  20d54c:	9a01      	ldr	r2, [sp, #4]
  20d54e:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
  20d552:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
  20d556:	425a      	negs	r2, r3
  20d558:	415a      	adcs	r2, r3
  20d55a:	602a      	str	r2, [r5, #0]
  20d55c:	e7ee      	b.n	20d53c <__swhatbuf_r+0x1c>
        *bufsize = _DEFAULT_ASPRINTF_BUFSIZE;
  20d55e:	2340      	movs	r3, #64	; 0x40
  return (snpt);
}
  20d560:	2000      	movs	r0, #0
  *bufsize = BUFSIZ;
  20d562:	6023      	str	r3, [r4, #0]
}
  20d564:	b016      	add	sp, #88	; 0x58
  20d566:	bd70      	pop	{r4, r5, r6, pc}

0020d568 <__smakebuf_r>:
  if (fp->_flags & __SNBF)
  20d568:	898b      	ldrh	r3, [r1, #12]
{
  20d56a:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if (fp->_flags & __SNBF)
  20d56c:	079d      	lsls	r5, r3, #30
{
  20d56e:	4606      	mov	r6, r0
  20d570:	460c      	mov	r4, r1
  if (fp->_flags & __SNBF)
  20d572:	d507      	bpl.n	20d584 <__smakebuf_r+0x1c>
	  fp->_bf._base = fp->_p = fp->_nbuf;
  20d574:	f104 0347 	add.w	r3, r4, #71	; 0x47
  20d578:	6023      	str	r3, [r4, #0]
  20d57a:	6123      	str	r3, [r4, #16]
	  fp->_bf._size = 1;
  20d57c:	2301      	movs	r3, #1
  20d57e:	6163      	str	r3, [r4, #20]
}
  20d580:	b002      	add	sp, #8
  20d582:	bd70      	pop	{r4, r5, r6, pc}
  flags = __swhatbuf_r (ptr, fp, &size, &couldbetty);
  20d584:	ab01      	add	r3, sp, #4
  20d586:	466a      	mov	r2, sp
  20d588:	f7ff ffca 	bl	20d520 <__swhatbuf_r>
  if ((p = _malloc_r (ptr, size)) == NULL)
  20d58c:	9900      	ldr	r1, [sp, #0]
  flags = __swhatbuf_r (ptr, fp, &size, &couldbetty);
  20d58e:	4605      	mov	r5, r0
  if ((p = _malloc_r (ptr, size)) == NULL)
  20d590:	4630      	mov	r0, r6
  20d592:	f7fb fe99 	bl	2092c8 <_malloc_r>
  20d596:	b948      	cbnz	r0, 20d5ac <__smakebuf_r+0x44>
      if (!(fp->_flags & __SSTR))
  20d598:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  20d59c:	059a      	lsls	r2, r3, #22
  20d59e:	d4ef      	bmi.n	20d580 <__smakebuf_r+0x18>
	  fp->_flags = (fp->_flags & ~__SLBF) | __SNBF;
  20d5a0:	f023 0303 	bic.w	r3, r3, #3
  20d5a4:	f043 0302 	orr.w	r3, r3, #2
  20d5a8:	81a3      	strh	r3, [r4, #12]
  20d5aa:	e7e3      	b.n	20d574 <__smakebuf_r+0xc>
      ptr->__cleanup = _cleanup_r;
  20d5ac:	4b0d      	ldr	r3, [pc, #52]	; (20d5e4 <__smakebuf_r+0x7c>)
  20d5ae:	62b3      	str	r3, [r6, #40]	; 0x28
      fp->_flags |= __SMBF;
  20d5b0:	89a3      	ldrh	r3, [r4, #12]
      fp->_bf._base = fp->_p = (unsigned char *) p;
  20d5b2:	6020      	str	r0, [r4, #0]
      fp->_flags |= __SMBF;
  20d5b4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
      fp->_bf._base = fp->_p = (unsigned char *) p;
  20d5b8:	6120      	str	r0, [r4, #16]
      fp->_flags |= __SMBF;
  20d5ba:	81a3      	strh	r3, [r4, #12]
      fp->_bf._size = size;
  20d5bc:	9b00      	ldr	r3, [sp, #0]
  20d5be:	6163      	str	r3, [r4, #20]
      if (couldbetty && _isatty_r (ptr, fp->_file))
  20d5c0:	9b01      	ldr	r3, [sp, #4]
  20d5c2:	b15b      	cbz	r3, 20d5dc <__smakebuf_r+0x74>
  20d5c4:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  20d5c8:	4630      	mov	r0, r6
  20d5ca:	f000 f871 	bl	20d6b0 <_isatty_r>
  20d5ce:	b128      	cbz	r0, 20d5dc <__smakebuf_r+0x74>
	fp->_flags = (fp->_flags & ~__SNBF) | __SLBF;
  20d5d0:	89a3      	ldrh	r3, [r4, #12]
  20d5d2:	f023 0303 	bic.w	r3, r3, #3
  20d5d6:	f043 0301 	orr.w	r3, r3, #1
  20d5da:	81a3      	strh	r3, [r4, #12]
      fp->_flags |= flags;
  20d5dc:	89a0      	ldrh	r0, [r4, #12]
  20d5de:	4305      	orrs	r5, r0
  20d5e0:	81a5      	strh	r5, [r4, #12]
  20d5e2:	e7cd      	b.n	20d580 <__smakebuf_r+0x18>
  20d5e4:	0020b9e1 	.word	0x0020b9e1

0020d5e8 <memmove>:
{
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  char *dst = dst_void;
  const char *src = src_void;

  if (src < dst && dst < src + length)
  20d5e8:	4288      	cmp	r0, r1
{
  20d5ea:	b510      	push	{r4, lr}
  20d5ec:	eb01 0402 	add.w	r4, r1, r2
  if (src < dst && dst < src + length)
  20d5f0:	d902      	bls.n	20d5f8 <memmove+0x10>
  20d5f2:	4284      	cmp	r4, r0
  20d5f4:	4623      	mov	r3, r4
  20d5f6:	d807      	bhi.n	20d608 <memmove+0x20>
  20d5f8:	1e43      	subs	r3, r0, #1
	  *--dst = *--src;
	}
    }
  else
    {
      while (length--)
  20d5fa:	42a1      	cmp	r1, r4
  20d5fc:	d008      	beq.n	20d610 <memmove+0x28>
	{
	  *dst++ = *src++;
  20d5fe:	f811 2b01 	ldrb.w	r2, [r1], #1
  20d602:	f803 2f01 	strb.w	r2, [r3, #1]!
  20d606:	e7f8      	b.n	20d5fa <memmove+0x12>
      dst += length;
  20d608:	4402      	add	r2, r0
  20d60a:	4601      	mov	r1, r0
      while (length--)
  20d60c:	428a      	cmp	r2, r1
  20d60e:	d100      	bne.n	20d612 <memmove+0x2a>
        }
    }

  return dst_void;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
  20d610:	bd10      	pop	{r4, pc}
	  *--dst = *--src;
  20d612:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
  20d616:	f802 4d01 	strb.w	r4, [r2, #-1]!
  20d61a:	e7f7      	b.n	20d60c <memmove+0x24>

0020d61c <_realloc_r>:
{
  20d61c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  20d61e:	4607      	mov	r7, r0
  20d620:	4614      	mov	r4, r2
    if (ptr == NULL) return nano_malloc(RCALL size);
  20d622:	460e      	mov	r6, r1
  20d624:	b921      	cbnz	r1, 20d630 <_realloc_r+0x14>
  20d626:	4611      	mov	r1, r2
}
  20d628:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    if (ptr == NULL) return nano_malloc(RCALL size);
  20d62c:	f7fb be4c 	b.w	2092c8 <_malloc_r>
    if (size == 0)
  20d630:	b922      	cbnz	r2, 20d63c <_realloc_r+0x20>
        return NULL;
  20d632:	4625      	mov	r5, r4
        nano_free(RCALL ptr);
  20d634:	f7ff fa76 	bl	20cb24 <_free_r>
}
  20d638:	4628      	mov	r0, r5
  20d63a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (nano_malloc_usable_size(RCALL ptr) >= size)
  20d63c:	f000 f848 	bl	20d6d0 <_malloc_usable_size_r>
  20d640:	42a0      	cmp	r0, r4
  20d642:	d20f      	bcs.n	20d664 <_realloc_r+0x48>
    mem = nano_malloc(RCALL size);
  20d644:	4621      	mov	r1, r4
  20d646:	4638      	mov	r0, r7
  20d648:	f7fb fe3e 	bl	2092c8 <_malloc_r>
    if (mem != NULL)
  20d64c:	4605      	mov	r5, r0
  20d64e:	2800      	cmp	r0, #0
  20d650:	d0f2      	beq.n	20d638 <_realloc_r+0x1c>
        memcpy(mem, ptr, size);
  20d652:	4631      	mov	r1, r6
  20d654:	4622      	mov	r2, r4
  20d656:	f7fe fdff 	bl	20c258 <memcpy>
        nano_free(RCALL ptr);
  20d65a:	4631      	mov	r1, r6
  20d65c:	4638      	mov	r0, r7
  20d65e:	f7ff fa61 	bl	20cb24 <_free_r>
  20d662:	e7e9      	b.n	20d638 <_realloc_r+0x1c>
  20d664:	4635      	mov	r5, r6
  20d666:	e7e7      	b.n	20d638 <_realloc_r+0x1c>

0020d668 <_read_r>:
_ssize_t
_read_r (struct _reent *ptr,
     int fd,
     void *buf,
     size_t cnt)
{
  20d668:	b538      	push	{r3, r4, r5, lr}
  20d66a:	4604      	mov	r4, r0
  _ssize_t ret;

  errno = 0;
  20d66c:	4d06      	ldr	r5, [pc, #24]	; (20d688 <_read_r+0x20>)
{
  20d66e:	4608      	mov	r0, r1
  20d670:	4611      	mov	r1, r2
  errno = 0;
  20d672:	2200      	movs	r2, #0
  20d674:	602a      	str	r2, [r5, #0]
  if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 && errno != 0)
  20d676:	461a      	mov	r2, r3
  20d678:	f7f6 fd0c 	bl	204094 <_read>
  20d67c:	1c43      	adds	r3, r0, #1
  20d67e:	d102      	bne.n	20d686 <_read_r+0x1e>
  20d680:	682b      	ldr	r3, [r5, #0]
  20d682:	b103      	cbz	r3, 20d686 <_read_r+0x1e>
    ptr->_errno = errno;
  20d684:	6023      	str	r3, [r4, #0]
  return ret;
}
  20d686:	bd38      	pop	{r3, r4, r5, pc}
  20d688:	200040a0 	.word	0x200040a0

0020d68c <_fstat_r>:
int
_fstat_r (ptr, fd, pstat)
     struct _reent *ptr;
     int fd;
     struct stat *pstat;
{
  20d68c:	b538      	push	{r3, r4, r5, lr}
  int ret;

  errno = 0;
  20d68e:	2300      	movs	r3, #0
  20d690:	4d06      	ldr	r5, [pc, #24]	; (20d6ac <_fstat_r+0x20>)
{
  20d692:	4604      	mov	r4, r0
  20d694:	4608      	mov	r0, r1
  if ((ret = _fstat (fd, pstat)) == -1 && errno != 0)
  20d696:	4611      	mov	r1, r2
  errno = 0;
  20d698:	602b      	str	r3, [r5, #0]
  if ((ret = _fstat (fd, pstat)) == -1 && errno != 0)
  20d69a:	f7f6 fc3b 	bl	203f14 <_fstat>
  20d69e:	1c43      	adds	r3, r0, #1
  20d6a0:	d102      	bne.n	20d6a8 <_fstat_r+0x1c>
  20d6a2:	682b      	ldr	r3, [r5, #0]
  20d6a4:	b103      	cbz	r3, 20d6a8 <_fstat_r+0x1c>
    ptr->_errno = errno;
  20d6a6:	6023      	str	r3, [r4, #0]
  return ret;
}
  20d6a8:	bd38      	pop	{r3, r4, r5, pc}
  20d6aa:	bf00      	nop
  20d6ac:	200040a0 	.word	0x200040a0

0020d6b0 <_isatty_r>:

int
_isatty_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
  20d6b0:	b538      	push	{r3, r4, r5, lr}
  int ret;

  errno = 0;
  20d6b2:	2300      	movs	r3, #0
  20d6b4:	4d05      	ldr	r5, [pc, #20]	; (20d6cc <_isatty_r+0x1c>)
{
  20d6b6:	4604      	mov	r4, r0
  if ((ret = _isatty (fd)) == -1 && errno != 0)
  20d6b8:	4608      	mov	r0, r1
  errno = 0;
  20d6ba:	602b      	str	r3, [r5, #0]
  if ((ret = _isatty (fd)) == -1 && errno != 0)
  20d6bc:	f7f6 fc24 	bl	203f08 <_isatty>
  20d6c0:	1c43      	adds	r3, r0, #1
  20d6c2:	d102      	bne.n	20d6ca <_isatty_r+0x1a>
  20d6c4:	682b      	ldr	r3, [r5, #0]
  20d6c6:	b103      	cbz	r3, 20d6ca <_isatty_r+0x1a>
    ptr->_errno = errno;
  20d6c8:	6023      	str	r3, [r4, #0]
  return ret;
}
  20d6ca:	bd38      	pop	{r3, r4, r5, pc}
  20d6cc:	200040a0 	.word	0x200040a0

0020d6d0 <_malloc_usable_size_r>:

#ifdef DEFINE_MALLOC_USABLE_SIZE
malloc_size_t nano_malloc_usable_size(RARG void * ptr)
{
    chunk * c = (chunk *)((char *)ptr - CHUNK_OFFSET);
    int size_or_offset = c->size;
  20d6d0:	f851 3c04 	ldr.w	r3, [r1, #-4]

    if (size_or_offset < 0)
  20d6d4:	1f18      	subs	r0, r3, #4
  20d6d6:	2b00      	cmp	r3, #0
    {
        /* Padding is used. Excluding the padding size */
        c = (chunk *)((char *)c + c->size);
        return c->size - CHUNK_OFFSET + size_or_offset;
  20d6d8:	bfbc      	itt	lt
  20d6da:	580b      	ldrlt	r3, [r1, r0]
  20d6dc:	18c0      	addlt	r0, r0, r3
    }
    return c->size - CHUNK_OFFSET;
}
  20d6de:	4770      	bx	lr

0020d6e0 <iprintf>:

#ifndef _REENT_ONLY

int
printf (const char *__restrict fmt, ...)
{
  20d6e0:	b40f      	push	{r0, r1, r2, r3}
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;
  20d6e2:	4b0a      	ldr	r3, [pc, #40]	; (20d70c <iprintf+0x2c>)
{
  20d6e4:	b513      	push	{r0, r1, r4, lr}
  struct _reent *ptr = _REENT;
  20d6e6:	681c      	ldr	r4, [r3, #0]

  _REENT_SMALL_CHECK_INIT (ptr);
  20d6e8:	b124      	cbz	r4, 20d6f4 <iprintf+0x14>
  20d6ea:	69a3      	ldr	r3, [r4, #24]
  20d6ec:	b913      	cbnz	r3, 20d6f4 <iprintf+0x14>
  20d6ee:	4620      	mov	r0, r4
  20d6f0:	f7fe f992 	bl	20ba18 <__sinit>
  va_start (ap, fmt);
  20d6f4:	ab05      	add	r3, sp, #20
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
  20d6f6:	9a04      	ldr	r2, [sp, #16]
  20d6f8:	68a1      	ldr	r1, [r4, #8]
  20d6fa:	4620      	mov	r0, r4
  va_start (ap, fmt);
  20d6fc:	9301      	str	r3, [sp, #4]
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
  20d6fe:	f7ff fbe7 	bl	20ced0 <_vfiprintf_r>
  va_end (ap);
  return ret;
}
  20d702:	b002      	add	sp, #8
  20d704:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  20d708:	b004      	add	sp, #16
  20d70a:	4770      	bx	lr
  20d70c:	20010060 	.word	0x20010060

0020d710 <_puts_r>:
 */

int
_puts_r (struct _reent *ptr,
       const char * s)
{
  20d710:	b570      	push	{r4, r5, r6, lr}
  20d712:	460e      	mov	r6, r1
  return result;
#else
  int result = EOF;
  const char *p = s;
  FILE *fp;
  _REENT_SMALL_CHECK_INIT (ptr);
  20d714:	4605      	mov	r5, r0
  20d716:	b118      	cbz	r0, 20d720 <_puts_r+0x10>
  20d718:	6983      	ldr	r3, [r0, #24]
  20d71a:	b90b      	cbnz	r3, 20d720 <_puts_r+0x10>
  20d71c:	f7fe f97c 	bl	20ba18 <__sinit>

  fp = _stdout_r (ptr);
  CHECK_INIT (ptr, fp);
  20d720:	69ab      	ldr	r3, [r5, #24]
  fp = _stdout_r (ptr);
  20d722:	68ac      	ldr	r4, [r5, #8]
  CHECK_INIT (ptr, fp);
  20d724:	b913      	cbnz	r3, 20d72c <_puts_r+0x1c>
  20d726:	4628      	mov	r0, r5
  20d728:	f7fe f976 	bl	20ba18 <__sinit>
  20d72c:	4b23      	ldr	r3, [pc, #140]	; (20d7bc <_puts_r+0xac>)
  20d72e:	429c      	cmp	r4, r3
  20d730:	d117      	bne.n	20d762 <_puts_r+0x52>
  20d732:	686c      	ldr	r4, [r5, #4]
  _newlib_flockfile_start (fp);
  ORIENT (fp, -1);
  /* Make sure we can write.  */
  if (cantwrite (ptr, fp))
  20d734:	89a3      	ldrh	r3, [r4, #12]
  20d736:	071b      	lsls	r3, r3, #28
  20d738:	d51d      	bpl.n	20d776 <_puts_r+0x66>
  20d73a:	6923      	ldr	r3, [r4, #16]
  20d73c:	b1db      	cbz	r3, 20d776 <_puts_r+0x66>
  20d73e:	3e01      	subs	r6, #1
  20d740:	68a3      	ldr	r3, [r4, #8]
    goto err;

  while (*p)
  20d742:	f816 1f01 	ldrb.w	r1, [r6, #1]!
  20d746:	3b01      	subs	r3, #1
_ELIDABLE_INLINE int __sputc_r(struct _reent *_ptr, int _c, FILE *_p) {
#ifdef __SCLE
	if ((_p->_flags & __SCLE) && _c == '\n')
	  __sputc_r (_ptr, '\r', _p);
#endif
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  20d748:	60a3      	str	r3, [r4, #8]
  20d74a:	b9e9      	cbnz	r1, 20d788 <_puts_r+0x78>
  20d74c:	2b00      	cmp	r3, #0
  20d74e:	da2e      	bge.n	20d7ae <_puts_r+0x9e>
		return (*_p->_p++ = _c);
	else
		return (__swbuf_r(_ptr, _c, _p));
  20d750:	4622      	mov	r2, r4
  20d752:	210a      	movs	r1, #10
  20d754:	4628      	mov	r0, r5
  20d756:	f7ff fd31 	bl	20d1bc <__swbuf_r>
    {
      if (__sputc_r (ptr, *p++, fp) == EOF)
	goto err;
    }
  if (__sputc_r (ptr, '\n', fp) == EOF)
  20d75a:	3001      	adds	r0, #1
  20d75c:	d011      	beq.n	20d782 <_puts_r+0x72>
    goto err;

  result = '\n';
  20d75e:	200a      	movs	r0, #10
  20d760:	e011      	b.n	20d786 <_puts_r+0x76>
  CHECK_INIT (ptr, fp);
  20d762:	4b17      	ldr	r3, [pc, #92]	; (20d7c0 <_puts_r+0xb0>)
  20d764:	429c      	cmp	r4, r3
  20d766:	d101      	bne.n	20d76c <_puts_r+0x5c>
  20d768:	68ac      	ldr	r4, [r5, #8]
  20d76a:	e7e3      	b.n	20d734 <_puts_r+0x24>
  20d76c:	4b15      	ldr	r3, [pc, #84]	; (20d7c4 <_puts_r+0xb4>)
  20d76e:	429c      	cmp	r4, r3
  20d770:	bf08      	it	eq
  20d772:	68ec      	ldreq	r4, [r5, #12]
  20d774:	e7de      	b.n	20d734 <_puts_r+0x24>
  if (cantwrite (ptr, fp))
  20d776:	4621      	mov	r1, r4
  20d778:	4628      	mov	r0, r5
  20d77a:	f7ff fd91 	bl	20d2a0 <__swsetup_r>
  20d77e:	2800      	cmp	r0, #0
  20d780:	d0dd      	beq.n	20d73e <_puts_r+0x2e>
  int result = EOF;
  20d782:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
  20d786:	bd70      	pop	{r4, r5, r6, pc}
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  20d788:	2b00      	cmp	r3, #0
  20d78a:	da04      	bge.n	20d796 <_puts_r+0x86>
  20d78c:	69a2      	ldr	r2, [r4, #24]
  20d78e:	429a      	cmp	r2, r3
  20d790:	dc06      	bgt.n	20d7a0 <_puts_r+0x90>
  20d792:	290a      	cmp	r1, #10
  20d794:	d004      	beq.n	20d7a0 <_puts_r+0x90>
		return (*_p->_p++ = _c);
  20d796:	6823      	ldr	r3, [r4, #0]
  20d798:	1c5a      	adds	r2, r3, #1
  20d79a:	6022      	str	r2, [r4, #0]
  20d79c:	7019      	strb	r1, [r3, #0]
  20d79e:	e7cf      	b.n	20d740 <_puts_r+0x30>
		return (__swbuf_r(_ptr, _c, _p));
  20d7a0:	4622      	mov	r2, r4
  20d7a2:	4628      	mov	r0, r5
  20d7a4:	f7ff fd0a 	bl	20d1bc <__swbuf_r>
      if (__sputc_r (ptr, *p++, fp) == EOF)
  20d7a8:	3001      	adds	r0, #1
  20d7aa:	d1c9      	bne.n	20d740 <_puts_r+0x30>
  20d7ac:	e7e9      	b.n	20d782 <_puts_r+0x72>
		return (*_p->_p++ = _c);
  20d7ae:	6823      	ldr	r3, [r4, #0]
  20d7b0:	200a      	movs	r0, #10
  20d7b2:	1c5a      	adds	r2, r3, #1
  20d7b4:	6022      	str	r2, [r4, #0]
  20d7b6:	7018      	strb	r0, [r3, #0]
  return result;
  20d7b8:	e7e5      	b.n	20d786 <_puts_r+0x76>
  20d7ba:	bf00      	nop
  20d7bc:	0800ed70 	.word	0x0800ed70
  20d7c0:	0800ed90 	.word	0x0800ed90
  20d7c4:	0800ed50 	.word	0x0800ed50

0020d7c8 <puts>:
#ifndef _REENT_ONLY

int
puts (char const * s)
{
  return _puts_r (_REENT, s);
  20d7c8:	4b02      	ldr	r3, [pc, #8]	; (20d7d4 <puts+0xc>)
{
  20d7ca:	4601      	mov	r1, r0
  return _puts_r (_REENT, s);
  20d7cc:	6818      	ldr	r0, [r3, #0]
  20d7ce:	f7ff bf9f 	b.w	20d710 <_puts_r>
  20d7d2:	bf00      	nop
  20d7d4:	20010060 	.word	0x20010060

0020d7d8 <strchr>:
char *
strchr (const char *s1,
	int i)
{
  const unsigned char *s = (const unsigned char *)s1;
  unsigned char c = i;
  20d7d8:	b2c9      	uxtb	r1, r1

  s = (unsigned char *) aligned_addr;

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*s && *s != c)
  20d7da:	4603      	mov	r3, r0
  20d7dc:	f810 2b01 	ldrb.w	r2, [r0], #1
  20d7e0:	b11a      	cbz	r2, 20d7ea <strchr+0x12>
  20d7e2:	428a      	cmp	r2, r1
  20d7e4:	d1f9      	bne.n	20d7da <strchr+0x2>
    s++;
  if (*s == c)
    return (char *)s;
  return NULL;
}
  20d7e6:	4618      	mov	r0, r3
  20d7e8:	4770      	bx	lr
  return NULL;
  20d7ea:	2900      	cmp	r1, #0
  20d7ec:	bf18      	it	ne
  20d7ee:	2300      	movne	r3, #0
  20d7f0:	e7f9      	b.n	20d7e6 <strchr+0xe>

0020d7f2 <strcpy>:
#endif

char* __attribute__((naked))
strcpy (char* dst, const char* src)
{
  asm (
  20d7f2:	4603      	mov	r3, r0
  20d7f4:	f811 2b01 	ldrb.w	r2, [r1], #1
  20d7f8:	f803 2b01 	strb.w	r2, [r3], #1
  20d7fc:	2a00      	cmp	r2, #0
  20d7fe:	d1f9      	bne.n	20d7f4 <strcpy+0x2>
  20d800:	4770      	bx	lr

0020d802 <strpbrk>:
#include <string.h>

char *
strpbrk (const char *s1,
	const char *s2)
{
  20d802:	b570      	push	{r4, r5, r6, lr}
  const char *c = s2;
  if (!*s1)
  20d804:	7803      	ldrb	r3, [r0, #0]
  20d806:	b1a3      	cbz	r3, 20d832 <strpbrk+0x30>
  20d808:	4603      	mov	r3, r0
  const char *c = s2;
  20d80a:	460c      	mov	r4, r1
  20d80c:	4618      	mov	r0, r3
    return (char *) NULL;

  while (*s1)
  20d80e:	f813 5b01 	ldrb.w	r5, [r3], #1
  20d812:	b14d      	cbz	r5, 20d828 <strpbrk+0x26>
  20d814:	460a      	mov	r2, r1
  20d816:	e001      	b.n	20d81c <strpbrk+0x1a>
    {
      for (c = s2; *c; c++)
	{
	  if (*s1 == *c)
  20d818:	42ae      	cmp	r6, r5
  20d81a:	d009      	beq.n	20d830 <strpbrk+0x2e>
  20d81c:	4614      	mov	r4, r2
      for (c = s2; *c; c++)
  20d81e:	f812 6b01 	ldrb.w	r6, [r2], #1
  20d822:	2e00      	cmp	r6, #0
  20d824:	d1f8      	bne.n	20d818 <strpbrk+0x16>
  20d826:	e7f1      	b.n	20d80c <strpbrk+0xa>
      if (*c)
	break;
      s1++;
    }

  if (*c == '\0')
  20d828:	7823      	ldrb	r3, [r4, #0]
    s1 = NULL;
  20d82a:	2b00      	cmp	r3, #0
  20d82c:	bf08      	it	eq
  20d82e:	2000      	moveq	r0, #0

  return (char *) s1;
}
  20d830:	bd70      	pop	{r4, r5, r6, pc}
    s1 = NULL;
  20d832:	4618      	mov	r0, r3
  20d834:	e7fc      	b.n	20d830 <strpbrk+0x2e>

0020d836 <strspn>:
	const char *s2)
{
  const char *s = s1;
  const char *c;

  while (*s1)
  20d836:	4603      	mov	r3, r0
{
  20d838:	b570      	push	{r4, r5, r6, lr}
  20d83a:	461e      	mov	r6, r3
  while (*s1)
  20d83c:	f813 4b01 	ldrb.w	r4, [r3], #1
  20d840:	b13c      	cbz	r4, 20d852 <strspn+0x1c>
  20d842:	1e4a      	subs	r2, r1, #1
  20d844:	e001      	b.n	20d84a <strspn+0x14>
    {
      for (c = s2; *c; c++)
	{
	  if (*s1 == *c)
  20d846:	42a5      	cmp	r5, r4
  20d848:	d0f7      	beq.n	20d83a <strspn+0x4>
      for (c = s2; *c; c++)
  20d84a:	f812 5f01 	ldrb.w	r5, [r2, #1]!
  20d84e:	2d00      	cmp	r5, #0
  20d850:	d1f9      	bne.n	20d846 <strspn+0x10>
	break;
      s1++;
    }

  return s1 - s;
}
  20d852:	1a30      	subs	r0, r6, r0
  20d854:	bd70      	pop	{r4, r5, r6, pc}

0020d856 <__aeabi_d2lz>:
#endif

#if defined(L_fixdfdi) && LIBGCC2_HAS_DF_MODE
DWtype
__fixdfdi (DFtype a)
{
  20d856:	4602      	mov	r2, r0
  20d858:	b508      	push	{r3, lr}
  20d85a:	460b      	mov	r3, r1
  20d85c:	ec43 2b17 	vmov	d7, r2, r3
  if (a < 0)
  20d860:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
  20d864:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20d868:	d509      	bpl.n	20d87e <__aeabi_d2lz+0x28>
    return - __fixunsdfDI (-a);
  20d86a:	eeb1 7b47 	vneg.f64	d7, d7
  20d86e:	ec51 0b17 	vmov	r0, r1, d7
  20d872:	f000 f809 	bl	20d888 <__aeabi_d2ulz>
  20d876:	4240      	negs	r0, r0
  20d878:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  return __fixunsdfDI (a);
}
  20d87c:	bd08      	pop	{r3, pc}
  20d87e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return __fixunsdfDI (a);
  20d882:	f000 b801 	b.w	20d888 <__aeabi_d2ulz>
	...

0020d888 <__aeabi_d2ulz>:
  const UWtype hi = a / Wtype_MAXp1_F;
  20d888:	ed9f 7b0b 	vldr	d7, [pc, #44]	; 20d8b8 <__aeabi_d2ulz+0x30>
{
  20d88c:	ec41 0b16 	vmov	d6, r0, r1
  const UWtype lo = a - (DFtype) hi * Wtype_MAXp1_F;
  20d890:	ed9f 5b0b 	vldr	d5, [pc, #44]	; 20d8c0 <__aeabi_d2ulz+0x38>
  const UWtype hi = a / Wtype_MAXp1_F;
  20d894:	ee26 7b07 	vmul.f64	d7, d6, d7
  20d898:	eebc 7bc7 	vcvt.u32.f64	s14, d7
  const UWtype lo = a - (DFtype) hi * Wtype_MAXp1_F;
  20d89c:	eeb8 4b47 	vcvt.f64.u32	d4, s14
}
  20d8a0:	ee17 1a10 	vmov	r1, s14
  const UWtype lo = a - (DFtype) hi * Wtype_MAXp1_F;
  20d8a4:	eea4 6b45 	vfms.f64	d6, d4, d5
}
  20d8a8:	eefc 7bc6 	vcvt.u32.f64	s15, d6
  20d8ac:	ee17 0a90 	vmov	r0, s15
  20d8b0:	4770      	bx	lr
  20d8b2:	bf00      	nop
  20d8b4:	f3af 8000 	nop.w
  20d8b8:	00000000 	.word	0x00000000
  20d8bc:	3df00000 	.word	0x3df00000
  20d8c0:	00000000 	.word	0x00000000
  20d8c4:	41f00000 	.word	0x41f00000

0020d8c8 <start>:
  20d8c8:	00000000                                ....

0020d8cc <_orchard_cmd_list_cmd_cpu>:
  20d8cc:	0800dab8 00201bc5                       ...... .

0020d8d4 <_orchard_cmd_list_cmd_mem>:
  20d8d4:	0800dbde 00202375                       ....u# .

0020d8dc <_orchard_cmd_list_cmd_memtest>:
  20d8dc:	0800dbbe 00201cc1                       ...... .

0020d8e4 <_orchard_cmd_list_cmd_reset>:
  20d8e4:	0800e0b2 00201ac5                       ...... .

0020d8ec <_orchard_cmd_list__func>:
	...
