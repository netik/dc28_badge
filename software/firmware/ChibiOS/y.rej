@@ -207,6 +207,66 @@
   }
 }
 
+/**
+ * @brief   Puts the SDRAM into self refresh mode.
+ *
+ * @param[in] sdramp         pointer to the @p SDRAMDriver object
+ *
+ * @notapi
+ */
+
+void fsmcSdramSelfRefresh(SDRAMDriver *sdramp) {
+
+  uint32_t command_target = 0;
+
+#if STM32_SDRAM_USE_FSMC_SDRAM1
+  command_target |= FMC_SDCMR_CTB1;
+#endif
+#if STM32_SDRAM_USE_FSMC_SDRAM2
+  command_target |= FMC_SDCMR_CTB2;
+#endif
+
+  if (sdramp->state == SDRAM_READY) {
+again:
+    _sdram_wait_ready();
+    SDRAMD.sdram->SDCMR = FMCCM_SELFREFRESH | command_target;
+      /* Make sure we actually get into self refresh mode. */
+#if STM32_SDRAM_USE_FSMC_SDRAM1
+    if ((SDRAMD.sdram->SDSR & FMC_SDSR_MODES1) != FMC_SDSR_MODES1_0)
+      goto again;
+#endif
+#if STM32_SDRAM_USE_FSMC_SDRAM2
+    if ((SDRAMD.sdram->SDSR & FMC_SDSR_MODES2) != FMC_SDSR_MODES2_0)
+      goto again;
+#endif
+  }
+}
+
+/**
+ * @brief   Puts the SDRAM into normal mode.
+ *
+ * @param[in] sdramp         pointer to the @p SDRAMDriver object
+ *
+ * @notapi
+ */
+void fsmcSdramNormal(SDRAMDriver *sdramp) {
+
+  uint32_t command_target = 0;
+
+#if STM32_SDRAM_USE_FSMC_SDRAM1
+  command_target |= FMC_SDCMR_CTB1;
+#endif
+#if STM32_SDRAM_USE_FSMC_SDRAM2
+  command_target |= FMC_SDCMR_CTB2;
+#endif
+
+  if (sdramp->state == SDRAM_READY) {
+    _sdram_wait_ready();
+    SDRAMD.sdram->SDCMR = FMCCM_NORMAL | command_target;
+    _sdram_wait_ready();
+  }
+}
+
 #endif /* STM32_USE_FSMC_SDRAM */
 
 #endif /* STM32F427xx / STM32F429xx / STM32F437xx / STM32F439xx */
